/*
 * $Id: fabric.h 1.41.6.2 Broadcom SDK $
 * 
 * $Copyright: Copyright 2011 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 * 
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 */

#ifndef __BCM_FABRIC_H__
#define __BCM_FABRIC_H__

#include <bcm/types.h>
#include <bcm/port.h>

#define BCM_FABRIC_PORT_EGRESS_MULTICAST    (1<<0)     
#define BCM_FABRIC_PORT_INGRESS_MULTICAST   (1<<1)     

#ifndef BCM_HIDE_DISPATCHABLE

/* Create subports corresponding to front panel ports. */
extern int bcm_fabric_port_create(
    int unit, 
    bcm_gport_t parent_port, 
    int offset, 
    uint32 flags, 
    bcm_gport_t *port);

/* Destroy subports corresponding to front panel ports. */
extern int bcm_fabric_port_destroy(
    int unit, 
    bcm_gport_t parent_port);

#endif /* BCM_HIDE_DISPATCHABLE */

/* bcm_fabric_control_t */
typedef enum bcm_fabric_control_e {
    bcmFabricArbiterId,                 /* Arbiter Identifier */
    bcmFabricActiveArbiterId,           /* Active Arbiter Identifier */
    bcmFabricArbiterConfig,             /* Arbiter NULL Grant Mechanism */
    bcmFabricMaximumFailedLinks,        /* Maximum Failed Links for load shared
                                           data plane redundancy mode */
    bcmFabricActiveId,                  /* retreives actual(versus provisioned)
                                           Active Arbiter Identifier */
    bcmFabricRedundancyMode,            /* Fabric Redundancy Mode */
    bcmFabricMode,                      /* Fabric Mode (QE fabric, QE TME) */
    bcmFabricManager,                   /* Fabric Manager Mode (XBAR only,
                                           ARB/XBAR, ARB capable/XBAR) */
    bcmFabricMcGroupSourceKnockout,     /* Multicast Group Source Knockout
                                           Configuration. For get operation the
                                           arg parameter direction In/Out */
    bcmFabricEgressQueueMin,            /* Local QID start index */
    bcmFabricEgressQueueMax,            /* Local QID end index */
    bcmFabricQueueMin,                  /* FIC QID start index */
    bcmFabricQueueMax,                  /* FIC QID end index */
    bcmFabricArbitrationMapFabric,      /* Arbitration Map for Fabric Queues */
    bcmFabricArbitrationMapSubscriber,  /* Arbitration Map for Subscriber Queues */
    bcmFabricArbitrationMapHierarchicalSubscriber, /* Arbitration Map for higher level
                                           schedulers/scheduling nodes */
    bcmFabricSubscriberCosLevels,       /* Maximum COS levels for subscriber
                                           queues */
    bcmFabricSubscriberCosLevelAllocation, /* Internal COS allocation for
                                           subscriber queues */
    bcmFabricShaperQueueMin,            /* FIC QID start shaping index */
    bcmFabricShaperQueueMax,            /* FIC QID end shaping index */
    bcmFabricShaperQueueIncrement,      /* FIC QID shaping increment. 1
                                           indicates shaping can be configured
                                           on every queue, 4 indicates shaping
                                           can be configured on every 4th queue,
                                           0 indicates shaping on entire queue
                                           group */
    bcmFabricShaperEgressQueueMin,      /* Local QID start shaping index */
    bcmFabricShaperEgressQueueMax,      /* Local QID end shaping index */
    bcmFabricShaperEgressQueueIncrement, /* Local QID shaping increment. 1
                                           indicates shaping can be configured
                                           on every queue, 4 indicates shaping
                                           can be configured on every 4th queue,
                                           0 indicates shaping on entire queue
                                           group */
    bcmFabricTsApplicationHierachySetup, /* Application manage ingress node
                                           resources. 1 indicates application
                                           manage, 0 indicate SDK auto manage */
    bcmFabricMaxPorts,                  /* Maximum fabric ports to be supported
                                           by SDK */
    bcmFabricEgressDropLimitBytes,      /* Total system-wide buffer drop limit */
    bcmFabricEgressRedDropLimitBytes,   /* Total system-wide Red drop limit */
    bcmFabricEgressYellowDropLimitBytes, /* Total system-wide Yellow drop limit */
    bcmFabricDemandCalculationEnable,   /* Enable the demand calculation (on QE) */
    bcmFabricOperatingIntervalEnable,   /* Enable the start of epoch/operating
                                           interval (on standby arbiter) */
    bcmFabricIngressLevel1NumSchedulers, /* Number of ingress schedulers on level
                                           1 */
    bcmFabricIngressLevel2NumSchedulers, /* Number of ingress schedulers on level
                                           2 */
    bcmFabricIngressLevel3NumSchedulers, /* Number of ingress schedulers on level
                                           3 */
    bcmFabricIngressLevel4NumSchedulers, /* Number of ingress schedulers on level
                                           4 */
    bcmFabricIngressLevel5NumSchedulers, /* Number of ingress schedulers on level
                                           5 */
    bcmFabricIngressLevel6NumSchedulers, /* Number of ingress schedulers on level
                                           6 */
    bcmFabricIngressLevel7NumSchedulers, /* Number of ingress schedulers on level
                                           7 */
    bcmFabricIngressLevel1SchedulerUpdateCycles, /* Ingress scheduler update cycles on
                                           level 1 */
    bcmFabricIngressLevel2SchedulerUpdateCycles, /* Ingress scheduler update cycles on
                                           level 2 */
    bcmFabricIngressLevel3SchedulerUpdateCycles, /* Ingress scheduler update cycles on
                                           level 3 */
    bcmFabricIngressLevel4SchedulerUpdateCycles, /* Ingress scheduler update cycles on
                                           level 4 */
    bcmFabricIngressLevel5SchedulerUpdateCycles, /* Ingress scheduler update cycles on
                                           level 5 */
    bcmFabricIngressLevel6SchedulerUpdateCycles, /* Ingress scheduler update cycles on
                                           level 6 */
    bcmFabricIngressLevel7SchedulerUpdateCycles /* Ingress scheduler update cycles on
                                           level 7 */
} bcm_fabric_control_t;

/* bcm_fabric_mode_t */
typedef enum bcm_fabric_mode_e {
    bcmFabricModeTME,                   /* QE Standalone/TME */
    bcmFabricModeFabric,                /* QE Uses external fabric device */
    bcmFabricModeArbiterCrossbar,       /* BM configured as both and arbiter and
                                           a crossbar */
    bcmFabricModeCrossbar,              /* BM configured as a crossbar without
                                           arbiter functionality */
    bcmFabricModeArbiterCapableCrossbar /* BM configured as xbar without arbiter
                                           functionality, but capable of to
                                           switching arbiter */
} bcm_fabric_mode_t;

/* bcm_fabric_connection_mode_t */
typedef enum bcm_fabric_connection_mode_e {
    bcmFabricXbarConnectionModeA = 1,   /* Plane A */
    bcmFabricXbarConnectionModeB = 2,   /* Plane B */
    bcmFabricXbarConnectionModeC = 3    /* Worst Case Plane A/Plane B */
} bcm_fabric_connection_mode_t;

/* BCM_FABRIC_XBAR_ABILITY_ flags */
#define BCM_FABRIC_XBAR_ABILITY_PROTOCOL_A  1          /* Plane A */
#define BCM_FABRIC_XBAR_ABILITY_PROTOCOL_B  2          /* Plane B */
#define BCM_FABRIC_XBAR_ABILITY_PROTOCOL_C  3          /* Worst Case Plane
                                                          A/Plane B */

/* bcm_fabric_redundancy_mode_t */
typedef enum bcm_fabric_redundancy_mode_e {
    bcmFabricRedManual,     /* Manual Mode */
    bcmFabricRed1Plus1Both, /* 1+1 Control Plane and 1+1 Data Plane */
    bcmFabricRed1Plus1LS,   /* 1+1 Control Plane and Load Sharing Data Plane */
    bcmFabricRed1Plus1ELS,  /* 1+1 Control Planeand Enhanced Load Sharing Data
                               Plane */
    bcmFabricRedLS,         /* Load Sharing Data Plane */
    bcmFabricRedELS         /* Enhanced Load Sharing Data Plane */
} bcm_fabric_redundancy_mode_t;

/* Information passed back during callback of redundancy state change */
typedef struct bcm_fabric_control_redundancy_info_s {
    int active_arbiter_id;  /* Active Arbiter Identifier. */
    uint64 xbars;           /* xbar links that are being used. */
} bcm_fabric_control_redundancy_info_t;

/* BCM_FABRIC_DISTRIBUTION_* flags. */
#define BCM_FABRIC_DISTRIBUTION_WITH_ID 0x00000001 /* flag to create
                                                      distributionId that is
                                                      passed */

/* Reference bcm_fabric_control_t, bcmFabricMcGroupSourceKnockout type. */
#define BCM_FABRIC_MC_GROUP_SOURCE_KNOCKOUT_ENABLE 0x40000000 /* Indicates if source
                                                          knockout is enabled on
                                                          a multicast group */
#define BCM_FABRIC_MC_GROUP_MASK            0x3FFFFFFF /* multicast group mask */

/* 
 * Allows more specific control in bcm_fabric_packet_adjust_get/set. 
 * With neither flag, get will fetch the ingress (or egress if the chip
 * does not support ingress) value, and set will set both values (of
 * whichever the chip supports if it supports only one).  ORing the
 * INGRESS flag with the selector ID will cause ingress to be set or
 * read.  ORing the EGRESS flag with the selector will cause egress to be
 * set or read.  ORing both INGRESS and EGRESS flags with the selector ID
 * will specifically set both, but is not valid for get.  The GLOBAL flag
 * indicates that the global adjust value (can be combined with ingress
 * and egress as appropriate to the device) is to be accessed, rather
 * than one of the indexed adjust values.
 */
#define BCM_FABRIC_PACKET_ADJUST_INGRESS    0x40000000 
#define BCM_FABRIC_PACKET_ADJUST_EGRESS     0x20000000 
#define BCM_FABRIC_PACKET_ADJUST_GLOBAL     0x10000000 
#define BCM_FABRIC_PACKET_ADJUST_SELECTOR_MASK 0x0FFFFFFF 

/* bcm_fabric_control_redundancy_handler_t */
typedef void (*bcm_fabric_control_redundancy_handler_t)(
    int unit, 
    bcm_fabric_control_redundancy_info_t *redundancy_info);

#ifndef BCM_HIDE_DISPATCHABLE

/* Initialize the BCM Fabric subsystem. */
extern int bcm_fabric_init(
    int unit);

/* defines connection setup between two nodes. */
extern int bcm_fabric_crossbar_connection_set(
    int unit, 
    int xbar, 
    int src_modid, 
    bcm_port_t src_xbport, 
    int dst_modid, 
    bcm_port_t dst_xbport);

/* retreives connection setup between two nodes. */
extern int bcm_fabric_crossbar_connection_get(
    int unit, 
    int xbar, 
    int src_modid, 
    bcm_port_t src_xbport, 
    int dst_modid, 
    bcm_port_t *dst_xbport);

/* Retrieves the number of active crossbars between two modules */
extern int bcm_fabric_crossbar_connection_status_get(
    int unit, 
    int src_modid, 
    int dst_modid, 
    bcm_fabric_connection_mode_t mode, 
    uint64 *xbars);

/* Retrieve fabric operating interval - epoch time */
extern int bcm_fabric_operating_interval_get(
    int unit, 
    int link_fail_count, 
    int *operating_interval);

/* Retrieves the number of timeslots in an epoch */
extern int bcm_fabric_connection_max_get(
    int unit, 
    int link_fail_count, 
    int *connection);

/* Gets fabric connection interval - timeslot size */
extern int bcm_fabric_connection_interval_get(
    int unit, 
    int link_fail_count, 
    int *connection_interval);

/* retrieve bytes per connection - bytes sent in a timeslot */
extern int bcm_fabric_connection_bytes_get(
    int unit, 
    int src_modid, 
    int dst_modid, 
    bcm_fabric_connection_mode_t mode, 
    int link_fail_count, 
    int *max_bytes);

/* Enable/disable TDM calendar */
extern int bcm_fabric_tdm_enable_set(
    int unit, 
    int enable);

/* Get enable/disable status of TDM calendar. */
extern int bcm_fabric_tdm_enable_get(
    int unit, 
    int *enable);

/* Get maximum TDM calendar size that is supported by the device. */
extern int bcm_fabric_calendar_max_get(
    int unit, 
    int *max_size);

/* Configure TDM calendar size */
extern int bcm_fabric_calendar_size_set(
    int unit, 
    int config_size);

/* Retrieve TDM calendar size */
extern int bcm_fabric_calendar_size_get(
    int unit, 
    int *config_size);

/* Set single calendar entry */
extern int bcm_fabric_calendar_set(
    int unit, 
    int cindex, 
    int connection, 
    bcm_gport_t dest_port, 
    bcm_cos_queue_t dest_cosq);

/* Get single calendar entry */
extern int bcm_fabric_calendar_get(
    int unit, 
    int cindex, 
    int *connection, 
    bcm_gport_t *dest_port, 
    bcm_cos_queue_t *dest_cosq);

/* Set multiple calendar entries */
extern int bcm_fabric_calendar_multi_set(
    int unit, 
    int array_size, 
    int *connection_array, 
    bcm_gport_t *dest_port_array, 
    bcm_cos_queue_t *dest_cosq_array);

/* Get multiple calendar entries */
extern int bcm_fabric_calendar_multi_get(
    int unit, 
    int array_size, 
    int *connection_array, 
    bcm_gport_t *dest_port_array, 
    bcm_cos_queue_t *dest_cosq_array);

/* Arm TDM calendar */
extern int bcm_fabric_calendar_active(
    int unit);

/* defines SFI link remap. */
extern int bcm_fabric_crossbar_mapping_set(
    int unit, 
    int modid, 
    int switch_fabric_arbiter_id, 
    int xbar, 
    bcm_port_t port);

/* retreive SFI link remap. */
extern int bcm_fabric_crossbar_mapping_get(
    int unit, 
    int modid, 
    int switch_fabric_arbiter_id, 
    int xbar, 
    bcm_port_t *port);

/* configure Link enable. */
extern int bcm_fabric_crossbar_enable_set(
    int unit, 
    uint64 xbars);

/* retreive Link enable. */
extern int bcm_fabric_crossbar_enable_get(
    int unit, 
    uint64 *xbars);

/* retreive runtime Link enable configuration. */
extern int bcm_fabric_crossbar_status_get(
    int unit, 
    uint64 *xbars);

/* set packet length adjustment. */
extern int bcm_fabric_packet_adjust_set(
    int unit, 
    int pkt_adjust_selector, 
    int pkt_adjust_len);

/* retreive packet length adjustment. */
extern int bcm_fabric_packet_adjust_get(
    int unit, 
    int pkt_adjust_selector, 
    int *pkt_adjust_len);

/* set failover/APS configuration. */
extern int bcm_fabric_port_failover_set(
    int unit, 
    bcm_gport_t port, 
    bcm_failover_t failover_id, 
    bcm_gport_t failover_port);

/* retreive failover/APS configuration. */
extern int bcm_fabric_port_failover_get(
    int unit, 
    bcm_gport_t port, 
    bcm_failover_t *failover_id, 
    bcm_gport_t *failover_port);

/* set fabric control attributes. */
extern int bcm_fabric_control_set(
    int unit, 
    bcm_fabric_control_t type, 
    int arg);

/* get fabric control attributes. */
extern int bcm_fabric_control_get(
    int unit, 
    bcm_fabric_control_t type, 
    int *arg);

/* Register user callback for redundancy state changes. */
extern int bcm_fabric_control_redundancy_register(
    int unit, 
    bcm_fabric_control_redundancy_handler_t f);

/* Unregister user callback for redundancy state changes. */
extern int bcm_fabric_control_redundancy_unregister(
    int unit, 
    bcm_fabric_control_redundancy_handler_t f);

/* Create Distribution Group. Reference BCM_FABRIC_DISTRIBUTION_* flags. */
extern int bcm_fabric_distribution_create(
    int unit, 
    uint32 flags, 
    bcm_fabric_distribution_t *ds_id);

/* Destroy Distribution Group. */
extern int bcm_fabric_distribution_destroy(
    int unit, 
    bcm_fabric_distribution_t ds_id);

/* Configure Distribution Group. */
extern int bcm_fabric_distribution_set(
    int unit, 
    bcm_fabric_distribution_t ds_id, 
    int modid_count, 
    int *dist_modids);

/* Retreive Distribution Group. */
extern int bcm_fabric_distribution_get(
    int unit, 
    bcm_fabric_distribution_t ds_id, 
    int max_count, 
    int *dist_modids, 
    int *count);

#endif /* BCM_HIDE_DISPATCHABLE */

#define BCM_FABRIC_DISTRIBUTION_SCHED_ALL   0x00000000 
#define BCM_FABRIC_DISTRIBUTION_SCHED_ANY   0x00000001 

/* Multicast Fabric distribution feature control. */
typedef enum bcm_fabric_distribution_control_e {
    bcmFabricDistributionSched  /* Multicast fabric forwarding - all nodes must
                                   be available or any. */
} bcm_fabric_distribution_control_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Configure Distribution Group fabric forwarding settings. */
extern int bcm_fabric_distribution_control_set(
    int unit, 
    bcm_fabric_distribution_t ds_id, 
    bcm_fabric_distribution_control_t type, 
    int value);

/* Get Distribution Group fabric forwarding settings. */
extern int bcm_fabric_distribution_control_get(
    int unit, 
    bcm_fabric_distribution_t ds_id, 
    bcm_fabric_distribution_control_t type, 
    int *value);

/* 
 * Sets the number of port status messages that will be present in
 * congestion message (e.g. E2ECC).
 */
extern int bcm_fabric_congestion_size_set(
    int unit, 
    bcm_module_t module_id, 
    int max_ports);

/* 
 * Gets the number of port status messages that will be present in
 * congestion message (e.g. E2ECC).
 */
extern int bcm_fabric_congestion_size_get(
    int unit, 
    bcm_module_t module_id, 
    int *max_ports);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Specifies the bit position and length of a field in packets */
typedef struct bcm_fabric_action_field_s {
    uint16 offset;  /* Bit offset of field in a packet */
    uint16 length;  /* Bit length of field in a packet */
} bcm_fabric_action_field_t;

/* Specifies where the predicate obtains its information for comparison */
typedef enum bcm_fabric_predicate_type_e {
    bcmFabricPredicateTypePacket,       /* Predicate is based upon packet
                                           contents (field indicates which bits) */
    bcmFabricPredicateTypeInterface,    /* Predicate is based upon 'interface'
                                           metadatum (field is ignored) */
    bcmFabricPredicateTypeSysport,      /* Predicate is based upon 'sysport'
                                           metadatum (field is ignored) */
    bcmFabricPredicateTypeChannel,      /* Predicate is based upon 'channel'
                                           metadatum (field is ignored) */
    bcmFabricPredicateTypeFifo,         /* Predicate is based upon 'fifo'
                                           metadatum (field is ignored) */
    bcmFabricPredicateTypeSubport,      /* Predicate is based upon 'subport'
                                           metadatum (field is ignored) */
    bcmFabricPredicateTypePacketClass,  /* Predicate is based upon 'packet
                                           class' metadatum (field is ignored) */
    bcmFabricPredicateTypeFlags         /* Predicate is based upon 'packet
                                           flags' metadata (field is ignored) */
} bcm_fabric_predicate_type_t;

#define BCM_FABRIC_PREDICATE_INFO_INGRESS   0x00000001 /* Predicate will be used
                                                          for ingress path
                                                          packets */
#define BCM_FABRIC_PREDICATE_INFO_EGRESS    0x00000002 /* Predicate will be used
                                                          for egress path
                                                          packets */
#define BCM_FABRIC_PREDICATE_INFO_WITH_ID   0x00000004 /* Predicate needs to be
                                                          created/replaced with
                                                          a specific ID */
#define BCM_FABRIC_PREDICATE_INFO_REPLACE   0x00000008 /* Predicate needs to be
                                                          replaced instead of
                                                          created */
#define BCM_FABRIC_PREDICATE_INFO_RANGE     0x00000010 /* Predicate comparison
                                                          is range instead of
                                                          equality-under-mask */

typedef struct bcm_fabric_predicate_info_s {
    uint32 flags;                       /* Flags controlling the creation and
                                           the operation of the parser */
    bcm_fabric_predicate_type_t source; /* Indicates from where the predicate
                                           will draw its comparison data */
    bcm_fabric_action_field_t field;    /* Indicates the bit field location in
                                           packets for packet type predicates;
                                           is ignored for metadata type
                                           predicates */
    uint32 data;                        /* Compare data for equality-under-mask
                                           comparisons (ignored for range) */
    uint32 mask;                        /* Masking value used for
                                           equality-under-mask comparisons
                                           (ignored for range) */
    uint32 range_low;                   /* Lowest included value for range
                                           comparisons (ignored for non-range) */
    uint32 range_high;                  /* Highest included value for range
                                           comparisons (ignored for non-range) */
} bcm_fabric_predicate_info_t;

/* Fabric predicate ID */
typedef int bcm_fabric_predicate_t;

/* Callback used by bcm_fabric_predicate_traverse */
typedef int (*bcm_fabric_predicate_traverse_cb)(
    int unit, 
    bcm_fabric_predicate_t pred_id, 
    bcm_fabric_predicate_info_t *pred_info, 
    void *user_data);

/* Initialize a fabric predicate info structure. */
extern void bcm_fabric_predicate_info_t_init(
    int unit, 
    bcm_fabric_predicate_info_t *pred_info);

#ifndef BCM_HIDE_DISPATCHABLE

/* Create or update a fabric predicate */
extern int bcm_fabric_predicate_create(
    int unit, 
    bcm_fabric_predicate_info_t *pred_info, 
    bcm_fabric_predicate_t *pred_id);

/* Destroys an existing predicate */
extern int bcm_fabric_predicate_destroy(
    int unit, 
    bcm_fabric_predicate_t pred_id);

/* Destroys all fabric predicates on the unit */
extern int bcm_fabric_predicate_destroy_all(
    int unit);

/* Retrieve the information about a specific predicate */
extern int bcm_fabric_predicate_get(
    int unit, 
    bcm_fabric_predicate_t pred_id, 
    bcm_fabric_predicate_info_t *pred_info);

/* 
 * Traverse the existing predicates, and invoke an application provided
 * callback for each one
 */
extern int bcm_fabric_predicate_traverse(
    int unit, 
    bcm_fabric_predicate_traverse_cb cb, 
    void *user_data);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Indicates source for queue index. */
typedef enum bcm_fabric_action_queue_idx_from_e {
    bcmFabricActionQueueIdxFromPacket,  /* Take queue index from queue field of
                                           packet */
    bcmFabricActionQueueIdxFromReplicantId, /* Take queue index from multicast
                                           replicant ID */
    bcmFabricActionQueueIdxFromReplicantLookup /* Take queue index from result of
                                           multicast replicant lookup */
} bcm_fabric_action_queue_idx_from_t;

/* Indicates source data (and size) selection for insert action */
typedef enum bcm_fabric_action_insert_e {
    bcmFabricActionInsertRepId16,       /* Insert 16-bit replicant ID from
                                           multicast path */
    bcmFabricActionInsertRepId18,       /* Insert 18-bit replicant ID from
                                           multicast path, overwriting low two
                                           bits of prior byte */
    bcmFabricActionInsertEncapId16,     /* Insert 16-bit encapId from primary
                                           lookup (based upon replicant ID) */
    bcmFabricActionInsertEncapId18,     /* Insert 18-bit encapId from primary
                                           lookup (based upon replicant ID),
                                           overwriting low two bits of prior
                                           byte */
    bcmFabricActionInsertQueueIndex16,  /* Insert 16-bit queue index pulled from
                                           packet by action */
    bcmFabricActionInsertQueueIndex18,  /* Insert 18-bit queue index pulled from
                                           packet by action, overwriting low two
                                           bits of prior byte */
    bcmFabricActionInsertQueueId16,     /* Insert 16-bit queue ID from secondary
                                           lookup (based upon queue index pulled
                                           from packet by action) */
    bcmFabricActionInsertQueueId18      /* Insert 18-bit queue ID from secondary
                                           lookup (based upon queue index pulled
                                           from packet by action), overwriting
                                           low two bits of prior byte */
} bcm_fabric_action_insert_t;

#define BCM_FABRIC_ACTION_INFO_INGRESS      0x00000001 /* Action will be used
                                                          for ingress path
                                                          packets */
#define BCM_FABRIC_ACTION_INFO_EGRESS       0x00000002 /* Action will be used
                                                          for egress path
                                                          packets */
#define BCM_FABRIC_ACTION_INFO_WITH_ID      0x00000004 /* Action needs to be
                                                          created/replaced with
                                                          a specific ID */
#define BCM_FABRIC_ACTION_INFO_REPLACE      0x00000008 /* Action needs to be
                                                          replaced instead of
                                                          created */
#define BCM_FABRIC_ACTION_INFO_QUEUE_DEFAULT 0x00000010 /* Use global default
                                                          queue instead of
                                                          deriving one from the
                                                          packet */
#define BCM_FABRIC_ACTION_INFO_USE_TAG_OFFSET 0x00000020 /* Include HGX extension
                                                          queue tag in queue
                                                          selection process */
#define BCM_FABRIC_ACTION_INFO_OVERWRITE_DEST 0x00000040 /* Overwrite packet
                                                          destination with
                                                          selected queue */
#define BCM_FABRIC_ACTION_INFO_LENGTH_ADJUST 0x00000080 /* Use packet len_adj_idx
                                                          to select length
                                                          adjustment */
#define BCM_FABRIC_ACTION_INFO_CLEAR_TEST_BIT 0x00000100 /* Clear the 'test' bit
                                                          in the packet header */
#define BCM_FABRIC_ACTION_INFO_LOOKUP_ENCAPID 0x00000200 /* Lookup encapId from
                                                          multicast replicantId */
#define BCM_FABRIC_ACTION_INFO_CLEAR_MC_BIT 0x00000400 /* Clear the 'multicast'
                                                          bit in the packet
                                                          header */
#define BCM_FABRIC_ACTION_INFO_LEN_ADJ_ON_SHAPING 0x00000800 /* Apply length
                                                          adjustment to the data
                                                          sent to shaping */
#define BCM_FABRIC_ACTION_INFO_LOOKUP_QUEUEID 0x00001000 /* Lookup queueId from
                                                          the queue index */
#define BCM_FABRIC_ACTION_INFO_XGS_MODE     0x00002000 /* Overwrite packet
                                                          header destination
                                                          field according to the
                                                          fifo into which the
                                                          packet is placed */
#define BCM_FABRIC_ACTION_INFO_STAT0_ADJ_PER_PACKET 0x00004000 /* Adjust stat 0 per
                                                          frame */
#define BCM_FABRIC_ACTION_INFO_STAT1_ADJ_PER_PACKET 0x00008000 /* Adjust stat 1 per
                                                          frame */
#define BCM_FABRIC_ACTION_INFO_STAT_COMBINE 0x00010000 /* Combine stat 0 and 1
                                                          so stat 0 is low bits
                                                          and stat 1 is high
                                                          bits */

/* Fabric action ID */
typedef int bcm_fabric_action_t;

/* Fabric qsel ID */
typedef int bcm_fabric_qsel_t;

/* Fabric qsel_offset ID */
typedef int bcm_fabric_qsel_offset_t;

/* Fabric statistics segment ID */
typedef int bcm_fabric_stats_segment_t;

/* Specifies the bit position and length of a field in packets */
typedef struct bcm_fabric_action_info_s {
    uint32 flags;                       /* Flags controlling the creation and
                                           operation of the action */
    bcm_fabric_action_field_t queue_field_low; /* Selects bits from packet to be used
                                           for low bits of queue index */
    bcm_fabric_action_field_t queue_field_high; /* Selects bits from packet to be used
                                           for high bits of queue index */
    bcm_fabric_action_field_t qsel_offset_index_field; /* Selects bits from packet to be used
                                           for qsel_offset index */
    int override_dp;                    /* Override value for packet drop
                                           precedence; set -1 to use value from
                                           packet */
    int override_ecn;                   /* Override value for packet ECN bits;
                                           set -1 to use value from packet */
    bcm_fabric_action_field_t len_adj_index_field; /* Selects bits from packet to be used
                                           for len_adj index */
    bcm_fabric_action_queue_idx_from_t queue_id_source; /* Selects whether to draw initial queue
                                           index from packet or multicast path */
    uint32 queue_index_offset;          /* Offset to apply to queue index during
                                           lookup of queue_id */
    bcm_fabric_qsel_t qsel;             /* Specifies the qsel that is to be used
                                           for queue lookup; if this is zero,
                                           the queue lookup is not performed and
                                           qsel_offset will be chosen according
                                           to the qsel_offset field rather than
                                           read during the lookup */
    bcm_fabric_qsel_offset_t qsel_offset; /* Specifies the qsel_offset to use if
                                           qsel is zero */
    bcm_fabric_action_field_t encap_id_field; /* Which bits in the packet to overwrite
                                           with the encap_id */
    bcm_fabric_action_field_t queue_id_field; /* Which bits in the packet to overwrite
                                           with the queue_id */
    int clear_ehv_bit;                  /* Which bit to clear for extended
                                           header valid bit clear; use -1 to
                                           inhibit */
    int clear_mp_bit;                   /* Which bit to clear for header MP bit
                                           clear; use -1 to inhibit */
    int four_byte_remove_offset;        /* Specifies the bit offset of a four
                                           byte block to remove from the packet;
                                           -1 indicates no removal */
    int header_bytes_remove;            /* Specifies a number of bytes to remove
                                           from the front of the packet; 0
                                           indicates no removal */
    bcm_fabric_action_insert_t insert_dest_select; /* Specifies the source (and size) of
                                           the insertion that will be done by an
                                           interface that is configured to
                                           perform a header insertion; the
                                           configuration of each interface
                                           determines whether the insertion is
                                           actually performed for packets on
                                           that interface */
    bcm_fabric_stats_segment_t stat0_segment; /* The statistics segment used for stat0 */
    bcm_fabric_predicate_type_t stat0_field_low_type; /* Indicate source of stat0 low bits */
    bcm_fabric_action_field_t stat0_field_low; /* Which bits from the packet select the
                                           low bits of stat0 */
    bcm_fabric_predicate_type_t stat0_field_high_type; /* Indicates source of stat0 high bits */
    bcm_fabric_action_field_t stat0_field_high; /* Which bits from the packet select the
                                           high bits of stat0 */
    int stat0_adjust;                   /* Adjustment applied to value for stat0
                                           during statistics update */
    bcm_fabric_stats_segment_t stat1_segment; /* The statistics segment used for stat0 */
    bcm_fabric_predicate_type_t stat1_field_low_type; /* Indicates source of stat1 low bits */
    bcm_fabric_action_field_t stat1_field_low; /* Which bits from the packet select the
                                           low bits of stat1 */
    bcm_fabric_predicate_type_t stat1_field_high_type; /* Indicates source of stat1 high bits */
    bcm_fabric_action_field_t stat1_field_high; /* Which bits from the packet select the
                                           high bits of stat1 */
    int stat1_adjust;                   /* Adjustment applied to value for stat1
                                           during statistics update */
} bcm_fabric_action_info_t;

/* Callback used by bcm_fabric_action_traverse */
typedef int (*bcm_fabric_action_traverse_cb)(
    int unit, 
    bcm_fabric_action_t action_id, 
    bcm_fabric_action_info_t *action_info, 
    void *user_data);

extern void bcm_fabric_action_info_t_init(
    int unit, 
    bcm_fabric_action_info_t *action_info);

#ifndef BCM_HIDE_DISPATCHABLE

/* Create or update a fabric action */
extern int bcm_fabric_action_create(
    int unit, 
    bcm_fabric_action_info_t *action_info, 
    bcm_fabric_action_t *action_id);

/* Destroy a fabric action */
extern int bcm_fabric_action_destroy(
    int unit, 
    bcm_fabric_action_t action_id);

/* Destroy all fabric actions on the unit */
extern int bcm_fabric_action_destroy_all(
    int unit);

/* Get information about a fabric action */
extern int bcm_fabric_action_get(
    int unit, 
    bcm_fabric_action_t action_id, 
    bcm_fabric_action_info_t *action_info);

/* 
 * Traverse the existing actions, and invoke an application provided
 * callback for each one
 */
extern int bcm_fabric_action_traverse(
    int unit, 
    bcm_fabric_action_traverse_cb cb, 
    void *user_data);

#endif /* BCM_HIDE_DISPATCHABLE */

#define BCM_FABRIC_PREDICATE_ACTION_INFO_INGRESS 0x00000001 /* Predicate will be used
                                                          for ingress path
                                                          packets */
#define BCM_FABRIC_PREDICATE_ACTION_INFO_EGRESS 0x00000002 /* Predicate will be used
                                                          for egress path
                                                          packets */
#define BCM_FABRIC_PREDICATE_ACTION_INFO_WITH_ID 0x00000004 /* Predicate needs to be
                                                          created/replaced with
                                                          a specific ID */
#define BCM_FABRIC_PREDICATE_ACTION_INFO_REPLACE 0x00000008 /* Predicate needs to be
                                                          replaced instead of
                                                          created */

#define BCM_FABRIC_PREDICATE_COUNT  32         /* Maximum number of supported
                                                  fabric predicates */

/* 
 * Used to specify mask and data for predicates when connecting them to
 * actions
 */
typedef SHR_BITDCL bcm_fabric_predicate_vector_t[_SHR_BITDCLSIZE(BCM_FABRIC_PREDICATE_COUNT)];

#define BCM_FABRIC_PREDICATE_VECTOR_GET(_vec, _n)  SHR_BITGET((_vec), (_n)) 
#define BCM_FABRIC_PREDICATE_VECTOR_SET(_vec, _n)  SHR_BITSET((_vec), (_n)) 
#define BCM_FABRIC_PREDICATE_VECTOR_CLR(_vec, _n)  SHR_BITCLR((_vec), (_n)) 

/* Fabric predicate action ID */
typedef int bcm_fabric_predicate_action_t;

typedef struct bcm_fabric_predicate_action_info_s {
    uint32 flags;                       /* Flags indicating how this
                                           predicate_action is to be
                                           created/replaced */
    int priority;                       /* The priority for this
                                           predicate_action */
    bcm_fabric_predicate_vector_t data; /* The value of the predicate vector for
                                           this predicate_action */
    bcm_fabric_predicate_vector_t mask; /* Indicates which predicates are
                                           significant in the data field */
    bcm_fabric_action_t action_id;      /* Specifies the action to be taken when
                                           the specified predicate condition is
                                           met */
} bcm_fabric_predicate_action_info_t;

/* Callback used by bcm_fabric_predicate_action_traverse */
typedef int (*bcm_fabric_predicate_action_traverse_cb)(
    int unit, 
    bcm_fabric_predicate_action_t predicate_action_id, 
    bcm_fabric_predicate_action_info_t *predicate_action_info, 
    void *user_data);

extern void bcm_fabric_predicate_action_info_t_init(
    int unit, 
    bcm_fabric_predicate_action_info_t *predicate_action_info);

#ifndef BCM_HIDE_DISPATCHABLE

/* Create or update a fabric action */
extern int bcm_fabric_predicate_action_create(
    int unit, 
    bcm_fabric_predicate_action_info_t *predicate_action, 
    bcm_fabric_predicate_action_t *predicate_action_id);

/* Read a fabric predicate action */
extern int bcm_fabric_predicate_action_get(
    int unit, 
    bcm_fabric_predicate_action_t predicate_action_id, 
    bcm_fabric_predicate_action_info_t *predicate_action_info);

/* Destroy a fabric predicate action */
extern int bcm_fabric_predicate_action_destroy(
    int unit, 
    bcm_fabric_predicate_action_t predicate_action_id);

/* Destroy all fabric predicate actions on the unit */
extern int bcm_fabric_predicate_action_destroy_all(
    int unit);

/* 
 * Traverse existing fabric predicate actions, calling the provided
 * callback one time per existing fabric predicate action
 */
extern int bcm_fabric_predicate_action_traverse(
    int unit, 
    bcm_fabric_predicate_action_traverse_cb cb, 
    void *user_data);

#endif /* BCM_HIDE_DISPATCHABLE */

#define BCM_FABRIC_QSEL_INGRESS 0x00000001 /* qsel will be used for ingress path
                                              packets */
#define BCM_FABRIC_QSEL_EGRESS  0x00000002 /* qsel will be used for egress path
                                              packets */
#define BCM_FABRIC_QSEL_WITH_ID 0x00000004 /* qsel needs to be created/replaced
                                              with a specific ID */
#define BCM_FABRIC_QSEL_REPLACE 0x00000008 /* qsel needs to be replaced instead
                                              of created */

/* Callback used by bcm_fabric_qsel_traverse */
typedef int (*bcm_fabric_qsel_traverse_cb)(
    int unit, 
    bcm_fabric_qsel_t qsel_id, 
    uint32 flags, 
    int base, 
    int count, 
    void *user_data);

/* Callback used by bcm_fabric_qsel_entry_traverse */
typedef int (*bcm_fabric_qsel_entry_traverse_cb)(
    int unit, 
    bcm_fabric_qsel_t qsel_id, 
    int offset, 
    bcm_gport_t queue, 
    bcm_fabric_qsel_offset_t qsel_offset, 
    void *user_data);

#ifndef BCM_HIDE_DISPATCHABLE

/* This creates or updates a qsel */
extern int bcm_fabric_qsel_create(
    int unit, 
    uint32 flags, 
    int base, 
    int count, 
    bcm_fabric_qsel_t *qsel_id);

/* This destroys a qsel */
extern int bcm_fabric_qsel_destroy(
    int unit, 
    bcm_fabric_qsel_t qsel_id);

/* Destroys all qsel on the unit */
extern int bcm_fabric_qsel_destroy_all(
    int unit);

/* This gets information about a qsel */
extern int bcm_fabric_qsel_get(
    int unit, 
    bcm_fabric_qsel_t qsel_id, 
    uint32 *flags, 
    int *base, 
    int *count);

/* 
 * Traverse existing fabric qsels, calling the provided callback one time
 * per existing qsel
 */
extern int bcm_fabric_qsel_traverse(
    int unit, 
    bcm_fabric_qsel_traverse_cb cb, 
    void *user_data);

/* 
 * Sets an entry within a qsel.  To effectively clear an entry, provide
 * BCM_GPORT_INVALID as the queue.
 */
extern int bcm_fabric_qsel_entry_set(
    int unit, 
    bcm_fabric_qsel_t qsel_id, 
    int offset, 
    bcm_gport_t queue, 
    bcm_fabric_qsel_offset_t qsel_offset_id);

/* 
 * Gets an entry within a qsel.  Entries which are not in use will return
 * BCM_GPORT_INVALID as their queue.
 */
extern int bcm_fabric_qsel_entry_get(
    int unit, 
    bcm_fabric_qsel_t qsel_id, 
    int offset, 
    bcm_gport_t *queue, 
    bcm_fabric_qsel_offset_t *qsel_offset_id);

/* 
 * Sets a group of entries within a qsel.  To effectively clear entries,
 * set their respective queues to BCM_GPORT_INVALID.
 */
extern int bcm_fabric_qsel_entry_multi_set(
    int unit, 
    bcm_fabric_qsel_t qsel_id, 
    int offset, 
    int count, 
    bcm_gport_t *queue, 
    bcm_fabric_qsel_offset_t *qsel_offset_id);

/* 
 * Gets a group of entries within a qsel.  Entries that are not in use
 * will have BCM_GPORT_INVALID as their queue.
 */
extern int bcm_fabric_qsel_entry_multi_get(
    int unit, 
    bcm_fabric_qsel_t qsel_id, 
    int offset, 
    int count, 
    bcm_gport_t *queue, 
    bcm_fabric_qsel_offset_t *qsel_offset_id);

/* 
 * Traverse existing entries within a specified qsel, calling the
 * provided callback one time per existing entry
 */
extern int bcm_fabric_qsel_entry_traverse(
    int unit, 
    bcm_fabric_qsel_t qsel_id, 
    bcm_fabric_qsel_entry_traverse_cb cb, 
    void *user_data);

#endif /* BCM_HIDE_DISPATCHABLE */

#define BCM_FABRIC_QSEL_OFFSET_INGRESS  0x00000001 /* qsel will be used for
                                                      ingress path packets */
#define BCM_FABRIC_QSEL_OFFSET_EGRESS   0x00000002 /* qsel will be used for
                                                      egress path packets */
#define BCM_FABRIC_QSEL_OFFSET_WITH_ID  0x00000004 /* qsel needs to be
                                                      created/replaced with a
                                                      specific ID */
#define BCM_FABRIC_QSEL_OFFSET_REPLACE  0x00000008 /* qsel needs to be replaced
                                                      instead of created */

/* Callback used by bcm_fabric_qsel_offset_traverse */
typedef int (*bcm_fabric_qsel_offset_traverse_cb)(
    int unit, 
    bcm_fabric_qsel_offset_t qsel_offset_id, 
    uint32 flags, 
    void *user_data);

/* Callback used by bcm_fabric_qsel_offset_entry_traverse */
typedef int (*bcm_fabric_qsel_offset_entry_traverse_cb)(
    int unit, 
    bcm_fabric_qsel_offset_t qsel_offset_id, 
    bcm_cos_t int_pri, 
    int offset, 
    void *user_data);

#ifndef BCM_HIDE_DISPATCHABLE

/* This creates or updates a qsel_offset */
extern int bcm_fabric_qsel_offset_create(
    int unit, 
    uint32 flags, 
    bcm_fabric_qsel_offset_t *qsel_offset_id);

/* This destroys a qsel_offset */
extern int bcm_fabric_qsel_offset_destroy(
    int unit, 
    bcm_fabric_qsel_offset_t qsel_offset_id);

/* Destroys all qsel_offset on the unit */
extern int bcm_fabric_qsel_offset_destroy_all(
    int unit);

/* 
 * Traverse existing qsel_offsets, calling the provided callback one time
 * per existing qsel_offset
 */
extern int bcm_fabric_qsel_offset_traverse(
    int unit, 
    bcm_fabric_qsel_offset_traverse_cb cb, 
    void *user_data);

/* Set an entry of a qsel_offset */
extern int bcm_fabric_qsel_offset_entry_set(
    int unit, 
    bcm_fabric_qsel_offset_t qsel_offset_id, 
    bcm_cos_t int_pri, 
    int offset);

/* Get an entry of a qsel_offset */
extern int bcm_fabric_qsel_offset_entry_get(
    int unit, 
    bcm_fabric_qsel_offset_t qsel_offset_id, 
    bcm_cos_t int_pri, 
    int *offset);

/* 
 * Traverse entries in a qsel_offset, calling the provided callback one
 * time per existing entry
 */
extern int bcm_fabric_qsel_offset_entry_traverse(
    int unit, 
    bcm_fabric_qsel_offset_t qsel_offset_id, 
    bcm_fabric_qsel_offset_entry_traverse_cb cb, 
    void *user_data);

#endif /* BCM_HIDE_DISPATCHABLE */

#endif /* __BCM_FABRIC_H__ */
