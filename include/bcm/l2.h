/*
 * $Id: l2.h 1.76.6.2 Broadcom SDK $
 * 
 * $Copyright: Copyright 2011 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 * 
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 */

#ifndef __BCM_L2_H__
#define __BCM_L2_H__

#include <bcm/types.h>

/* 
 * Flags for device-independent L2 address.
 * 
 * Special note on insert/delete/lookup-specific flags:
 * 
 *   BCM_L2_NATIVE
 *   BCM_L2_MOVE
 *   BCM_L2_FROM_NATIVE
 *   BCM_L2_TO_NATIVE
 *   BCM_L2_MOVE_PORT
 *   BCM_L2_LOCAL_CPU
 * 
 * On a move, two calls occur: delete and insert. The from native/to
 * native calls are set the same for both of these operations. On an age,
 * the move bit is not set and only one delete operation occurs.
 * 
 * Suggested application operation:
 * 
 *      Insert:  If native is set, send insert op to all units.
 *      Age:     If native is set, send delete operation to all units.
 *      Move:    Ignore delete indication and wait for insert operation.
 *               Treat insert like above.
 * 
 * That is, ignore move-delete operations; only forward other
 * operations if native.
 * 
 * The BCM_L2_LOCAL_CPU flag indicates the entry is for the local CPU on
 * the device. This is valid for _add operations only. Note that
 * BCM_L2_LOCAL_CPU is related to the L2_NATIVE value. L2_NATIVE is valid
 * on reads, L2_LOCAL_CPU is valid on move or write.
 */
#define BCM_L2_COS_SRC_PRI              0x00000001 /* Source COS has priority
                                                      over destination COS. */
#define BCM_L2_DISCARD_SRC              0x00000002 
#define BCM_L2_DISCARD_DST              0x00000004 
#define BCM_L2_COPY_TO_CPU              0x00000008 
#define BCM_L2_L3LOOKUP                 0x00000010 
#define BCM_L2_STATIC                   0x00000020 
#define BCM_L2_HIT                      0x00000040 
#define BCM_L2_TRUNK_MEMBER             0x00000080 
#define BCM_L2_MCAST                    0x00000100 
#define BCM_L2_REPLACE_DYNAMIC          0x00000200 
#define BCM_L2_SRC_HIT                  0x00000400 
#define BCM_L2_DES_HIT                  0x00000800 
#define BCM_L2_REMOTE_TRUNK             0x00001000 
#define BCM_L2_MIRROR                   0x00002000 
#define BCM_L2_SETPRI                   0x00004000 
#define BCM_L2_REMOTE_LOOKUP            0x00008000 
#define BCM_L2_NATIVE                   0x00010000 
#define BCM_L2_MOVE                     0x00020000 
#define BCM_L2_FROM_NATIVE              0x00040000 
#define BCM_L2_TO_NATIVE                0x00080000 
#define BCM_L2_MOVE_PORT                0x00100000 
#define BCM_L2_LOCAL_CPU                0x00200000 /* Entry is for the local CPU
                                                      on the device. */
#define BCM_L2_USE_FABRIC_DISTRIBUTION  0x00400000 /* Use specified fabric
                                                      distribution class. */
#define BCM_L2_PENDING                  0x00800000 
#define BCM_L2_LEARN_LIMIT_EXEMPT       0x01000000 
#define BCM_L2_LEARN_LIMIT              0x02000000 

/* These are in bit order. */
#define BCM_L2_FLAGS_STR        \
{ \
    "SrcCOS", \
    "SrcDisc", \
    "DestDisc", \
    "CopyCPU", \
    "L3Lkup", \
    "Static", \
    "Hit", \
    "Trunk", \
    "Mcast", \
    "RplDyn", \
    "SrcHit", \
    "DestHit", \
    "RTrunk", \
    "Mirror", \
    "SetPri", \
    "RemoteLookup", \
    "Native", \
    "Move", \
    "FrNative", \
    "ToNative", \
    "MovePort", \
    "LclCPU", \
    "MplsVpn", \
    "Gport" \
} 

/* bcm_l2_flags_str */
extern char *bcm_l2_flags_str[];

/* bcm_l2_flags_count */
extern int bcm_l2_flags_count;

#define BCM_L2_RTAG_MAC_SRC     0x1        
#define BCM_L2_RTAG_MAC_DST     0x2        
#define BCM_L2_RTAG_MAC_SRCDST  0x3        
#define BCM_L2_RTAG_IP_SRC      0x4        
#define BCM_L2_RTAG_IP_DST      0x5        
#define BCM_L2_RTAG_IP_SRCDST   0x6        

#define BCM_L2_AUTH_NONE            0          
#define BCM_L2_AUTH_STATIC_ACCEPT   4          
#define BCM_L2_AUTH_STATIC_REJECT   5          
#define BCM_L2_AUTH_SA_NUM          6          
#define BCM_L2_AUTH_SA_MATCH        7          

#define BCM_L2_VID_MASK_ALL     0x0fff     
#define BCM_L2_SRCPORT_MASK_ALL 0x3f       

#define BCM_L2_CALLBACK_DELETE  0          
#define BCM_L2_CALLBACK_ADD     1          
#define BCM_L2_CALLBACK_REPORT  2          

/* Device-independent L2 address structure. */
typedef struct bcm_l2_addr_s {
    uint32 flags;                       /* BCM_L2_xxx flags. */
    bcm_mac_t mac;                      /* 802.3 MAC address. */
    bcm_vlan_t vid;                     /* VLAN identifier. */
    int port;                           /* Zero-based port number. */
    int modid;                          /* XGS: modid. */
    bcm_trunk_t tgid;                   /* Trunk group ID. */
    int rtag;                           /* Trunk port select formula. */
    bcm_cos_t cos_dst;                  /* COS based on dst addr. */
    bcm_cos_t cos_src;                  /* COS based on src addr. */
    int l2mc_index;                     /* XGS: index in L2MC table. For SBX
                                           chips it is the Multicast Group index */
    bcm_pbmp_t block_bitmap;            /* XGS: blocked egress bitmap. */
    int auth;                           /* Used if auth enabled on port. */
    int group;                          /* Group number for FP. */
    bcm_fabric_distribution_t distribution_class; /* Fabric Distribution Class. */
} bcm_l2_addr_t;

/* Flags for device-independent L2 egress. */
#define BCM_L2_EGRESS_WITH_ID               0x00000001 /* Use the specified
                                                          Encap ID while
                                                          creating. */
#define BCM_L2_EGRESS_REPLACE               0x00000002 /* Replace config of
                                                          existing egress
                                                          object. */
#define BCM_L2_EGRESS_DEST_MAC_REPLACE      0x00000004 /* Replace dest MAC. */
#define BCM_L2_EGRESS_DEST_MAC_PREFIX5_REPLACE 0x00000008 /* Replace only 5 prefix
                                                          bytes of dest MAC. */
#define BCM_L2_EGRESS_SRC_MAC_REPLACE       0x00000010 /* Replace source MAC. */
#define BCM_L2_EGRESS_OUTER_VLAN_REPLACE    0x00000020 /* Replace outer vlan. */
#define BCM_L2_EGRESS_OUTER_PRIO_REPLACE    0x00000040 /* Replace outer tag
                                                          priority. */
#define BCM_L2_EGRESS_INNER_VLAN_REPLACE    0x00000080 /* Replace inner vlan. */
#define BCM_L2_EGRESS_INNER_PRIO_REPLACE    0x00000100 /* Replace inner tag
                                                          priority. */
#define BCM_L2_EGRESS_ETHERTYPE_REPLACE     0x00000200 /* Replace ethertype */
#define BCM_L2_EGRESS_DEST_PORT             0x00000400 /* Associate l2 egress
                                                          entry with a
                                                          particular dest port */

/* Device-independent L2 egress structure. */
typedef struct bcm_l2_egress_s {
    uint32 flags;               /* BCM_L2_EGRESS_XXX flags. */
    bcm_mac_t dest_mac;         /* Destination MAC address to replace with. */
    bcm_mac_t src_mac;          /* Source MAC address to replace with. */
    bcm_vlan_t outer_vlan;      /* outer vlan tag to replace with. */
    bcm_vlan_t inner_vlan;      /* inner vlan tag to replace with. */
    bcm_ethertype_t ethertype;  /* Ethertype to replace with. */
    bcm_gport_t dest_port;      /* Destination gport to associate this l2 egress
                                   entry with */
    bcm_if_t encap_id;          /* Encapsulation index */
} bcm_l2_egress_t;

/* Flags for device-independent L2 cache address. */
#define BCM_L2_CACHE_CPU            0x00000001 /* Packet is copied to CPU. */
#define BCM_L2_CACHE_DISCARD        0x00000002 /* Packet is not switched. */
#define BCM_L2_CACHE_MIRROR         0x00000004 /* Packet is mirrored. */
#define BCM_L2_CACHE_L3             0x00000008 /* Packet is to be L3 routed. */
#define BCM_L2_CACHE_BPDU           0x00000010 /* Packet is BPDU. */
#define BCM_L2_CACHE_SETPRI         0x00000020 /* Internal prio from prio field. */
#define BCM_L2_CACHE_TRUNK          0x00000040 /* Destination is a trunk. */
#define BCM_L2_CACHE_REMOTE_LOOKUP  0x00000080 /* Remote L2 lookup requested. */
#define BCM_L2_CACHE_LEARN_DISABLE  0x00000100 /* Packet source address is not
                                                  learned for this destination
                                                  address. */
#define BCM_L2_CACHE_TUNNEL         0x00000200 /* Tunnel termination address. */
#define BCM_L2_CACHE_DESTPORTS      0x00000400 /* Packet is forwarded by
                                                  multiport L2 address. */
#define BCM_L2_CACHE_SUBTYPE        0x00000800 /* Slow protocol subtype to
                                                  match. */
#define BCM_L2_CACHE_LOOKUP         0x00001000 /* L2 lookup requested. */
#define BCM_L2_CACHE_MULTICAST      0x00002000 /* Destination is (flood)
                                                  multicast group. */

/* Device-independent L2 cache address structure. */
typedef struct bcm_l2_cache_addr_s {
    uint32 flags;               /* BCM_L2_CACHE_xxx flags. */
    bcm_mac_t mac;              /* Destination MAC address to match. */
    bcm_mac_t mac_mask;         /* MAC address mask. */
    bcm_vlan_t vlan;            /* VLAN to match. */
    bcm_vlan_t vlan_mask;       /* VLAN mask. */
    bcm_port_t src_port;        /* Ingress port to match (BCM5660x). */
    bcm_port_t src_port_mask;   /* Ingress port mask (must be 0 if not
                                   BCM5660x). */
    bcm_module_t dest_modid;    /* Switch destination module ID. */
    bcm_port_t dest_port;       /* Switch destination port. */
    bcm_trunk_t dest_trunk;     /* Switch destination trunk ID. */
    int prio;                   /* Internal priority, use -1 to not set. */
    bcm_pbmp_t dest_ports;      /* Destination ports for Multiport L2 address
                                   forwarding. */
    int lookup_class;           /* Classification class ID. */
    uint8 subtype;              /* Slow protocol subtype to match. */
    bcm_if_t encap_id;          /* Encapsulation index. */
    bcm_multicast_t group;      /* Flood domain for L2CP. */
} bcm_l2_cache_addr_t;

/* Flags for L2 learn limit. */
#define BCM_L2_LEARN_LIMIT_SYSTEM           0x00000001 /* Limit is system wide. */
#define BCM_L2_LEARN_LIMIT_VLAN             0x00000002 /* Limit is on per VLAN
                                                          basis. */
#define BCM_L2_LEARN_LIMIT_PORT             0x00000004 /* Limit is on per port
                                                          basis. */
#define BCM_L2_LEARN_LIMIT_TRUNK            0x00000008 /* Limit is on per trunk
                                                          basis. */
#define BCM_L2_LEARN_LIMIT_ACTION_DROP      0x00000010 /* Drop if over limit. */
#define BCM_L2_LEARN_LIMIT_ACTION_CPU       0x00000020 /* Send to CPU if over
                                                          limit. */
#define BCM_L2_LEARN_LIMIT_ACTION_PREFER    0x00000040 /* Use system drop/CPU if
                                                          over both system limit
                                                          and non-system limit,
                                                          used by system wide
                                                          setting only. */

/* L2 learn limit structure. */
typedef struct bcm_l2_learn_limit_s {
    uint32 flags;       /* BCM_L2_LEARN_LIMIT_xxx actions and qualifiers. */
    bcm_vlan_t vlan;    /* VLAN identifier. */
    bcm_port_t port;    /* Port number. */
    bcm_trunk_t trunk;  /* Trunk identifier. */
    int limit;          /* Maximum number of learned entries, -1 for unlimited. */
} bcm_l2_learn_limit_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Initialize the BCM L2 subsystem. */
extern int bcm_l2_init(
    int unit);

/* Clear the BCM L2 subsystem. */
extern int bcm_l2_clear(
    int unit);

/* Finalize the BCM L2 subsystem. */
extern int bcm_l2_detach(
    int unit);

#endif /* BCM_HIDE_DISPATCHABLE */

/* 
 * Initialize an L2 address structure to a specified MAC address and VLAN
 * ID.
 */
extern void bcm_l2_addr_t_init(
    bcm_l2_addr_t *l2addr, 
    const bcm_mac_t mac_addr, 
    bcm_vlan_t vid);

#define bcm_l2_addr_init        bcm_l2_addr_t_init 

#ifndef BCM_HIDE_DISPATCHABLE

/* Add an L2 address entry to the specified device. */
extern int bcm_l2_addr_add(
    int unit, 
    bcm_l2_addr_t *l2addr);

#endif /* BCM_HIDE_DISPATCHABLE */

#define BCM_L2_DELETE_STATIC        0x00000001 
#define BCM_L2_DELETE_PENDING       0x00000002 
#define BCM_L2_DELETE_NO_CALLBACKS  0x00000004 

#ifndef BCM_HIDE_DISPATCHABLE

/* Delete an L2 address entry from the specified device. */
extern int bcm_l2_addr_delete(
    int unit, 
    bcm_mac_t mac, 
    bcm_vlan_t vid);

/* Delete L2 entries associated with a destination module/port. */
extern int bcm_l2_addr_delete_by_port(
    int unit, 
    bcm_module_t mod, 
    bcm_port_t port, 
    uint32 flags);

/* Delete L2 entries associated with a MAC address. */
extern int bcm_l2_addr_delete_by_mac(
    int unit, 
    bcm_mac_t mac, 
    uint32 flags);

/* Delete L2 entries associated with a VLAN. */
extern int bcm_l2_addr_delete_by_vlan(
    int unit, 
    bcm_vlan_t vid, 
    uint32 flags);

/* Delete L2 entries associated with a trunk. */
extern int bcm_l2_addr_delete_by_trunk(
    int unit, 
    bcm_trunk_t tid, 
    uint32 flags);

/* 
 * Delete L2 entries associated with a MAC address and a destination
 * module/port.
 */
extern int bcm_l2_addr_delete_by_mac_port(
    int unit, 
    bcm_mac_t mac, 
    bcm_module_t mod, 
    bcm_port_t port, 
    uint32 flags);

/* 
 * Delete L2 entries associated with a VLAN and a destination
 * module/port.
 */
extern int bcm_l2_addr_delete_by_vlan_port(
    int unit, 
    bcm_vlan_t vid, 
    bcm_module_t mod, 
    bcm_port_t port, 
    uint32 flags);

/* 
 * Delete L2 entries associated with a VLAN and a destination
 * module/port.
 */
extern int bcm_l2_addr_delete_by_vlan_trunk(
    int unit, 
    bcm_vlan_t vid, 
    bcm_trunk_t tid, 
    uint32 flags);

/* Check if an L2 entry is present in the L2 table. */
extern int bcm_l2_addr_get(
    int unit, 
    bcm_mac_t mac_addr, 
    bcm_vlan_t vid, 
    bcm_l2_addr_t *l2addr);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Dump a hardware-independent L2 address. */
extern void bcm_l2_addr_dump(
    bcm_l2_addr_t *l2e);

#ifndef BCM_HIDE_DISPATCHABLE

/* Dump the key portion of a hardware-independent L2 address. */
extern int bcm_l2_key_dump(
    int unit, 
    char *pfx, 
    bcm_l2_addr_t *entry, 
    char *sfx);

#endif /* BCM_HIDE_DISPATCHABLE */

/* 
 * Callback function used for receiving notification about insertions
 * into and deletions from the L2 table dynamically as they occur. Valid
 * operations are: delete, add, and report. A report with l2addr=NULL
 * indicates a scan completion of the L2 table.
 */
typedef void (*bcm_l2_addr_callback_t)(
    int unit, 
    bcm_l2_addr_t *l2addr, 
    int operation, 
    void *userdata);

#ifndef BCM_HIDE_DISPATCHABLE

/* Register/Unregister a callback routine for BCM L2 subsystem. */
extern int bcm_l2_addr_register(
    int unit, 
    bcm_l2_addr_callback_t callback, 
    void *userdata);

/* Register/Unregister a callback routine for BCM L2 subsystem. */
extern int bcm_l2_addr_unregister(
    int unit, 
    bcm_l2_addr_callback_t callback, 
    void *userdata);

/* Set/Get the age timer. */
extern int bcm_l2_age_timer_set(
    int unit, 
    int age_seconds);

/* Set/Get the age timer. */
extern int bcm_l2_age_timer_get(
    int unit, 
    int *age_seconds);

/* Get the number of BPDU addresses available. */
extern int bcm_l2_bpdu_count(
    int unit);

/* Set/Get the BPDU address. */
extern int bcm_l2_bpdu_set(
    int unit, 
    int index, 
    bcm_mac_t addr);

/* Set/Get the BPDU address. */
extern int bcm_l2_bpdu_get(
    int unit, 
    int index, 
    bcm_mac_t *addr);

/* Temporarily stop/restore L2 table from changing. */
extern int bcm_l2_addr_freeze(
    int unit);

/* Temporarily stop/restore L2 table from changing. */
extern int bcm_l2_addr_thaw(
    int unit);

/* 
 * Given an L2 address entry, return existing addresses which could
 * conflict.
 */
extern int bcm_l2_conflict_get(
    int unit, 
    bcm_l2_addr_t *addr, 
    bcm_l2_addr_t *cf_array, 
    int cf_max, 
    int *cf_count);

/* Determine if the given port is "native" from the point of view of L2. */
extern int bcm_l2_port_native(
    int unit, 
    int modid, 
    int port);

/* Initialize the L2 cache. */
extern int bcm_l2_cache_init(
    int unit);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Initialize an L2 cache address structure. */
extern void bcm_l2_cache_addr_t_init(
    bcm_l2_cache_addr_t *addr);

#ifndef BCM_HIDE_DISPATCHABLE

/* Get number of L2 cache entries. */
extern int bcm_l2_cache_size_get(
    int unit, 
    int *size);

/* Set an L2 cache entry. */
extern int bcm_l2_cache_set(
    int unit, 
    int index, 
    bcm_l2_cache_addr_t *addr, 
    int *index_used);

/* Get an L2 cache entry. */
extern int bcm_l2_cache_get(
    int unit, 
    int index, 
    bcm_l2_cache_addr_t *addr);

/* Clear an L2 cache entry. */
extern int bcm_l2_cache_delete(
    int unit, 
    int index);

/* Clear all L2 cache entries. */
extern int bcm_l2_cache_delete_all(
    int unit);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Initialize an l2 egress object. */
extern void bcm_l2_egress_t_init(
    bcm_l2_egress_t *egr);

#ifndef BCM_HIDE_DISPATCHABLE

/* Create an l2 encapsulation index. */
extern int bcm_l2_egress_create(
    int unit, 
    bcm_l2_egress_t *egr);

/* Destroy an l2 encapsulation index. */
extern int bcm_l2_egress_destroy(
    int unit, 
    bcm_if_t encap_id);

/* Get l2 egress object configuration. */
extern int bcm_l2_egress_get(
    int unit, 
    bcm_if_t encap_id, 
    bcm_l2_egress_t *egr);

/* Find an encapsulation index with a specific l2 egress configuration. */
extern int bcm_l2_egress_find(
    int unit, 
    bcm_l2_egress_t *egr, 
    bcm_if_t *encap_id);

#endif /* BCM_HIDE_DISPATCHABLE */

/* l2 egress traverse callback */
typedef int (*bcm_l2_egress_traverse_cb)(
    int unit, 
    bcm_l2_egress_t *egr, 
    void *user_data);

#ifndef BCM_HIDE_DISPATCHABLE

/* Traverse L2 egress objects */
extern int bcm_l2_egress_traverse(
    int unit, 
    bcm_l2_egress_traverse_cb trav_fn, 
    void *user_data);

/* Add a destination L2 address to trigger tunnel processing. */
extern int bcm_l2_tunnel_add(
    int unit, 
    bcm_mac_t mac, 
    bcm_vlan_t vlan);

/* Clear a destination L2 address used to trigger tunnel processing. */
extern int bcm_l2_tunnel_delete(
    int unit, 
    bcm_mac_t mac, 
    bcm_vlan_t vlan);

/* Clear all destination L2 addresses used to trigger tunnel processing. */
extern int bcm_l2_tunnel_delete_all(
    int unit);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Initialize an L2 learn limit structure. */
extern void bcm_l2_learn_limit_t_init(
    bcm_l2_learn_limit_t *limit);

#ifndef BCM_HIDE_DISPATCHABLE

/* Set/Get L2 addresses learn limit. */
extern int bcm_l2_learn_limit_set(
    int unit, 
    bcm_l2_learn_limit_t *limit);

/* Set/Get L2 addresses learn limit. */
extern int bcm_l2_learn_limit_get(
    int unit, 
    bcm_l2_learn_limit_t *limit);

#endif /* BCM_HIDE_DISPATCHABLE */

#define BCM_L2_LEARN_CLASS_MOVE 0x01       

#ifndef BCM_HIDE_DISPATCHABLE

/* Set/Get attributes for the specified L2 learning class. */
extern int bcm_l2_learn_class_set(
    int unit, 
    int lclass, 
    int lclass_prio, 
    uint32 flags);

/* Set/Get attributes for the specified L2 learning class. */
extern int bcm_l2_learn_class_get(
    int unit, 
    int lclass, 
    int *lclass_prio, 
    uint32 *flags);

/* Set/Get L2 learning class for the specified port. */
extern int bcm_l2_learn_port_class_set(
    int unit, 
    bcm_gport_t port, 
    int lclass);

#endif /* BCM_HIDE_DISPATCHABLE */

/* L2 Statistics. */
typedef enum bcm_l2_stat_e {
    bcmL2StatSourcePackets, 
    bcmL2StatSourceBytes, 
    bcmL2StatDestPackets, 
    bcmL2StatDestBytes, 
    bcmL2StatDropPackets, 
    bcmL2StatDropBytes 
} bcm_l2_stat_t;

#define BCM_STAT_CHECK_L2_STAT(type)  do { if ( ((type) < bcmL2StatSourcePackets) || ((type) > bcmL2StatDropBytes) ) { return (BCM_E_BADID); } } while (0) 

#ifndef BCM_HIDE_DISPATCHABLE

/* Get the specified L2 statistic from the chip. */
extern int bcm_l2_stat_get(
    int unit, 
    bcm_l2_addr_t *l2_addr, 
    bcm_l2_stat_t stat, 
    uint64 *val);

/* Get the specified L2 statistic from the chip. */
extern int bcm_l2_stat_get32(
    int unit, 
    bcm_l2_addr_t *l2_addr, 
    bcm_l2_stat_t stat, 
    uint32 *val);

/* 
 * Set the specified L2 statistic to the indicated value for the
 * specified L2 address.
 */
extern int bcm_l2_stat_set(
    int unit, 
    bcm_l2_addr_t *l2_addr, 
    bcm_l2_stat_t stat, 
    uint64 val);

/* 
 * Set the specified L2 statistic to the indicated value for the
 * specified L2 address.
 */
extern int bcm_l2_stat_set32(
    int unit, 
    bcm_l2_addr_t *l2_addr, 
    bcm_l2_stat_t stat, 
    uint32 val);

/* Enable/disable collection of statistics on the indicated L2 entry. */
extern int bcm_l2_stat_enable_set(
    int unit, 
    bcm_l2_addr_t *l2_addr, 
    int enable);

/* Set/Get L2 learning class for the specified port. */
extern int bcm_l2_learn_port_class_get(
    int unit, 
    bcm_gport_t port, 
    int *lclass);

#endif /* BCM_HIDE_DISPATCHABLE */

/* bcm_l2_traverse_cb */
typedef int (*bcm_l2_traverse_cb)(
    int unit, 
    bcm_l2_addr_t *info, 
    void *user_data);

#ifndef BCM_HIDE_DISPATCHABLE

/* Traverse L2 table */
extern int bcm_l2_traverse(
    int unit, 
    bcm_l2_traverse_cb trav_fn, 
    void *user_data);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Flags for l2_replace API */
#define BCM_L2_REPLACE_MATCH_STATIC 0x0001     /* Replace L2 static entries. */
#define BCM_L2_REPLACE_MATCH_MAC    0x0002     /* Replace all L2 entries
                                                  matching given MAC address */
#define BCM_L2_REPLACE_MATCH_VLAN   0x0004     /* Replace all L2 entries
                                                  matching given VLAN id */
#define BCM_L2_REPLACE_MATCH_DEST   0x0008     /* Replace all L2 entries
                                                  matching given modid port/tgid */
#define BCM_L2_REPLACE_DELETE       0x0100     /* L2 replace will perform delete
                                                  operation instead of replace
                                                  on matching entries */
#define BCM_L2_REPLACE_NEW_TRUNK    0x0200     /* New destination is a trunk
                                                  group */
#define BCM_L2_REPLACE_PENDING      0x0400     /* Replace L2 pending entries. */
#define BCM_L2_REPLACE_NO_CALLBACKS 0x0800     /* Replace L2 entries without
                                                  callbacks. */
#define BCM_L2_REPLACE_LEARN_LIMIT  0x1000     /* Force ALL entries including
                                                  static to be counted for learn
                                                  limit */

#ifndef BCM_HIDE_DISPATCHABLE

/* Replace L2 entries matching given criterions */
extern int bcm_l2_replace(
    int unit, 
    uint32 flags, 
    bcm_l2_addr_t *match_addr, 
    bcm_module_t new_module, 
    bcm_port_t new_port, 
    bcm_trunk_t new_trunk);

#endif /* BCM_HIDE_DISPATCHABLE */

#endif /* __BCM_L2_H__ */
