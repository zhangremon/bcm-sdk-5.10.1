/*
 * $Id: l3.h 1.128.2.5 Broadcom SDK $
 * 
 * $Copyright: Copyright 2011 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 * 
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 */

#ifndef __BCM_L3_H__
#define __BCM_L3_H__

#if defined(INCLUDE_L3)

#include <bcm/types.h>
#include <bcm/stat.h>

/* L3 module flags. */
#define BCM_L3_L2ONLY           (1 << 0)   /* L2 switch only on interface. */
#define BCM_L3_UNTAG            (1 << 1)   /* Packet goes out untagged. */
#define BCM_L3_S_HIT            (1 << 2)   /* Source IP address match. */
#define BCM_L3_D_HIT            (1 << 3)   /* Destination IP address match. */
#define BCM_L3_HIT              (BCM_L3_S_HIT | BCM_L3_D_HIT) 
#define BCM_L3_HIT_CLEAR        (1 << 4)   /* Clear HIT bit. */
#define BCM_L3_ADD_TO_ARL       (1 << 5)   /* Add interface address MAC to ARL. */
#define BCM_L3_WITH_ID          (1 << 6)   /* ID is provided. */
#define BCM_L3_NEGATE           (1 << 7)   /* Negate a set. */
#define BCM_L3_REPLACE          (1 << 8)   /* Replace existing entry. */
#define BCM_L3_TGID             (1 << 9)   /* Port belongs to trunk. */
#define BCM_L3_RPE              (1 << 10)  /* Pick up new priority (COS). */
#define BCM_L3_IPMC             (1 << 11)  /* Set IPMC for real IPMC entry. */
#define BCM_L3_L2TOCPU          (1 << 12)  /* Packet to CPU unrouted, XGS12: Set
                                              IPMC for UC address. */
#define BCM_L3_DEFIP_CPU        (1 << 13)  /* Strata: DEFIP CPU bit set. */
#define BCM_L3_DEFIP_LOCAL      BCM_L3_DEFIP_CPU /* XGS: Local DEFIP route. */
#define BCM_L3_MULTIPATH        (1 << 14)  /* Specify ECMP treatment. */
#define BCM_L3_LPM_DEFROUTE     (1 << 15)  /* Default route in LPM. */
#define BCM_L3_HOST_AS_ROUTE    (1 << 16)  /* Use LPM if host table full. */
#define BCM_L3_IP6              (1 << 17)  /* IPv6. */
#define BCM_L3_RPF              (1 << 18)  /* RPF check. */
#define BCM_L3_SRC_DISCARD      (1 << 19)  /* Source Match Discard. */
#define BCM_L3_DST_DISCARD      (1 << 20)  /* Destination match discard. */
#define BCM_L3_SECONDARY        (1 << 21)  /* Secondary L3 interface. */
#define BCM_L3_ROUTE_LABEL      (1 << 22)  /* Indicates that MPLS label in route
                                              entry is valid. */
#define BCM_L3_COPY_TO_CPU      (1 << 23)  /* Send a copy to CPU. */
#define BCM_L3_KEEP_SRCMAC      (1 << 24)  /* Disable SA replacement for L3UC
                                              packets. */
#define BCM_L3_KEEP_DSTMAC      (1 << 25)  /* Disable DA replacement for L3UC
                                              packets. */
#define BCM_L3_KEEP_VLAN        (1 << 26)  /* Disable VLAN replacement for L3UC
                                              packets. */
#define BCM_L3_KEEP_TTL         (1 << 27)  /* Disable TTL replacement for L3UC
                                              packets. */
#define BCM_L3_TRILL_ONLY       (1 << 28)  /* Specific for TRILL Nexthop */

/* L3 Ingress Interface flags. */
#define BCM_L3_INGRESS_WITH_ID              (1 << 0)   /* L3 Ingress ID is
                                                          provided. */
#define BCM_L3_INGRESS_REPLACE              (1 << 1)   /* Replace existing L3
                                                          Ingress entry. */
#define BCM_L3_INGRESS_GLOBAL_ROUTE         (1 << 2)   /* Allow Global Route on
                                                          L3 Ingress Interface. */
#define BCM_L3_INGRESS_DSCP_TRUST           (1 << 3)   /* Trust incoming DSCP on
                                                          L3 Ingress */
#define BCM_L3_INGRESS_URPF_DEFAULT_ROUTE_CHECK (1 << 4)   /* Allow URPF Check on
                                                          Default Routes. */

/* L3 Interface QOS flags. */
#define BCM_L3_INTF_QOS_OUTER_VLAN_PRI_COPY (1 << 0)   /* Copy Outer Vlan .1p
                                                          from incoming packet
                                                          .1p. */
#define BCM_L3_INTF_QOS_OUTER_VLAN_PRI_SET  (1 << 1)   /* Set Outer Vlan .1p
                                                          from table entry. */
#define BCM_L3_INTF_QOS_OUTER_VLAN_PRI_REMARK (1 << 2)   /* Remark Outer Vlan .1p
                                                          from PHB. */
#define BCM_L3_INTF_QOS_INNER_VLAN_PRI_COPY (1 << 3)   /* Copy Inner Vlan .1p
                                                          from incoming packet
                                                          .1p. */
#define BCM_L3_INTF_QOS_INNER_VLAN_PRI_SET  (1 << 4)   /* Set Inner Vlan .1p
                                                          from table entry. */
#define BCM_L3_INTF_QOS_INNER_VLAN_PRI_REMARK (1 << 5)   /* Remark Outer Vlan .1p
                                                          from PHB. */
#define BCM_L3_INTF_QOS_DSCP_COPY           (1 << 6)   /* Use existing DSCP */
#define BCM_L3_INTF_QOS_DSCP_SET            (1 << 7)   /* Set DSCP from table
                                                          entry. */
#define BCM_L3_INTF_QOS_DSCP_REMARK         (1 << 8)   /* Remark DSCP from PHB. */

/* Reserved VRF values . */
#define BCM_L3_VRF_OVERRIDE     _SHR_L3_VRF_OVERRIDE /* Matches before VRF specific
                                              entries. */
#define BCM_L3_VRF_GLOBAL       _SHR_L3_VRF_GLOBAL /* Matches after VRF specific
                                              entries. */
#define BCM_L3_VRF_DEFAULT      _SHR_L3_VRF_DEFAULT /* Default VRF ID. */

/* Backward compatibility. */
#define BCM_L3_TUNNEL_TYPE_IP6_IP4  BCM_L3_TUNNEL_TYPE_6TO4 

/* Invalid L3 Ingress Interface */
#define BCM_L3_INGRESS_INTERFACE_INVALID    4095       /* Invalid L3 Ingress
                                                          Interface */

#define BCM_IP6_BYTE(a, n)      (((uint8 *) (a))[n]) 

#define BCM_IP6_HALF(a, n)      (((uint16 *) (a))[n]) 

#define BCM_IP6_WORD(a, n)      (((uint8 *) (a))[n]) 

#define BCM_IP4_MULTICAST(a)    \
    (((a) & 0xf0000000) == 0xe0000000) 

#define BCM_IP6_MULTICAST(a)    \
    ((BCM_IP6_BYTE(a, 0)) == 0xff) 

#define BCM_IP6_ADDR_EQ(a1, a2)  \
    (sal_memcmp((a1), (a2), BCM_IP6_ADDRLEN) == 0) 

#define BCM_IP6_LOOPBACK(a)     \
    ((BCM_IP6_WORD((a), 0) | BCM_IP6_WORD((a), 1) | \
      BCM_IP6_WORD((a), 2) | BCM_IP6_HALF((a), 6) | \
      BCM_IP6_BYTE((a), 14)) == 0 && BCM_IP6_BYTE((a), 15) == 1) 

#define BCM_IP6_V4_MAPPED(a)    \
    ((BCM_IP6_WORD((a), 0) | BCM_IP6_WORD((a), 1) | \
      BCM_IP6_HALF((a), 4)) == 0 && BCM_IP6_HALF((a), 5) == 0xffff) 

#define BCM_IP6_V4_COMPATIBLE(a)  \
    (BCM_IP6_WORD((a), 0) | BCM_IP6_WORD((a), 1) | BCM_IP6_WORD((a), 2) == 0) 

/* L3 Interface QOS setting. */
typedef struct bcm_l3_intf_qos_s {
    uint32 flags;   /* See BCM_L3_INTF_QOS_XXX flag definitions. */
    int qos_map_id; /* QOS Map ID. */
    uint8 pri;      /* Packet .1p. */
    uint8 cfi;      /* Packet CFI. */
    int dscp;       /* Packet DSCP. */
} bcm_l3_intf_qos_t;

/* 
 * L3 Interface Structure.
 * 
 * Contains information required for manipulating L3 interfaces.
 */
typedef struct bcm_l3_intf_s {
    uint32 l3a_flags;                   /* See BCM_L3_XXX flag definitions. */
    bcm_vrf_t l3a_vrf;                  /* Virtual router instance. */
    bcm_if_t l3a_intf_id;               /* Interface ID. */
    bcm_mac_t l3a_mac_addr;             /* MAC address. */
    bcm_vlan_t l3a_vid;                 /* VLAN ID. */
    bcm_vlan_t l3a_inner_vlan;          /* Inner vlan for double tagged packets. */
    int l3a_tunnel_idx;                 /* Tunnel (initiator) index. */
    int l3a_ttl;                        /* TTL threshold. */
    int l3a_mtu;                        /* MTU. */
    bcm_if_group_t l3a_group;           /* Interface group number. */
    bcm_l3_intf_qos_t vlan_qos;         /* Outer-Vlan QoS Setting. */
    bcm_l3_intf_qos_t inner_vlan_qos;   /* Inner-Vlan QoS Setting. */
    bcm_l3_intf_qos_t dscp_qos;         /* DSCP QoS Setting. */
} bcm_l3_intf_t;

/* 
 * L3 Egress Structure.
 * 
 * Description of an L3 forwarding destination.
 */
typedef struct bcm_l3_egress_s {
    uint32 flags;                   /* Interface flags (BCM_L3_TGID,
                                       BCM_L3_L2TOCPU). */
    bcm_if_t intf;                  /* L3 interface (source MAC, tunnel). */
    bcm_mac_t mac_addr;             /* Next hop forwarding destination mac. */
    bcm_vlan_t vlan;                /* Next hop vlan id. */
    bcm_module_t module; 
    bcm_port_t port;                /* Port packet switched to (if
                                       !BCM_L3_TGID). */
    bcm_trunk_t trunk;              /* Trunk packet switched to (if
                                       BCM_L3_TGID). */
    uint32 mpls_flags;              /* BCM_MPLS flag definitions. */
    bcm_mpls_label_t mpls_label;    /* MPLS label. */
    int mpls_qos_map_id;            /* MPLS EXP map ID. */
    int mpls_ttl;                   /* MPLS TTL threshold. */
    uint8 mpls_pkt_pri;             /* MPLS Packet Priority Value. */
    uint8 mpls_pkt_cfi;             /* MPLS Packet CFI Value. */
    uint8 mpls_exp;                 /* MPLS Exp. */
    bcm_if_t encap_id;              /* Encapsulation index. */
    bcm_failover_t failover_id;     /* Failover Object Index. */
    bcm_if_t failover_if_id;        /* Failover Egress Object index. */
} bcm_l3_egress_t;

/* L3 Ingress Interface URPF Mode setting. */
typedef enum bcm_l3_ingress_urpf_mode_e {
    bcmL3IngressUrpfDisable,    /* Disable unicast RPF. */
    bcmL3IngressUrpfLoose,      /* Loose mode Unicast RPF. */
    bcmL3IngressUrpfStrict      /* Strict mode Unicast RPF. */
} bcm_l3_ingress_urpf_mode_t;

/* 
 * L3 Ingress Structure.
 * 
 * Description of an L3 Ingress interface.
 */
typedef struct bcm_l3_ingress_s {
    uint32 flags;                       /* Interface flags. */
    bcm_vrf_t vrf;                      /* Virtual router id. */
    bcm_l3_ingress_urpf_mode_t urpf_mode; /* URPF mode setting for L3 Ingress
                                           Interface. */
    int intf_class;                     /* Classification class ID. */
    bcm_vlan_t ipmc_intf_id;            /* IPMC L2 distribution Vlan. */
    int qos_map_id;                     /* QoS DSCP priority map. */
} bcm_l3_ingress_t;

/* 
 * L3 Host Structure.
 * 
 * Contains information required for manipulating L3 host table entries.
 * 
 * The BCM_L3_IP6 flag in l3a_flags must be set to specify whether the
 * IPv4 or IPv6 addresses are valid.
 */
typedef struct bcm_l3_host_s {
    uint32 l3a_flags;           /* See BCM_L3_xxx flag definitions. */
    bcm_vrf_t l3a_vrf;          /* Virtual router instance. */
    bcm_ip_t l3a_ip_addr;       /* Destination host IP address (IPv4). */
    bcm_ip6_t l3a_ip6_addr;     /* Destination host IP address (IPv6). */
    bcm_cos_t l3a_pri;          /* New priority in packet. */
    bcm_if_t l3a_intf;          /* L3 intf associated with this address. */
    bcm_mac_t l3a_nexthop_mac;  /* Next hop MAC addr. */
    bcm_module_t l3a_modid;     /* Module ID packet is switched to. */
    bcm_port_t l3a_port_tgid;   /* Port/TGID packet is switched to. */
    bcm_port_t l3a_stack_port;  /* Used if modid not local (Strata Only). */
    int l3a_ipmc_ptr;           /* Pointer to IPMC table. */
    int l3a_lookup_class;       /* Classification lookup class ID. */
} bcm_l3_host_t;

/* Backward compatibility. */
typedef bcm_l3_host_t bcm_l3_ip_t;

/* 
 * L3 Key Structure.
 * 
 * Defines L3 table hash key structure.
 * 
 *   - For unicast addresses, key is DIP address or SIP to update HIT bit
 *   - For multicast addresses, the key is either IPMC group address
 *     (IPMC group address + src IP address), or
 *     (IPMC group address + src IP address + VID)
 *     depending on the chip being used and the (G, S, V) mode enable.
 * 
 * The BCM_L3_IP6 flag in l3k_flags is set to specify whether the IPv4 or
 * IPv6 addresses are valid.
 */
typedef struct bcm_l3_key_s {
    uint32 l3k_flags;           /* Set BCM_L3_IP6 for IPv6, default is IPv4, no
                                   other flags are relevant. */
    bcm_ip_t l3k_ip_addr;       /* Destination IP address (IPv4). */
    bcm_ip6_t l3k_ip6_addr;     /* Destination IP address (IPv6). */
    bcm_ip_t l3k_sip_addr;      /* Source IP address (IPv4). */
    bcm_ip6_t l3k_sip6_addr;    /* Source IP address (IPv6). */
    bcm_vlan_t l3k_vid;         /* VLAN ID. */
    bcm_vrf_t l3k_vrf;          /* BCM5660x: Virtual router instance. */
} bcm_l3_key_t;

/* 
 * L3 Route Structure
 * 
 * Contains information required for manipulating L3 route table entries.
 * 
 * @pThe BCM_L3_IP6 flag in l3a_flags must be set to specify whether the
 * IPv4 or IPv6 addresses are valid.
 */
typedef struct bcm_l3_route_s {
    uint32 l3a_flags;                   /* See BCM_L3_xxx flag definitions. */
    bcm_vrf_t l3a_vrf;                  /* Virtual router instance. */
    bcm_ip_t l3a_subnet;                /* IP subnet address (IPv4). */
    bcm_ip6_t l3a_ip6_net;              /* IP subnet address (IPv6). */
    bcm_ip_t l3a_ip_mask;               /* IP subnet mask (IPv4). */
    bcm_ip6_t l3a_ip6_mask;             /* IP subnet mask (IPv6). */
    bcm_if_t l3a_intf;                  /* L3 interface associated with route. */
    bcm_ip_t l3a_nexthop_ip;            /* Next hop IP address (XGS1/2, IPv4). */
    bcm_mac_t l3a_nexthop_mac;          /* Next hop MAC address. */
    bcm_module_t l3a_modid;             /* Module ID. */
    bcm_port_t l3a_port_tgid;           /* Port or trunk group ID. */
    bcm_port_t l3a_stack_port;          /* Used if modid is not local (Strata
                                           Only). */
    bcm_vlan_t l3a_vid;                 /* BCM5695 only - for per-VLAN def
                                           route. */
    bcm_cos_t l3a_pri;                  /* Priority (COS). */
    uint32 l3a_tunnel_option;           /* Tunnel option value. */
    bcm_mpls_label_t l3a_mpls_label;    /* MPLS label. */
    int l3a_lookup_class;               /* Classification class ID. */
} bcm_l3_route_t;

/* 
 * L3 Information Structure.
 * 
 * Contains information about L3 hardware capacity and utilization.
 * 
 * Note that in chips that implement the longest prefix match route table
 * as a trie, one IP route may consume up to 128 table entries in the
 * worst case.
 */
typedef struct bcm_l3_info_s {
    int l3info_max_vrf;             /* Maximum number of virtual routers
                                       allowed. */
    int l3info_used_vrf;            /* Number of virtual routers created so far. */
    int l3info_max_intf;            /* Maximum L3 interfaces the chip supports. */
    int l3info_max_intf_group;      /* Maximum L3 interface groups the chip
                                       supports. */
    int l3info_max_host;            /* L3 host table size(unit is IPv4 unicast). */
    int l3info_max_route;           /* L3 route table size (unit is IPv4 route). */
    int l3info_max_ecmp;            /* Maximum ECMP paths allowed. */
    int l3info_used_intf;           /* L3 interfaces used. */
    int l3info_used_host;           /* L3 host entries used. */
    int l3info_used_route;          /* L3 route entries used. */
    int l3info_max_lpm_block;       /* Maximum LPM blocks. */
    int l3info_used_lpm_block;      /* LPM blocks used. */
    int l3info_max_l3;              /* Superseded by l3info_max_host. */
    int l3info_max_defip;           /* Superseded by l3info_max_route. */
    int l3info_used_l3;             /* Superseded by l3info_occupied_host. */
    int l3info_used_defip;          /* Superseded by l3info_occupied_route. */
    int l3info_max_nexthop;         /* Maximum NextHops. */
    int l3info_used_nexthop;        /* NextHops used. */
    int l3info_max_tunnel_init;     /* Maximum IPV4 tunnels that can be
                                       initiated. */
    int l3info_used_tunnel_init;    /* Number of active IPV4 tunnels initiated. */
    int l3info_max_tunnel_term;     /* Maximum IPV4 tunnels that can be
                                       terminated. */
    int l3info_used_tunnel_term;    /* Number of active IPV4 tunnels terminated. */
} bcm_l3_info_t;

/* Renamed bcm_l3_info_t fields. */
#define l3info_occupied_intf    l3info_used_intf 
#define l3info_occupied_host    l3info_used_host 
#define l3info_occupied_route   l3info_used_route 
#define l3info_occupied_l3      l3info_used_l3 
#define l3info_occupied_defip   l3info_used_defip 
#define bcm_l3_detach           bcm_l3_cleanup 

/* bcm_l3_host_traverse_cb */
typedef int (*bcm_l3_host_traverse_cb)(
    int unit, 
    int index, 
    bcm_l3_host_t *info, 
    void *user_data);

/* bcm_l3_route_traverse_cb */
typedef int (*bcm_l3_route_traverse_cb)(
    int unit, 
    int index, 
    bcm_l3_route_t *info, 
    void *user_data);

/* bcm_l3_egress_traverse_cb */
typedef int (*bcm_l3_egress_traverse_cb)(
    int unit, 
    bcm_if_t intf, 
    bcm_l3_egress_t *info, 
    void *user_data);

/* bcm_l3_ingress_traverse_cb */
typedef int (*bcm_l3_ingress_traverse_cb)(
    int unit, 
    bcm_if_t intf_id, 
    bcm_l3_ingress_t *ing_intf, 
    void *user_data);

/* bcm_l3_egress_multipath_traverse_cb */
typedef int (*bcm_l3_egress_multipath_traverse_cb)(
    int unit, 
    bcm_if_t mpintf, 
    int intf_count, 
    bcm_if_t *intf_array, 
    void *user_data);

#ifndef BCM_HIDE_DISPATCHABLE

/* Initialize the BCM L3 subsystem. */
extern int bcm_l3_init(
    int unit);

/* De-initialize the BCM L3 subsystem. */
extern int bcm_l3_cleanup(
    int unit);

#endif /* BCM_HIDE_DISPATCHABLE */

#define bcm_l3_detach           bcm_l3_cleanup 

#ifndef BCM_HIDE_DISPATCHABLE

/* Enable/disable L3 function without clearing any L3 tables. */
extern int bcm_l3_enable_set(
    int unit, 
    int enable);

/* Get the status of hardware tables. */
extern int bcm_l3_info(
    int unit, 
    bcm_l3_info_t *l3info);

/* bcm_l3_untagged_update */
extern int bcm_l3_untagged_update(
    int unit);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Initialize a bcm_l3_intf_t/bcmx_l3_intf_t structure. */
extern void bcm_l3_intf_t_init(
    bcm_l3_intf_t *intf);

#ifndef BCM_HIDE_DISPATCHABLE

/* Create a new L3 interface. */
extern int bcm_l3_intf_create(
    int unit, 
    bcm_l3_intf_t *intf);

/* Delete an L3 interface. */
extern int bcm_l3_intf_delete(
    int unit, 
    bcm_l3_intf_t *intf);

/* Delete all L3 interfaces. */
extern int bcm_l3_intf_delete_all(
    int unit);

/* Search for L3 interface by MAC address and VLAN. */
extern int bcm_l3_intf_find(
    int unit, 
    bcm_l3_intf_t *intf);

/* Search for L3 interface by VLAN only. */
extern int bcm_l3_intf_find_vlan(
    int unit, 
    bcm_l3_intf_t *intf);

/* Given the L3 interface number, return the interface information. */
extern int bcm_l3_intf_get(
    int unit, 
    bcm_l3_intf_t *intf);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Initialize a bcm_l3_egress_t/bcmx_l3_egress_t structure. */
extern void bcm_l3_egress_t_init(
    bcm_l3_egress_t *egr);

#ifndef BCM_HIDE_DISPATCHABLE

/* Create an Egress forwarding object. */
extern int bcm_l3_egress_create(
    int unit, 
    uint32 flags, 
    bcm_l3_egress_t *egr, 
    bcm_if_t *if_id);

/* Destroy an Egress forwarding object. */
extern int bcm_l3_egress_destroy(
    int unit, 
    bcm_if_t intf);

/* Get an Egress forwarding object. */
extern int bcm_l3_egress_get(
    int unit, 
    bcm_if_t intf, 
    bcm_l3_egress_t *egr);

/* Find an interface pinting to an Egress forwarding object. */
extern int bcm_l3_egress_find(
    int unit, 
    bcm_l3_egress_t *egr, 
    bcm_if_t *intf);

/* 
 * Traverse through the egress object table and run callback at each
 * valid entry.
 */
extern int bcm_l3_egress_traverse(
    int unit, 
    bcm_l3_egress_traverse_cb trav_fn, 
    void *user_data);

/* Create a Multipath Egress forwarding object. */
extern int bcm_l3_egress_multipath_create(
    int unit, 
    uint32 flags, 
    int intf_count, 
    bcm_if_t *intf_array, 
    bcm_if_t *mpintf);

/* Create a Multipath Egress forwarding object with specified path-width. */
extern int bcm_l3_egress_multipath_max_create(
    int unit, 
    uint32 flags, 
    int max_paths, 
    int intf_count, 
    bcm_if_t *intf_array, 
    bcm_if_t *mpintf);

/* Destroy an Egress Multipath forwarding object. */
extern int bcm_l3_egress_multipath_destroy(
    int unit, 
    bcm_if_t mpintf);

/* Get an Egress Multipath forwarding object. */
extern int bcm_l3_egress_multipath_get(
    int unit, 
    bcm_if_t mpintf, 
    int intf_size, 
    bcm_if_t *intf_array, 
    int *intf_count);

/* 
 * Add an Egress forwarding object to an Egress Multipath forwarding
 * object.
 */
extern int bcm_l3_egress_multipath_add(
    int unit, 
    bcm_if_t mpintf, 
    bcm_if_t intf);

/* 
 * Delete an Egress forwarding object from an Egress Multipath forwarding
 * object.
 */
extern int bcm_l3_egress_multipath_delete(
    int unit, 
    bcm_if_t mpintf, 
    bcm_if_t intf);

/* Find an interface pinting to an Egress Multipath forwarding object. */
extern int bcm_l3_egress_multipath_find(
    int unit, 
    int intf_count, 
    bcm_if_t *intf_array, 
    bcm_if_t *mpintf);

/* 
 * Traverse through the multipath egress object table and run callback at
 * each valid entry.
 */
extern int bcm_l3_egress_multipath_traverse(
    int unit, 
    bcm_l3_egress_multipath_traverse_cb trav_fn, 
    void *user_data);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Initialize a bcm_l3_ingress_t/bcmx_l3_ingress_t structure. */
extern void bcm_l3_ingress_t_init(
    bcm_l3_ingress_t *ing_intf);

#ifndef BCM_HIDE_DISPATCHABLE

/* Create an L3 Ingress Interface. */
extern int bcm_l3_ingress_create(
    int unit, 
    bcm_l3_ingress_t *ing_intf, 
    bcm_if_t *intf_id);

/* Destroy an L3 Ingress Interface. */
extern int bcm_l3_ingress_destroy(
    int unit, 
    bcm_if_t intf_id);

/* Get L3 Ingress Interface configuration. */
extern int bcm_l3_ingress_get(
    int unit, 
    bcm_if_t intf, 
    bcm_l3_ingress_t *ing_intf);

/* Find an identical ingress L3 interface. */
extern int bcm_l3_ingress_find(
    int unit, 
    bcm_l3_ingress_t *ing_intf, 
    bcm_if_t *intf_id);

/* 
 * Traverse through the L3 ingress interfaces and invoke a user provide
 * callback for each valid entry.
 */
extern int bcm_l3_ingress_traverse(
    int unit, 
    bcm_l3_ingress_traverse_cb trav_fn, 
    void *user_data);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Initialize a bcm_l3_host_t/bcmx_l3_host_t structure. */
extern void bcm_l3_host_t_init(
    bcm_l3_host_t *ip);

#ifndef BCM_HIDE_DISPATCHABLE

/* Look up an L3 host table entry based on IP address. */
extern int bcm_l3_host_find(
    int unit, 
    bcm_l3_host_t *info);

/* Add an entry into the L3 switching table. */
extern int bcm_l3_host_add(
    int unit, 
    bcm_l3_host_t *info);

/* Delete an entry from the L3 host table. */
extern int bcm_l3_host_delete(
    int unit, 
    bcm_l3_host_t *ip_addr);

/* Delete L3 entries based on IP prefix (network). */
extern int bcm_l3_host_delete_by_network(
    int unit, 
    bcm_l3_route_t *ip_addr);

/* 
 * Deletes L3 entries that match or do not match a specified L3 interface
 * number.
 */
extern int bcm_l3_host_delete_by_interface(
    int unit, 
    bcm_l3_host_t *info);

/* Deletes all L3 host table entries. */
extern int bcm_l3_host_delete_all(
    int unit, 
    bcm_l3_host_t *info);

/* Return list of conflicts in the L3 table. */
extern int bcm_l3_host_conflict_get(
    int unit, 
    bcm_l3_key_t *ipkey, 
    bcm_l3_key_t *cf_array, 
    int cf_max, 
    int *cf_count);

/* Run L3 table aging. */
extern int bcm_l3_host_age(
    int unit, 
    uint32 flags, 
    bcm_l3_host_traverse_cb age_cb, 
    void *user_data);

/* Traverse through the L3 table and run callback at each valid L3 entry. */
extern int bcm_l3_host_traverse(
    int unit, 
    uint32 flags, 
    uint32 start, 
    uint32 end, 
    bcm_l3_host_traverse_cb cb, 
    void *user_data);

/* bcm_l3_host_invalidate_entry */
extern int bcm_l3_host_invalidate_entry(
    int unit, 
    bcm_ip_t info);

/* bcm_l3_host_validate_entry */
extern int bcm_l3_host_validate_entry(
    int unit, 
    bcm_ip_t info);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Initialize a bcm_l3_route_t/bcmx_l3_route_t_init structure. */
extern void bcm_l3_route_t_init(
    bcm_l3_route_t *route);

#ifndef BCM_HIDE_DISPATCHABLE

/* Add an IP route to the L3 route table. */
extern int bcm_l3_route_add(
    int unit, 
    bcm_l3_route_t *info);

/* Delete an IP route from the DEFIP table. */
extern int bcm_l3_route_delete(
    int unit, 
    bcm_l3_route_t *info);

/* Delete routes based on matching or non-matching L3 interface number. */
extern int bcm_l3_route_delete_by_interface(
    int unit, 
    bcm_l3_route_t *info);

/* Delete all routes. */
extern int bcm_l3_route_delete_all(
    int unit, 
    bcm_l3_route_t *info);

/* Look up a route given the network and netmask. */
extern int bcm_l3_route_get(
    int unit, 
    bcm_l3_route_t *info);

/* Given a network, return all the paths for this route. */
extern int bcm_l3_route_multipath_get(
    int unit, 
    bcm_l3_route_t *the_route, 
    bcm_l3_route_t *path_array, 
    int max_path, 
    int *path_count);

/* Age the route table. */
extern int bcm_l3_route_age(
    int unit, 
    uint32 flags, 
    bcm_l3_route_traverse_cb age_out, 
    void *user_data);

/* Traverse through the routing table and run callback at each route. */
extern int bcm_l3_route_traverse(
    int unit, 
    uint32 flags, 
    uint32 start, 
    uint32 end, 
    bcm_l3_route_traverse_cb trav_fn, 
    void *user_data);

/* Set the maximum ECMP paths allowed for a route (XGS only). */
extern int bcm_l3_route_max_ecmp_set(
    int unit, 
    int max);

/* Get the maximum ECMP paths allowed for a route (XGS only). */
extern int bcm_l3_route_max_ecmp_get(
    int unit, 
    int *max);

/* 
 * Extract list of IPv6 prefixes which are forwarded based on lower 32
 * bit of IPv6 address, treated as IPv4 address.
 */
extern int bcm_l3_ip6_prefix_map_get(
    int unit, 
    int map_size, 
    bcm_ip6_t *ip6_array, 
    int *ip6_count);

/* 
 * Add IPv6 prefix to the list of prefixes which are forwarded based on
 * lower 32 bit of IPv6 address, treated as IPv4 address.
 */
extern int bcm_l3_ip6_prefix_map_add(
    int unit, 
    bcm_ip6_t ip6_addr);

/* 
 * Remove IPv6 prefix from the list of prefixes which are forwarded based
 * on lower 32 bit of IPv6 address, treated as IPv4 address.
 */
extern int bcm_l3_ip6_prefix_map_delete(
    int unit, 
    bcm_ip6_t ip6_addr);

/* 
 * Remove all the IPv6 prefixes from the list of prefixes which are
 * forwarded based on lower 32 bit of IPv6 address, treated as IPv4
 * address.
 */
extern int bcm_l3_ip6_prefix_map_delete_all(
    int unit);

#endif /* BCM_HIDE_DISPATCHABLE */

/* bcm_l3_age_cb */
typedef void (*bcm_l3_age_cb)(
    int unit, 
    bcm_ip_t ip);

#ifndef BCM_HIDE_DISPATCHABLE

/* Create a new L3 interface. */
extern int bcm_l3_interface_create(
    int unit, 
    bcm_mac_t mac_addr, 
    bcm_vlan_t vid, 
    int add_to_arl);

/* Create a new L3 interface with specified interface ID. */
extern int bcm_l3_interface_id_create(
    int unit, 
    bcm_mac_t mac_addr, 
    bcm_vlan_t vid, 
    int intf_idx, 
    int add_to_arl);

/* Create/update a new/existing L3 interface with specified interface ID. */
extern int bcm_l3_interface_id_update(
    int unit, 
    bcm_mac_t mac_addr, 
    bcm_vlan_t vid, 
    int intf_idx, 
    int add_to_arl);

/* Search for L3 interface based on MAC address and VLAN. */
extern int bcm_l3_interface_lookup(
    int unit, 
    bcm_mac_t mac_addr, 
    bcm_vlan_t vid, 
    int *intf_id);

/* Delete a L3 interface. */
extern int bcm_l3_interface_destroy(
    int unit, 
    int intf_id);

/* Given the L3 interface number, return the MAC and VLAN. */
extern int bcm_l3_interface_find(
    int unit, 
    int intf_id, 
    bcm_vlan_t *vid, 
    bcm_mac_t mac_addr);

/* Find the L3 interface by VLAN ID. */
extern int bcm_l3_interface_find_by_vlan(
    int unit, 
    bcm_vlan_t vid, 
    int *intf_id);

/* Lookup L3 host entry based on IP address. */
extern int bcm_l3_ip_find(
    int unit, 
    bcm_l3_ip_t *info);

/* bcm_l3_ip_find_index */
extern int bcm_l3_ip_find_index(
    int unit, 
    int index, 
    bcm_l3_ip_t *info);

/* Add an entry into L3 host table. */
extern int bcm_l3_ip_add(
    int unit, 
    bcm_l3_ip_t *info);

/* Delete an entry from the L3 host table. */
extern int bcm_l3_ip_delete(
    int unit, 
    bcm_ip_t ip_addr);

/* Delete L3 host entries based on IP prefix (network). */
extern int bcm_l3_ip_delete_by_prefix(
    int unit, 
    bcm_ip_t ip_addr, 
    bcm_ip_t mask);

/* Delete L3 host entries that match L3 interface number. */
extern int bcm_l3_ip_delete_by_interface(
    int unit, 
    int intf);

/* Delete all L3 host table entries. */
extern int bcm_l3_ip_delete_all(
    int unit);

/* 
 * Update L3 host entry with new information, the L3 host entry is
 * identified by the key of the entry which is the IP address for
 * unicast.
 */
extern int bcm_l3_ip_update_entry_by_key(
    int unit, 
    bcm_l3_ip_t *info);

/* Return list of conflicts in the L3 table. */
extern int bcm_l3_conflict_get(
    int unit, 
    bcm_l3_key_t *ipkey, 
    bcm_l3_key_t *cf_array, 
    int cf_max, 
    int *cf_count);

/* Invalidate L3 entry without clearing so it can be re-validated later. */
extern int bcm_l3_invalidate_entry(
    int unit, 
    bcm_ip_t l3_addr);

/* Invalidate L3 entry without clearing so it can be re-validated later. */
extern int bcm_l3_validate_entry(
    int unit, 
    bcm_ip_t l3_addr);

/* Run L3 table aging. */
extern int bcm_l3_age(
    int unit, 
    uint32 flags, 
    bcm_l3_age_cb age_out);

/* Return L3 status information. */
extern int bcm_l3_status(
    int unit, 
    int *free_l3intf, 
    int *free_l3, 
    int *free_defip, 
    int *free_lpm_blk);

/* Add an IP route to the route table. */
extern int bcm_l3_defip_add(
    int unit, 
    bcm_l3_route_t *info);

/* Delete an IP route from the route table. */
extern int bcm_l3_defip_delete(
    int unit, 
    bcm_l3_route_t *info);

/* Given the net/prefix, return route info. */
extern int bcm_l3_defip_get(
    int unit, 
    bcm_l3_route_t *info);

/* bcm_l3_defip_find_index */
extern int bcm_l3_defip_find_index(
    int unit, 
    int index, 
    bcm_l3_route_t *info);

/* Delete routes based on matching L3 interface number. */
extern int bcm_l3_defip_delete_by_interface(
    int unit, 
    int intf);

/* Delete all routes. */
extern int bcm_l3_defip_delete_all(
    int unit);

/* Age the route table. */
extern int bcm_l3_defip_age(
    int unit, 
    bcm_l3_route_traverse_cb age_out);

/* Set the maximum ECMP paths allowed for a route (XGS only). */
extern int bcm_l3_defip_max_ecmp_set(
    int unit, 
    int max);

/* Get the maximum ECMP paths allowed for a route (XGS only). */
extern int bcm_l3_defip_max_ecmp_get(
    int unit, 
    int *max);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Initialize a bcm_l3_key_t_init structure. */
extern void bcm_l3_key_t_init(
    bcm_l3_key_t *key);

/* Initialize a bcm_l3_info_t_init structure. */
extern void bcm_l3_info_t_init(
    bcm_l3_info_t *info);

/* Types of counters per L3 object. */
typedef enum bcm_l3_stat_e {
    bcmL3StatOutPackets, 
    bcmL3StatOutBytes, 
    bcmL3StatDropPackets, 
    bcmL3StatDropBytes, 
    bcmL3StatInPackets, 
    bcmL3StatInBytes 
} bcm_l3_stat_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Extract L3 egress statistics from the chip. */
extern int bcm_l3_egress_stat_get(
    int unit, 
    bcm_l3_egress_t *egr, 
    bcm_l3_stat_t stat, 
    uint64 *val);

/* Extract L3 egress statistics from the chip. */
extern int bcm_l3_egress_stat_get32(
    int unit, 
    bcm_l3_egress_t *egr, 
    bcm_l3_stat_t stat, 
    uint32 *val);

/* 
 * Set the specified L3 statistic to the indicated value for the
 * specified L3 egress.
 */
extern int bcm_l3_egress_stat_set(
    int unit, 
    bcm_l3_egress_t *egr, 
    bcm_l3_stat_t stat, 
    uint64 val);

/* 
 * Set the specified L3 statistic to the indicated value for the
 * specified L3 egress.
 */
extern int bcm_l3_egress_stat_set32(
    int unit, 
    bcm_l3_egress_t *egr, 
    bcm_l3_stat_t stat, 
    uint32 val);

/* Enable/disable collection of statistics on the indicated L3 egress. */
extern int bcm_l3_egress_stat_enable_set(
    int unit, 
    bcm_l3_egress_t *egr, 
    int enable);

/* Extract L3 host statistics from the chip. */
extern int bcm_l3_host_stat_get(
    int unit, 
    bcm_l3_host_t *host, 
    bcm_l3_stat_t stat, 
    uint64 *val);

/* Extract L3 host statistics from the chip. */
extern int bcm_l3_host_stat_get32(
    int unit, 
    bcm_l3_host_t *host, 
    bcm_l3_stat_t stat, 
    uint32 *val);

/* 
 * Set the specified L3 statistic to the indicated value for the
 * specified L3 host.
 */
extern int bcm_l3_host_stat_set(
    int unit, 
    bcm_l3_host_t *host, 
    bcm_l3_stat_t stat, 
    uint64 val);

/* 
 * Set the specified L3 statistic to the indicated value for the
 * specified L3 host.
 */
extern int bcm_l3_host_stat_set32(
    int unit, 
    bcm_l3_host_t *host, 
    bcm_l3_stat_t stat, 
    uint32 val);

/* Enable/disable collection of statistics for the indicated L3 host. */
extern int bcm_l3_host_stat_enable_set(
    int unit, 
    bcm_l3_host_t *host, 
    int enable);

extern int bcm_l3_route_stat_get(
    int unit, 
    bcm_l3_route_t *route, 
    bcm_l3_stat_t stat, 
    uint64 *val);

extern int bcm_l3_route_stat_get32(
    int unit, 
    bcm_l3_route_t *route, 
    bcm_l3_stat_t stat, 
    uint32 *val);

extern int bcm_l3_route_stat_set(
    int unit, 
    bcm_l3_route_t *route, 
    bcm_l3_stat_t stat, 
    uint64 val);

extern int bcm_l3_route_stat_set32(
    int unit, 
    bcm_l3_route_t *route, 
    bcm_l3_stat_t stat, 
    uint32 val);

/* Enable/disable collection of statistics for the indicated L3 route. */
extern int bcm_l3_route_stat_enable_set(
    int unit, 
    bcm_l3_route_t *route, 
    int enable);

#endif /* BCM_HIDE_DISPATCHABLE */

/* Types of statistics that are maintained per L3 VRF. */
typedef enum bcm_l3_vrf_stat_e {
    bcmL3VrfStatIngressPackets, /* Packets that ingress on the L3 VRF */
    bcmL3VrfStatIngressBytes    /* Bytes that ingress on the L3 VRF */
} bcm_l3_vrf_stat_t;

#ifndef BCM_HIDE_DISPATCHABLE

/* Enable/disable packet and byte counters for the selected VRF. */
extern int bcm_l3_vrf_stat_enable_set(
    int unit, 
    bcm_vrf_t vrf, 
    int enable);

/* Get 64-bit counter value for specified VRF statistic type. */
extern int bcm_l3_vrf_stat_get(
    int unit, 
    bcm_vrf_t vrf, 
    bcm_l3_vrf_stat_t stat, 
    uint64 *val);

/* Get lower 32-bit counter value for specified VRF statistic type. */
extern int bcm_l3_vrf_stat_get32(
    int unit, 
    bcm_vrf_t vrf, 
    bcm_l3_vrf_stat_t stat, 
    uint32 *val);

/* Provide stat counter ids associated with given vrf */
extern int bcm_l3_vrf_stat_id_get(
    int unit, 
    bcm_vrf_t vrf, 
    bcm_l3_vrf_stat_t stat, 
    uint32 *stat_counter_id);

/* Set 64-bit counter value for specified VRF statistic type. */
extern int bcm_l3_vrf_stat_set(
    int unit, 
    bcm_vrf_t vrf, 
    bcm_l3_vrf_stat_t stat, 
    uint64 val);

/* Set lower 32-bit counter value for specified VRF statistic type. */
extern int bcm_l3_vrf_stat_set32(
    int unit, 
    bcm_vrf_t vrf, 
    bcm_l3_vrf_stat_t stat, 
    uint32 val);

/* Get 64-bit counter value for multiple VRF statistic types. */
extern int bcm_l3_vrf_stat_multi_get(
    int unit, 
    bcm_vrf_t vrf, 
    int nstat, 
    bcm_l3_vrf_stat_t *stat_arr, 
    uint64 *value_arr);

/* Get lower 32-bit counter value for multiple VRF statistic types. */
extern int bcm_l3_vrf_stat_multi_get32(
    int unit, 
    bcm_vrf_t vrf, 
    int nstat, 
    bcm_l3_vrf_stat_t *stat_arr, 
    uint32 *value_arr);

/* Set 64-bit counter value for multiple VRF statistic types. */
extern int bcm_l3_vrf_stat_multi_set(
    int unit, 
    bcm_vrf_t vrf, 
    int nstat, 
    bcm_l3_vrf_stat_t *stat_arr, 
    uint64 *value_arr);

/* Set lower 32-bit counter value for multiple VRF statistic types. */
extern int bcm_l3_vrf_stat_multi_set32(
    int unit, 
    bcm_vrf_t vrf, 
    int nstat, 
    bcm_l3_vrf_stat_t *stat_arr, 
    uint32 *value_arr);

#endif /* BCM_HIDE_DISPATCHABLE */

#define BCM_L3_SOURCE_BIND_IP6      0x00000001 
#define BCM_L3_SOURCE_BIND_REPLACE  0x00000002 

/* L3 source binding information structure. */
typedef struct bcm_l3_source_bind_s {
    uint32 flags;                   /* BCM_L3_SOURCE_BIND_xxx flags. */
    bcm_gport_t port;               /* Source module and port, BCM_GPORT_INVALID
                                       to wildcard. */
    bcm_ip_t ip;                    /* Source IPv4 address. */
    bcm_ip6_t ip6;                  /* Source IPv6 address. */
    bcm_mac_t mac;                  /* Source MAC address. */
    bcm_ipfix_rate_id_t rate_id;    /* IPFIX rate ID */
} bcm_l3_source_bind_t;

/* Initialize a bcm_l3_source_bind_t structure. */
extern void bcm_l3_source_bind_t_init(
    bcm_l3_source_bind_t *info);

#ifndef BCM_HIDE_DISPATCHABLE

/* Enable or disable l3 source binding checks on an ingress port. */
extern int bcm_l3_source_bind_enable_set(
    int unit, 
    bcm_port_t port, 
    int enable);

/* 
 * Retrieve whether l3 source binding checks are performed on an ingress
 * port.
 */
extern int bcm_l3_source_bind_enable_get(
    int unit, 
    bcm_port_t port, 
    int *enable);

/* Add or replace an L3 source binding. */
extern int bcm_l3_source_bind_add(
    int unit, 
    bcm_l3_source_bind_t *info);

/* Remove an existing L3 source binding. */
extern int bcm_l3_source_bind_delete(
    int unit, 
    bcm_l3_source_bind_t *info);

/* Remove all existing L3 source bindings. */
extern int bcm_l3_source_bind_delete_all(
    int unit);

/* Retrieve the details of an existing L3 source binding. */
extern int bcm_l3_source_bind_get(
    int unit, 
    bcm_l3_source_bind_t *info);

#endif /* BCM_HIDE_DISPATCHABLE */

typedef int (*bcm_l3_source_bind_traverse_cb)(
    int unit, 
    bcm_l3_source_bind_t *info, 
    void *user_data);

#ifndef BCM_HIDE_DISPATCHABLE

/* 
 * Traverse through the L3 source bindings and run callback at each
 * defined binding.
 */
extern int bcm_l3_source_bind_traverse(
    int unit, 
    bcm_l3_source_bind_traverse_cb cb, 
    void *user_data);

/* 
 * Add VRID for the given VSI. Adding a VRID using this API means the
 * physical node has become the master for the virtual router
 */
extern int bcm_l3_vrrp_add(
    int unit, 
    bcm_vlan_t vlan, 
    uint32 vrid);

/* Delete VRID for a particulat VLAN/VSI */
extern int bcm_l3_vrrp_delete(
    int unit, 
    bcm_vlan_t vlan, 
    uint32 vrid);

/* Delete all the VRIDs for a particular VLAN/VSI */
extern int bcm_l3_vrrp_delete_all(
    int unit, 
    bcm_vlan_t vlan);

/* 
 * Get all the VRIDs for which the physical node is master for the
 * virtual routers on the given VLAN/VSI
 */
extern int bcm_l3_vrrp_get(
    int unit, 
    bcm_vlan_t vlan, 
    int alloc_size, 
    int *vrid_array, 
    int *count);

/* Attach   counters entries to the given VRF. */
extern int bcm_l3_vrf_stat_attach(
    int unit, 
    bcm_vrf_t vrf, 
    uint32 stat_counter_id);

/* Detach   counters entries to the given VRF. */
extern int bcm_l3_vrf_stat_detach(
    int unit, 
    bcm_vrf_t vrf);

/* Get L3 VRF counter value for specified VRF statistic type */
extern int bcm_l3_vrf_stat_counter_get(
    int unit, 
    bcm_vrf_t vrf, 
    bcm_l3_vrf_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values);

/* Set L3 VRF counter value for specified VRF statistic type */
extern int bcm_l3_vrf_stat_counter_set(
    int unit, 
    bcm_vrf_t vrf, 
    bcm_l3_vrf_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values);

/* Attach counters entries to the given L3 Egress interface */
extern int bcm_l3_egress_stat_attach(
    int unit, 
    bcm_if_t intf_id, 
    uint32 stat_counter_id);

/* Detach  counters entries to the given L3 Egress interface. */
extern int bcm_l3_egress_stat_detach(
    int unit, 
    bcm_if_t intf_id);

/* Get the specified counter statistic for a L3 egress interface */
extern int bcm_l3_egress_stat_counter_get(
    int unit, 
    bcm_if_t intf_id, 
    bcm_l3_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values);

/* Provide stat counter ids associated with given L3 egress interface */
extern int bcm_l3_egress_stat_id_get(
    int unit, 
    bcm_if_t intf_id, 
    bcm_l3_stat_t stat, 
    uint32 *stat_counter_id);

/* Set the specified counter statistic for a L3 egress interface */
extern int bcm_l3_egress_stat_counter_set(
    int unit, 
    bcm_if_t intf_id, 
    bcm_l3_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values);

/* Attach counters entries to the given L3 Ingress interface */
extern int bcm_l3_ingress_stat_attach(
    int unit, 
    bcm_if_t intf_id, 
    uint32 stat_counter_id);

/* Detach  counters entries to the given L3 Ingress interface. */
extern int bcm_l3_ingress_stat_detach(
    int unit, 
    bcm_if_t intf_id);

/* Get the specified counter statistic for a L3 ingress interface */
extern int bcm_l3_ingress_stat_counter_get(
    int unit, 
    bcm_if_t intf_id, 
    bcm_l3_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values);

/* Provide stat counter ids associated with given L3 ingress interface */
extern int bcm_l3_ingress_stat_id_get(
    int unit, 
    bcm_if_t intf_id, 
    bcm_l3_stat_t stat, 
    uint32 *stat_counter_id);

/* Set the specified counter statistic for a L3 ingress interface */
extern int bcm_l3_ingress_stat_counter_set(
    int unit, 
    bcm_if_t intf_id, 
    bcm_l3_stat_t stat, 
    uint32 num_entries, 
    uint32 *counter_indexes, 
    bcm_stat_value_t *counter_values);

#endif /* defined(INCLUDE_L3) */

#endif /* BCM_HIDE_DISPATCHABLE */

#endif /* __BCM_L3_H__ */
