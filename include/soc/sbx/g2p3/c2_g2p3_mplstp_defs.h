/*
 * $Id: c2_g2p3_mplstp_defs.h 1.108.6.3 Broadcom SDK $
 *
 *
 *
 * $Copyright: Copyright 2011 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 * 
 *
 * g2p3_defs.h: Guadalupe2k V1.3 microcode accessor functions
 */

/**
 * @file g2p3_defs.h
 * Guadalupe2k V1.3 microcode accessor functions.
 *
 * This file provides the public interface to the Guadalupe2k V1.3
 * microcode.  Only explicitly documented elements (types  & functions)
 * are supported, external interfaces.  Other elements are exported only
 * for debugging convenience.
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 */
#ifdef BCM_SBX_MPLSTP_SUPPORT
#ifndef _G2P3_DEFS_H
#define _G2P3_DEFS_H
#ifdef BCM_SBX_SUPPORT
#include <sal/types.h>
#include <soc/sbx/fe2k_common/sbFe2000DmaMgr.h>
#include <sal/core/sync.h>

/*
 * Memory element enumeration
 * Not public: exported for debugging convenience only
 */
typedef enum soc_sbx_g2p3_memory_id_s {
    SOC_SBX_G2P3_MM0_NAR0_ID,
    SOC_SBX_G2P3_MM0_NAR1_ID,
    SOC_SBX_G2P3_MM0_WIDE_ID,
    SOC_SBX_G2P3_MM0_INT0_ID,
    SOC_SBX_G2P3_MM0_INT1_ID,
    SOC_SBX_G2P3_MM1_NAR0_ID,
    SOC_SBX_G2P3_MM1_NAR1_ID,
    SOC_SBX_G2P3_MM1_WIDE_ID,
    SOC_SBX_G2P3_MM1_INT0_ID,
    SOC_SBX_G2P3_MM1_INT1_ID,
    SOC_SBX_G2P3_RC0_RR_ID,
    SOC_SBX_G2P3_RC1_RR_ID,
    SOC_SBX_G2P3_RXPORTDATA_ID,
    SOC_SBX_G2P3_INITIALQSTATE20_ID,
    SOC_SBX_G2P3_INITIALQSTATE25_ID,
    SOC_SBX_G2P3_EMIRRORHW20_ID,
    SOC_SBX_G2P3_EMIRRORHW25_ID,
    SOC_SBX_G2P3_MEMORY_MAX_ID
} soc_sbx_g2p3_memory_id_t;

/*
 * Shared constant enumeration
 * Not public: exported for debugging convenience only
 */
typedef enum soc_sbx_g2p3_constant_id_s {
    SOC_SBX_G2P3_MAX_PORTS_ID,
    SOC_SBX_G2P3_IPV4_VRF_BITS_ID,
    SOC_SBX_G2P3_EXC_IP_CHECKSUM_IDX_ID,
    SOC_SBX_G2P3_EXC_STP_BLOCKED_IDX_ID,
    SOC_SBX_G2P3_EXC_SMAC_DROP_IDX_ID,
    SOC_SBX_G2P3_EXC_SMAC_UNKNOWN_IDX_ID,
    SOC_SBX_G2P3_EXC_MAC_HAIRPIN_IDX_ID,
    SOC_SBX_G2P3_EXC_DMAC_DROP_IDX_ID,
    SOC_SBX_G2P3_EXC_TTL_EXPIRED_IDX_ID,
    SOC_SBX_G2P3_EXC_EGR_STP_BLOCKED_IDX_ID,
    SOC_SBX_G2P3_EXC_SPLIT_IDX_ID,
    SOC_SBX_G2P3_EXC_MTU_IDX_ID,
    SOC_SBX_G2P3_EXC_OAM_MISMATCH_ID,
    SOC_SBX_G2P3_EXC_OAM_LEARN_ID,
    SOC_SBX_G2P3_EXC_OAM_NO_ENDPOINT_ID,
    SOC_SBX_G2P3_EXC_OAM_TYPE_ID,
    SOC_SBX_G2P3_EXC_OAM_RDI_ID,
    SOC_SBX_G2P3_EXC_VLAN_DROP_IDX_ID,
    SOC_SBX_G2P3_EXC_V4MC_RPF_CHECK_IDX_ID,
    SOC_SBX_G2P3_EXC_URPF_DROP_IDX_ID,
    SOC_SBX_G2P3_EXC_IP_SA_DROP_IDX_ID,
    SOC_SBX_G2P3_EXC_MIM_BAD_FORMAT_IDX_ID,
    SOC_SBX_G2P3_EXC_ISID2E_MISS_IDX_ID,
    SOC_SBX_G2P3_EXC_OAM_THRESHOLD_EXCEEDED_ID,
    SOC_SBX_G2P3_EXC_OAM_COPY_TO_HOST_ID,
    SOC_SBX_G2P3_EXC_OAM_PARAM_CHANGE_ID,
    SOC_SBX_G2P3_EXC_BAD_OUTER_LABEL_IDX_ID,
    SOC_SBX_G2P3_EXC_BAD_INNER_LABEL_IDX_ID,
    SOC_SBX_G2P3_EXC_LSP_PING_IDX_ID,
    SOC_SBX_G2P3_EXC_TOO_MANY_LABELS_IDX_ID,
    SOC_SBX_G2P3_EXC_EGR_DROP_TAGGED_IDX_ID,
    SOC_SBX_G2P3_EXC_EGR_DROP_UNTAGGED_IDX_ID,
    SOC_SBX_G2P3_EXC_EGR_OAM_LINK_IDX_ID,
    SOC_SBX_G2P3_EXC_OAM_EP_INVALID_IDX_ID,
    SOC_SBX_G2P3_EXC_DCN_IDX_ID,
    SOC_SBX_G2P3_EXC_MPLS_FILTER_IDX_ID,
    SOC_SBX_G2P3_EXC_MIN_FREE_EXCEPTION_ID,
    SOC_SBX_G2P3_MAX_FREE_EXCEPTION_ID,
    SOC_SBX_G2P3_EXC_SMAC_LEARN_IDX_ID,
    SOC_SBX_G2P3_EXC_PIM_IDX_ID,
    SOC_SBX_G2P3_EXC_IGMP_IDX_ID,
    SOC_SBX_G2P3_EXC_RT_COPY_IDX_ID,
    SOC_SBX_G2P3_EXC_L2CP_COPY_IDX_ID,
    SOC_SBX_G2P3_EXC_DMAC_COPY_IDX_ID,
    SOC_SBX_G2P3_EXC_IPREDIRECT_IDX_ID,
    SOC_SBX_G2P3_EXC_BMAC_LEARN_IDX_ID,
    SOC_SBX_G2P3_EXC_COPY_MAX_IDX_ID,
    SOC_SBX_G2P3_HTYPE_ERH_ID,
    SOC_SBX_G2P3_HTYPE_ETYPE_ID,
    SOC_SBX_G2P3_HTYPE_ETH_ID,
    SOC_SBX_G2P3_HTYPE_IETH_ID,
    SOC_SBX_G2P3_HTYPE_LLC_ID,
    SOC_SBX_G2P3_HTYPE_SNAP_ID,
    SOC_SBX_G2P3_HTYPE_VTAG_ID,
    SOC_SBX_G2P3_HTYPE_DVTAG_ID,
    SOC_SBX_G2P3_HTYPE_MPLS_ID,
    SOC_SBX_G2P3_HTYPE_IPV4_ID,
    SOC_SBX_G2P3_HTYPE_IPV6_ID,
    SOC_SBX_G2P3_HTYPE_ACH_ID,
    SOC_SBX_G2P3_HTYPE_MIM_ID,
    SOC_SBX_G2P3_HTYPE_ELEN_ID,
    SOC_SBX_G2P3_HTYPE_UNKN_ID,
    SOC_SBX_G2P3_TRAP_OAMLABELPRESENT_ID,
    SOC_SBX_G2P3_TRAP_LINKLOOPBACK_ID,
    SOC_SBX_G2P3_LSMAC_TABLE_SIZE_ID,
    SOC_SBX_G2P3_L2CPMAC_TABLE_SIZE_ID,
    SOC_SBX_G2P3_OAMUPMAC_TABLE_SIZE_ID,
    SOC_SBX_G2P3_OAMEPREMAP_C2_TABLE_SIZE_ID,
    SOC_SBX_G2P3_OAMMULTIPLIER_C2_TABLE_SIZE_ID,
    SOC_SBX_G2P3_EGRCTR_CA_COUNTER_SIZE_ID,
    SOC_SBX_G2P3_MAC_CA_TABLE_SIZE_ID,
    SOC_SBX_G2P3_PTYPE_UNKNOWN_UNICAST_ID,
    SOC_SBX_G2P3_PTYPE_KNOWN_UNICAST_ID,
    SOC_SBX_G2P3_PTYPE_MULTICAST_ID,
    SOC_SBX_G2P3_PTYPE_BROADCAST_ID,
    SOC_SBX_G2P3_PTYPE_LAST_ID,
    SOC_SBX_G2P3_CUCKOO_TYPE_PVV_ID,
    SOC_SBX_G2P3_CUCKOO_TYPE_ISID_ID,
    SOC_SBX_G2P3_CUCKOO_TYPE_PVD_ID,
    SOC_SBX_G2P3_CUCKOO_TYPE_MAIDMEP_ID,
    SOC_SBX_G2P3_CUCKOO_TYPE_SHIFT_ID,
    SOC_SBX_G2P3_OAM_EP_SUBTYPE_CCM_ID,
    SOC_SBX_G2P3_OAM_EP_SUBTYPE_LM_ID,
    SOC_SBX_G2P3_OAM_EP_SUBTYPE_DM_ID,
    SOC_SBX_G2P3_OAM_EP_SUBTYPE_SHIFT_ID,
    SOC_SBX_G2P3_OAM_TYPE_INVALID_ID,
    SOC_SBX_G2P3_OAM_TYPE_ENET_ID,
    SOC_SBX_G2P3_OAM_TYPE_MPLS_PWE_ID,
    SOC_SBX_G2P3_OAM_TYPE_MPLS_LSP_ID,
    SOC_SBX_G2P3_OAM_FUNCTION_UNUSED_ID,
    SOC_SBX_G2P3_OAM_FUNCTION_BFD_ID,
    SOC_SBX_G2P3_OAM_FUNCTION_LM_ID,
    SOC_SBX_G2P3_OAM_FUNCTION_DM_ID,
    SOC_SBX_G2P3_OAM_FUNCTION_CCM_FIRST_ID,
    SOC_SBX_G2P3_OAM_FUNCTION_CCM_SECOND_ID,
    SOC_SBX_G2P3_OAM_FUNCTION_CCM_PEER_ID,
    SOC_SBX_G2P3_OAM_FUNCTION_PSC_ID,
    SOC_SBX_G2P3_OAM_FUNCTION_PM_ID,
    SOC_SBX_G2P3_OAM_FUNCTION_CCM_LOCAL_ID,
    SOC_SBX_G2P3_OAM_NUM_ENDPOINTS_ID,
    SOC_SBX_G2P3_OAM_MAX_CALENDAR_ID,
    SOC_SBX_G2P3_OAM_BUBBLE_TIMEOUT_ID,
    SOC_SBX_G2P3_OAM_LIST_MGR_SIZE_ID,
    SOC_SBX_G2P3_OAM_LIST_MGR_SIZE_CA_ID,
    SOC_SBX_G2P3_OAM_BUBBLE_TIMER_ADDR_ID,
    SOC_SBX_G2P3_OAM_LIST_MGR_ADDR_ID,
    SOC_SBX_G2P3_OAM_INTERVAL1_ID,
    SOC_SBX_G2P3_OAM_INTERVAL2_ID,
    SOC_SBX_G2P3_OAM_INTERVAL3_ID,
    SOC_SBX_G2P3_OAM_INTERVAL4_ID,
    SOC_SBX_G2P3_OAM_INTERVAL5_ID,
    SOC_SBX_G2P3_OAM_INTERVAL6_ID,
    SOC_SBX_G2P3_OAM_INTERVAL7_ID,
    SOC_SBX_G2P3_OAM_REMOTE_EP_BASE_ID,
    SOC_SBX_G2P3_MAX_QOS_PROFILE_INDEX_ID,
    SOC_SBX_G2P3_MAX_QOS_MAP_TABLE_ID,
    SOC_SBX_G2P3_MAX_QOS_REMARK_TABLE_ID,
    SOC_SBX_G2P3_MAX_L2CP_TYPES_ID,
    SOC_SBX_G2P3_MAX_L2CP_SUBTYPES_ID,
    SOC_SBX_G2P3_URPF_DEFAULT_PID_ID,
    SOC_SBX_G2P3_STPSTATE_FORWARD_ID,
    SOC_SBX_G2P3_STPSTATE_BLOCK_ID,
    SOC_SBX_G2P3_STPSTATE_LEARN_ID,
    SOC_SBX_G2P3_MPLSTP_LOOPBACK_OAM_ID,
    SOC_SBX_G2P3_MPLSTP_LOOPBACK_FULL_ID,
    SOC_SBX_G2P3_MPLSTP_LOOPBACK_NONE_ID,
    SOC_SBX_G2P3_LABEL_LSR_ID,
    SOC_SBX_G2P3_LABEL_ETH_PWE3_ID,
    SOC_SBX_G2P3_LABEL_LER_ID,
    SOC_SBX_G2P3_LABEL_CES_PWE3_ID,
    SOC_SBX_G2P3_CONSTANT_MAX_ID
} soc_sbx_g2p3_constant_id_t;

/*
 * Global value enumeration
 * Not public: exported for debugging convenience only
 */
typedef enum soc_sbx_g2p3_global_id_s {
    SOC_SBX_G2P3_CONTEXTS_ID,
    SOC_SBX_G2P3_TPID0_ID,
    SOC_SBX_G2P3_TPID1_ID,
    SOC_SBX_G2P3_TPID2_ID,
    SOC_SBX_G2P3_DEFITAG_ID,
    SOC_SBX_G2P3_AGE_ID,
    SOC_SBX_G2P3_LABELCUCKOO_ABSEED_ID,
    SOC_SBX_G2P3_CUCKOO_ABSEED_ID,
    SOC_SBX_G2P3_NODE_ID,
    SOC_SBX_G2P3_VLAN_FT_BASE_ID,
    SOC_SBX_G2P3_VPWS_VLAN_ID,
    SOC_SBX_G2P3_VPWS_FT_OFFSET_ID,
    SOC_SBX_G2P3_EEX_MIRROR0_ID,
    SOC_SBX_G2P3_EEX_MIRROR1_ID,
    SOC_SBX_G2P3_MAX_PIDS_ID,
    SOC_SBX_G2P3_MC_FT_OFFSET_ID,
    SOC_SBX_G2P3_OAM_DROP_BIT_ID,
    SOC_SBX_G2P3_OAM_ENET_CONTINUE_BYTE_ID,
    SOC_SBX_G2P3_OAM_MPLS_CONTINUE_BYTE_ID,
    SOC_SBX_G2P3_OAM_ENET_FRAME_LEN_ID,
    SOC_SBX_G2P3_OAM_MPLS_FRAME_LEN_ID,
    SOC_SBX_G2P3_OAM_SOURCE_QUEUE_ID,
    SOC_SBX_G2P3_OAM_DEST_QUEUE_ID,
    SOC_SBX_G2P3_OAM_SOURCE_BUFFER_ID,
    SOC_SBX_G2P3_OAM_BUBBLE_TIMER_OFFSET_ID,
    SOC_SBX_G2P3_OAM_SA_LM_ID,
    SOC_SBX_G2P3_OAM_SA_DM_ID,
    SOC_SBX_G2P3_OAM_MPLS_SA_LM_ID,
    SOC_SBX_G2P3_OAM_MPLS_SA_DM_ID,
    SOC_SBX_G2P3_OAM_PWE_IP_SA_ID,
    SOC_SBX_G2P3_OAM_PWE_UDP_DEST_PORT_ID,
    SOC_SBX_G2P3_OAM_MIRROR_INDEX_ID,
    SOC_SBX_G2P3_OAM_LOOPBACK_QID_ID,
    SOC_SBX_G2P3_OAM_SA_4LO_ID,
    SOC_SBX_G2P3_OAM_SA_2HI_ID,
    SOC_SBX_G2P3_OAM_SA_4LO_AUX_ID,
    SOC_SBX_G2P3_OAM_SA_2HI_AUX_ID,
    SOC_SBX_G2P3_OAM_BFD_STATE_TABLE_ID,
    SOC_SBX_G2P3_OAM_BFD_RDI_DIAG_CODE_ID,
    SOC_SBX_G2P3_OAM_TX_PACKETS_PER_BUBBLE_ID,
    SOC_SBX_G2P3_OAM_TX_PACKETS_PER_BUBBLE_CA_ID,
    SOC_SBX_G2P3_OAM_PSC_RX_FILTER_ID,
    SOC_SBX_G2P3_OAM_LOCAL_FE_QID_ID,
    SOC_SBX_G2P3_BLACKHOLE_VLAN_ID,
    SOC_SBX_G2P3_IGMP_PROXY_MODE_ID,
    SOC_SBX_G2P3_STATIC_LAG_ID,
    SOC_SBX_G2P3_IPV4_CHECKSUM_MODE_ID,
    SOC_SBX_G2P3_EXIT_FILTER_ON_BTAG_ID,
    SOC_SBX_G2P3_SWITCH_METER_ADJUST_ID,
    SOC_SBX_G2P3_RC1_RULE_STARTIDX_ID,
    SOC_SBX_G2P3_IPV6_ACL_ENABLE_ID,
    SOC_SBX_G2P3_OI2EOFF_ID,
    SOC_SBX_G2P3_ETE0PLUS1_ID,
    SOC_SBX_G2P3_ETE1PLUS1_ID,
    SOC_SBX_G2P3_GLOBAL_MAX_ID
} soc_sbx_g2p3_global_id_t;

/*
 * Table enumeration
 * Not public: exported for debugging convenience only
 */
typedef enum soc_sbx_g2p3_table_id_s {
    SOC_SBX_G2P3_PORTDATA20_TABLE_ID,
    SOC_SBX_G2P3_PORTDATA25_TABLE_ID,
    SOC_SBX_G2P3_QOS_TABLE_ID,
    SOC_SBX_G2P3_DSCP_QOS_TABLE_ID,
    SOC_SBX_G2P3_IRT_TABLE_ID,
    SOC_SBX_G2P3_RT_MT_TABLE_ID,
    SOC_SBX_G2P3_RT_RR0_TABLE_ID,
    SOC_SBX_G2P3_RT_RR1_TABLE_ID,
    SOC_SBX_G2P3_LAG_TABLE_ID,
    SOC_SBX_G2P3_RR_TABLE_ID,
    SOC_SBX_G2P3_XT_TABLE_ID,
    SOC_SBX_G2P3_MIRROR_TABLE_ID,
    SOC_SBX_G2P3_EMIRROR20_TABLE_ID,
    SOC_SBX_G2P3_EMIRROR25_TABLE_ID,
    SOC_SBX_G2P3_MAC_TABLE_ID,
    SOC_SBX_G2P3_IPV6DHOST_TABLE_ID,
    SOC_SBX_G2P3_MST_TABLE_ID,
    SOC_SBX_G2P3_PV2E_TABLE_ID,
    SOC_SBX_G2P3_P2APPDATA_TABLE_ID,
    SOC_SBX_G2P3_PV2APPDATA_TABLE_ID,
    SOC_SBX_G2P3_IPV6SHOST_TABLE_ID,
    SOC_SBX_G2P3_CUCKOO_TABLE_ID,
    SOC_SBX_G2P3_OUTERLABELCUCKOO_TABLE_ID,
    SOC_SBX_G2P3_INNERLABELCUCKOO_TABLE_ID,
    SOC_SBX_G2P3_V2E_TABLE_ID,
    SOC_SBX_G2P3_V2E1_TABLE_ID,
    SOC_SBX_G2P3_LP_TABLE_ID,
    SOC_SBX_G2P3_L2E_TABLE_ID,
    SOC_SBX_G2P3_L2CP_TABLE_ID,
    SOC_SBX_G2P3_L2CPSLOW_TABLE_ID,
    SOC_SBX_G2P3_L2CPNOP_TABLE_ID,
    SOC_SBX_G2P3_FT_TABLE_ID,
    SOC_SBX_G2P3_OAMTIMERCALENDAR_TABLE_ID,
    SOC_SBX_G2P3_OAMPORTMDLEVEL2ETC_TABLE_ID,
    SOC_SBX_G2P3_IPV6MCSG_TABLE_ID,
    SOC_SBX_G2P3_IPV6MCG_TABLE_ID,
    SOC_SBX_G2P3_IPV4MCG_TABLE_ID,
    SOC_SBX_G2P3_IPV4MCSG_TABLE_ID,
    SOC_SBX_G2P3_IPV4SA_TABLE_ID,
    SOC_SBX_G2P3_EVP2E_TABLE_ID,
    SOC_SBX_G2P3_OI2E_TABLE_ID,
    SOC_SBX_G2P3_ETE_TABLE_ID,
    SOC_SBX_G2P3_OAMEP_TABLE_ID,
    SOC_SBX_G2P3_REMARK_TABLE_ID,
    SOC_SBX_G2P3_EPV2E_TABLE_ID,
    SOC_SBX_G2P3_ESMAC_TABLE_ID,
    SOC_SBX_G2P3_ERT_TABLE_ID,
    SOC_SBX_G2P3_OAMMULTIPLIER_TABLE_ID,
    SOC_SBX_G2P3_OAMEPREMAP_TABLE_ID,
    SOC_SBX_G2P3_IPV6DA_TABLE_ID,
    SOC_SBX_G2P3_IPV6SA_TABLE_ID,
    SOC_SBX_G2P3_IPV4DA_TABLE_ID,
    SOC_SBX_G2P3_P2FTI_TABLE_ID,
    SOC_SBX_G2P3_TABLE_MAX_ID
} soc_sbx_g2p3_table_id_t;

/*
 * Entry enumeration
 * Not public: exported for debugging convenience only
 */
typedef enum soc_sbx_g2p3_entry_id_s {
    SOC_SBX_G2P3_P2E_ID,
    SOC_SBX_G2P3_EP2E_ID,
    SOC_SBX_G2P3_P2E20_ID,
    SOC_SBX_G2P3_EP2E20_ID,
    SOC_SBX_G2P3_P2E25_ID,
    SOC_SBX_G2P3_EP2E25_ID,
    SOC_SBX_G2P3_TPID_ID,
    SOC_SBX_G2P3_OAM_RX_ID,
    SOC_SBX_G2P3_OAM_TX_ID,
    SOC_SBX_G2P3_LSMAC_ID,
    SOC_SBX_G2P3_L2CPMAC_ID,
    SOC_SBX_G2P3_OAMUPMAC_ID,
    SOC_SBX_G2P3_QOS_ID,
    SOC_SBX_G2P3_DSCP_QOS_ID,
    SOC_SBX_G2P3_IRT_ID,
    SOC_SBX_G2P3_IRT_WRAP_ID,
    SOC_SBX_G2P3_RT_MT_ID,
    SOC_SBX_G2P3_RT_RR0_ID,
    SOC_SBX_G2P3_RT_ID,
    SOC_SBX_G2P3_RT_RR1_ID,
    SOC_SBX_G2P3_LAG_ID,
    SOC_SBX_G2P3_RR_ID,
    SOC_SBX_G2P3_XT_ID,
    SOC_SBX_G2P3_MIRROR_ID,
    SOC_SBX_G2P3_EMIRROR_ID,
    SOC_SBX_G2P3_EMIRROR20_ID,
    SOC_SBX_G2P3_EMIRROR25_ID,
    SOC_SBX_G2P3_EMLL1_ID,
    SOC_SBX_G2P3_MAC_ID,
    SOC_SBX_G2P3_MACL1_ID,
    SOC_SBX_G2P3_MACL2_ID,
    SOC_SBX_G2P3_IPV6DHOST_ID,
    SOC_SBX_G2P3_IPV6DHOSTL1_ID,
    SOC_SBX_G2P3_IPV6DHOSTL2_ID,
    SOC_SBX_G2P3_MST_ID,
    SOC_SBX_G2P3_PV2E_ID,
    SOC_SBX_G2P3_P2APPDATA_ID,
    SOC_SBX_G2P3_PV2APPDATA_ID,
    SOC_SBX_G2P3_IPV6SHOST_ID,
    SOC_SBX_G2P3_IPV6SHOSTL1_ID,
    SOC_SBX_G2P3_IPV6SHOSTL2_ID,
    SOC_SBX_G2P3_PVV2E_ID,
    SOC_SBX_G2P3_PVV2EPACK_ID,
    SOC_SBX_G2P3_ISID2E_ID,
    SOC_SBX_G2P3_OAMPVD2E_ID,
    SOC_SBX_G2P3_OAMMAIDMEP2E_ID,
    SOC_SBX_G2P3_CUCKOO_ID,
    SOC_SBX_G2P3_LEFT_ID,
    SOC_SBX_G2P3_RIGHT_ID,
    SOC_SBX_G2P3_OUTERLABELCUCKOO_ID,
    SOC_SBX_G2P3_OUTERLABELLEFT_ID,
    SOC_SBX_G2P3_OUTERLABELRIGHT_ID,
    SOC_SBX_G2P3_INNERLABELCUCKOO_ID,
    SOC_SBX_G2P3_INNERLABELLEFT_ID,
    SOC_SBX_G2P3_INNERLABELRIGHT_ID,
    SOC_SBX_G2P3_LABEL2E_ID,
    SOC_SBX_G2P3_TAGGED_MPLS_ID,
    SOC_SBX_G2P3_V2E_ID,
    SOC_SBX_G2P3_V2E1_ID,
    SOC_SBX_G2P3_LP_ID,
    SOC_SBX_G2P3_L2E_ID,
    SOC_SBX_G2P3_L2CP_ID,
    SOC_SBX_G2P3_L2CPSLOW_ID,
    SOC_SBX_G2P3_L2CPNOP_ID,
    SOC_SBX_G2P3_FT_ID,
    SOC_SBX_G2P3_OAMTIMERCALENDAR_ID,
    SOC_SBX_G2P3_OAMPORTMDLEVEL2ETC_ID,
    SOC_SBX_G2P3_V4UC_STR_SEL_ID,
    SOC_SBX_G2P3_CMAC_ID,
    SOC_SBX_G2P3_BMAC_ID,
    SOC_SBX_G2P3_IPV6MCSG_ID,
    SOC_SBX_G2P3_IPV6MCSGL1_ID,
    SOC_SBX_G2P3_IPV6MCSGL2_ID,
    SOC_SBX_G2P3_IPV6MCG_ID,
    SOC_SBX_G2P3_IPV6MCGL1_ID,
    SOC_SBX_G2P3_IPV6MCGL2_ID,
    SOC_SBX_G2P3_IPV4MCG_ID,
    SOC_SBX_G2P3_IPV4MCGL1_ID,
    SOC_SBX_G2P3_IPV4MCGL2_ID,
    SOC_SBX_G2P3_IPV4MCSG_ID,
    SOC_SBX_G2P3_IPV4MCSGL1_ID,
    SOC_SBX_G2P3_IPV4MCSGL2_ID,
    SOC_SBX_G2P3_LPMNODE_ID,
    SOC_SBX_G2P3_IPV4SA_ID,
    SOC_SBX_G2P3_IPV4SAL0_ID,
    SOC_SBX_G2P3_IPV4SAODD_ID,
    SOC_SBX_G2P3_IPV4SAEVEN_ID,
    SOC_SBX_G2P3_IPV4SAPAYLOAD_ID,
    SOC_SBX_G2P3_IFP_ID,
    SOC_SBX_G2P3_IFP_V6_ID,
    SOC_SBX_G2P3_EVP2E_ID,
    SOC_SBX_G2P3_OI2E_ID,
    SOC_SBX_G2P3_ETEENCAP_ID,
    SOC_SBX_G2P3_ETEL2_ID,
    SOC_SBX_G2P3_OAMEP_ID,
    SOC_SBX_G2P3_REMARK_ID,
    SOC_SBX_G2P3_EPV2E_ID,
    SOC_SBX_G2P3_ESMAC_ID,
    SOC_SBX_G2P3_ERT_ID,
    SOC_SBX_G2P3_ERT_WRAP_ID,
    SOC_SBX_G2P3_V4MC_STR_SEL_ID,
    SOC_SBX_G2P3_EFP_ID,
    SOC_SBX_G2P3_EFP_V6_ID,
    SOC_SBX_G2P3_OAMMULTIPLIER_ID,
    SOC_SBX_G2P3_OAMEPREMAP_ID,
    SOC_SBX_G2P3_IPV6DA_ID,
    SOC_SBX_G2P3_IPV6DAL0_ID,
    SOC_SBX_G2P3_IPV6DAODD_ID,
    SOC_SBX_G2P3_IPV6DAEVEN_ID,
    SOC_SBX_G2P3_IPV6DAPAYLOAD_ID,
    SOC_SBX_G2P3_IPV6SA_ID,
    SOC_SBX_G2P3_IPV6SAL0_ID,
    SOC_SBX_G2P3_IPV6SAODD_ID,
    SOC_SBX_G2P3_IPV6SAEVEN_ID,
    SOC_SBX_G2P3_IPV6SAPAYLOAD_ID,
    SOC_SBX_G2P3_IPV4DA_ID,
    SOC_SBX_G2P3_IPV4DAL0_ID,
    SOC_SBX_G2P3_IPV4DAODD_ID,
    SOC_SBX_G2P3_IPV4DAEVEN_ID,
    SOC_SBX_G2P3_IPV4DAPAYLOAD_ID,
    SOC_SBX_G2P3_P2FTI_ID,
    SOC_SBX_G2P3_POLICER_ID,
    SOC_SBX_G2P3_TIMER_ID,
    SOC_SBX_G2P3_SEQUENCE_ID,
    SOC_SBX_G2P3_ENTRY_MAX_ID
} soc_sbx_g2p3_entry_id_t;

/*
 * Counter enumeration
 * Not public: exported for debugging convenience only
 */
typedef enum soc_sbx_g2p3_counter_id_s {
    SOC_SBX_G2P3_PDCTR_ID,
    SOC_SBX_G2P3_RTCTR_ID,
    SOC_SBX_G2P3_IRTCTR_ID,
    SOC_SBX_G2P3_IFPCTR_ID,
    SOC_SBX_G2P3_IFP_V6CTR_ID,
    SOC_SBX_G2P3_ERTCTR_ID,
    SOC_SBX_G2P3_EFPCTR_ID,
    SOC_SBX_G2P3_EFP_V6CTR_ID,
    SOC_SBX_G2P3_EXCCTR_ID,
    SOC_SBX_G2P3_INGCTR_ID,
    SOC_SBX_G2P3_EGRCTR_ID,
    SOC_SBX_G2P3_COUNTER_MAX_ID
} soc_sbx_g2p3_counter_id_t;

/*
 * Policer enumeration
 * Not public: exported for debugging convenience only
 */
typedef enum soc_sbx_g2p3_policer_id_s {
    SOC_SBX_G2P3_XTPOL_ID,
    SOC_SBX_G2P3_INGEGRPOL_ID,
    SOC_SBX_G2P3_OAMTIMER_ID,
    SOC_SBX_G2P3_OAMSEQ_ID,
    SOC_SBX_G2P3_POLICER_MAX_ID
} soc_sbx_g2p3_policer_id_t;

#define SOC_SBX_G2P3_TABLE_BANKS_MAX 10
#define SOC_SBX_G2P3_COMPLEX_BANKS_MAX 24
#define SOC_SBX_G2P3_COUNTER_BANKS_MAX 32
#define SOC_SBX_G2P3_POLICER_BANKS_MAX 9

/**
 * Pack function for quasi-internal complex table implementation code.
 */
typedef int (*soc_sbx_g2p3_complex_pack_f_t)
   (int unit, void *e, void *b, int bsz);

/*
 * Constant description type
 * Not public: exported for debugging convenience only
 */
typedef struct soc_sbx_g2p3_constant_desc_s {
    char *name;
} soc_sbx_g2p3_constant_desc_t;

/*
 * Global value description type
 * Not public: exported for debugging convenience only
 */
typedef struct soc_sbx_g2p3_global_desc_s {
    char *name;
    int   range;
    int   value;
} soc_sbx_g2p3_global_desc_t;

/*
 * Table bank description type
 * Not public: exported for debugging convenience only
 */
typedef struct soc_sbx_g2p3_table_bank_s {
    int memory;
    int mbank;
    int size;
    int width;
    int base;
} soc_sbx_g2p3_table_bank_t;

/*
 * Table type.
 */
typedef enum soc_sbx_g2p3_table_type_s {
    SOC_SBX_G2P3_ARRAY_TABLE_TYPE  = 0,
    SOC_SBX_G2P3_LPM_TABLE_TYPE    = 1,
    SOC_SBX_G2P3_EML_TABLE_TYPE    = 2,
    SOC_SBX_G2P3_EM32_TABLE_TYPE   = 3
} soc_sbx_g2p3_table_type_t;

/*
 * Table description type
 * Not public: exported for debugging convenience only
 */
typedef struct soc_sbx_g2p3_table_desc_s {
    char *name;
    int nextaligned;
    int type;
    int nbanks;
    soc_sbx_g2p3_table_bank_t banks[SOC_SBX_G2P3_TABLE_BANKS_MAX];
    /* Complex-only state */
    int b0size;
    void *cstate;
} soc_sbx_g2p3_table_desc_t;

/*
 * Integer format type
 * Not public: exported for debugging convenience only
 */
typedef enum soc_sbx_g2p3_integer_format_s {
    SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT = 0,
    SOC_SBX_G2P3_LE_INTEGER_FORMAT     = 1,
    SOC_SBX_G2P3_BE_INTEGER_FORMAT     = 2
} soc_sbx_g2p3_integer_format_t;

/*
 * Index description type
 * Not public: exported for debugging convenience only
 */
typedef struct soc_sbx_g2p3_index_desc_s {
    char *name;
    int   pos;
    int   range;
    int   orange;
    int   width;
    int   format;
} soc_sbx_g2p3_index_desc_t;

/*
 * Field description type
 * Not public: exported for debugging convenience only
 */
typedef struct soc_sbx_g2p3_field_desc_s {
    char *name;
    int   pos;
    int   range;
    int   width;
} soc_sbx_g2p3_field_desc_t;

/*
 * Entry bank description type
 * Not public: exported for debugging convenience only
 */
typedef struct soc_sbx_g2p3_entry_bank_s {
    int tablebank;
    int width;
    int stridebits;
} soc_sbx_g2p3_entry_bank_t;

/*
 * Entry type
 */
typedef enum soc_sbx_g2p3_entry_type_s {
    SOC_SBX_G2P3_ARRAY_ENTRY_TYPE = 0,
    SOC_SBX_G2P3_ARRAYHOOK_ENTRY_TYPE = 1,
    SOC_SBX_G2P3_EXT_ENTRY_TYPE = 2,
    SOC_SBX_G2P3_LPM_ENTRY_TYPE = 3,
    SOC_SBX_G2P3_EML_ENTRY_TYPE = 4,
    SOC_SBX_G2P3_EM32_ENTRY_TYPE = 5
} soc_sbx_g2p3_entry_type_t;

/*
 * Entry description type
 * Not public: exported for debugging convenience only
 */
typedef struct soc_sbx_g2p3_entry_desc_s {
    char *name;
    int type;
    soc_sbx_g2p3_table_id_t table;
    int esize;
    int epsize;
    soc_sbx_g2p3_complex_pack_f_t pack;
    int nindexes;
    soc_sbx_g2p3_index_desc_t *indexes;
    int indexeswidth;
    int nfields;
    soc_sbx_g2p3_field_desc_t *fields;
    int totalwidth;
    int nbanks;
    soc_sbx_g2p3_entry_bank_t banks[SOC_SBX_G2P3_TABLE_BANKS_MAX];
} soc_sbx_g2p3_entry_desc_t;

/*
 * Counter bank description type
 * Not public: exported for debugging convenience only
 */
typedef struct soc_sbx_g2p3_counter_bank_desc_s {
    int memory;
    int mbank;
    int base;
    int size;
} soc_sbx_g2p3_counter_bank_desc_t;

/*
 * Counter description type
 * Not public: exported for debugging convenience only
 */
typedef struct soc_sbx_g2p3_counter_desc_s {
    char *name;
    int bank;
    int base;
    int size;
} soc_sbx_g2p3_counter_desc_t;

/**
 * Policer bank type.
 */
typedef enum soc_sbx_g2p3_policer_bank_type_s {
    SOC_SBX_G2P3_POLICER_POLICER_BANK_TYPE  = 0,   /**< regular policer */
    SOC_SBX_G2P3_TIMER_POLICER_BANK_TYPE    = 1,   /**< OAM timer */
    SOC_SBX_G2P3_SEQUENCE_POLICER_BANK_TYPE = 2    /**< sequence number generator */
} soc_sbx_g2p3_policer_bank_type_t;

/*
 * Policer bank description type
 * Not public: exported for debugging convenience only
 */
typedef struct soc_sbx_g2p3_policer_bank_desc_s {
    int type;
    int memory;
    int mbank;
    int base;
    int size;
    int kbps;
} soc_sbx_g2p3_policer_bank_desc_t;

/*
 * Policer description type
 * Not public: exported for debugging convenience only
 */
typedef struct soc_sbx_g2p3_policer_desc_s {
    char *name;
    int bank;
    int base;
    int size;
} soc_sbx_g2p3_policer_desc_t;

/*
 * Memory bank type
 * Not public: exported for debugging convenience only
 */
typedef enum soc_sbx_g2p3_bank_type_s {
    SOC_SBX_G2P3_TABLE_BANK_TYPE,
    SOC_SBX_G2P3_COUNTER_BANK_TYPE,
    SOC_SBX_G2P3_POLICER_BANK_TYPE
} soc_sbx_g2p3_bank_type_t;

/*
 * Memory bank description type
 * Not public: exported for debugging convenience only
 */
typedef struct soc_sbx_g2p3_memory_bank_desc_s {
    soc_sbx_g2p3_bank_type_t type;
    int number;
    int bank;
    int nextaligned;
} soc_sbx_g2p3_memory_bank_desc_t;

/*
 * Memory description type
 * Not public: exported for debugging convenience only
 */
typedef struct soc_sbx_g2p3_memory_desc_s {
    char *name;
    int width;
    int size;
    int dma;
    int descending;
    int reg;
    int alignedlist;
    soc_sbx_g2p3_memory_bank_desc_t *banks;
    int nbanks;
} soc_sbx_g2p3_memory_desc_t;

/*
 * Table management state structure
 * Not public: exported for debugging convenience only
 */
typedef struct soc_sbx_g2p3_table_manager_s {
    int behost;
    soc_sbx_g2p3_memory_desc_t *memories;
    soc_sbx_g2p3_constant_desc_t *constants;
    soc_sbx_g2p3_global_desc_t *globals;
    int alignedlist;
    soc_sbx_g2p3_table_desc_t *tables;
    soc_sbx_g2p3_index_desc_t *indexes;
    soc_sbx_g2p3_entry_desc_t *entries;
    soc_sbx_g2p3_counter_bank_desc_t counterbanks[32];
    soc_sbx_g2p3_counter_desc_t *counters;
    soc_sbx_g2p3_policer_bank_desc_t policerbanks[9];
    soc_sbx_g2p3_policer_desc_t *policers;
    int policerbase;
    soc_sbx_g2p3_memory_bank_desc_t *memorybanks;
    int bufsize;
    uint8 *entrydmabuf;
    sal_paddr_t entrydmabufhba;
    sbFe2000DmaOp_t entrydmaop;
    sal_mutex_t dmabufmutex;
} soc_sbx_g2p3_table_manager_t;

/* ***
 * *** Types for public functions
 * ***/

/*
 * Big field types
 */

/** 6 byte type (typedef needed to keep ASE from dying) */
typedef uint8 soc_sbx_g2p3_6_byte_t[6];
/** 7 byte type (typedef needed to keep ASE from dying) */
typedef uint8 soc_sbx_g2p3_7_byte_t[7];
/** 8 byte type (typedef needed to keep ASE from dying) */
typedef uint8 soc_sbx_g2p3_8_byte_t[8];
/** 15 byte type (typedef needed to keep ASE from dying) */
typedef uint8 soc_sbx_g2p3_15_byte_t[15];
/** 16 byte type (typedef needed to keep ASE from dying) */
typedef uint8 soc_sbx_g2p3_16_byte_t[16];

/**
 * Complex table bank type
 */
typedef enum soc_sbx_g2p3_complex_bank_type_s {
    SOC_SBX_G2P3_KEY_COMPLEX_BANK_TYPE = 0,      /**< key substring */
    SOC_SBX_G2P3_PAYLOAD_COMPLEX_BANK_TYPE = 1,  /**< payload substring */
    SOC_SBX_G2P3_SPACER_COMPLEX_BANK_TYPE = 2    /**< spacer (padding) */
} soc_sbx_g2p3_complex_bank_type_t;

/**
 * Complex table bank description.
 *
 * Passed to quasi-internal complex table initialization code.
 */
typedef struct soc_sbx_g2p3_complex_bank_desc_s {
    int type;        /**< complex bank type */
    int singleton;   /**< boolean: lpm only, true if singleton slice */
    int pos;         /**< first bit position */
    int width;       /**< bank width, in bits */
    int memory;      /**< bank memory identifier */
    int base;        /**< bank base address */
    int size;        /**< bank size, in memory words */
} soc_sbx_g2p3_complex_bank_desc_t;


/**
 * Memory parameter structure.
 */
typedef struct soc_sbx_g2p3_memory_params_s {
    int size;   /**< size of memory, in words (-1 means unknown) */
    int width;  /**< width of memory word, in bits */
} soc_sbx_g2p3_memory_params_t;

/**
 * Table bank parameters.
 * 
 * Tables are composed of one or more banks, each of which is a contiguous
 * section of a memory.
 */
typedef struct soc_sbx_g2p3_table_bank_params_s {
    int base;   /**< base address, in memory words */
    int size;   /**< size, in memory words */
    int memory; /**< memory index (also CPU DMA memory port number) */
} soc_sbx_g2p3_table_bank_params_t;
/**
 * Counter bank parameters.
 *
 * Each counter bank resides in a contiguous section of a particular
 * memory, and is distinctly configured into the CM block.  A counter
 * bank may contain one or more counter blocks.
 */
typedef struct soc_sbx_g2p3_counter_bank_params_s {
    int memory; /**< memory index (also CPU DMA memory port number) */
    int base;   /**< base address, in memory words */
    int size;   /**< size, in memory words */
} soc_sbx_g2p3_counter_bank_params_t;

/**
 * Counter block parameters.
 *
 * Each counter block (or simply 'counter') is contained in a counter bank.
 * Each counter is a distinct functional group of counters
 * in the microcode forwarding application.
 */
typedef struct soc_sbx_g2p3_counter_params_s {
    int bank;   /**< bank number for the containing counter bank */
    int size;   /**< size, in counters */
    int base;   /**< base, address offset within the counter bank */
} soc_sbx_g2p3_counter_params_t;

/**
 * Counter value.
 *
 * The value of a single counter (pair) in bytes and packets
 */
typedef struct soc_sbx_g2p3_counter_value_s {
    COMPILER_UINT64 bytes;    /**< bytes */
    COMPILER_UINT64 packets;  /**< packets */
} soc_sbx_g2p3_counter_value_t;

/**
 * Policer bank parameters.
 *
 * Each policer bank resides in a contiguous section of the memory
 * attached to the PMU, and has distinct PMU parameters, including
 * functional type (policer, timer, or sequence generator), etc..  A policer
 * bank may contain one or more policer blocks.
 */
typedef struct soc_sbx_g2p3_policer_bank_params_s {
    int type;   /**< policer bank type (policer, timer or sequence generator */ 
    int memory; /**< memory index (also CPU DMA memory port number) */
    int base;   /**< base address, in memory words */
    int size;   /**< size, in memory words */
    int kbps;   /**< base rate, in kilobits/second */
} soc_sbx_g2p3_policer_bank_params_t;

/**
 * Policer block parameters.
 *
 * Each policer block (or simply 'policer') is contained in a policer bank.
 * Each policer is a distinct functional group of policers in the microcode
 * forwarding application.
 */
typedef struct soc_sbx_g2p3_policer_params_s {
    int bank;   /**< policer bank index */
    int size;   /**< size, in policers */
    int base;   /**< base, word address in memory (NB, not offset in bank!) */
} soc_sbx_g2p3_policer_params_t;

    /**
     * Ingress Port Table.
     * This table contains ingress per-port configuration data.
     * The contents of this table are contained in the PPE
     * per-port data and PPE variable memories.
     * 
     * <br><br>The PPE per-port and variable memories are
     * organized by source queue.  SWS source
     * queues may be assigned to ports in somewhat
     * arbitrary ways as necessary to ensure full
     * throughput for a given front panel port
     * configuation, so among other things, the
     * <tt>p2e</tt> and <tt>ep2e</tt> contain the ordinal
     * port number associated with a particular SWS queue.
     * <br><br>Although the data is internally organized by SWS
     * queue, the interface to the <tt>p2e</tt> table is by port.
     * The set and get implementation automatically perform
     * translation from forwarding port number to SWS queue to
     * access the appropriate per-port state.
     */
typedef struct soc_sbx_g2p3_p2e_s {
    /**
     * Microcode port number (for LRP use).  This field is
     * read-only.
     */
    uint32 port;
    /** default (native) VID for untagged packets */
    uint32 nativevid;
    /** default CFI for untagged packets */
    uint32 defcfi;
    /** default Ethernet priority for untagged packets */
    uint32 defpri;
    /**
     * strip VLAN tags unless overriden by
     * pv[v]2e.keeporstrip.  This flag is typically set for
     * both customer and provider ports for 802.1 provider bridging
     * forwarding (where a customer tag is transported from a
     * customer port, through a provider network).  This flag is
     * cleared for other cases, such as traditional 802.1
     * bridging, and VLAN cross-connect (e.g. TR-101-style
     * 2 tag service identification).
     */
    uint32 defstrip;
    /**
     * always strip the outer VLAN tag.
     * This flag is set only for provider bridging provider
     * ports.  pstrip=1 ensures the STAG is always stripped and
     * the CTAG is forwarded transparently.
     */
    uint32 pstrip;
    /**
     * PBB mode information.
     * This flag is set only for provider backbone bridging 
     * ports.  mim=0 means PBB is not enabled on this port.
     * The non-zero values are (tdb).
     */
    uint32 mim;
    /** MPLSTP enabled on this port */
    uint32 mplstp;
    /** HIDE */
    soc_sbx_g2p3_8_byte_t mask;
    /**
     * parse at most one CTPID tag on a packet.  Must not be set
     * concurrently with p2e.provider.  If both p2e.customer and
     * p2e.provider
     * are 0, all VLAN tags will be processed completely
     * transparently (i.e. ignored), similarly to a non
     * VLAN-capable switch.  This transparent mode is typically
     * not used for normal system operation, but is
     * useful for testing purpose.
     */
    uint32 customer;
    /**
     * parse at most once STPID tag, possibly with a CTPID tag
     * beneath it, on a packet.  The STPID (either STPID0 or
     * STPID1) is selected based on p2e.stpid1.  p2e.provider
     * not be set concurrently with p2e.customer.  If both
     * p2e.customer and p2e.provider
     * are 0, all VLAN tags will be processed completely
     * transparently (i.e. ignored), similarly to a non
     * VLAN-capable switch.  This transparent mode is typically
     * not used for normal system operation, but is
     * useful for testing purpose.
     */
    uint32 provider;
    /**
     * enable 802.3 link OAM loopback mode.
     * When oamloop=1, all ingress packets are sent to the
     * exception stream with a PPE trap code indicating the port
     * is in link loopback mode.  The ingress exception
     * stream microcode will loop back all packets except
     * L2CP slow protocol packets which will be sent to
     * the CPU as exceptions.  When oamloop=1, egress L2CP slow
     * protocol packets are forwarded normally, and all other
     * packets are sent to the egress exception stream with
     * a PPE trap code indicating the port is in link loopback
     * mode.  The egress exception microcode will drop all
     * link loopback packets.
     */
    uint32 oamloop;
    /** use STPID1 for provider-mode tag parsing. */
    uint32 stpid1;
    /**
     * enable an additional STPID for provider-mode tag parsing.
     * If p2e.twintpid=1, a provider tag can either be preceded
     * by the configured STPID (0 or 1, depending on p2e.stpid1), 
     * or by a third STPID value (STPID2).  This allows a single
     * port to concurrently support two different STPID
     * conventions for interworking scenarios.
     */
    uint32 twintpid;
    /** enable PBB fast-path fowarding on a port */
    uint32 pbb;
    /** enable IPv4 multicast fast-path fowarding on a port */
    uint32 ipv4mc;
    /** HIDE */
    uint32 state;
    /**
     * Microcode port number (for PPE parsing use).  This field is
     * read-only.  It is used for behavior such as matching
     * per-port local station addresses.
     */
    uint32 pport;
    /** HIDE */
    uint32 htype;
} soc_sbx_g2p3_p2e_t;

    /**
     * Egress Port Table.
     * This egress table contains per-port configuration data.
     * The contents of this table are contained in the PPE
     * per-port data and PPE variable memories.
     * 
     * <br><br>The PPE per-port and variable memories are
     * organized by source queue.  SWS source
     * queues may be assigned to ports in somewhat
     * arbitrary ways as necessary to ensure full
     * throughput for a given front panel port
     * configuation, so among other things, the
     * <tt>p2e</tt> and <tt>ep2e</tt> contain the ordinal
     * port number associated with a particular SWS queue.
     * <br><br>Although the data is internally organized by SWS
     * queue, the interface to the <tt>p2e</tt> table is by port.
     * The set and get implementation automatically perform
     * translation from forwarding port number to SWS queue to
     * access the appropriate per-port state.
     */
typedef struct soc_sbx_g2p3_ep2e_s {
    /**
     * PBB mode information.
     * This flag is set only for provider backbone bridging 
     * ports.  mim=0 means PBB is not enabled on this port.
     * The non-zero values are (tdb).
     */
    uint32 mim;
    /**
     * egress port id.  This value is used to perform
     * split-horizon packet dropping in cases where the ETE
     * does not contain an ETE-specific PID value.
     */
    uint32 pid;
    /** use STPID0 for STAGs. */
    uint32 stpid0;
    /** use STPID1 for STAGs. */
    uint32 stpid1;
    /**
     * enable provider bridging customer port egress CTAG
     * processing.  This bit should be set on provider bridging
     * customer ports (but not on ports operating in any other role
     * such as `traditional' 802.1 bridging ports, provider
     * bridging provider ports, transparent mux/demux ports, or
     * TR-101-style crossconnect ports).  When ep2e.customer=1, 
     * the tag of a tagged packet arriving at egress is used to
     * determine STP state, tag stripping and classification.
     * Untagged packets will use a native VID and default PCP
     * from the ETE.
     * When ep2e.customer=0, any tags on the packet are ignored
     * by egress processing, and the PCP is always computed from
     * the remark table lookup.
     */
    uint32 customer;
    /**
     * do not strip the ERH.  This flag can be used when
     * the FE is connected to a third party device (e.g. an FPGA)
     * that requires information from the ERH, such as the packet
     * length
     */
    uint32 keeperh;
    /**
     * Microcode port number (for LRP use).  This field is
     * read-only.
     */
    uint32 port;
    /**
     * egress mirror index; unlike ingress mirroring, egress
     * mirroring selects one of 16 FE hardware mirrors; on the
     * BCM88020, to direct an egress mirrored flow some place
     * other than a port on the local FE, an unused port
     * must be put into loopback mode, and the ingress
     * packet processing configured to direct all looped
     * packets to the mirror port or tunnel; the BCM88025
     * supports arbitrary forwarding of hardware mirrored
     * traffic so using port loopback is not necessary
     */
    uint32 mirroridx;
    /** HIDE */
    soc_sbx_g2p3_8_byte_t mask;
    /**
     * enable 802.3 link OAM loopback mode.
     * When oamloop=1, all ingress packets are sent to the
     * exception stream with a PPE trap code indicating the port
     * is in link loopback mode.  The ingress exception
     * stream microcode will loop back all packets except
     * L2CP slow protocol packets which will be sent to
     * the CPU as exceptions.  When oamloop=1, egress L2CP slow
     * protocol packets are forwarded normally, and all other
     * packets are sent to the egress exception stream with
     * a PPE trap code indicating the port is in link loopback
     * mode.  The egress exception microcode will drop all
     * link loopback packets.
     */
    uint32 oamloop;
    /** enable PBB fast-path fowarding on a port */
    uint32 pbb;
    /** HIDE */
    uint32 state;
    /** HIDE */
    uint32 htype;
} soc_sbx_g2p3_ep2e_t;

    /** p2e20 entry contents. */
typedef struct soc_sbx_g2p3_p2e20_s {
    /**
     * Microcode port number (for LRP use).  This field is
     * read-only.
     */
    uint32 port;
    /** default (native) VID for untagged packets */
    uint32 nativevid;
    /** default CFI for untagged packets */
    uint32 defcfi;
    /** default Ethernet priority for untagged packets */
    uint32 defpri;
    /**
     * strip VLAN tags unless overriden by
     * pv[v]2e.keeporstrip.  This flag is typically set for
     * both customer and provider ports for 802.1 provider bridging
     * forwarding (where a customer tag is transported from a
     * customer port, through a provider network).  This flag is
     * cleared for other cases, such as traditional 802.1
     * bridging, and VLAN cross-connect (e.g. TR-101-style
     * 2 tag service identification).
     */
    uint32 defstrip;
    /**
     * always strip the outer VLAN tag.
     * This flag is set only for provider bridging provider
     * ports.  pstrip=1 ensures the STAG is always stripped and
     * the CTAG is forwarded transparently.
     */
    uint32 pstrip;
    /**
     * PBB mode information.
     * This flag is set only for provider backbone bridging 
     * ports.  mim=0 means PBB is not enabled on this port.
     * The non-zero values are (tdb).
     */
    uint32 mim;
    /** MPLSTP enabled on this port */
    uint32 mplstp;
    /** HIDE */
    soc_sbx_g2p3_8_byte_t mask;
    /**
     * parse at most one CTPID tag on a packet.  Must not be set
     * concurrently with p2e.provider.  If both p2e.customer and
     * p2e.provider
     * are 0, all VLAN tags will be processed completely
     * transparently (i.e. ignored), similarly to a non
     * VLAN-capable switch.  This transparent mode is typically
     * not used for normal system operation, but is
     * useful for testing purpose.
     */
    uint32 customer;
    /**
     * parse at most once STPID tag, possibly with a CTPID tag
     * beneath it, on a packet.  The STPID (either STPID0 or
     * STPID1) is selected based on p2e.stpid1.  p2e.provider
     * not be set concurrently with p2e.customer.  If both
     * p2e.customer and p2e.provider
     * are 0, all VLAN tags will be processed completely
     * transparently (i.e. ignored), similarly to a non
     * VLAN-capable switch.  This transparent mode is typically
     * not used for normal system operation, but is
     * useful for testing purpose.
     */
    uint32 provider;
    /**
     * enable 802.3 link OAM loopback mode.
     * When oamloop=1, all ingress packets are sent to the
     * exception stream with a PPE trap code indicating the port
     * is in link loopback mode.  The ingress exception
     * stream microcode will loop back all packets except
     * L2CP slow protocol packets which will be sent to
     * the CPU as exceptions.  When oamloop=1, egress L2CP slow
     * protocol packets are forwarded normally, and all other
     * packets are sent to the egress exception stream with
     * a PPE trap code indicating the port is in link loopback
     * mode.  The egress exception microcode will drop all
     * link loopback packets.
     */
    uint32 oamloop;
    /** use STPID1 for provider-mode tag parsing. */
    uint32 stpid1;
    /**
     * enable an additional STPID for provider-mode tag parsing.
     * If p2e.twintpid=1, a provider tag can either be preceded
     * by the configured STPID (0 or 1, depending on p2e.stpid1), 
     * or by a third STPID value (STPID2).  This allows a single
     * port to concurrently support two different STPID
     * conventions for interworking scenarios.
     */
    uint32 twintpid;
    /** enable PBB fast-path fowarding on a port */
    uint32 pbb;
    /** enable IPv4 multicast fast-path fowarding on a port */
    uint32 ipv4mc;
    /** HIDE */
    uint32 state;
    /**
     * Microcode port number (for PPE parsing use).  This field is
     * read-only.  It is used for behavior such as matching
     * per-port local station addresses.
     */
    uint32 pport;
    /** HIDE */
    uint32 htype;
} soc_sbx_g2p3_p2e20_t;

    /** ep2e20 entry contents. */
typedef struct soc_sbx_g2p3_ep2e20_s {
    /**
     * PBB mode information.
     * This flag is set only for provider backbone bridging 
     * ports.  mim=0 means PBB is not enabled on this port.
     * The non-zero values are (tdb).
     */
    uint32 mim;
    /**
     * egress port id.  This value is used to perform
     * split-horizon packet dropping in cases where the ETE
     * does not contain an ETE-specific PID value.
     */
    uint32 pid;
    /** use STPID0 for STAGs. */
    uint32 stpid0;
    /** use STPID1 for STAGs. */
    uint32 stpid1;
    /**
     * enable provider bridging customer port egress CTAG
     * processing.  This bit should be set on provider bridging
     * customer ports (but not on ports operating in any other role
     * such as `traditional' 802.1 bridging ports, provider
     * bridging provider ports, transparent mux/demux ports, or
     * TR-101-style crossconnect ports).  When ep2e.customer=1, 
     * the tag of a tagged packet arriving at egress is used to
     * determine STP state, tag stripping and classification.
     * Untagged packets will use a native VID and default PCP
     * from the ETE.
     * When ep2e.customer=0, any tags on the packet are ignored
     * by egress processing, and the PCP is always computed from
     * the remark table lookup.
     */
    uint32 customer;
    /**
     * do not strip the ERH.  This flag can be used when
     * the FE is connected to a third party device (e.g. an FPGA)
     * that requires information from the ERH, such as the packet
     * length
     */
    uint32 keeperh;
    /**
     * Microcode port number (for LRP use).  This field is
     * read-only.
     */
    uint32 port;
    /**
     * egress mirror index; unlike ingress mirroring, egress
     * mirroring selects one of 16 FE hardware mirrors; on the
     * BCM88020, to direct an egress mirrored flow some place
     * other than a port on the local FE, an unused port
     * must be put into loopback mode, and the ingress
     * packet processing configured to direct all looped
     * packets to the mirror port or tunnel; the BCM88025
     * supports arbitrary forwarding of hardware mirrored
     * traffic so using port loopback is not necessary
     */
    uint32 mirroridx;
    /** HIDE */
    soc_sbx_g2p3_8_byte_t mask;
    /**
     * enable 802.3 link OAM loopback mode.
     * When oamloop=1, all ingress packets are sent to the
     * exception stream with a PPE trap code indicating the port
     * is in link loopback mode.  The ingress exception
     * stream microcode will loop back all packets except
     * L2CP slow protocol packets which will be sent to
     * the CPU as exceptions.  When oamloop=1, egress L2CP slow
     * protocol packets are forwarded normally, and all other
     * packets are sent to the egress exception stream with
     * a PPE trap code indicating the port is in link loopback
     * mode.  The egress exception microcode will drop all
     * link loopback packets.
     */
    uint32 oamloop;
    /** enable PBB fast-path fowarding on a port */
    uint32 pbb;
    /** HIDE */
    uint32 state;
    /** HIDE */
    uint32 htype;
} soc_sbx_g2p3_ep2e20_t;

    /** p2e25 entry contents. */
typedef struct soc_sbx_g2p3_p2e25_s {
    /**
     * Microcode port number (for LRP use).  This field is
     * read-only.
     */
    uint32 port;
    /** default (native) VID for untagged packets */
    uint32 nativevid;
    /** default CFI for untagged packets */
    uint32 defcfi;
    /** default Ethernet priority for untagged packets */
    uint32 defpri;
    /**
     * strip VLAN tags unless overriden by
     * pv[v]2e.keeporstrip.  This flag is typically set for
     * both customer and provider ports for 802.1 provider bridging
     * forwarding (where a customer tag is transported from a
     * customer port, through a provider network).  This flag is
     * cleared for other cases, such as traditional 802.1
     * bridging, and VLAN cross-connect (e.g. TR-101-style
     * 2 tag service identification).
     */
    uint32 defstrip;
    /**
     * always strip the outer VLAN tag.
     * This flag is set only for provider bridging provider
     * ports.  pstrip=1 ensures the STAG is always stripped and
     * the CTAG is forwarded transparently.
     */
    uint32 pstrip;
    /**
     * PBB mode information.
     * This flag is set only for provider backbone bridging 
     * ports.  mim=0 means PBB is not enabled on this port.
     * The non-zero values are (tdb).
     */
    uint32 mim;
    /** MPLSTP enabled on this port */
    uint32 mplstp;
    /** HIDE */
    soc_sbx_g2p3_8_byte_t mask;
    /**
     * parse at most one CTPID tag on a packet.  Must not be set
     * concurrently with p2e.provider.  If both p2e.customer and
     * p2e.provider
     * are 0, all VLAN tags will be processed completely
     * transparently (i.e. ignored), similarly to a non
     * VLAN-capable switch.  This transparent mode is typically
     * not used for normal system operation, but is
     * useful for testing purpose.
     */
    uint32 customer;
    /**
     * parse at most once STPID tag, possibly with a CTPID tag
     * beneath it, on a packet.  The STPID (either STPID0 or
     * STPID1) is selected based on p2e.stpid1.  p2e.provider
     * not be set concurrently with p2e.customer.  If both
     * p2e.customer and p2e.provider
     * are 0, all VLAN tags will be processed completely
     * transparently (i.e. ignored), similarly to a non
     * VLAN-capable switch.  This transparent mode is typically
     * not used for normal system operation, but is
     * useful for testing purpose.
     */
    uint32 provider;
    /**
     * enable 802.3 link OAM loopback mode.
     * When oamloop=1, all ingress packets are sent to the
     * exception stream with a PPE trap code indicating the port
     * is in link loopback mode.  The ingress exception
     * stream microcode will loop back all packets except
     * L2CP slow protocol packets which will be sent to
     * the CPU as exceptions.  When oamloop=1, egress L2CP slow
     * protocol packets are forwarded normally, and all other
     * packets are sent to the egress exception stream with
     * a PPE trap code indicating the port is in link loopback
     * mode.  The egress exception microcode will drop all
     * link loopback packets.
     */
    uint32 oamloop;
    /** use STPID1 for provider-mode tag parsing. */
    uint32 stpid1;
    /**
     * enable an additional STPID for provider-mode tag parsing.
     * If p2e.twintpid=1, a provider tag can either be preceded
     * by the configured STPID (0 or 1, depending on p2e.stpid1), 
     * or by a third STPID value (STPID2).  This allows a single
     * port to concurrently support two different STPID
     * conventions for interworking scenarios.
     */
    uint32 twintpid;
    /** enable PBB fast-path fowarding on a port */
    uint32 pbb;
    /** enable IPv4 multicast fast-path fowarding on a port */
    uint32 ipv4mc;
    /** HIDE */
    uint32 state;
    /**
     * Microcode port number (for PPE parsing use).  This field is
     * read-only.  It is used for behavior such as matching
     * per-port local station addresses.
     */
    uint32 pport;
    /** HIDE */
    uint32 htype;
} soc_sbx_g2p3_p2e25_t;

    /** ep2e25 entry contents. */
typedef struct soc_sbx_g2p3_ep2e25_s {
    /**
     * PBB mode information.
     * This flag is set only for provider backbone bridging 
     * ports.  mim=0 means PBB is not enabled on this port.
     * The non-zero values are (tdb).
     */
    uint32 mim;
    /**
     * egress port id.  This value is used to perform
     * split-horizon packet dropping in cases where the ETE
     * does not contain an ETE-specific PID value.
     */
    uint32 pid;
    /** use STPID0 for STAGs. */
    uint32 stpid0;
    /** use STPID1 for STAGs. */
    uint32 stpid1;
    /**
     * enable provider bridging customer port egress CTAG
     * processing.  This bit should be set on provider bridging
     * customer ports (but not on ports operating in any other role
     * such as `traditional' 802.1 bridging ports, provider
     * bridging provider ports, transparent mux/demux ports, or
     * TR-101-style crossconnect ports).  When ep2e.customer=1, 
     * the tag of a tagged packet arriving at egress is used to
     * determine STP state, tag stripping and classification.
     * Untagged packets will use a native VID and default PCP
     * from the ETE.
     * When ep2e.customer=0, any tags on the packet are ignored
     * by egress processing, and the PCP is always computed from
     * the remark table lookup.
     */
    uint32 customer;
    /**
     * do not strip the ERH.  This flag can be used when
     * the FE is connected to a third party device (e.g. an FPGA)
     * that requires information from the ERH, such as the packet
     * length
     */
    uint32 keeperh;
    /**
     * Microcode port number (for LRP use).  This field is
     * read-only.
     */
    uint32 port;
    /**
     * egress mirror index; unlike ingress mirroring, egress
     * mirroring selects one of 16 FE hardware mirrors; on the
     * BCM88020, to direct an egress mirrored flow some place
     * other than a port on the local FE, an unused port
     * must be put into loopback mode, and the ingress
     * packet processing configured to direct all looped
     * packets to the mirror port or tunnel; the BCM88025
     * supports arbitrary forwarding of hardware mirrored
     * traffic so using port loopback is not necessary
     */
    uint32 mirroridx;
    /** HIDE */
    soc_sbx_g2p3_8_byte_t mask;
    /**
     * enable 802.3 link OAM loopback mode.
     * When oamloop=1, all ingress packets are sent to the
     * exception stream with a PPE trap code indicating the port
     * is in link loopback mode.  The ingress exception
     * stream microcode will loop back all packets except
     * L2CP slow protocol packets which will be sent to
     * the CPU as exceptions.  When oamloop=1, egress L2CP slow
     * protocol packets are forwarded normally, and all other
     * packets are sent to the egress exception stream with
     * a PPE trap code indicating the port is in link loopback
     * mode.  The egress exception microcode will drop all
     * link loopback packets.
     */
    uint32 oamloop;
    /** enable PBB fast-path fowarding on a port */
    uint32 pbb;
    /** HIDE */
    uint32 state;
    /** HIDE */
    uint32 htype;
} soc_sbx_g2p3_ep2e25_t;

    /**
     * Ingress TPID Table.
     * This table controls the TPIDs used for ingress
     * packet parsing.  There is 1 TPID for customer tags, and
     * 2 TPIDs for provider tags.  The SVID TPID is selected
     * per-port for ports in provider mode by the
     * <tt>p2e.stpid1</tt> bit.  In addition, provider-mode ports
     * can be configured to allow 2 different SVID TPIDs to
     * indicate the presence of a provider tag with the
     * <tt>p2e.twintpid</tt> bit.
     * <br><br>At present, there is no mechanism
     * to set the `twin' SVID TPID (it defaults to 0x8100), but
     * ultimately it will be set through this table.
     */
typedef struct soc_sbx_g2p3_tpid_s {
    /** TPID Ethertype value (e.g. 0x8100) */
    uint32 tpid;
} soc_sbx_g2p3_tpid_t;

    /**
     * Ingress OAM RX Enable Table.
     * This table enables/disables PPE parsing for
     * ingress fast-path service OAM processing.  If PPE
     * parsing for OAM is disabled,
     * OAM packets are forwarded using ordinary forwarding
     * mechanisms.
     */
typedef struct soc_sbx_g2p3_oam_rx_s {
    /** enable PPE parsing for service OAM packets */
    uint32 valid;
} soc_sbx_g2p3_oam_rx_t;

    /** HIDE */
typedef struct soc_sbx_g2p3_oam_tx_s {
    /** valid */
    uint32 valid;
} soc_sbx_g2p3_oam_tx_t;

    /**
     * Ingress Local Station MAC Address Table.
     * This table contains local station MAC addresses
     * that will cause the ingress PPE processing to select
     * routed
     * forwarding functions (IP, IPMC and MPLS).
     * <br><br>Local station addresses can either be global,
     * matching on any port, or port-specific, matching on a
     * single port.  If a local station should match on a set of
     * ports, it must be added to this table once for each port.
     * <br><br>Setting an entry with a MAC address of
     * <tt>0:0:0:0:0:0</tt> will delete the entry.
     */
typedef struct soc_sbx_g2p3_lsmac_s {
    /** port number to match, if useport=1 */
    uint32 port;
    /** local station MAC is port-specific */
    uint32 useport;
    /** local station MAC address */
    soc_sbx_g2p3_6_byte_t mac;
} soc_sbx_g2p3_lsmac_t;

    /**
     * Ingress L2CP MAC Table.
     * This table contains base MAC addresses for MAC
     * address
     * ranges from xx:xx:xx:xx:xx:00 to xx:xx:xx:xx:xx:ff that
     * ingress PPE parsing will treat as  Ethernet Layer 2 Control
     * Protocol (L2CP) packets.
     * <br><br>L2CP packets receive special processing based on
     * the <tt>l2cp</tt> and
     * <tt>l2cpslow</tt> tables.  L2CP packets are also looked up
     * in the <tt>mac</tt> table with a least significant octet
     * of 0.  In effect, this wildcards the least signficant octet.
     * <br><br>The <tt>l2cpmac</tt> table is usually configured
     * to match traditional/customer IEEE L2CP MAC addresses, or
     * or the provider IEEE L2CP MAC addresses, or both.  It also
     * allows support of proprietary L2CP MAC address ranges.
     */
typedef struct soc_sbx_g2p3_l2cpmac_s {
    /** port number to match, if useport=1 */
    uint32 port;
    /** L2CP MAC base address is port-specific */
    uint32 useport;
    /** L2CP MAC base address */
    soc_sbx_g2p3_6_byte_t mac;
} soc_sbx_g2p3_l2cpmac_t;

    /**
     * Egress OAM Local Station MAC Table.
     * This table contains the MAC addresses for egress OAM 
     * local station matches.  When matched, the packet will  
     * be delivered to the up OAM processing stream.
     * It allows for a small number of matches (under mask).
     */
typedef struct soc_sbx_g2p3_oamupmac_s {
    /** up OAM LSM address */
    soc_sbx_g2p3_6_byte_t mac;
    /** up OAM LSM mask */
    soc_sbx_g2p3_6_byte_t mask;
} soc_sbx_g2p3_oamupmac_t;

    /**
     * Ingress QoS Mapping Table.
     * This table maps ingress QoS packet markings,
     * including Ethernet priority code point information,
     * 802.1 priority (PRI) bits and discard eligible (DE) bit,
     * and MPLS experimental (EXP) bits to internal QoS values.
     * <br><br>The QoS mapping table returns 3 separate
     * class-of-service (CoS) values:
     * <ul>
     *   <li><i>remark</i> CoS.  This CoS is used by egress
     *       processing to generate new CoS packet markings.</li>
     *   <li><i>fabric</i> CoS.  This CoS is used by the fabric
     *       to select a queue, which, in turn, determines
     *       scheduling behavior such as priority, guaranteed
     *       bandwidth and selective dropping behavior (WRED
     *       curves).</li>
     *   <li><i>mef</i> CoS.  This CoS is used to select an
     *       application policer (and counters) from a group of
     *       such policers associated with a service.</li>
     * </ul>
     * <br><br>The QoS mapping table also determines the initial
     * discard eligibility (color) for a packet.  The initial
     * color is
     * used for policing, and then for selective dropping in the
     * fabric, and finally for regenerating QoS packet markings
     * on egress.
     * <br><br>Finally, the QoS mapping table indicates a packet
     * is eligible for marking by the fabric if the configured
     * congestion criteria are met in the fabric (i.e. the packet
     * is part of an ECN-capable transport flow).
     */
typedef struct soc_sbx_g2p3_qos_s {
    /** packet is eligible for marking in the fabric */
    uint32 e;
    /** initial discard eligibility; 0: green, 1: yellow, 2: red */
    uint32 dp;
    /** remark class-of-service */
    uint32 cos;
    /** fabric class-of-service */
    uint32 fcos;
    /** MEF service policer and counter class-of-service */
    uint32 mefcos;
} soc_sbx_g2p3_qos_t;

    /**
     * Ingress QoS Mapping Table.
     * This table maps ingress IPv4 DiffServ code point 
     * information to internal QoS values.
     * <br><br>The QoS mapping table returns 3 separate
     * class-of-service (CoS) values:
     * <ul>
     *   <li><i>remark</i> CoS.  This CoS is used by egress
     *       processing to generate new CoS packet markings.</li>
     *   <li><i>fabric</i> CoS.  This CoS is used by the fabric
     *       to select a queue, which, in turn, determines
     *       scheduling behavior such as priority, guaranteed
     *       bandwidth and selective dropping behavior (WRED
     *       curves).</li>
     *   <li><i>mef</i> CoS.  This CoS is used to select an
     *       application policer (and counters) from a group of
     *       such policers associated with a service.</li>
     * </ul>
     * <br><br>The QoS mapping table also determines the initial
     * discard eligibility (color) for a packet.  The initial
     * color is
     * used for policing, and then for selective dropping in the
     * fabric, and finally for regenerating QoS packet markings
     * on egress.
     * <br><br>Finally, the QoS mapping table indicates a packet
     * is eligible for marking by the fabric if the configured
     * congestion criteria are met in the fabric (i.e. the packet
     * is part of an ECN-capable transport flow).
     */
typedef struct soc_sbx_g2p3_dscp_qos_s {
    /** packet is eligible for marking in the fabric */
    uint32 e;
    /** initial discard eligibility; 0: green, 1: yellow, 2: red */
    uint32 dp;
    /** remark class-of-service */
    uint32 cos;
    /** fabric class-of-service */
    uint32 fcos;
    /** MEF service policer and counter class-of-service */
    uint32 mefcos;
} soc_sbx_g2p3_dscp_qos_t;

    /**
     * Ingress Rule Action Table.
     * This table contains the actions associated with an IFP
     * (<i>ingress field processor</i> also known as <i>ingress
     *  classifier</i> or the <i>ingress rule classification
     *  engine (RCE)</i>) pattern match.
     * <br><br>This table is not accessed directly by the host
     * software, but is managed by the RCE control software.  The
     * <tt>ifp</tt> table provides the host software (SDK) control 
     * interface to IFP operation.
     * <br><br>This table contains more elements than the number of
     * patterns that a single packet could possibly match for
     * several reasons:
     * <ul>
     *   <li>The 88020 employs a technique called <i>batching</i>
     *       to increase the total number of patterns supported.
     *       Each batch of patterns is associated with a subset
     *       of all physical ports.</li>
     *   <li>Hitless update of the IFP database requires one spare
     *       batch worth of ifp entries.</li>
     * </ul>
     * The RCE control software manages these extra table elements
     * automatically.
     */
typedef struct soc_sbx_g2p3_irt_s {
    /** new VLAN to assign.  This field is a union with ftidx */
    uint32 vlan;
    /** FT to which to forwarding.  This field is a union with vlan */
    uint32 ftidx;
    /**
     * mirror table index for mirroring;  mirror=0 means
     * do not mirror
     */
    uint32 mirror;
    /**
     * forward the packet on VLAN vlan; it is illegal to set
     * usevlan if useftidx is set
     */
    uint32 usevlan;
    /**
     * forward the packet through forwarding table entry ftidx;
     * it is illegal to set useftidx if usevlan is set
     */
    uint32 useftidx;
    /**
     * generate an RT copy exception (in addition to nominal
     * forwarding)
     */
    uint32 copy;
    /** initial discard eligibility; 0: green, 1: yellow, 2: red */
    uint32 dp;
    /** remark class-of-service */
    uint32 cos;
    /** fabric class-of-service */
    uint32 fcos;
    /** update the color with dp */
    uint32 usedp;
    /** update remark cos with cos and the fabric cos with fcos */
    uint32 usecos;
    /** policer to apply; 0 means do not override policer selection */
    uint32 policer;
    /** used typed policing */
    uint32 typedpolice;
    /** use MEF class-of-service policing; mef must be 1 if mefcos=1 */
    uint32 mefcos;
    /** use MEF policing */
    uint32 mef;
} soc_sbx_g2p3_irt_t;

    /** HIDE */
typedef struct soc_sbx_g2p3_irt_wrap_s {
    /** new VLAN to assign.  This field is a union with ftidx */
    uint32 vlan;
    /** FT to which to forwarding.  This field is a union with vlan */
    uint32 ftidx;
    /**
     * mirror table index for mirroring;  mirror=0 means
     * do not mirror
     */
    uint32 mirror;
    /**
     * forward the packet on VLAN vlan; it is illegal to set
     * usevlan if useftidx is set
     */
    uint32 usevlan;
    /**
     * forward the packet through forwarding table entry ftidx;
     * it is illegal to set useftidx if usevlan is set
     */
    uint32 useftidx;
    /**
     * generate an RT copy exception (in addition to nominal
     * forwarding)
     */
    uint32 copy;
    /** initial discard eligibility; 0: green, 1: yellow, 2: red */
    uint32 dp;
    /** remark class-of-service */
    uint32 cos;
    /** fabric class-of-service */
    uint32 fcos;
    /** update the color with dp */
    uint32 usedp;
    /** update remark cos with cos and the fabric cos with fcos */
    uint32 usecos;
    /** policer to apply; 0 means do not override policer selection */
    uint32 policer;
    /** used typed policing */
    uint32 typedpolice;
    /** use MEF class-of-service policing; mef must be 1 if mefcos=1 */
    uint32 mefcos;
    /** use MEF policing */
    uint32 mef;
} soc_sbx_g2p3_irt_wrap_t;

    /** HIDE */
typedef struct soc_sbx_g2p3_rt_mt_s {
    /** policer to apply; 0 means do not override policer selection */
    uint32 policer;
} soc_sbx_g2p3_rt_mt_t;

    /** HIDE */
typedef struct soc_sbx_g2p3_rt_rr0_s {
    /** resv */
    uint32 resv;
    /**
     * forward the packet on VLAN vlan; it is illegal to set
     * usevlan if useftidx is set
     */
    uint32 usevlan;
    /**
     * forward the packet through forwarding table entry ftidx;
     * it is illegal to set useftidx if usevlan is set
     */
    uint32 useftidx;
    /** new VLAN to assign.  This field is a union with ftidx */
    uint32 vlan;
    /** FT to which to forwarding.  This field is a union with vlan */
    uint32 ftidx;
    /**
     * generate an RT copy exception (in addition to nominal
     * forwarding)
     */
    uint32 copy;
    /** initial discard eligibility; 0: green, 1: yellow, 2: red */
    uint32 dp;
    /** update the color with dp */
    uint32 usedp;
    /**
     * mirror table index for mirroring;  mirror=0 means
     * do not mirror
     */
    uint32 mirror;
    /** used typed policing */
    uint32 typedpolice;
    /** use MEF class-of-service policing; mef must be 1 if mefcos=1 */
    uint32 mefcos;
    /** use MEF policing */
    uint32 mef;
    /** remark class-of-service */
    uint32 cos;
    /** fabric class-of-service */
    uint32 fcos;
    /** update remark cos with cos and the fabric cos with fcos */
    uint32 usecos;
    /** emirror */
    uint32 emirror;
    /** drop */
    uint32 drop;
    /** rtidx */
    uint32 rtidx;
} soc_sbx_g2p3_rt_rr0_t;

    /** rt entry contents. */
typedef struct soc_sbx_g2p3_rt_s {
} soc_sbx_g2p3_rt_t;

    /** HIDE */
typedef struct soc_sbx_g2p3_rt_rr1_s {
    /** resv */
    uint32 resv;
    /**
     * forward the packet on VLAN vlan; it is illegal to set
     * usevlan if useftidx is set
     */
    uint32 usevlan;
    /**
     * forward the packet through forwarding table entry ftidx;
     * it is illegal to set useftidx if usevlan is set
     */
    uint32 useftidx;
    /** new VLAN to assign.  This field is a union with ftidx */
    uint32 vlan;
    /** FT to which to forwarding.  This field is a union with vlan */
    uint32 ftidx;
    /**
     * generate an RT copy exception (in addition to nominal
     * forwarding)
     */
    uint32 copy;
    /** initial discard eligibility; 0: green, 1: yellow, 2: red */
    uint32 dp;
    /** update the color with dp */
    uint32 usedp;
    /**
     * mirror table index for mirroring;  mirror=0 means
     * do not mirror
     */
    uint32 mirror;
    /** used typed policing */
    uint32 typedpolice;
    /** use MEF class-of-service policing; mef must be 1 if mefcos=1 */
    uint32 mefcos;
    /** use MEF policing */
    uint32 mef;
    /** remark class-of-service */
    uint32 cos;
    /** fabric class-of-service */
    uint32 fcos;
    /** update remark cos with cos and the fabric cos with fcos */
    uint32 usecos;
    /** emirror */
    uint32 emirror;
    /** drop */
    uint32 drop;
    /** rtidx */
    uint32 rtidx;
} soc_sbx_g2p3_rt_rr1_t;

    /**
     * Ingress LAG Table.
     * This table holds groups of forwarding parameters for
     * ingress link aggregation group (LAG) forwarding.
     * <br><br>If the forwarding table entry indicates the
     * destination is a LAG, a configurable number of bits
     * of a hash computed by the PPE from various L2-4 packet
     * fields are used to select the final forwarding information 
     * (queue and output editing control information) from the
     * <tt>lag</tt> table.
     * <br><br>The entries of the <tt>lag</tt> table are freely
     * managed by the SDK.  The group of <tt>lag</tt> table entries
     * for a LAG can start at any <tt>lag</tt> table
     * index, and includes all <tt>lag</tt> table entries from
     * that base through the maximum value of the LAG
     * hash for the particular LAG
     * (<tt>(1 << ft.lagsize) - 1</tt>).
     */
typedef struct soc_sbx_g2p3_lag_s {
    /** fabric base queue identifier */
    uint32 qid;
    /**
     * egress route header (ERH) out header index (OI); oi=0 use
     * ft.oi to compute the OI (i.e. ft.oi=0 means erh.oi=VLAN,
     * otherwise erh.oi=ft.oi)
     */
    uint32 oi;
} soc_sbx_g2p3_lag_t;

    /**
     * Ingress Fast Reroute Table.
     * This table controls ingress fast rerouting.  Every
     * forwarding table
     * includes a <tt>rr</tt> table index that controls whether
     * the primary or backup forwarding information (fabric base
     * queue identifier and egress editing information, or LAG 
     * specifier).
     * <br><br>This scheme allows any subset of forwarding paths
     * to be rerouted at any granularity desired.  For example
     * all forwarding table entries to a particular port could
     * share a single <tt>rr</tt> entry to implement per-port
     * fast rerouting, or rerouting could be performed per
     * peer router, or per tunnel.  Typically, one entry of the
     * <tt>rr</tt> table is reserved for forwarding paths that
     * are not candidates for fast rerouting.
     */
typedef struct soc_sbx_g2p3_rr_s {
    /** use the backup forwarding path */
    uint32 backup;
} soc_sbx_g2p3_rr_t;

    /**
     * Exception Table.
     * This table is shared between ingress and egress
     * processing and controls forwarding of exception packets.
     * <br><br>Exceptions fall in several different ranges:
     * <ul>
     *   <li>Exception 0 is reserved.</li>
     *   <li>Exceptions <tt>0x1-0xf</tt> are used by microcode for
     *       replication
     *       exceptions.  Replication exceptions are exceptions that
     *       can occur in addition to nominal packet forwarding.
     *       A packet can cause multiple replication exceptions,
     *       which will cause one exception packet per replication
     *       exception, in addition to the nominal packet
     *       forwarding.  Replication exceptions are not generated
     *       if nominal processing ends with an
     *       exception, <i>except</i> a learning exception may be
     *       generated if <tt>xt.learn=1.</tt></li>
     *   <li>Exceptions <tt>0x10-0x53</tt> are generated by packet
     *       checkers
     *       in the PPE hardware.  For example, SMAC=0, SMAC=DMAC,
     *       IP checksum failure, etc.  PPE checker exceptions
     *       can be individually enabled or disabled by modifying
     *       the appropriate PPE configuration registers (using
     *       the SDK bcm_switch_control_set() API.</li>
     *   <li>Exceptions <tt>0x53-MIN_FREE_EXCEPTION-1</tt> are
     *       generated by microcode.  Unlike replication exceptions,
     *       these exceptions affect the nominal packet
     *       forwarding.</li>
     *   <li>Exceptions <tt>MIN_FREE_EXCEPTION-MAX_FREE_EXCEPTION
     *       </tt> are available for the SDK to assign to
     *       any other exceptions that can be classified using
     *       nominal forwarding mechanisms.  For example, 
     *       exceptions for different types of processor-bound
     *       traffic (BGP versus OSPF versus L2CP), packet dropping
     *       causes (drop particular destination MAC entries, or
     *       control protocol traffic, or DOS traffic), and
     *       consistency checks (invalid forwarding table
     *       entries).</li>
     * </ul>
     * <br><br>The exception table is the only mechanism for
     * sending packets to the CPU.  While it is possible to
     * configure a regular forwarding table entry to a CPU queue
     * in the system, this will not result in the ERH being
     * formatted properly for the SDK to correctly interpret
     * the packet.  The SDK assumes the source port and module
     * information and exception identifier are in the ERH, which
     * will only happen if the packet is forwarded as an exception.
     * The SDK allocates a generic to-CPU exception for the
     * purposes sending general (not otherwise exceptional) traffic
     * to the CPU.
     */
typedef struct soc_sbx_g2p3_xt_s {
    /** forward the exception; forward=0 means drop */
    uint32 forward;
    /**
     * drop precedence for policer and fabric; 0: green,
     * 1: yellow, 2: red
     */
    uint32 dp;
    /** fabric queue identifier for forwarding */
    uint32 qid;
    /**
     * truncate packets to 64 bytes (actually, truncation length
     * is configured in the PED with registers); typically used for
     * learning exceptions, or other exceptions where only the
     * header of the packet is necessary.  This will reduce load
     * on the CPU PCI interface
     */
    uint32 trunc;
    /**
     * generate a learning exception even if the nominal processing
     * ends in an exception; typically used for STP drop and other
     * L2CP exception cases
     */
    uint32 learn;
    /**
     * debit the policer by 64 bytes for every packet;
     * allows policing as a function of packet rate instead of
     * packet size
     */
    uint32 ppspolice;
    /** policer to debit; policer=0 means no policer */
    uint32 policer;
} soc_sbx_g2p3_xt_t;

    /**
     * Ingress Mirror Table.
     * This table controls ingress mirrored packet forwarding.
     */
typedef struct soc_sbx_g2p3_mirror_s {
    /** mirrored packet fabric discard eligibility */
    uint32 yellow;
    /** mirrored packet fabric queue identifier */
    uint32 qid;
    /** mirrored packet egress out header index */
    uint32 oi;
} soc_sbx_g2p3_mirror_t;

    /**
     * Egress Mirror Table.
     * This table controls egress mirrored packet forwarding.
     */
typedef struct soc_sbx_g2p3_emirror_s {
    /**
     * local flag; set to 1 for mirroring to the local FE,
     * else 0.  BCM88020 only supports local=1
     */
    uint32 local;
    /**
     * local port; local FE port for egress mirroring.  Only
     * valid when (mirror.local=1)
     */
    uint32 port;
    /**
     * primary path base fabric queue identifier; the final
     * queue identifier is computed by adding the fabric QoS
     * to this value.  This field is only valid for non-local
     * mirroring (mirror.local=0).
     */
    uint32 qid;
    /**
     * primary path output output editing index (also called
     * out header index or OI); for traditional bridging forwarding
     * set the oi=VLAN.
     */
    uint32 oi;
} soc_sbx_g2p3_emirror_t;

    /** HIDE */
typedef struct soc_sbx_g2p3_emirror20_s {
    /** queue */
    uint32 queue;
    /** hdrpresent */
    uint32 hdrpresent;
    /** dropsrcpkt */
    uint32 dropsrcpkt;
} soc_sbx_g2p3_emirror20_t;

    /** HIDE */
typedef struct soc_sbx_g2p3_emirror25_s {
    /** queue */
    uint32 queue;
    /** hdrpresent */
    uint32 hdrpresent;
    /** dropsrcpkt */
    uint32 dropsrcpkt;
    /** higighdr */
    uint32 higighdr;
    /** overwritehdr */
    uint32 overwritehdr;
    /** hdrdata0 */
    uint32 hdrdata0;
    /** hdrdata1 */
    uint32 hdrdata1;
    /** hdrdata2 */
    uint32 hdrdata2;
    /** hdrdata3 */
    uint32 hdrdata3;
} soc_sbx_g2p3_emirror25_t;

    /** HIDE */
typedef struct soc_sbx_g2p3_emll1_s {
    /**
     * occupancy bitmask for the associate EML L2 table;
     * there is a 1 bit for each populated bucket
     */
    uint32 usemap;
    /**
     * point to an L2 EML table; if usemap=0, there is no
     * L2 table
     */
    uint32 pointer;
    /**
     * hash function salt, combined with the EML table key
     * to compute a L2 EML table hash index
     */
    uint32 salt;
} soc_sbx_g2p3_emll1_t;

    /**
     * MAC address table.
     * This single MAC table is shared between both `regular'
     * MAC addresses, and Provider Backbone Bridging (PBB) backbone
     * source MAC addresses (BSMACs).  A single bit of the key
     * distinguishes the two entry types.  Regular MAC addresses
     * are subject to automatic aging as defined in the 802.1
     * standard.  Backbone MAC addresses are not aged automatically.
     * Instead, the upper layer code must keep track of (customer) MAC
     * addresses `underneath' each BMAC and explicitly remove the a BMAC
     * address when there are no MAC addresses underneath.
     * [TODO: more documentation on MAC table operation]
     */
typedef struct soc_sbx_g2p3_mac_s {
    /**
     * source MAC entry hit timestamp; each time
     * a packet with this SMAC is received, the age
     * field is written with the current age stamp to 
     * allow aging scans of the MAC table to identify
     * and remove old entries
     */
    uint32 age;
    /**
     * forwarding port identifier (PID); the PID is used
     * as the forwarding table index for DMAC lookups, and
     * as the expected source PID for SMAC station movement
     * detection
     */
    uint32 pid;
    /** copy this packet if dcopy=1 on a DMAC lookup */
    uint32 dcopy;
    /**
     * fabric and remark CoS to use for the packet copy
     * when dcopy=1
     */
    uint32 dcopycos;
    /** drop this packet if ddrop=1 on a DMAC lookup */
    uint32 ddrop;
    /** drop this packet if sdrop=1 on a SMAC lookup */
    uint32 sdrop;
    /**
     * do not remove this packet from the MAC table even
     * if it is old; this bit is not used by the microcode,
     * but is used by the SDK to implement its age scanning
     */
    uint32 dontage;
    /** drop this packet if sdrop=1 on a B-SMAC lookup */
    uint32 bsdrop;
    /**
     * forwarding port identifier (PID); the PID is used
     * as the expected source PID for B-SMAC station movement
     * detection
     */
    uint32 bpid;
    /**
     * B-SMAC tunnel identifier (TID); the TID is used
     * as the expected source TID for inner SMAC station movement
     * detection
     */
    uint32 btid;
} soc_sbx_g2p3_mac_t;

    /** macl1 entry contents. */
typedef struct soc_sbx_g2p3_macl1_s {
    /**
     * occupancy bitmask for the associate EML L2 table;
     * there is a 1 bit for each populated bucket
     */
    uint32 usemap;
    /**
     * point to an L2 EML table; if usemap=0, there is no
     * L2 table
     */
    uint32 pointer;
    /**
     * hash function salt, combined with the EML table key
     * to compute a L2 EML table hash index
     */
    uint32 salt;
} soc_sbx_g2p3_macl1_t;

    /** macl2 entry contents. */
typedef struct soc_sbx_g2p3_macl2_s {
    /** mac */
    soc_sbx_g2p3_6_byte_t mac;
    /** vlan */
    uint32 vlan;
    /** bmac */
    uint32 bmac;
    /**
     * source MAC entry hit timestamp; each time
     * a packet with this SMAC is received, the age
     * field is written with the current age stamp to 
     * allow aging scans of the MAC table to identify
     * and remove old entries
     */
    uint32 age;
    /**
     * forwarding port identifier (PID); the PID is used
     * as the forwarding table index for DMAC lookups, and
     * as the expected source PID for SMAC station movement
     * detection
     */
    uint32 pid;
    /** copy this packet if dcopy=1 on a DMAC lookup */
    uint32 dcopy;
    /**
     * fabric and remark CoS to use for the packet copy
     * when dcopy=1
     */
    uint32 dcopycos;
    /** drop this packet if ddrop=1 on a DMAC lookup */
    uint32 ddrop;
    /** drop this packet if sdrop=1 on a SMAC lookup */
    uint32 sdrop;
    /**
     * do not remove this packet from the MAC table even
     * if it is old; this bit is not used by the microcode,
     * but is used by the SDK to implement its age scanning
     */
    uint32 dontage;
    /** HIDE */
    uint32 notage;
    /** drop this packet if sdrop=1 on a B-SMAC lookup */
    uint32 bsdrop;
    /**
     * forwarding port identifier (PID); the PID is used
     * as the expected source PID for B-SMAC station movement
     * detection
     */
    uint32 bpid;
    /**
     * B-SMAC tunnel identifier (TID); the TID is used
     * as the expected source TID for inner SMAC station movement
     * detection
     */
    uint32 btid;
} soc_sbx_g2p3_macl2_t;

    /** ipv6dhost entry contents. */
typedef struct soc_sbx_g2p3_ipv6dhost_s {
    /**
     * forwarding table base index; the final forwarding table
     * index is ftidx + ((1<< ecmpmask-1) & ppe aggr hash)
     */
    uint32 ftidx;
    /**
     * equal cost multipath (ECMP) set size; if ecmpmask=0, then
     * the route is not an ECMP route
     */
    uint32 ecmpmask;
    /**
     * destination VID for the route; this field is compared
     * with the source VID to determine if an IP redirect
     * exception message should be generated
     */
    uint32 vid;
} soc_sbx_g2p3_ipv6dhost_t;

    /** ipv6dhostl1 entry contents. */
typedef struct soc_sbx_g2p3_ipv6dhostl1_s {
    /**
     * occupancy bitmask for the associate EML L2 table;
     * there is a 1 bit for each populated bucket
     */
    uint32 usemap;
    /**
     * point to an L2 EML table; if usemap=0, there is no
     * L2 table
     */
    uint32 pointer;
    /**
     * hash function salt, combined with the EML table key
     * to compute a L2 EML table hash index
     */
    uint32 salt;
} soc_sbx_g2p3_ipv6dhostl1_t;

    /** ipv6dhostl2 entry contents. */
typedef struct soc_sbx_g2p3_ipv6dhostl2_s {
    /** key */
    soc_sbx_g2p3_16_byte_t key;
    /**
     * forwarding table base index; the final forwarding table
     * index is ftidx + ((1<< ecmpmask-1) & ppe aggr hash)
     */
    uint32 ftidx;
    /**
     * equal cost multipath (ECMP) set size; if ecmpmask=0, then
     * the route is not an ECMP route
     */
    uint32 ecmpmask;
    /**
     * destination VID for the route; this field is compared
     * with the source VID to determine if an IP redirect
     * exception message should be generated
     */
    uint32 vid;
} soc_sbx_g2p3_ipv6dhostl2_t;

    /**
     * Ingress Recirculation (Mirror, Sample, Trap) State Table.
     * The <tt>mst</tt> (mirror, sample & trap) table is used
     * internally by the ingress microcode to 
     * pass state from the initial (nominal) processing of
     * a packet, to processing of replicated packets.  Packet
     * replication is performed for exceptions that are generated
     * in addition to the nominal processing of the packet (e.g.
     * learning, snooping and copying to the CPU).
     */
typedef struct soc_sbx_g2p3_mst_s {
    /** packet triggered a MAC learning exception */
    uint32 learn;
    /** packet triggered a PIM snooping exception */
    uint32 pim;
    /** packet triggered an IGMP snooping exception */
    uint32 igmp;
    /** packet triggered an IFP copy */
    uint32 rtcopy;
    /** packet triggered an L2CP copy */
    uint32 l2cpcopy;
    /** packet triggered a destination address (DMAC or DA) copy */
    uint32 dcopy;
    /** packet triggered an IP redirect exception */
    uint32 ipredirect;
    /** packet triggered a BMAC learning exception (for MiM) */
    uint32 learn_bmac;
    /**
     * mirror table entry index for the packet.  If mirroridx=0,
     * the packet is not mirrored.
     */
    uint32 mirroridx;
    /**
     * VLAN (VSI) for the nominal packet.  This field is used
     * to insert the correct VSI into the ERH for learning
     * exceptions.
     */
    uint32 vsi;
} soc_sbx_g2p3_mst_t;

    /**
     * Ingress Port, VID Table.
     * This table contains per-ingress (physical port, VLAN
     * identifier) state.
     * <br><br>If a <tt>pvv2e</tt> table entry is found, it will
     * override the contents of the <tt>pv2e</tt> table.
     */
typedef struct soc_sbx_g2p3_pv2e_s {
    /** lp table index; if lp=0, the port is used as lp table index */
    uint32 lpi;
    /** internal forwarding VLAN (virtual switching identifier) */
    uint32 vlan;
    /**
     * spanning tree state: stpstate_forward, stpstate_block or
     * stpstate_learn
     */
    uint32 stpstate;
    /**
     * prevents a (customer) tag from being added to a packet that
     * does not already have one.  This value is actually intended
     * to be a per-port property, but implementation expediency
     * forced it into the pv2e table.  It should only be
     * set to 0 for provider bridging customer ports where
     * CTAG transparency is desired (i.e. the packet contains a
     * CTAG in the provider network only if it contained a CTAG
     * when it arrived at the customer port).  For all other cases
     * (customer ports in nontransparent services, provider ports,
     * and `normal' 802.1 bridging ports), it should be left at
     * its default of 1.
     */
    uint32 untagged_strip;
    /** Point to Point VPWS Pseudowire customer facing port */
    uint32 vpws;
} soc_sbx_g2p3_pv2e_t;

    /**
     * SDK-only Port Table.
     * This table contains per-port, SDK-only state.  This state
     * is used for SDK book keeping, and is not used by the
     * microcode.
     */
typedef struct soc_sbx_g2p3_p2appdata_s {
    /**
     * ingress VLAN filtering enabled; drop packets on VLANs
     * to which the port does not belong
     */
    uint32 ifilteren;
    /**
     * egress VLAN filtering enabled; drop packets on VLANs
     * to which the port does not belong
     */
    uint32 efilteren;
} soc_sbx_g2p3_p2appdata_t;

    /**
     * SDK-only Port, VID Table.
     * This table contains per-port, per-VLAN state, SDK-only
     * state.  This state is used for SDK book keeping, and is
     * not used by the microcode.
     */
typedef struct soc_sbx_g2p3_pv2appdata_s {
    /** the port is a member of the VLAN */
    uint32 member;
} soc_sbx_g2p3_pv2appdata_t;

    /** ipv6shost entry contents. */
typedef struct soc_sbx_g2p3_ipv6shost_s {
    /** Point of entry (port, node) */
    uint32 poe;
    /**
     * Per src RPF check flags. Supported modes are
     * URPF_DISABLED (0x0)
     * URPF_STRICT   (0x1)
     * URPF_LOOSE    (0x2) 
     */
    uint32 rpfmode;
    /** Source drop flag */
    uint32 srcdrop;
    /** Source counter */
    uint32 srccnt;
} soc_sbx_g2p3_ipv6shost_t;

    /** ipv6shostl1 entry contents. */
typedef struct soc_sbx_g2p3_ipv6shostl1_s {
    /**
     * occupancy bitmask for the associate EML L2 table;
     * there is a 1 bit for each populated bucket
     */
    uint32 usemap;
    /**
     * point to an L2 EML table; if usemap=0, there is no
     * L2 table
     */
    uint32 pointer;
    /**
     * hash function salt, combined with the EML table key
     * to compute a L2 EML table hash index
     */
    uint32 salt;
} soc_sbx_g2p3_ipv6shostl1_t;

    /** ipv6shostl2 entry contents. */
typedef struct soc_sbx_g2p3_ipv6shostl2_s {
    /** key */
    soc_sbx_g2p3_16_byte_t key;
    /**
     * forwarding table base index; the final forwarding table
     * index is ftidx + ((1<< ecmpmask-1) & ppe aggr hash)
     */
    uint32 ftidx;
    /**
     * equal cost multipath (ECMP) set size; if ecmpmask=0, then
     * the route is not an ECMP route
     */
    uint32 ecmpmask;
    /**
     * destination VID for the route; this field is compared
     * with the source VID to determine if an IP redirect
     * exception message should be generated
     */
    uint32 vid;
} soc_sbx_g2p3_ipv6shostl2_t;

    /**
     * Ingress Port, Outer VID, Inner VID Table.
     * This table contains ingress per-port, per-outer VLAN,
     * per-inner VLAN state.
     * <br><br><tt>pvv2e</tt> is overlayed on the
     * <tt>cuckoo</tt> EM32 hash table.
     * <br><br>If no entry is present, then the contents of the
     * <tt>pv2e</tt> are used.
     * <br><br>If the packet has no inner tag, <tt>0xfff</tt> is
     * used as the inner tag index.
     */
typedef struct soc_sbx_g2p3_pvv2e_s {
    /** lp table index; if lp=0, the port is used as lp table index */
    uint32 lpi;
    /** internal forwarding VLAN (virtual switching identifier) */
    uint32 vlan;
    /**
     * spanning tree state: stpstate_forward, stpstate_block or
     * stpstate_learn
     */
    uint32 stpstate;
    /**
     * prevents a (customer) tag from being added to a packet that
     * does not already have one.  This value is actually intended
     * to be a per-port property, but implementation expediency
     * forced it into the pvv2e table.  It should only be
     * set to 0 for provider bridging customer ports where
     * CTAG transparency is desired (i.e. the packet contains a
     * CTAG in the provider network only if it contained a CTAG
     * when it arrived at the customer port).  For all other cases
     * (customer ports in nontransparent services, provider ports,
     * and `normal' 802.1 bridging ports), it should be left at 1.
     */
    uint32 untagged_strip;
    /** Point to Point VPWS Pseudowire customer facing port */
    uint32 vpws;
    /**
     * new VLAN identifier for rewriting a customer tag if
     * replace=1
     */
    uint32 vid;
    /**
     * rewrite the VID of the customer tag that is forwarded into
     * the system when the port is operating in a provider bridging
     * customer role
     */
    uint32 replace;
    /**
     * if the port is configured to forward a customer tag into
     * the system, a customer tag will not be forwarded; if
     * the port is configured not to forward a customer tag into
     * the system, a customer tag will be forwarded.  In other
     * words, this bit reverses the per-port configured behavior
     * customer tag preservation behavior
     */
    uint32 keeporstrip;
} soc_sbx_g2p3_pvv2e_t;

    /** HIDE */
typedef struct soc_sbx_g2p3_pvv2epack_s {
    /** lp table index; if lp=0, the port is used as lp table index */
    uint32 lpi;
    /** internal forwarding VLAN (virtual switching identifier) */
    uint32 vlan;
    /**
     * spanning tree state: stpstate_forward, stpstate_block or
     * stpstate_learn
     */
    uint32 stpstate;
    /**
     * prevents a (customer) tag from being added to a packet that
     * does not already have one.  This value is actually intended
     * to be a per-port property, but implementation expediency
     * forced it into the pvv2e table.  It should only be
     * set to 0 for provider bridging customer ports where
     * CTAG transparency is desired (i.e. the packet contains a
     * CTAG in the provider network only if it contained a CTAG
     * when it arrived at the customer port).  For all other cases
     * (customer ports in nontransparent services, provider ports,
     * and `normal' 802.1 bridging ports), it should be left at 1.
     */
    uint32 untagged_strip;
    /** Point to Point VPWS Pseudowire customer facing port */
    uint32 vpws;
    /**
     * new VLAN identifier for rewriting a customer tag if
     * replace=1
     */
    uint32 vid;
    /**
     * rewrite the VID of the customer tag that is forwarded into
     * the system when the port is operating in a provider bridging
     * customer role
     */
    uint32 replace;
    /**
     * if the port is configured to forward a customer tag into
     * the system, a customer tag will not be forwarded; if
     * the port is configured not to forward a customer tag into
     * the system, a customer tag will be forwarded.  In other
     * words, this bit reverses the per-port configured behavior
     * customer tag preservation behavior
     */
    uint32 keeporstrip;
} soc_sbx_g2p3_pvv2epack_t;

    /** HIDE */
typedef struct soc_sbx_g2p3_isid2e_s {
    /** lp table index; if lp=0, the port is used as lp table index */
    uint32 lpi;
    /** internal forwarding VLAN (virtual switching identifier) */
    uint32 vlan;
    /**
     * spanning tree state: stpstate_forward, stpstate_block or
     * stpstate_learn
     */
    uint32 stpstate;
} soc_sbx_g2p3_isid2e_t;

    /**
     * Ingress OAM Port, VID, Direction Table.
     * This table contains per-port, per-VID, per-direction
     * (up/down) Ethernet OAM connectivity fault management (CFM)
     * receive state.
     * <br><br><tt>oampvd2e</tt> is overlayed on the
     * <tt>cuckoo</tt> EM32 hash table.
     * <br><br>If no entry is found in this table for a particular
     * service (identified by port & VID), that means CFM is
     * not enabled for the service.  Otherwise, this table contains
     * state that indicates:
     * <ul>
     *   <li>CFM end or midpoint is active for each
     *       maintenence level</li>
     * </ul>
     * TODO
     */
typedef struct soc_sbx_g2p3_oampvd2e_s {
    /** Index into Endpoint Table. */
    uint32 endpointPtr;
    /** Index into Fowarding Table. */
    uint32 ftIdx;
    /**
     * Received packets with matching MdLevel have endpoint pointed
     * to by endpointPtr.
     */
    uint32 mdLevelEp;
    /**
     * Received packets with matching MdLevel are forwarded using
     * ftIdx.
     */
    uint32 mdLevelFwd;
} soc_sbx_g2p3_oampvd2e_t;

    /**
     * This table contains OAM MEP peer index information.
     * Each entry maps from a local MEP entry and peer MepId
     * to an index into the EP table where the peer entry
     * resides.
     * <br><br><tt>oammaidmep2e</tt> is overlayed on the
     * <tt>cuckoo</tt> EM32 hash table.
     */
typedef struct soc_sbx_g2p3_oammaidmep2e_s {
    /** This is an index into the endpoint table for the peer MEP. */
    uint32 endpointPtr;
    /** Entry valid. */
    uint32 epValid;
} soc_sbx_g2p3_oammaidmep2e_t;

    /**
     * EM32 table.
     * This table contains an EM32 hash lookup structor
     * that contains <tt>pvv2e</tt>, <tt>oampv2e</tt>, and
     * <tt>oammaidmep2e.</tt>
     * <br><br>The elements of the various member tables
     * are differentiated by a 2-bit type code in the
     * lookup key.
     */
typedef struct soc_sbx_g2p3_cuckoo_s {
    /** pay */
    soc_sbx_g2p3_6_byte_t pay;
} soc_sbx_g2p3_cuckoo_t;

    /** left entry contents. */
typedef struct soc_sbx_g2p3_left_s {
    /** pay */
    soc_sbx_g2p3_6_byte_t pay;
    /** key */
    uint32 key;
} soc_sbx_g2p3_left_t;

    /** right entry contents. */
typedef struct soc_sbx_g2p3_right_s {
    /** pay */
    soc_sbx_g2p3_6_byte_t pay;
    /** key */
    uint32 key;
} soc_sbx_g2p3_right_t;

    /**
     * EM32 table.
     * This table contains an Label EM32 hash lookup structor.
     */
typedef struct soc_sbx_g2p3_outerlabelcuckoo_s {
    /** pay */
    soc_sbx_g2p3_6_byte_t pay;
} soc_sbx_g2p3_outerlabelcuckoo_t;

    /** outerlabelleft entry contents. */
typedef struct soc_sbx_g2p3_outerlabelleft_s {
    /** pay */
    soc_sbx_g2p3_6_byte_t pay;
    /** key */
    uint32 key;
} soc_sbx_g2p3_outerlabelleft_t;

    /** outerlabelright entry contents. */
typedef struct soc_sbx_g2p3_outerlabelright_s {
    /** pay */
    soc_sbx_g2p3_6_byte_t pay;
    /** key */
    uint32 key;
} soc_sbx_g2p3_outerlabelright_t;

    /**
     * EM32 table.
     * This table contains an Label EM32 hash lookup structor.
     */
typedef struct soc_sbx_g2p3_innerlabelcuckoo_s {
    /** pay */
    soc_sbx_g2p3_6_byte_t pay;
} soc_sbx_g2p3_innerlabelcuckoo_t;

    /** innerlabelleft entry contents. */
typedef struct soc_sbx_g2p3_innerlabelleft_s {
    /** pay */
    soc_sbx_g2p3_6_byte_t pay;
    /** key */
    uint32 key;
} soc_sbx_g2p3_innerlabelleft_t;

    /** innerlabelright entry contents. */
typedef struct soc_sbx_g2p3_innerlabelright_s {
    /** pay */
    soc_sbx_g2p3_6_byte_t pay;
    /** key */
    uint32 key;
} soc_sbx_g2p3_innerlabelright_t;

    /**
     * Ingress MPLS TP Label Table.
     * This table contains ingress per-MPLS label state.
     */
typedef struct soc_sbx_g2p3_label2e_s {
    /** internal forwarding VLAN (virtual switching identifier) */
    uint32 vlan;
    /**
     * the forwarding table index for LSR forwarding, 
     * lower 14bits of Ftidx
     */
    uint32 ftidx0;
    /**  label operational code */
    uint32 opcode;
    /** Logical Port Index */
    uint32 lpidx;
    /** cos value associated with label (LLSP) */
    uint32 cos;
    /** OAM loopback mode; 0: No loopback 1: OLB 2: FLB */
    uint32 loopback;
    /** Point to Point VPWS Pseudowire PE Port */
    uint32 vpws;
    /** the forwarding table index for LSR forwarding, rest 14bits are overlayed over vlan for LSR */
    uint32 ftidx1;
    /**
     * spanning tree state: stpstate_forward, stpstate_block or
     * stpstate_learn
     */
    uint32 stpstate;
    /** label is an LSR label for an E-LSP path; in this case, the ftidx used is l2e.ftidx + label.exp */
    uint32 elsp;
    /** pipe-model TTL processing applies; if pipe=1, the TTL from the inner label (for LSR forwarding), or the encapsulated IP header (for IP LER forwarding) is used,otherwise, the TTL from the outer MPLS label (even if it is not the switching label) is used */
    uint32 pipe;
} soc_sbx_g2p3_label2e_t;

    /** Ingress Tagged MPLS Route/Bridge Toggle */
typedef struct soc_sbx_g2p3_tagged_mpls_s {
    /** enable PPE parsing for Tagged MPLS  packets through MPLS Stream */
    uint32 valid;
} soc_sbx_g2p3_tagged_mpls_t;

    /**
     * Ingress VLAN Table.
     * This table contains ingress per-VLAN state.
     */
typedef struct soc_sbx_g2p3_v2e_s {
    /** enable snooping of PIM control messages on this VLAN */
    uint32 pim;
    /** enable snooping of IGMP control messages on this VLAN */
    uint32 igmp;
    /**
     * force flooding of all packets on this VLAN; this bit can
     * be used to permit very fast spanning tree topology
     * changes by eliminating flushing of MAC addresses
     * from the MAC table from the critical path of the response
     * to the topology change
     */
    uint32 forceflood;
    /**
     * drop packets with unknown SMAC addresses; this allows
     * a VLAN to only forward packets from explicitly provisioned
     * end stations
     */
    uint32 dropunksmac;
    /**
     * do not generate learning exceptions; this can be used
     * to make a VLAN operate as a circuit rather than a
     * traditional LAN.  Fully efficient circuit-style forwarding
     * requires 2 internal VLANs one for each direction, both
     * with learning disabled
     */
    uint32 dontlearn;
    /** virtual routing context identifier */
    uint32 vrf;
    /**
     * McMode indicates if the packet needs to be handled as V6Multicast 
     * Packet or Bridged Multicast packet.
     */
    uint32 v6mcmode;
    /**
     * McMode indicates if the packet needs to be handled as V4Multicast 
     * Packet or Bridged Multicast packet.
     */
    uint32 v4mcmode;
    /**
     * Static LAG HASH value, will be used for aggrHash from PPE 
     * when static LAG is selected for the trunk.
     */
    uint32 laghash;
    /**  indicates if IPV4 routing is enabled on this VSI. */
    uint32 v4route;
    /**  indicates if IPV6 routing is enabled on this VSI. */
    uint32 v6route;
} soc_sbx_g2p3_v2e_t;

    /**
     * Ingress VLAN Table.
     * This table contains VRRP VRID configuration per VLAN
     */
typedef struct soc_sbx_g2p3_v2e1_s {
    /** vrid0 */
    uint32 vrid0;
    /** vrid1 */
    uint32 vrid1;
    /** vrid2 */
    uint32 vrid2;
    /** vrid3 */
    uint32 vrid3;
} soc_sbx_g2p3_v2e1_t;

    /**
     * Ingress Logical Port Table.
     * This table, sometimes called the <i>logical port</i> table
     * contains the majority of ingress per-port state except
     * what is required to control packet parsing.  Packet
     * parsing per-port state is in the <tt>p2e</tt> table.
     * <br><br>There are various means to identify
     * a logical port:
     * <ul>
     *   <li>A physical port.  The first 0-max ports <tt>lp</tt>
     *       table entries are associated with physical ports.
     *       If the <tt>lpi</tt> computed by interface resolution
     *       logic is 0, the physical port <tt>lp</tt> table entry
     *       will be used.</li>
     *   <li>A VLAN circuit; this can be identified by
     *       <tt>(port, VID)</tt> or
     *       <tt>(port, outer VID, inner VID)</tt>.  Note that
     *       a VLAN circuit is an extremely nontraditional (and
     *       frequently unexpected or undesirable) use of Ethernet
     *       VLAN tags.  Specifically, two different VLAN circuits
     *       on the same port, <tt>(port, VID0)</tt> and
     *       <tt>(port, VID1)</tt> fully behave as if they are
     *       different ports.  For example, a packet
     *       that is flooded from <tt>(port, VID0)</tt> will
     *       go back out <i>the same port</i> on
     *       <tt>(port, VID1)</tt>.  If an SMAC is learned
     *       on <tt>(port, VID0)</tt> and then a packet
     *       arrives with that SMAC on <tt>(port, VID1),</tt>
     *       a learning exception will be generated.
     *       <br><br>If the <tt>lp.pid</tt>
     *       values are the same for the physical port
     *       <tt>port, (port, VID0)</tt> and
     *       <tt>(port, VID1)</tt>, then packets are be
     *       forwarded in a more traditional 802.1 style where
     *       a packet never 'hairpins' to the same port.</li>
     *   <li>An MPLS tunnel; every MPLS label has a unique
     *       <tt>lp</tt> table entry.</li>
     * </ul>
     * <br><br>The behavior associated with logical ports includes:
     * <ul>
     *   <li>counting</li>
     *   <li>policing</li>
     *   <li>QoS processing</li>
     *   <li>mirroring</li>
     * </ul>
     */
typedef struct soc_sbx_g2p3_lp_s {
    /**
     * L2 forwarding source port identifier (PID); the source PID
     * is used to perform MAC address station movement detection,
     * it is also used as the source PID (also called SID) in
     * the egress route header (ERH) when <tt>lp.usecolor=0</tt>
     */
    uint32 pid;
    /**
     * QoS packet marking translation profile index; used
     * as an input, with packet markings, to the QoS mapping
     * table lookup
     */
    uint32 qos;
    /** use the MPLS EXP packet marking for the QoS table lookup */
    uint32 useexp;
    /** use the IPv4 DSCP packet marking for the QoS table lookup */
    uint32 usedscp;
    /**
     * update the ERH fabric discard eligibility (DP) with the
     * result of polcing
     */
    uint32 updatefdp;
    /** mirror index; do not mirror if mirror=0 */
    uint32 mirror;
    /**
     * update the ERH remark discard eligibility (DP) with the
     * result of polcing
     */
    uint32 updaterdp;
    /** policer to apply; 0 means do not override policer selection */
    uint32 policer;
    /** used typed policing */
    uint32 typedpolice;
    /** use MEF class-of-service policing; mef must be 1 if mefcos=1 */
    uint32 mefcos;
    /** use MEF policing */
    uint32 mef;
    /** RX coherent counter index; used for OAM PM frame loss. */
    uint32 cocounter;
    /**
     * The Priority Class determines which service frames to
     * count as part of the OAM LM service.  Currently the
     * Priority class contains one packet-Priority value.
     */
    uint32 priclass;
    /**
     * When this flag is set (1) all packet-priorities are
     * considered to be in the Priority Class for this OAM
     * LM service.  The allpri flag over-rides thr priclass
     * field.
     */
    uint32 allpri;
    /**
     * Override the policer associated with exceptions with the
     * control policer associated with this lp context. These are
     * policerGroups of *WithControl type. The base policer is
     * used for control path to host and rest are for normal data path.
     * When using this feature, different exceptions are policed
     * using the same single control policer.
     */
    uint32 xtpolreplace;
    /** base counter for the packet; do not count if counter=0 */
    uint32 counter;
    /**
     * use traffic type counting; traffic types are
     * PTYPE_UNKNOWN_UNICAST, PTYPE_KNOWN_UNICAST, 
     * PTYPE_MULTICAST, and PTYPE_BROADCAST
     */
    uint32 typedcount;
    /**
     * egress route header (ERH) source port identifier (SID);
     * if usecolor=1, then the ERH SID is set to lp.color, otherwise
     * it is set to lp.pid.  This field is primarily intended to
     * support topologies where if a packet arrives on one logical
     * port, it should not
     * be flooded to some subset of other logical ports on the
     * VLAN.  For example, VPLS requires packets arriving from
     * the core of the network not be flooded back to the core
     * of the network.  In that case, every port in a particular
     * VPLS core (there can be overlapping, independent VPLS
     * networks at a single switch), will use the same lp.color
     * value and the same ete.pid
     */
    uint32 color;
    /** set erh.sid=lp.color if usecolor=1 */
    uint32 usecolor;
    /**
     * MPLS OAM endpoint record index; only used for MPLS
     * logical ports
     */
    uint32 oamepi;
} soc_sbx_g2p3_lp_t;

    /**
     * Ingress MPLS Label Table.
     * This table contains ingress per-MPLS label state.
     * <br><br>The most significant bits of the MPLS label
     * are used by the PPE to control whether a label is
     * the switching label, when <tt>s=0</tt>, and
     * the parsing of the encapsulated payload, IP or Ethernet,
     * when <tt>s=1</tt>.  The least significant bits are
     * used as an index into the <tt>l2e</tt> table
     * irrespective of the most significant bits.  In
     * other words any entry of the <tt>l2e</tt> table
     * can be associated with an LSR label, an IP LER label
     * or a PWE3 label, depending on the most significant bits
     * of the label distributed to the remote peer.
     */
typedef struct soc_sbx_g2p3_l2e_s {
    /** internal forwarding VLAN (virtual switching identifier) */
    uint32 vlan;
    /**
     * spanning tree state: stpstate_forward, stpstate_block or
     * stpstate_learn
     */
    uint32 stpstate;
    /**
     * label is an LSR label for an E-LSP path; in this case, 
     * the ftidx used is l2e.ftidx + label.exp
     */
    uint32 elsp;
    /**
     * pipe-model TTL processing applies; if pipe=1, the TTL
     * from the inner label (for LSR forwarding), or the
     * encapsulated IP header (for IP LER forwarding) is used,
     * otherwise, the TTL from the outer MPLS label (even if it
     * is not the switching label) is used
     */
    uint32 pipe;
    /** the forwarding table index for LSR forwarding */
    uint32 ftidx;
    /** enable MPLS OAM for this LSP */
    uint32 oamen;
    /** perform IP LER forwarding for this label */
    uint32 leren;
} soc_sbx_g2p3_l2e_t;

    /**
     * Ingress L2CP Table.
     * This table controls special processing for all ingress
     * Ethernet layer 2 control protocol (L2CP) packets except
     * L2CP slow protocol packets (<tt>xx:xx:xx:xx:xx:02</tt>).
     * <br><br>L2CP packets are identified by the PPE using
     * the address ranges in the <tt>l2cpmacs</tt> table.
     * <br><br>The <tt>l2cp</tt> table can be used to
     * implement various L2CP behaviors per protocol & port:
     * <ul>
     *   <li><b>drop:</b> set <tt>copy=0, forward=1,
     *       ftidx=</tt>drop FTE index.</li>
     *   <li><b>peer:</b> set <tt>copy=0, forward=1,
     *       ftidx=</tt>to-CPU ftidx</li>
     *   <li><b>transmit:</b> set <tt>copy=0, forward=1,
     *       ftidx=</tt>service flood FTE or unicast FTE, or
     *       set <tt>forward=0</tt> and the L2CP DMAC lookup will
     *       control forwarding.  An L2CP DMAC table entry with
     *       will forward <i>all</i> L2CP protocols 
     *       with <tt>l2cp[slow].forward=0</tt>.  L2CP DMAC
     *       table entries can be used
     *       on a provider port to terminate an L2CP transit
     *       function, or on a customer to implement per-service
     *       L2CP forwarding (versus per-port L2CP forwarding
     *       provided by the <tt>l2cp</tt> and
     *       <tt>l2cpslow</tt> tables).</li>
     *   <li><b>snoop:</b> set <tt>copy=1</tt> and <tt>forward</tt>
     *       and <tt>ftidx</tt> as for transmit.</li>
     * </ul>
     * <br><br>The <tt>l2cp</tt> and <tt>l2cpslow</tt> tables have
     * exactly the same contents.
     */
typedef struct soc_sbx_g2p3_l2cp_s {
    /** forwarding table index; on used if forward=1 */
    uint32 ftidx;
    /** forward to ftidx */
    uint32 forward;
    /**
     * do not generate an STP drop exception, even if STP state
     * is not FORWARD; for example, BPDUs should not be dropped
     * no matter what the STP state
     */
    uint32 passstp;
    /**
     * generate a copy of the L2CP packet; this is used to
     * implement various forms of L2CP snooping
     */
    uint32 copy;
} soc_sbx_g2p3_l2cp_t;

    /**
     * Ingress L2CP Slow Table.
     * This table controls special processing for ingress Ethernet
     * layer 2 control protocol (L2CP) slow protocol packets
     * (L2CP packets with DMAC <tt>xx:xx:xx:xx:xx:02</tt>).
     * <br><br>L2CP slow protocol packets are identified by
     * the PPE using the address ranges in the <tt>l2cpmacs</tt>
     * table.
     * <br><br>The <tt>l2cpslow</tt> table can be used to
     * implement various L2CP behaviors per protocol & port:
     * <ul>
     *   <li><b>drop:</b> set <tt>copy=0, forward=1,
     *       ftidx=</tt>drop FTE index.</li>
     *   <li><b>peer:</b> set <tt>copy=0, forward=1,
     *       ftidx=</tt>to-CPU ftidx</li>
     *   <li><b>transmit:</b> set <tt>copy=0, forward=1,
     *       ftidx=</tt>service flood FTE or unicast FTE, or
     *       set <tt>forward=0</tt> and the L2CP DMAC lookup will
     *       control forwarding.  An L2CP DMAC table entry with
     *       will forward <i>all</i> L2CP protocols 
     *       with <tt>l2cp[slow].forward=0</tt>.  L2CP DMAC
     *       table entries can be used
     *       on a provider port to terminate an L2CP transit
     *       function, or on a customer to implement per-service
     *       L2CP forwarding (versus per-port L2CP forwarding
     *       provided by the <tt>l2cp</tt> and
     *       <tt>l2cpslow</tt> tables).</li>
     *   <li><b>snoop:</b> set <tt>copy=1</tt> and <tt>forward</tt>
     *       and <tt>ftidx</tt> as for transmit.</li>
     * </ul>
     * <br><br>The <tt>l2cpslow</tt> and <tt>l2cp</tt> tables have
     * exactly the same contents.
     */
typedef struct soc_sbx_g2p3_l2cpslow_s {
    /** forwarding table index; on used if forward=1 */
    uint32 ftidx;
    /** forward to ftidx */
    uint32 forward;
    /**
     * do not generate an STP drop exception, even if STP state
     * is not FORWARD; for example, BPDUs should not be dropped
     * no matter what the STP state
     */
    uint32 passstp;
    /**
     * generate a copy of the L2CP packet; this is used to
     * implement various forms of L2CP snooping
     */
    uint32 copy;
} soc_sbx_g2p3_l2cpslow_t;

    /**
     * Ingress L2CP NOP Table.
     * This table contains a single <tt>l2cp[slow]</tt> table
     * element configured to be inactive (<tt>forward=0, copy=0,
     * passstp=0)</tt>.  This element is used as an internal
     * microcode implementation trick to reduce instruction count.
     * This element is used when a packet is not an L2CP packet.
     */
typedef struct soc_sbx_g2p3_l2cpnop_s {
    /** forwarding table index; on used if forward=1 */
    uint32 ftidx;
    /** forward to ftidx */
    uint32 forward;
    /**
     * do not generate an STP drop exception, even if STP state
     * is not FORWARD; for example, BPDUs should not be dropped
     * no matter what the STP state
     */
    uint32 passstp;
    /**
     * generate a copy of the L2CP packet; this is used to
     * implement various forms of L2CP snooping
     */
    uint32 copy;
} soc_sbx_g2p3_l2cpnop_t;

    /**
     * Ingress Forwarding Table.
     * This table controls destination-specific ingress forwarding
     * behavior.
     * <br><br>The forwarding table contains a fast reroute
     * index, a set of fields that are independent of rerouting
     * and two sets of destination specifier information, one
     * for the primary path, and one for the backup path.
     */
typedef struct soc_sbx_g2p3_ft_s {
    /** fast reroute index */
    uint32 rridx;
    /**
     * exception index; if excidx=0 the packet is forwarded
     * normally
     */
    uint32 excidx;
    /**
     * fabric packet length adjustment index; this field is used
     * by the fabric to adjust traffic scheduling operations
     * for packet encapsulation and overhead that is
     * not on the packet within the fabric, but will be added
     * when the packet is sent
     */
    uint32 lenadj;
    /**
     * egress route header multicast bit; setting this bit will
     * cause the fabric to treat this packet as multicast
     */
    uint32 mc;
    /**
     * egress route header test bit; setting this bit will cause
     * information about the packet to be captured at various
     * points within the system
     */
    uint32 t;
    /**
     * header capture; setting this bit will cause the
     * header processing header record to be captured in the PED
     */
    uint32 hc;
    /**
     * primary path output output editing index (also called
     * out header index or OI); if oi=0, the VLAN is put in
     * the erh.oi field to support traditional bridging forwarding;
     * if the destination fabric queue is a multicast queue,
     * this field contains the fabric multicast group identifier
     */
    uint32 oi;
    /**
     * primary path base fabric queue identifier; the final
     * queue identifier is computed by adding the fabric QoS
     * to this value.  This field is a union with lagbase and
     * lagsize and is only used if lag=0
     */
    uint32 qid;
    /**
     * the primary path link aggregation group (LAG) base index;
     * the final LAG table index is computed by adding the PPE
     * LAG hash for the packet masked by (1<<lagsize)-1. 
     * This field is a union with qid and is only used if lag=1
     */
    uint32 lagbase;
    /**
     * the primary path link aggregation group size; the LAG
     * contains (1 << lagsize) elements.  This field is a union
     * with qid and is only used if lag=1
     */
    uint32 lagsize;
    /**
     * the primary path link aggregation group flag; controls
     * whether qid or lagbase/lagsize is used for the packet
     * destination
     */
    uint32 lag;
    /**
     * backup path output output editing index (also called
     * out header index or OI); if oib=0, the VLAN is put in
     * the erh.oi field to support traditional bridging forwarding;
     * if the destination fabric queue is a multicast queue,
     * this field contains the fabric multicast group identifier
     */
    uint32 oib;
    /**
     * backup path base fabric queue identifier; the final
     * queue identifier is computed by adding the fabric QoS
     * to this value.  This field is a union with lagbaseb and
     * lagsizeb and is only used if lagb=0
     */
    uint32 qidb;
    /**
     * the backup path link aggregation group (LAG) base index;
     * the final LAG table index is computed by adding the PPE
     * LAG hash for the packet masked by (1<<lagsizeb)-1. 
     * This field is a union with qid and is only used if lagb=1
     */
    uint32 lagbaseb;
    /**
     * the backup path link aggregation group size; the LAG
     * contains (1 << lagsizeb) elements.  This field is a union
     * with qid and is only used if lagb=1
     */
    uint32 lagsizeb;
    /**
     * the backup path link aggregation group flag; controls
     * whether qidb or lagbaseb/lagsizeb is used for the packet
     * destination
     */
    uint32 lagb;
} soc_sbx_g2p3_ft_t;

    /** HIDE */
typedef struct soc_sbx_g2p3_oamtimercalendar_s {
    /** Pointer to OAM Endpoint Record. */
    uint32 endpointPtr;
    /**
     * The interval (or period) enumeration.  invalid/un-used
     * entries have a value of zero.
     */
    uint32 xmitPeriod;
    /**
     * Current timer value, expressed in list-manager iterations.
     * Each iteration through the entire timer calendar table
     * decrements each entry's xmitCount by one.  When this field
     * reaches zero, a packet will be generated and transmitted,
     * and the xmitCount is reset again to the value represented
     * by the xmitPeriod enumeration.
     */
    uint32 xmitCount;
} soc_sbx_g2p3_oamtimercalendar_t;

    /** HIDE */
typedef struct soc_sbx_g2p3_oamportmdlevel2etc_s {
    /** Indicated the Maintenance Endpoint Pointer(MEP) is valid. */
    uint32 valid;
    /** Recirculate (forward) the packet. */
    uint32 fwd;
    /** Pointer to OAM Endpoint Record. */
    uint32 epIdx;
} soc_sbx_g2p3_oamportmdlevel2etc_t;

    /** Ingress V4uc Stream Select Table. */
typedef struct soc_sbx_g2p3_v4uc_str_sel_s {
    /** enable PPE parsing for sending IPv4 Unicast packets to V4UC Stream */
    uint32 valid;
} soc_sbx_g2p3_v4uc_str_sel_t;

    /** cmac entry contents. */
typedef struct soc_sbx_g2p3_cmac_s {
    /**
     * source MAC entry hit timestamp; each time
     * a packet with this SMAC is received, the age
     * field is written with the current age stamp to 
     * allow aging scans of the MAC table to identify
     * and remove old entries
     */
    uint32 age;
    /**
     * forwarding port identifier (PID); the PID is used
     * as the forwarding table index for DMAC lookups, and
     * as the expected source PID for SMAC station movement
     * detection
     */
    uint32 pid;
    /** copy this packet if dcopy=1 on a DMAC lookup */
    uint32 dcopy;
    /**
     * fabric and remark CoS to use for the packet copy
     * when dcopy=1
     */
    uint32 dcopycos;
    /** drop this packet if ddrop=1 on a DMAC lookup */
    uint32 ddrop;
    /** drop this packet if sdrop=1 on a SMAC lookup */
    uint32 sdrop;
    /**
     * do not remove this packet from the MAC table even
     * if it is old; this bit is not used by the microcode,
     * but is used by the SDK to implement its age scanning
     */
    uint32 dontage;
} soc_sbx_g2p3_cmac_t;

    /** bmac entry contents. */
typedef struct soc_sbx_g2p3_bmac_s {
    /** drop this packet if sdrop=1 on a B-SMAC lookup */
    uint32 bsdrop;
    /**
     * forwarding port identifier (PID); the PID is used
     * as the expected source PID for B-SMAC station movement
     * detection
     */
    uint32 bpid;
    /**
     * B-SMAC tunnel identifier (TID); the TID is used
     * as the expected source TID for inner SMAC station movement
     * detection
     */
    uint32 btid;
} soc_sbx_g2p3_bmac_t;

    /** ipv6mcsg entry contents. */
typedef struct soc_sbx_g2p3_ipv6mcsg_s {
    /** Forwarding Table Index Entry - Part of (*,g) Payload */
    uint32 ftidx;
    /** RPF Union Entry - Part of (*,g) Payload */
    uint32 rpfunion;
    /**
     * Field Set indicates pkt to be copied to proc - 
     * Part of (*,g) Payload
     */
    uint32 proccopy;
} soc_sbx_g2p3_ipv6mcsg_t;

    /** ipv6mcsgl1 entry contents. */
typedef struct soc_sbx_g2p3_ipv6mcsgl1_s {
    /**
     * occupancy bitmask for the associate EML L2 table;
     * there is a 1 bit for each populated bucket
     */
    uint32 usemap;
    /**
     * point to an L2 EML table; if usemap=0, there is no
     * L2 table
     */
    uint32 pointer;
    /**
     * hash function salt, combined with the EML table key
     * to compute a L2 EML table hash index
     */
    uint32 salt;
} soc_sbx_g2p3_ipv6mcsgl1_t;

    /** ipv6mcsgl2 entry contents. */
typedef struct soc_sbx_g2p3_ipv6mcsgl2_s {
    /** g */
    soc_sbx_g2p3_15_byte_t g;
    /** s */
    soc_sbx_g2p3_16_byte_t s;
    /** vlan */
    uint32 vlan;
    /**
     * Field Set indicates pkt to be copied to proc - 
     * Part of (*,g) Payload
     */
    uint32 proccopy;
    /** Forwarding Table Index Entry - Part of (*,g) Payload */
    uint32 ftidx;
    /** RPF Union Entry - Part of (*,g) Payload */
    uint32 rpfunion;
} soc_sbx_g2p3_ipv6mcsgl2_t;

    /** ipv6mcg entry contents. */
typedef struct soc_sbx_g2p3_ipv6mcg_s {
    /** Forwarding Table Index Entry - Part of (*,g) Payload */
    uint32 ftidx;
    /** RPF Union Entry - Part of (*,g) Payload */
    uint32 rpfunion;
    /**
     * Field set indicates pkt to be copied to proc - 
     * Part of (*,g) Payload
     */
    uint32 proccopy;
} soc_sbx_g2p3_ipv6mcg_t;

    /** ipv6mcgl1 entry contents. */
typedef struct soc_sbx_g2p3_ipv6mcgl1_s {
    /**
     * occupancy bitmask for the associate EML L2 table;
     * there is a 1 bit for each populated bucket
     */
    uint32 usemap;
    /**
     * point to an L2 EML table; if usemap=0, there is no
     * L2 table
     */
    uint32 pointer;
    /**
     * hash function salt, combined with the EML table key
     * to compute a L2 EML table hash index
     */
    uint32 salt;
} soc_sbx_g2p3_ipv6mcgl1_t;

    /** ipv6mcgl2 entry contents. */
typedef struct soc_sbx_g2p3_ipv6mcgl2_s {
    /** g */
    soc_sbx_g2p3_15_byte_t g;
    /** Forwarding Table Index Entry - Part of (*,g) Payload */
    uint32 ftidx;
    /** RPF Union Entry - Part of (*,g) Payload */
    uint32 rpfunion;
    /** vlan */
    uint32 vlan;
    /**
     * Field set indicates pkt to be copied to proc - 
     * Part of (*,g) Payload
     */
    uint32 proccopy;
} soc_sbx_g2p3_ipv6mcgl2_t;

    /** ipv4mcg entry contents. */
typedef struct soc_sbx_g2p3_ipv4mcg_s {
    /** Forwarding Table Index Entry - Part of (*,g) Payload */
    uint32 ftidx;
    /** RPF Union Entry - Part of (*,g) Payload */
    uint32 rpfunion;
    /**
     * Field Set indicates pkt to be copied to proc - 
     * Part of (*,g) Payload
     */
    uint32 proccopy;
} soc_sbx_g2p3_ipv4mcg_t;

    /** ipv4mcgl1 entry contents. */
typedef struct soc_sbx_g2p3_ipv4mcgl1_s {
    /**
     * occupancy bitmask for the associate EML L2 table;
     * there is a 1 bit for each populated bucket
     */
    uint32 usemap;
    /**
     * point to an L2 EML table; if usemap=0, there is no
     * L2 table
     */
    uint32 pointer;
    /**
     * hash function salt, combined with the EML table key
     * to compute a L2 EML table hash index
     */
    uint32 salt;
} soc_sbx_g2p3_ipv4mcgl1_t;

    /** ipv4mcgl2 entry contents. */
typedef struct soc_sbx_g2p3_ipv4mcgl2_s {
    /** g */
    uint32 g;
    /** Forwarding Table Index Entry - Part of (*,g) Payload */
    uint32 ftidx;
    /** RPF Union Entry - Part of (*,g) Payload */
    uint32 rpfunion;
    /** vlan */
    uint32 vlan;
    /**
     * Field Set indicates pkt to be copied to proc - 
     * Part of (*,g) Payload
     */
    uint32 proccopy;
} soc_sbx_g2p3_ipv4mcgl2_t;

    /** ipv4mcsg entry contents. */
typedef struct soc_sbx_g2p3_ipv4mcsg_s {
    /** Forwarding Table Index Entry - Part of (*,g) Payload */
    uint32 ftidx;
    /** RPF Union Entry - Part of (*,g) Payload */
    uint32 rpfunion;
    /**
     * Field Set indicates pkt to be copied to proc - 
     * Part of (*,g) Payload
     */
    uint32 proccopy;
} soc_sbx_g2p3_ipv4mcsg_t;

    /** ipv4mcsgl1 entry contents. */
typedef struct soc_sbx_g2p3_ipv4mcsgl1_s {
    /**
     * occupancy bitmask for the associate EML L2 table;
     * there is a 1 bit for each populated bucket
     */
    uint32 usemap;
    /**
     * point to an L2 EML table; if usemap=0, there is no
     * L2 table
     */
    uint32 pointer;
    /**
     * hash function salt, combined with the EML table key
     * to compute a L2 EML table hash index
     */
    uint32 salt;
} soc_sbx_g2p3_ipv4mcsgl1_t;

    /** ipv4mcsgl2 entry contents. */
typedef struct soc_sbx_g2p3_ipv4mcsgl2_s {
    /** g */
    uint32 g;
    /** s */
    uint32 s;
    /** Forwarding Table Index Entry - Part of (*,g) Payload */
    uint32 ftidx;
    /** RPF Union Entry - Part of (*,g) Payload */
    uint32 rpfunion;
    /** vlan */
    uint32 vlan;
    /**
     * Field Set indicates pkt to be copied to proc - 
     * Part of (*,g) Payload
     */
    uint32 proccopy;
} soc_sbx_g2p3_ipv4mcsgl2_t;

    /** HIDE */
typedef struct soc_sbx_g2p3_lpmnode_s {
    /**
     * the prefix pattern to compare if singleton=1; this
     * pattern is prefix encoded: the least
     * significant 1 bit indicates the pattern length, and
     * all more significant bits are the pattern value
     */
    uint32 pattern;
    /**
     * the following node is a singleton; instead of an array of
     * 1 << slice size bits, the node is an array of 2 with
     * one element if the singleton pattern does not match,
     * and the other element if the singleton pattern does match
     */
    uint32 singleton;
    /**
     * points to the following node if leaf=0, or the payload
     * if leaf=1
     */
    uint32 pointer;
    /** signals that pointer points to the final payload */
    uint32 leaf;
} soc_sbx_g2p3_lpmnode_t;

    /**
     * Ingress IPv4 SA LPM Table.
     * This table is used to implement unicast <i>reverse
     * path forwarding</i> (uRPF) checks for IPv4 packets
     * directed to the local station MAC address.
     * The table supports both strict and loose uRPF
     * checking, selected on a per-prefix basis.
     * <br><br>This table is composed of 5 slice trie structure
     * with a singleton optimization for the bottom 3
     * slices.  The slices, starting from bit 0, are
     * 16 bits, 10 bits, 6 bits, 5 bits and 7 bits.  The
     * key is the concatenation of a 12-bit virtual
     * routing function identifer (vrf) and a 32-bit
     * IPv4 address.
     * <br><br>Storage for the first slice is statically
     * allocate and subsequent slices are dynamically
     * allocated from two banks of storage.  Payload
     * is also allocated from one of the two banks of
     * storage.  Payloads of equal value are shared
     * by all prefixes, forming a direct-acyclic graph
     * with sharing only on the final node.
     */
typedef struct soc_sbx_g2p3_ipv4sa_s {
    /** Point of entry (port, node) */
    uint32 poe;
    /**
     * Per src RPF check flags. Supported modes are
     * URPF_DISABLED (0x0)
     * URPF_STRICT   (0x1)
     * URPF_LOOSE    (0x2) 
     */
    uint32 rpfmode;
    /** Source drop flag */
    uint32 srcdrop;
    /** Source counter */
    uint32 srccnt;
} soc_sbx_g2p3_ipv4sa_t;

    /** ipv4sal0 entry contents. */
typedef struct soc_sbx_g2p3_ipv4sal0_s {
    /**
     * the prefix pattern to compare if singleton=1; this
     * pattern is prefix encoded: the least
     * significant 1 bit indicates the pattern length, and
     * all more significant bits are the pattern value
     */
    uint32 pattern;
    /**
     * the following node is a singleton; instead of an array of
     * 1 << slice size bits, the node is an array of 2 with
     * one element if the singleton pattern does not match,
     * and the other element if the singleton pattern does match
     */
    uint32 singleton;
    /**
     * points to the following node if leaf=0, or the payload
     * if leaf=1
     */
    uint32 pointer;
    /** signals that pointer points to the final payload */
    uint32 leaf;
} soc_sbx_g2p3_ipv4sal0_t;

    /** ipv4saodd entry contents. */
typedef struct soc_sbx_g2p3_ipv4saodd_s {
    /**
     * the prefix pattern to compare if singleton=1; this
     * pattern is prefix encoded: the least
     * significant 1 bit indicates the pattern length, and
     * all more significant bits are the pattern value
     */
    uint32 pattern;
    /**
     * the following node is a singleton; instead of an array of
     * 1 << slice size bits, the node is an array of 2 with
     * one element if the singleton pattern does not match,
     * and the other element if the singleton pattern does match
     */
    uint32 singleton;
    /**
     * points to the following node if leaf=0, or the payload
     * if leaf=1
     */
    uint32 pointer;
    /** signals that pointer points to the final payload */
    uint32 leaf;
} soc_sbx_g2p3_ipv4saodd_t;

    /** ipv4saeven entry contents. */
typedef struct soc_sbx_g2p3_ipv4saeven_s {
    /**
     * the prefix pattern to compare if singleton=1; this
     * pattern is prefix encoded: the least
     * significant 1 bit indicates the pattern length, and
     * all more significant bits are the pattern value
     */
    uint32 pattern;
    /**
     * the following node is a singleton; instead of an array of
     * 1 << slice size bits, the node is an array of 2 with
     * one element if the singleton pattern does not match,
     * and the other element if the singleton pattern does match
     */
    uint32 singleton;
    /**
     * points to the following node if leaf=0, or the payload
     * if leaf=1
     */
    uint32 pointer;
    /** signals that pointer points to the final payload */
    uint32 leaf;
} soc_sbx_g2p3_ipv4saeven_t;

    /** ipv4sapayload entry contents. */
typedef struct soc_sbx_g2p3_ipv4sapayload_s {
    /** Point of entry (port, node) */
    uint32 poe;
    /**
     * Per src RPF check flags. Supported modes are
     * URPF_DISABLED (0x0)
     * URPF_STRICT   (0x1)
     * URPF_LOOSE    (0x2) 
     */
    uint32 rpfmode;
    /** Source drop flag */
    uint32 srcdrop;
    /** Source counter */
    uint32 srccnt;
} soc_sbx_g2p3_ipv4sapayload_t;

    /**
     * Ingress Field Processor Table.
     * This table is the front-end used by the SDK to access the
     * ingress field processor (IFP) classification database.
     * The IFP function is implemented with a combination of
     * the FE rule classification engine (RCE) hardware (also
     * sometimes called <i>the classifier</i>), a rule action
     * table, and group of rule firing counters.  The IFP
     * management software operates on all the resources in
     * a coordinated manner based on updates to the <tt>ifp</tt>
     * table.
     * <br><br>The <tt>ifp</tt> table contains two groups of
     * fields:
     * <ul>
     *   <li><i>pattern fields:</i> indicate which packets
     *       match a rule.  There are several differen types of
     *       pattern fields, including <i>wildcard match,</i>
     *       composed of a <i>value</i> and an <i>any</i> flag, 
     *       <i>prefix match,</i> composed of a <i>value</i> and
     *       a <i>prefix length</i>, and <i>range,</i> composed
     *       of a <i>lower limit</i> and an <i>upper limit.</i></li>
     *   <li><i>action fields:</i> indicate actions to
     *       take when a rule is matched.</li>
     * </ul>
     * <br><br>Matching higher-layer protocol fields correctly
     * requires qualifying the match with additional fields that
     * ensure the packet is actually of the expected format.  For
     * example, a rule that matches packets with the TCP urgent
     * flag set, must also match <tt>etype=0x0800, fragment=0,
     * proto=0x06</tt>.
     * <br><br>IFP entries are matched in the order in which
     * they occur in the IFP database.  For example, if a
     * wildcard entry is added as entry 0, then no other
     * entries will ever be matched.
     * <br><br>The microcode relies on the ifp database
     * containing a final, wild-card <i>sentinel</i> entry to
     * always match if no user-specified rules match.  This
     * sentinel entry is automatically added by the IFP 
     * management software.
     */
typedef struct soc_sbx_g2p3_ifp_s {
    /** Database Type */
    uint32 dbtype;
    /** use dbtype in match */
    uint32 usedbtype;
    /** ingress port */
    uint32 port;
    /** use ingress port in match */
    uint32 useport;
    /** ingress port bit map, active low */
    soc_sbx_g2p3_7_byte_t pbmpn;
    /** Ethernet priority bits */
    uint32 pri;
    /** use Ethernet priority bits in match */
    uint32 usepri;
    /**
     * IP fragment flag; set if ip.fragoff != 0 (i.e. the packet
     * is a subsequent fragment, it is not set if the packet is
     * an initial fragment)
     */
    uint32 fragment;
    /** use IP fragment flag in match */
    uint32 usefragment;
    /** TCP urgent flag */
    uint32 urg;
    /** use IP fragment flag in match */
    uint32 useurg;
    /** TCP acknowledge flag */
    uint32 ack;
    /** use TCP acknowledge flag in match */
    uint32 useack;
    /** TCP push flag */
    uint32 psh;
    /** use TCP push flag in match */
    uint32 usepsh;
    /** TCP reset flag */
    uint32 rst;
    /** use TCP reset flag in match */
    uint32 userst;
    /** TCP synchronize flag */
    uint32 syn;
    /** use TCP synchronize flag in match */
    uint32 usesyn;
    /** TCP finish flag */
    uint32 fin;
    /** use TCP finish flag in match */
    uint32 usefin;
    /**
     * DiffServ code point; dscp+ecn can be used to match the
     * complete IP TOS byte
     */
    uint32 dscp;
    /** use DiffServ code point in match */
    uint32 usedscp;
    /**
     * explicit congestion notification flags; dscp+ecn can be
     * used to match the complete IP TOS byte
     */
    uint32 ecn;
    /** use explicit congestion notification flags in match */
    uint32 useecn;
    /** IP protocol */
    uint32 proto;
    /** use IP protocol in match */
    uint32 useproto;
    /**
     * TCP/UDP source port upper bound; also matches
     * LLC SSAP & DSAP (or bytes 0 & 1 of any data
     * beyond what the PPE parses)
     */
    uint32 sporthi;
    /** TCP/UDP source port lower bound */
    uint32 sportlo;
    /** TCP/UDP destination port upper bound */
    uint32 dporthi;
    /** TCP/UDP destination port lower bound */
    uint32 dportlo;
    /** IP source address */
    uint32 sa;
    /** IP source address prefix length; 0 means wildcard */
    uint32 sawidth;
    /** IP destination address */
    uint32 da;
    /** IP destination address prefix length; 0 means wildcard */
    uint32 dawidth;
    /** Ethertype; etype=0 means match LLC packet (but not SNAP) */
    uint32 etype;
    /** use Ethertype in match */
    uint32 useetype;
    /** source MAC address */
    soc_sbx_g2p3_6_byte_t smac;
    /** source MAC address prefix length; 0 means wildcard */
    uint32 smacwidth;
    /** destination MAC address */
    soc_sbx_g2p3_6_byte_t dmac;
    /** destination MAC address prefix length; 0 means wildcard */
    uint32 dmacwidth;
    /** (outer) VLAN identifier */
    uint32 vid;
    /** use VLAN identifier in match */
    uint32 usevid;
    /** LLC source service access point upper bound */
    uint32 ssaphi;
    /** LLC source service access point lower bound */
    uint32 ssaplo;
    /** use LLC source service access point in match */
    uint32 usessap;
    /** LLC destination service access point upper bound */
    uint32 dsaphi;
    /** LLC destination service access point lower bound */
    uint32 dsaplo;
    /** use LLC destination service access point in match */
    uint32 usedsap;
    /** LLC control byte upper bound */
    uint32 llcctrlhi;
    /** LLC control byte lower bound */
    uint32 llcctrllo;
    /** use LLC control byte in match */
    uint32 usellcctrl;
    /** enable this rule to match */
    uint32 enable;
    /** new VLAN to assign.  This field is a union with ftidx */
    uint32 vlan;
    /** FT to which to forwarding.  This field is a union with vlan */
    uint32 ftidx;
    /**
     * mirror table index for mirroring;  mirror=0 means
     * do not mirror
     */
    uint32 mirror;
    /**
     * forward the packet on VLAN vlan; it is illegal to set
     * usevlan if useftidx is set
     */
    uint32 usevlan;
    /**
     * forward the packet through forwarding table entry ftidx;
     * it is illegal to set useftidx if usevlan is set
     */
    uint32 useftidx;
    /**
     * generate an RT copy exception (in addition to nominal
     * forwarding)
     */
    uint32 copy;
    /** initial discard eligibility; 0: green, 1: yellow, 2: red */
    uint32 dp;
    /** remark class-of-service */
    uint32 cos;
    /** fabric class-of-service */
    uint32 fcos;
    /** update the color with dp */
    uint32 usedp;
    /** update remark cos with cos and the fabric cos with fcos */
    uint32 usecos;
    /** policer to apply; 0 means do not override policer selection */
    uint32 policer;
    /** used typed policing */
    uint32 typedpolice;
    /** use MEF class-of-service policing; mef must be 1 if mefcos=1 */
    uint32 mefcos;
    /** use MEF policing */
    uint32 mef;
} soc_sbx_g2p3_ifp_t;

    /** Ingress Field Processor Table for Ipv6. */
typedef struct soc_sbx_g2p3_ifp_v6_s {
    /** dbtype for the classification */
    uint32 dbtype;
    /** use dbtype in match */
    uint32 usedbtype;
    /** ingress port */
    uint32 port;
    /** use ingress port in match */
    uint32 useport;
    /** ingress port bit map, active low */
    soc_sbx_g2p3_7_byte_t pbmpn;
    /** TCP urgent flag */
    uint32 urg;
    /** use urgent flag in match */
    uint32 useurg;
    /** TCP acknowledge flag */
    uint32 ack;
    /** use TCP acknowledge flag in match */
    uint32 useack;
    /** TCP push flag */
    uint32 psh;
    /** use TCP push flag in match */
    uint32 usepsh;
    /** TCP reset flag */
    uint32 rst;
    /** use TCP reset flag in match */
    uint32 userst;
    /** TCP synchronize flag */
    uint32 syn;
    /** use TCP synchronize flag in match */
    uint32 usesyn;
    /** TCP finish flag */
    uint32 fin;
    /** use TCP finish flag in match */
    uint32 usefin;
    /**
     * DiffServ code point; dscp+ecn can be used to match the
     * complete IP TOS byte
     */
    uint32 TC;
    /** use DiffServ code point in match */
    uint32 useTC;
    /** IPv6 NextHeader upper bound */
    uint32 nextheaderhi;
    /** IPv6 NextHeader lower bound */
    uint32 nextheaderlo;
    /** TCP/UDP source port upper bound */
    uint32 sporthi;
    /** TCP/UDP source port lower bound */
    uint32 sportlo;
    /** TCP/UDP destination port upper bound */
    uint32 dporthi;
    /** TCP/UDP destination port lower bound */
    uint32 dportlo;
    /** IP source address */
    soc_sbx_g2p3_16_byte_t sa;
    /** IP source address prefix length; 0 means wildcard */
    uint32 sawidth;
    /** IP destination address */
    soc_sbx_g2p3_16_byte_t da;
    /** IP destination address prefix length; 0 means wildcard */
    uint32 dawidth;
    /** (outer) VLAN identifier */
    uint32 vid;
    /** use VLAN identifier in match */
    uint32 usevid;
    /** enable this rule to match */
    uint32 enable;
    /** new VLAN to assign.  This field is a union with ftidx */
    uint32 vlan;
    /** FT to which to forwarding.  This field is a union with vlan */
    uint32 ftidx;
    /**
     * mirror table index for mirroring;  mirror=0 means
     * do not mirror
     */
    uint32 mirror;
    /**
     * forward the packet on VLAN vlan; it is illegal to set
     * usevlan if useftidx is set
     */
    uint32 usevlan;
    /**
     * forward the packet through forwarding table entry ftidx;
     * it is illegal to set useftidx if usevlan is set
     */
    uint32 useftidx;
    /**
     * generate an RT copy exception (in addition to nominal
     * forwarding)
     */
    uint32 copy;
    /** initial discard eligibility; 0: green, 1: yellow, 2: red */
    uint32 dp;
    /** remark class-of-service */
    uint32 cos;
    /** fabric class-of-service */
    uint32 fcos;
    /** update the color with dp */
    uint32 usedp;
    /** update remark cos with cos and the fabric cos with fcos */
    uint32 usecos;
    /** policer to apply; 0 means do not override policer selection */
    uint32 policer;
    /** used typed policing */
    uint32 typedpolice;
    /** use MEF class-of-service policing; mef must be 1 if mefcos=1 */
    uint32 mefcos;
    /** use MEF policing */
    uint32 mef;
} soc_sbx_g2p3_ifp_v6_t;

    /**
     * Egress Port, TB VLAN Table.
     * This table is used to implement egress <i>traditional
     * bridging
     * model (TB)</i> forwarding.  It is indexed by
     * internal VLAN identifiers in the range 0-4K-1, and physical
     * output port and returns an ETE pointer, output counter
     * identifier, and egress mirror index.  The internal VLAN
     * identifier comes from the egress route header (ERH)
     * out header index field.  The <tt>evp2e</tt> table is used
     * when:
     * <ul>
     *   <li><tt><b>erh.oi < 4K:</b></tt> traditional bridging
     *       forwarding on VLAN <tt>erh.oi</tt>.</li>
     *   <li><tt><b>4K <= erh.oi < 8K:</b></tt> traditional
     *       bridging-optimized IP multicast forwarding
     *       on VLAN <tt>erh.oi - 4K</tt></li>
     * </ul>
     * <br><br>Because this table is a full matrix of port and
     * VLAN, it is very efficient to implement all possible output
     * behaviors within the TB VLAN range.  It is possible to
     * share ETEs across ports and VLANs to provide very modest
     * ETE consumption for a range of behaviors including
     * untagged, traditional 802.1 single tagged, provider
     * bridging customer and provider ports, and TR-101-style
     * VLAN cross-connections.
     * <br><br>The alternative forwarding model, <i>logical
     * interface (LI),</i> forwarding is typically only necessary
     * for entering tunnels (e.g. MPLS PWE3) and for L3
     * routing (IP and MPLS LSR).
     * <br><br>Traditional bridging-optimized IP multicast
     * exploits similar efficiency to TB forwarding
     * (using the same ETEs as TB forwarding) for Ethernet
     * & VLAN tag encapsulated IP multicast routing.  The main
     * functional difference between TB forwarding and TBIPMC
     * forwarding is TBIPMC decrements the IP TTL and rewrites
     * the SMAC.
     */
typedef struct soc_sbx_g2p3_evp2e_s {
    /** egress table entry (ETE) pointer */
    uint32 eteptr;
    /** egress counter; counter=0 means do not count */
    uint32 counter;
    /**
     * coherent counter index, used to count transmitted frames
     * for OAM PM.
     */
    uint32 cocounter;
    /**
     * The Priority Class determines which service frames to
     * count as part of the OAM LM service.  Currently the
     * Priority class contains one packet-Priority value.
     */
    uint32 priclass;
    /**
     * When this flag is set (1) all packet-priorities are
     * considered to be in the Priority Class for this OAM
     * LM service.  The allpri flag over-rides thr priclass
     * field.
     */
    uint32 allpri;
} soc_sbx_g2p3_evp2e_t;

    /**
     * Egress OI Table.
     * This table is used to implement egress <i>logical interface
     * model (LI)</i> forwarding.  It is indexed by
     * the egress route header (ERH) output header index
     * minus 8K (<tt>erh.oi - 8K</tt>).  The <tt>oi2e</tt> table
     * is used when <tt>erh.oi >= 8K</tt>
     * <br><br>LI forwarding is typically used
     * for entering tunnels (e.g. MPLS PWE3) and for L3
     * routing (IP and MPLS LSR).
     */
typedef struct soc_sbx_g2p3_oi2e_s {
    /** egress table entry (ETE) pointer */
    uint32 eteptr;
    /** egress counter; counter=0 means do not count */
    uint32 counter;
    /**
     * coherent counter index, used to count transmitted frames
     * for OAM PM.
     */
    uint32 cocounter;
    /**
     * The Priority Class determines which service frames to
     * count as part of the OAM LM service.  Currently the
     * Priority class contains one packet-Priority value.
     */
    uint32 priclass;
    /**
     * When this flag is set (1) all packet-priorities are
     * considered to be in the Priority Class for this OAM
     * LM service.  The allpri flag over-rides thr priclass
     * field.
     */
    uint32 allpri;
} soc_sbx_g2p3_oi2e_t;

    /**
     * Encapsulation Egress Table Entry.
     * This entry is the encapsulation egress table entry (ETE).
     * The <tt>eteencap</tt> contains predominantly layer 3
     * editing fields, including MPLS tunneling encapsulation
     * and the next-hop DMAC address.
     * <br><br>One 112-bit portion of the <tt>eteencap</tt> is
     * the <i>encapsulation area</i> and contains a sequence
     * of bytes that can be used to add several different types
     * of encapsulation to egress packets:
     * <ul>
     *   <li>an Ethertype + 1 to 3 MPLS labels.</li>
     *   <li>a unique inner VLAN tag (including TPID) that is
     *       not delivered from
     *       ingress.  The most common two tag bridging cases such
     *       as 802.1 provider bridging, do not require this
     *       so an <tt>eteencap</tt> is not needed at all for 
     *       most bridging cases.  However, the TR-101-style
     *       of using a pair of tags as a single, combined service
     *       identifier may require generation of a unique
     *       pair of VLAN tags per service on output.</li>
     *   <li>a MAC-in-MAC (MiM) I-Tag; MiM is not currently
     *       supported, but will be added in a future release</li>
     * </ul>
     * While the encapsulation area can contained unstructured
     * bytes added to the packet between the MAC header
     * and the packet payload, the egress microcode
     * also understands the structure of the data for some cases
     * such as MPLS, where the EXP, S and TTL fields
     * must be manipulated as part of normal processing.
     * <br><br>One subtlety of the encapsulation area processing
     * is that it <i>overwrites</i> the existing Ethertype
     * field in the packet.  If <tt>eteencap.encaplen=0</tt>
     * the existing Ethertype is not touched.  If
     * <tt>eteencap=2</tt> the existing Ethertype is overwritten
     * (with <tt>eteencap.etype</tt>).
     * <br><br>The MPLS label stack ordering created by the
     * <tt>eteencap</tt> is:
     * <ul>
     *   <li><tt>label2</tt> only on a stack of 1 label
     *       (<tt>eteencap.encaplen=6</tt>),</li>
     *   <li><tt>label2</tt> on top, <tt>label1</tt> on the bottom
     *       on a stack of 2 labels
     *       (<tt>eteencap.encaplen=10</tt>),</li>
     *   <li><tt>label2</tt> only on a stack of 1 label,</li>
     *   <li><tt>label2</tt> on top, <tt>label1</tt> in the middle,
     *       <tt>label0</tt> on the bottom of a stack of 3 labels
     *       (<tt>eteencap.encaplen=14</tt>),</li>
     * </ul>
     */
typedef struct soc_sbx_g2p3_eteencap_s {
    /** pointer to associated etel2 */
    uint32 l2ete;
    /**
     * update the DMAC address; this bit is typically only
     * cleared for unusual bridging cases where an eteencap
     * is required such as VLAN circuits (need a unique
     * egress port identifier (PID)) or TR-101-style VLAN
     * cross-connection (need 2 unique VLAN tags)
     */
    uint32 dmacset;
    /**
     * update the DMAC least significant byte; this bit is
     * typically equal to dmacset except when implementing
     * legacy-style L2CP tunneling, where an IEEE L2CP DMAC
     * address is rewritten to some proprietary value
     * that prevents intermediate switches from processing
     * customer L2CP packets in any special way; the 802.1
     * definition of separate customer and provider L2CP DMAC
     * ranges for provider bridging has rendered this type of
     * L2CP tunneling obsolete
     */
    uint32 dmacsetlsb;
    /**
     * update the DSCP of the packet based on internal QoS
     * information
     */
    uint32 dscpremark;
    /** egress QoS remarking table selector */
    uint32 remark;
    /**
     * set the TTL of an MPLS label beneath the switching label
     * to erh.ttl-1; set mplsttldec=1 for uniform or short-pipe
     * model TTL processing when not pushing any new labels 
     * (an MPLS LSR label pop scenario) and set mplsttldec=0
     * for all other cases (including long-pipe model tunnels)
     */
    uint32 mplsttldec;
    /**
     * length of egress encapsulation, including updated
     * Ethertype
     */
    uint32 encaplen;
    /**
     * encapsulate the entire packet with new headers; if
     * encapmac=0, the existing Ethernet header (DMAC, SMAC
     * and Ethertype) is overwritten, otherwise, a new
     * Ethernet header is created; set encapmac=1 for 
     * PWE3 or MiM encapsulation
     */
    uint32 encapmac;
    /**
     * do not strip the VLAN tag, regardless of the setting
     * of epv2e.strip; this flag is typically never set
     */
    uint32 nostrip;
    /**
     * do not apply EFP classification; set this flag for
     * a raw ETE (e.g. for packets from the CPU)
     */
    uint32 noclass;
    /**
     * use the egress port identifier (PID) from this ETE for
     * split horizon checking; set etepid=1 for L2 tunnels
     * (PWE3 or MiM) or VLAN circuits; if etepid=0, the ep2e.pid
     * is used for split horizon checking
     */
    uint32 etepid;
    /**
     * enable the tunnel entering point. When enabled, a bottom
     * stack bits won't get filtered (ANDed) by ERH.s
     */
    uint32 tunnelenter;
    /** remark the EXP in MPLS label 0 */
    uint32 exp0remark;
    /** remark the EXP in MPLS label 1 */
    uint32 exp1remark;
    /** remark the EXP in MPLS label 2 */
    uint32 exp2remark;
    /**
     * set the TTL of MPLS label 0 to erh.ttl-1; set ttl0dec=1 for
     * uniform model TTL processing and set ttl0dec=0 for all
     * other cases
     */
    uint32 ttl0dec;
    /**
     * set the TTL of MPLS label 1 to erh.ttl-1; set ttl1dec=1 for
     * uniform model TTL processing and set ttl1dec=0 for all
     * other cases
     */
    uint32 ttl1dec;
    /**
     * set the TTL of MPLS label 2 to erh.ttl-1; set ttl2dec=1 for
     * uniform model TTL processing and set ttl2dec=0 for all
     * other cases
     */
    uint32 ttl2dec;
    /**
     * update the packet SMAC; set smacset=1 for routing
     * (where the packet must originate from the local system)
     */
    uint32 smacset;
    /**
     * disable split horizon checking; set nosplitcheck=1 for
     * routing (where the packet may return to the source port)
     */
    uint32 nosplitcheck;
    /**
     * enable TTL expiry checking; set ttlcheck=1 for IP
     * and MPLS LSR routing (but not MPLS PWE3 tunnel entry)
     */
    uint32 ttlcheck;
    /**
     * set the IP TTL to erh.ttl-1; set iplttldec for most
     * IP routing cases; set ipttldec=0 for MPLS LER long pipe
     * model tunnels
     */
    uint32 ipttldec;
    /**
     * set 1 to add PW Control word. MPLS-TP always processes PW
     * packets only with Control word.
     */
    uint32 add_pwcw;
    /** DMAC byte 5 */
    uint32 dmac5;
    /** DMAC byte 4 */
    uint32 dmac4;
    /** DMAC byte 3 */
    uint32 dmac3;
    /** DMAC byte 2 */
    uint32 dmac2;
    /** DMAC byte 1 */
    uint32 dmac1;
    /** DMAC byte 0 */
    uint32 dmac0;
    /** Service that packet arrived on, used for OAM upMEP processing */
    uint32 vlan;
    /**
     * inner VLAN tag VLAN identifier; this field is part of the
     * encapsulation area
     */
    uint32 vid;
    /**
     * inner VLAN tag priority & CFI (PCP); this field is part
     * of the encapsulation area
     */
    uint32 pricfi;
    /**
     * inner VLAN tag TPID; this field is part
     * of the encapsulation area (overlays eteencap.etype)
     */
    uint32 tpid;
    /** encapsulating Ethertype for MIM */
    uint32 mimtype;
    /**
     * B-TAG VLAN identifier; this field is part of the
     * encapsulation area
     */
    uint32 btag_vid;
    /**
     * B-TAG priority & CFI (PCP); this field is part
     * of the encapsulation area
     */
    uint32 btag_pricfi;
    /**
     * B-TAG TPID; this field is part
     * of the encapsulation area (overlays eteencap.etype)
     */
    uint32 btag_tpid;
    /** label 2 TTL */
    uint32 ttl2;
    /** label 2 bottom-of-stack bit */
    uint32 s2;
    /** label 2 EXP field */
    uint32 exp2;
    /** label 2 label identifier */
    uint32 label2;
    /**
     * encapsulating Ethertype; this will overwrite the existing
     * packet Ethertype unless encapmac=1, in which case
     * it will be the Ethertype of the new, encapsulating
     * Ethernet header
     */
    uint32 etype;
    /**
     * output port identifier (PID); this is used for
     * split horizon drop checking when etepid=1
     */
    uint32 pid;
    /** I-TAG I-SID */
    uint32 isid;
    /** I-TAG Reserved */
    uint32 rsvd;
    /** I-TAG Use Customer MAC */
    uint32 ucm;
    /** I-TAG Drop Eligible Indicator */
    uint32 dei;
    /** I-TAG Priority Code Point */
    uint32 pcp;
    /** label 0 TTL */
    uint32 ttl0;
    /** label 0 bottom-of-stack bit */
    uint32 s0;
    /** label 0 EXP field */
    uint32 exp0;
    /** label 2 label identifier */
    uint32 label0;
    /** label 1 TTL */
    uint32 ttl1;
    /** label 1 bottom-of-stack bit */
    uint32 s1;
    /** label 1 EXP field */
    uint32 exp1;
    /** label 1 label identifier */
    uint32 label1;
} soc_sbx_g2p3_eteencap_t;

    /**
     * L2 Egress Table Entry.
     * This entry is the layer 2 egress table entry (ETE).
     * The <tt>etel2</tt> contains predominantly Ethernet
     * editing fields, including an (outer) VLAN tag, QoS
     * remarking, and maximum transmission unit.  The
     * <tt>etel2</tt> also contains the local
     * station SMAC address index used for routed
     * forwarding.  An <tt>etel2</tt> can be used alone to
     * perform Ethernet encapsulated IP multicast routing.
     */
typedef struct soc_sbx_g2p3_etel2_s {
    /**
     * update the DSCP of the packet based on internal QoS
     * information
     */
    uint32 dscpremark;
    /** egress encapsulation length; must be 0 for etel2 */
    uint32 encaplen;
    /**
     * do not strip the VLAN tag, regardless of the setting
     * of epv2e.strip; this flag is typically never set
     */
    uint32 nostrip;
    /**
     * do not apply EFP classification; set this flag for
     * a raw ETE (e.g. for packets from the CPU)
     */
    uint32 noclass;
    /** egress QoS remarking table selector */
    uint32 remark;
    /**
     * disable split horizon checking; set nosplitcheck=1 for
     * routing (where the packet may return to the source port)
     */
    uint32 nosplitcheck;
    /**
     * default vid opeartion is to add a tag (from erh or ete). 
     * This is over-ridden on customer port (ep2e.customer) where there 
     * is a vlan tag in the packet.  This field allows for the same over-ride 
     * even if ep2e.customer=0.
     */
    uint32 usetag;
    /** drop packets without a customer tag */
    uint32 dropuntagged;
    /** drop packets with a customer tag */
    uint32 droptagged;
    /**
     * local station SMAC index for routed packets; only
     * applies if the packet is TBIPMC (4K <= erh.oi < 8K)
     * or has an eteencap
     */
    uint32 smacindex;
    /**
     * enable STP drop exception; set stpcheck=0 for a raw
     * (from-processor) ETE to send L2CP packets bypassing
     * a port in STP blocked or learning state
     */
    uint32 stpcheck;
    /** VLAN identifier; only used if usevid=1 */
    uint32 vid;
    /**
     * default Ethernet priority and CFI (PCP); only used
     * when ep2e.customer=1 and the packet arrives at the
     * egress without a customer tag
     */
    uint32 defpricfi;
    /** egress maximum transmission unit (MTU) */
    uint32 mtu;
    /**
     * use the VLAN identifier in the etel2; if usevid=0
     * && ep2e.customer=0 then the VID is erh.oi
     */
    uint32 usevid;
} soc_sbx_g2p3_etel2_t;

    /** Endpoint information for local and peer OAM and MPLS entries. */
typedef struct soc_sbx_g2p3_oamep_s {
    /** Index of the next table entry for this endpoint. */
    uint32 nextentry;
    /** Specifies the Endpoint Entry's type and OAM function. */
    uint32 function;
    /**
     * OAM packets egressing out Provider ports will use this
     * field as the erh->rcos/rdp values for egress marking.
     */
    uint32 type;
    /** Packet Interval (frequency) */
    uint32 interval;
    /** Maintenance Domain Level */
    uint32 mdlevel;
    /**
     * Transmit one packet only.  Single-shot tx for On-Demand
     * PM Services (SE-LM, 1W-DM, 2W-DM).
     */
    uint32 singletx;
    /**
     * LM: single-ended (0) or dual-ended (1).
     * DM: one-way (0) or two-way (1).
     * BFD: CV-Type ACH-only (0) or IP/UDP (1).
     */
    uint32 mode;
    /** MEP direction: down (0) or up (1). */
    uint32 dir;
    /** Continous To Host; send all received packets to host. */
    uint32 conttohost;
    /** Single To Host; send the next received packet to host. */
    uint32 singletohost;
    /** Forwarding Table Entry Index */
    uint32 ftidx;
    /**
     * Configure the TX and expected RX value of the M-Bit.
     * Unidirectional and multicast endpoints set this to 1,
     * otherwise it is 0.
     */
    uint32 m;
    /**
     * Configure the TX and expected RX value of the D-Bit.
     * Currently demand mode is not supported so this is always 0.
     */
    uint32 d;
    /**
     * Configure the TX and expected RX value of the A-Bit.
     * Currently authentication is not supported so this is always 0.
     */
    uint32 a;
    /**
     * Configure the TX and expected RX value of the C-Bit.
     * Currently this is always set to 1 for TX, ignored on RX.
     */
    uint32 c;
    /**
     * 0 indicates Uni-directional operation,
     * 1 indicates Bi-directional operation.
     */
    uint32 unibi;
    /** Enable Connectivity verification */
    uint32 cv;
    /**
     * Set by host app, will trigger sending only one Final message.
     * This flag will be auto-cleared by the ucode.
     */
    uint32 fbit;
    /** LM Coherent Counter index. */
    uint32 counteridx;
    /** multiplier table index. */
    uint32 multiplieridx;
    /** Recieve frame count; either direction. */
    uint32 rxfc;
    /** Remote Defect Indication (populates the TX packet) */
    uint32 rdi;
    /** 1=MIP, 0=MEP */
    uint32 mip;
    /** Dual-Ended LM support. */
    uint32 lm;
    /** Logical not of the lm flag. */
    uint32 notlm;
    /** Maintenance Endpoint ID (Enet, BFD) */
    uint32 mepid;
    /**
     * OAM packets egressing out Provider ports will use this
     * field as the erh->rcos/rdp values for egress marking.
     */
    uint32 intpri;
    /** When set to one, use the secondary push-down SMAC. */
    uint32 smacaux;
    /**
     * When set to one, add the smacLSB to the push-down SMAC.
     * Otherwise over-write the push-down's LSB with smacLSB.
     */
    uint32 smacadd;
    /** Identifies one of 64 contiguous SMACs. */
    uint32 smacoffset;
    /** Ingress port/node (not used) */
    uint32 sid;
    /** Used by ucode.  Must be set to zero. */
    uint32 tx;
    /** Your (or Peer/Remote) discriminator */
    uint32 yourdiscrim;
    /** My (or Local) discriminator */
    uint32 mydiscrim;
    /** Receive frame count; local. */
    uint32 rxfcl;
    /**
     * LM only, need to move the Next Endpoint Entry Index
     * out of the first pair of lookups to make room for
     * the Coherent Counter index.
     */
    uint32 nextentry_store;
    /**
     * LM only, need to move Forwarding Table Entry Index
     * out of the first pair of lookups to make room for 
     * three frame counts.
     */
    uint32 ftidx_store;
    /** Current delay, seconds. */
    uint32 delaysec;
    /** Time spent during remote processing, seconds. */
    uint32 remotesec;
    /** Maintenance Association ID, word 3, bytes 12 through 15. */
    uint32 maidw3;
    /** Maintenance Association ID, word 2, bytes 8 through 11. */
    uint32 maidw2;
    /** Maintenance Association ID, word 9, bytes 36 through 39. */
    uint32 maidw9;
    /** Maintenance Association ID, word 8, bytes 32 through 35. */
    uint32 maidw8;
    /** The 48 byte MAID reduced to 4 byte hash value. */
    uint32 maidcrc;
    /** Data path. */
    uint32 path;
    /** Fault path. */
    uint32 fpath;
    /** Reserved. */
    uint32 reserved;
    /** Revertive flag. */
    uint32 revertive;
    /** Protection Type. */
    uint32 pt;
    /** Request code. */
    uint32 request;
    /** Version number. */
    uint32 version;
    /** Entire psc header, 4 bytes. */
    uint32 pschdr;
    /** Counter used for the slow-rate TX. */
    uint32 slowrate;
    /** Counter used for filter received burst messages. */
    uint32 filter;
    /** Counts the number of burst packets to transmit. */
    uint32 burst;
    /**
     * If there is a PSC session residing on the same tunnel,
     * then this is the PSC EP index, else this must be zero.
     */
    uint32 pscentry;
    /** For CV-Type IP/UDP encap, this is the IP DA. */
    uint32 ipda;
    /** Transmit frame count in the forward direction. */
    uint32 txfcf;
    /** Transmit frame count in the backwards direction. */
    uint32 txfcb;
    /** Maintenance Association ID, word 1, bytes 4 through 7. */
    uint32 maidw1;
    /** Maintenance Association ID, word 0, bytes 0 through 3. */
    uint32 maidw0;
    /** Maintenance Association ID, word 7, bytes 28 through 31. */
    uint32 maidw7;
    /** Maintenance Association ID, word 6, bytes 24 through 27. */
    uint32 maidw6;
    /** Configurable slow rate transmission interval. */
    uint32 maxslowrate;
    /** Peer's RDI state (set by RX). */
    uint32 peerrdi;
    /** Application RDI exception handshake bit. */
    uint32 ackrdi;
    /** Both the rdi and handshake bit. */
    uint32 ackrdi_rdi;
    /** PolicerId for Watchdog Timer support. */
    uint32 policerid;
    /** UDP Source Port. */
    uint32 udpsourceport;
    /** point-to-multipoint BFD */
    uint32 multipoint;
    /** Peer (Remote) endpoint's state. */
    uint32 peerstate;
    /** Not currently used. */
    uint32 final;
    /** Application sets poll bit in transmitted messages. */
    uint32 poll;
    /** Local endpoint's state. */
    uint32 localstate;
    /** Local Endpoints reason code for the last session down. */
    uint32 diag;
    /** Peer (or Remote) endpoint's Detection Time Multiplier. */
    uint32 peerdetectmulti;
    /** Local endpoint's Detection Time Multiplier. */
    uint32 localdetectmulti;
    /** Current interval far-end frame loss count. */
    uint32 framelossfar;
    /** Current interval near-end frame loss. */
    uint32 framelossnear;
    /** Current delay, nano-seconds. */
    uint32 delaynanosec;
    /** Time spent during remote processing, nano-seconds. */
    uint32 remotenanosec;
    /** Maintenance Association ID, word 5, bytes 16 through 19. */
    uint32 maidw5;
    /** Maintenance Association ID, word 4, bytes 20 through 23. */
    uint32 maidw4;
    /** Maintenance Association ID, word 11, bytes 44 through 47. */
    uint32 maidw11;
    /** Maintenance Association ID, word 10, bytes 40 through 43. */
    uint32 maidw10;
    /** Configurable filter length. */
    uint32 maxfilter;
    /**
     * Length of optional TLVs in bytes.  Max is 4 bytes of TLV.
     * Default is zero bytes of TLV.
     */
    uint32 tlvlength;
    /** Optional TLV bytes 0 through 3. */
    uint32 tlv0_3;
} soc_sbx_g2p3_oamep_t;

    /**
     * Egress QoS Remarking Table.
     * This table maps internal QoS information to egress
     * packet markings.
     */
typedef struct soc_sbx_g2p3_remark_s {
    /** Ethernet CFI (DE) field */
    uint32 cfi;
    /** Ethernet priority (pri) field */
    uint32 pri;
    /** MPLS EXP field */
    uint32 exp;
    /** IP DSCP field; only used if ete*.usedscp=1 */
    uint32 dscp;
} soc_sbx_g2p3_remark_t;

    /**
     * Egress Port, VID Table.
     * This table contains egress per-port, per-VID state.
     */
typedef struct soc_sbx_g2p3_epv2e_s {
    /** drop the packet; used for STP blocked and learning states */
    uint32 drop;
    /** strip the outer VLAN tag */
    uint32 strip;
} soc_sbx_g2p3_epv2e_t;

    /**
     * Egress Local Station SMAC Table.
     * This table contains egress local station SMAC values.
     */
typedef struct soc_sbx_g2p3_esmac_s {
    /** SMAC byte 5 */
    uint32 smac5;
    /** SMAC byte 4 */
    uint32 smac4;
    /** SMAC byte 3 */
    uint32 smac3;
    /** SMAC byte 2 */
    uint32 smac2;
    /** SMAC byte 1 */
    uint32 smac1;
    /** SMAC byte 0 */
    uint32 smac0;
} soc_sbx_g2p3_esmac_t;

    /**
     * Egress Rule Action Table.
     * This table contains the actions associated with an EFP
     * (<i>egress field processor</i> also known as <i>egress
     * classifier</i> or the <i>egress rule classification
     * engine (RCE)</i>) pattern match.
     * <br><br>This table is not accessed directly by the host
     * software, but is managed by the RCE control software.  The
     * <tt>efp</tt> table provides the host software (SDK) control 
     * interface to EFP operation.
     * <br><br>This table contains twice the number of elements
     * than patterns a packet could match to provide hitless
     * update of the EFP database.
     */
typedef struct soc_sbx_g2p3_ert_s {
    /**
     * egress mirror index; unlike ingress mirroring, egress
     * mirroring selects one of 16 FE hardware mirrors; on the
     * BCM88020, to direct an egress mirrored flow some place
     * other than a port on the local FE, an unused port
     * must be put into loopback mode, and the ingress
     * packet processing configured to direct all looped
     * packets to the mirror port or tunnel; the BCM88025
     * supports arbitrary forwarding of hardware mirrored
     * traffic so using port loopback is not necessary
     */
    uint32 mirror;
    /** drop the packet */
    uint32 drop;
} soc_sbx_g2p3_ert_t;

    /**
     * Egress Rule Action Table.
     * This table contains the actions associated with an EFP
     * (<i>egress field processor</i> also known as <i>egress
     * classifier</i> or the <i>egress rule classification
     * engine (RCE)</i>) pattern match.
     * <br><br>This table is not accessed directly by the host
     * software, but is managed by the RCE control software.  The
     * <tt>efp</tt> table provides the host software (SDK) control 
     * interface to EFP operation.
     * <br><br>This table contains twice the number of elements
     * than patterns a packet could match to provide hitless
     * update of the EFP database.
     */
typedef struct soc_sbx_g2p3_ert_wrap_s {
    /**
     * egress mirror index; unlike ingress mirroring, egress
     * mirroring selects one of 16 FE hardware mirrors; on the
     * BCM88020, to direct an egress mirrored flow some place
     * other than a port on the local FE, an unused port
     * must be put into loopback mode, and the ingress
     * packet processing configured to direct all looped
     * packets to the mirror port or tunnel; the BCM88025
     * supports arbitrary forwarding of hardware mirrored
     * traffic so using port loopback is not necessary
     */
    uint32 mirror;
    /** drop the packet */
    uint32 drop;
} soc_sbx_g2p3_ert_wrap_t;

    /** Ingress V4Mc Stream Select Table. */
typedef struct soc_sbx_g2p3_v4mc_str_sel_s {
    /** enable PPE parsing for IPv4 Multicast packets through V4Mc Stream */
    uint32 valid;
} soc_sbx_g2p3_v4mc_str_sel_t;

    /**
     * Egress Field Processor Table.
     * This table is the front-end used by the SDK to access the
     * egress field processor (EFP) classification database.
     * The EFP function is implemented with a combination of
     * the FE rule classification engine (RCE) hardware (also
     * sometimes called <i>the classifier</i>), a rule action
     * table, and group of rule firing counters.  The EFP
     * management software operates on all the resources in
     * a coordinated manner based on updates to the <tt>efp</tt>
     * table.
     */
typedef struct soc_sbx_g2p3_efp_s {
    /** Database Type */
    uint32 dbtype;
    /** use dbtype in match */
    uint32 usedbtype;
    /** egress port */
    uint32 port;
    /** use egress port in match */
    uint32 useport;
    /** egress port bit map, active low */
    soc_sbx_g2p3_7_byte_t pbmpn;
    /** Ethernet priority bits */
    uint32 pri;
    /** use Ethernet priority bits in match */
    uint32 usepri;
    /**
     * IP fragment flag; set if ip.fragoff != 0 (i.e. the packet
     * is a subsequent fragment, it is not set if the packet is
     * an initial fragment)
     */
    uint32 fragment;
    /** use IP fragment flag in match */
    uint32 usefragment;
    /** TCP urgent flag */
    uint32 urg;
    /** use IP fragment flag in match */
    uint32 useurg;
    /** TCP acknowledge flag */
    uint32 ack;
    /** use TCP acknowledge flag in match */
    uint32 useack;
    /** TCP push flag */
    uint32 psh;
    /** use TCP push flag in match */
    uint32 usepsh;
    /** TCP reset flag */
    uint32 rst;
    /** use TCP reset flag in match */
    uint32 userst;
    /** TCP synchronize flag */
    uint32 syn;
    /** use TCP synchronize flag in match */
    uint32 usesyn;
    /** TCP finish flag */
    uint32 fin;
    /** use TCP finish flag in match */
    uint32 usefin;
    /**
     * DiffServ code point; dscp+ecn can be used to match the
     * complete IP TOS byte
     */
    uint32 dscp;
    /** use DiffServ code point in match */
    uint32 usedscp;
    /**
     * explicit congestion notification flags; dscp+ecn can be
     * used to match the complete IP TOS byte
     */
    uint32 ecn;
    /** use explicit congestion notification flags in match */
    uint32 useecn;
    /** IP protocol */
    uint32 proto;
    /** use IP protocol in match */
    uint32 useproto;
    /**
     * TCP/UDP source port upper bound; also matches
     * LLC SSAP & DSAP (or bytes 0 & 1 of any data
     * beyond what the PPE parses)
     */
    uint32 sporthi;
    /** TCP/UDP source port lower bound */
    uint32 sportlo;
    /** TCP/UDP destination port upper bound */
    uint32 dporthi;
    /** TCP/UDP destination port lower bound */
    uint32 dportlo;
    /** IP source address */
    uint32 sa;
    /** IP source address prefix length; 0 means wildcard */
    uint32 sawidth;
    /** IP destination address */
    uint32 da;
    /** IP destination address prefix length; 0 means wildcard */
    uint32 dawidth;
    /** Ethertype; etype=0 means match LLC packet (but not SNAP) */
    uint32 etype;
    /** use Ethertype in match */
    uint32 useetype;
    /** source MAC address */
    soc_sbx_g2p3_6_byte_t smac;
    /** source MAC address prefix length; 0 means wildcard */
    uint32 smacwidth;
    /** destination MAC address */
    soc_sbx_g2p3_6_byte_t dmac;
    /** destination MAC address prefix length; 0 means wildcard */
    uint32 dmacwidth;
    /** (outer) VLAN identifier */
    uint32 pvlan;
    /** use VLAN identifier in match */
    uint32 usepvlan;
    /** LLC source service access point upper bound */
    uint32 ssaphi;
    /** LLC source service access point lower bound */
    uint32 ssaplo;
    /** use LLC source service access point in match */
    uint32 usessap;
    /** LLC destination service access point upper bound */
    uint32 dsaphi;
    /** LLC destination service access point lower bound */
    uint32 dsaplo;
    /** use LLC destination service access point in match */
    uint32 usedsap;
    /** LLC control byte upper bound */
    uint32 llcctrlhi;
    /** LLC control byte lower bound */
    uint32 llcctrllo;
    /** use LLC control byte in match */
    uint32 usellcctrl;
    /** enable this rule to match */
    uint32 enable;
    /**
     * egress mirror index; unlike ingress mirroring, egress
     * mirroring selects one of 16 FE hardware mirrors; on the
     * BCM88020, to direct an egress mirrored flow some place
     * other than a port on the local FE, an unused port
     * must be put into loopback mode, and the ingress
     * packet processing configured to direct all looped
     * packets to the mirror port or tunnel; the BCM88025
     * supports arbitrary forwarding of hardware mirrored
     * traffic so using port loopback is not necessary
     */
    uint32 mirror;
    /** drop the packet */
    uint32 drop;
} soc_sbx_g2p3_efp_t;

    /** Egress ipv6 Field Processor Table. */
typedef struct soc_sbx_g2p3_efp_v6_s {
    /** dbtype for classification */
    uint32 dbtype;
    /** use dbtype in match */
    uint32 usedbtype;
    /** egress port */
    uint32 port;
    /** use egress port in match */
    uint32 useport;
    /** egress port bit map, active low */
    soc_sbx_g2p3_7_byte_t pbmpn;
    /** TCP urgent flag */
    uint32 urg;
    /** use TCP urgent flag in match */
    uint32 useurg;
    /** TCP acknowledge flag */
    uint32 ack;
    /** use TCP acknowledge flag in match */
    uint32 useack;
    /** TCP push flag */
    uint32 psh;
    /** use TCP push flag in match */
    uint32 usepsh;
    /** TCP reset flag */
    uint32 rst;
    /** use TCP reset flag in match */
    uint32 userst;
    /** TCP synchronize flag */
    uint32 syn;
    /** use TCP synchronize flag in match */
    uint32 usesyn;
    /** TCP finish flag */
    uint32 fin;
    /** use TCP finish flag in match */
    uint32 usefin;
    /**
     * DiffServ code point; dscp+ecn can be used to match the
     * complete IP TOS byte
     */
    uint32 TC;
    /** use DiffServ code point in match */
    uint32 useTC;
    /** IPv6 Next Header upper bound */
    uint32 nextheaderhi;
    /** IPv6 Next Header lower bound */
    uint32 nextheaderlo;
    /** TCP/UDP source port upper bound */
    uint32 sporthi;
    /** TCP/UDP source port lower bound */
    uint32 sportlo;
    /** TCP/UDP destination port upper bound */
    uint32 dporthi;
    /** TCP/UDP destination port lower bound */
    uint32 dportlo;
    /** IP source address */
    soc_sbx_g2p3_16_byte_t sa;
    /** IP source address prefix length; 0 means wildcard */
    uint32 sawidth;
    /** IP destination address */
    soc_sbx_g2p3_16_byte_t da;
    /** IP destination address prefix length; 0 means wildcard */
    uint32 dawidth;
    /** (outer) VLAN identifier */
    uint32 vid;
    /** use VLAN identifier in match */
    uint32 usevid;
    /** enable this rule to match */
    uint32 enable;
    /**
     * egress mirror index; unlike ingress mirroring, egress
     * mirroring selects one of 16 FE hardware mirrors; on the
     * BCM88020, to direct an egress mirrored flow some place
     * other than a port on the local FE, an unused port
     * must be put into loopback mode, and the ingress
     * packet processing configured to direct all looped
     * packets to the mirror port or tunnel; the BCM88025
     * supports arbitrary forwarding of hardware mirrored
     * traffic so using port loopback is not necessary
     */
    uint32 mirror;
    /** drop the packet */
    uint32 drop;
} soc_sbx_g2p3_efp_v6_t;

    /** Multiplication lookup for the frame loss ratio calculation. */
typedef struct soc_sbx_g2p3_oammultiplier_s {
    /** Minimum number of frames needed for interval to not be degraded. */
    uint32 frameCount;
} soc_sbx_g2p3_oammultiplier_t;

    /** . */
typedef struct soc_sbx_g2p3_oamepremap_s {
    /** Endpoint index. */
    uint32 epIdx;
} soc_sbx_g2p3_oamepremap_t;

    /**
     * Ingress IPv6 DA LPM Table.
     * This table is used to determine the forwarding
     * behavior for unicast IPv6 packets directed to the
     * local station MAC address that are not locally
     * attached hosts.  A separate <i>host table</i>
     * contains locally attached hosts.  The IPv6 DA
     * LPM table is searched based on the most significant
     * 64 bits of the 128-bit IPv6 DA.
     * <br><br>This table is composed of 7 slice trie structure
     * without any singleton optimization.
     * The slices, starting from bit 0, are
     * 16 bits, followed by 6 slices of 8 bits each.
     * <br><br>Storage for the first slice is statically
     * allocate and subsequent slices are dynamically
     * allocated from two banks of storage.  Payload
     * is also allocated from one of the two banks of
     * storage.  Payloads of equal value are shared
     * by all prefixes, forming a direct-acyclic graph
     * with sharing only on the final node.
     */
typedef struct soc_sbx_g2p3_ipv6da_s {
    /**
     * forwarding table base index; the final forwarding table
     * index is ftidx + ((1<< ecmpmask-1) & ppe aggr hash)
     */
    uint32 ftidx;
    /**
     * equal cost multipath (ECMP) set size; if ecmpmask=0, then
     * the route is not an ECMP route
     */
    uint32 ecmpmask;
    /**
     * destination VID for the route; this field is compared
     * with the source VID to determine if an IP redirect
     * exception message should be generated
     */
    uint32 vid;
} soc_sbx_g2p3_ipv6da_t;

    /** ipv6dal0 entry contents. */
typedef struct soc_sbx_g2p3_ipv6dal0_s {
    /**
     * the prefix pattern to compare if singleton=1; this
     * pattern is prefix encoded: the least
     * significant 1 bit indicates the pattern length, and
     * all more significant bits are the pattern value
     */
    uint32 pattern;
    /**
     * the following node is a singleton; instead of an array of
     * 1 << slice size bits, the node is an array of 2 with
     * one element if the singleton pattern does not match,
     * and the other element if the singleton pattern does match
     */
    uint32 singleton;
    /**
     * points to the following node if leaf=0, or the payload
     * if leaf=1
     */
    uint32 pointer;
    /** signals that pointer points to the final payload */
    uint32 leaf;
} soc_sbx_g2p3_ipv6dal0_t;

    /** ipv6daodd entry contents. */
typedef struct soc_sbx_g2p3_ipv6daodd_s {
    /**
     * the prefix pattern to compare if singleton=1; this
     * pattern is prefix encoded: the least
     * significant 1 bit indicates the pattern length, and
     * all more significant bits are the pattern value
     */
    uint32 pattern;
    /**
     * the following node is a singleton; instead of an array of
     * 1 << slice size bits, the node is an array of 2 with
     * one element if the singleton pattern does not match,
     * and the other element if the singleton pattern does match
     */
    uint32 singleton;
    /**
     * points to the following node if leaf=0, or the payload
     * if leaf=1
     */
    uint32 pointer;
    /** signals that pointer points to the final payload */
    uint32 leaf;
} soc_sbx_g2p3_ipv6daodd_t;

    /** ipv6daeven entry contents. */
typedef struct soc_sbx_g2p3_ipv6daeven_s {
    /**
     * the prefix pattern to compare if singleton=1; this
     * pattern is prefix encoded: the least
     * significant 1 bit indicates the pattern length, and
     * all more significant bits are the pattern value
     */
    uint32 pattern;
    /**
     * the following node is a singleton; instead of an array of
     * 1 << slice size bits, the node is an array of 2 with
     * one element if the singleton pattern does not match,
     * and the other element if the singleton pattern does match
     */
    uint32 singleton;
    /**
     * points to the following node if leaf=0, or the payload
     * if leaf=1
     */
    uint32 pointer;
    /** signals that pointer points to the final payload */
    uint32 leaf;
} soc_sbx_g2p3_ipv6daeven_t;

    /** ipv6dapayload entry contents. */
typedef struct soc_sbx_g2p3_ipv6dapayload_s {
    /**
     * forwarding table base index; the final forwarding table
     * index is ftidx + ((1<< ecmpmask-1) & ppe aggr hash)
     */
    uint32 ftidx;
    /**
     * equal cost multipath (ECMP) set size; if ecmpmask=0, then
     * the route is not an ECMP route
     */
    uint32 ecmpmask;
    /**
     * destination VID for the route; this field is compared
     * with the source VID to determine if an IP redirect
     * exception message should be generated
     */
    uint32 vid;
} soc_sbx_g2p3_ipv6dapayload_t;

    /**
     * Ingress IPv6 SA LPM Table.
     * This table is used to implement unicast <i>reverse
     * path forwarding</i> (uRPF) checks for IPv6 packets
     * directed to the local station MAC address.
     * The table supports both strict and loose uRPF
     * checking, selected on a per-prefix basis.
     * The IPv6 SA LPM table is searched
     * based on the most significant
     * 64 bits of the 128-bit IPv6 SA.
     * <br><br>This table is composed of 7 slice trie structure
     * without any singleton optimization.
     * The slices, starting from bit 0, are
     * 16 bits, followed by 6 slices of 8 bits each.
     * <br><br>Storage for the first slice is statically
     * allocate and subsequent slices are dynamically
     * allocated from two banks of storage.  Payload
     * is also allocated from one of the two banks of
     * storage.  Payloads of equal value are shared
     * by all prefixes, forming a direct-acyclic graph
     * with sharing only on the final node.
     */
typedef struct soc_sbx_g2p3_ipv6sa_s {
    /** Point of entry (port, node) */
    uint32 poe;
    /**
     * Per src RPF check flags. Supported modes are
     * URPF_DISABLED (0x0)
     * URPF_STRICT   (0x1)
     * URPF_LOOSE    (0x2) 
     */
    uint32 rpfmode;
    /** Source drop flag */
    uint32 srcdrop;
    /** Source counter */
    uint32 srccnt;
} soc_sbx_g2p3_ipv6sa_t;

    /** ipv6sal0 entry contents. */
typedef struct soc_sbx_g2p3_ipv6sal0_s {
    /**
     * the prefix pattern to compare if singleton=1; this
     * pattern is prefix encoded: the least
     * significant 1 bit indicates the pattern length, and
     * all more significant bits are the pattern value
     */
    uint32 pattern;
    /**
     * the following node is a singleton; instead of an array of
     * 1 << slice size bits, the node is an array of 2 with
     * one element if the singleton pattern does not match,
     * and the other element if the singleton pattern does match
     */
    uint32 singleton;
    /**
     * points to the following node if leaf=0, or the payload
     * if leaf=1
     */
    uint32 pointer;
    /** signals that pointer points to the final payload */
    uint32 leaf;
} soc_sbx_g2p3_ipv6sal0_t;

    /** ipv6saodd entry contents. */
typedef struct soc_sbx_g2p3_ipv6saodd_s {
    /**
     * the prefix pattern to compare if singleton=1; this
     * pattern is prefix encoded: the least
     * significant 1 bit indicates the pattern length, and
     * all more significant bits are the pattern value
     */
    uint32 pattern;
    /**
     * the following node is a singleton; instead of an array of
     * 1 << slice size bits, the node is an array of 2 with
     * one element if the singleton pattern does not match,
     * and the other element if the singleton pattern does match
     */
    uint32 singleton;
    /**
     * points to the following node if leaf=0, or the payload
     * if leaf=1
     */
    uint32 pointer;
    /** signals that pointer points to the final payload */
    uint32 leaf;
} soc_sbx_g2p3_ipv6saodd_t;

    /** ipv6saeven entry contents. */
typedef struct soc_sbx_g2p3_ipv6saeven_s {
    /**
     * the prefix pattern to compare if singleton=1; this
     * pattern is prefix encoded: the least
     * significant 1 bit indicates the pattern length, and
     * all more significant bits are the pattern value
     */
    uint32 pattern;
    /**
     * the following node is a singleton; instead of an array of
     * 1 << slice size bits, the node is an array of 2 with
     * one element if the singleton pattern does not match,
     * and the other element if the singleton pattern does match
     */
    uint32 singleton;
    /**
     * points to the following node if leaf=0, or the payload
     * if leaf=1
     */
    uint32 pointer;
    /** signals that pointer points to the final payload */
    uint32 leaf;
} soc_sbx_g2p3_ipv6saeven_t;

    /** ipv6sapayload entry contents. */
typedef struct soc_sbx_g2p3_ipv6sapayload_s {
    /** Point of entry (port, node) */
    uint32 poe;
    /**
     * Per src RPF check flags. Supported modes are
     * URPF_DISABLED (0x0)
     * URPF_STRICT   (0x1)
     * URPF_LOOSE    (0x2) 
     */
    uint32 rpfmode;
    /** Source drop flag */
    uint32 srcdrop;
    /** Source counter */
    uint32 srccnt;
} soc_sbx_g2p3_ipv6sapayload_t;

    /**
     * Ingress IPv4 DA LPM Table.
     * This table is used to determine the forwarding
     * behavior for unicast IPv4 packets directed to the
     * local station MAC address.  A single table stores
     * both prefix addresses and local station addresses
     * (the <i>ARP cache</i>).
     * <br><br>This table is composed of 5 slice trie structure
     * with a singleton optimization for the bottom 3
     * slices.  The slices, starting from bit 0, are
     * 18 bits, 8 bits, 6 bits, 5 bits and 7 bits.  The
     * key is the concatenation of a 12-bit virtual
     * routing function identifer (vrf) and a 32-bit
     * IPv4 address.
     * <br><br>Storage for the first slice is statically
     * allocate and subsequent slices are dynamically
     * allocated from two banks of storage.  Payload
     * is also allocated from one of the two banks of
     * storage.  Payloads of equal value are shared
     * by all prefixes, forming a direct-acyclic graph
     * with sharing only on the final node.
     */
typedef struct soc_sbx_g2p3_ipv4da_s {
    /**
     * forwarding table base index; the final forwarding table
     * index is ftidx + ((1<< ecmpmask-1) & ppe aggr hash)
     */
    uint32 ftidx;
    /**
     * equal cost multipath (ECMP) set size; if ecmpmask=0, then
     * the route is not an ECMP route
     */
    uint32 ecmpmask;
    /**
     * destination VID for the route; this field is compared
     * with the source VID to determine if an IP redirect
     * exception message should be generated
     */
    uint32 vid;
} soc_sbx_g2p3_ipv4da_t;

    /** ipv4dal0 entry contents. */
typedef struct soc_sbx_g2p3_ipv4dal0_s {
    /**
     * the prefix pattern to compare if singleton=1; this
     * pattern is prefix encoded: the least
     * significant 1 bit indicates the pattern length, and
     * all more significant bits are the pattern value
     */
    uint32 pattern;
    /**
     * the following node is a singleton; instead of an array of
     * 1 << slice size bits, the node is an array of 2 with
     * one element if the singleton pattern does not match,
     * and the other element if the singleton pattern does match
     */
    uint32 singleton;
    /**
     * points to the following node if leaf=0, or the payload
     * if leaf=1
     */
    uint32 pointer;
    /** signals that pointer points to the final payload */
    uint32 leaf;
} soc_sbx_g2p3_ipv4dal0_t;

    /** ipv4daodd entry contents. */
typedef struct soc_sbx_g2p3_ipv4daodd_s {
    /**
     * the prefix pattern to compare if singleton=1; this
     * pattern is prefix encoded: the least
     * significant 1 bit indicates the pattern length, and
     * all more significant bits are the pattern value
     */
    uint32 pattern;
    /**
     * the following node is a singleton; instead of an array of
     * 1 << slice size bits, the node is an array of 2 with
     * one element if the singleton pattern does not match,
     * and the other element if the singleton pattern does match
     */
    uint32 singleton;
    /**
     * points to the following node if leaf=0, or the payload
     * if leaf=1
     */
    uint32 pointer;
    /** signals that pointer points to the final payload */
    uint32 leaf;
} soc_sbx_g2p3_ipv4daodd_t;

    /** ipv4daeven entry contents. */
typedef struct soc_sbx_g2p3_ipv4daeven_s {
    /**
     * the prefix pattern to compare if singleton=1; this
     * pattern is prefix encoded: the least
     * significant 1 bit indicates the pattern length, and
     * all more significant bits are the pattern value
     */
    uint32 pattern;
    /**
     * the following node is a singleton; instead of an array of
     * 1 << slice size bits, the node is an array of 2 with
     * one element if the singleton pattern does not match,
     * and the other element if the singleton pattern does match
     */
    uint32 singleton;
    /**
     * points to the following node if leaf=0, or the payload
     * if leaf=1
     */
    uint32 pointer;
    /** signals that pointer points to the final payload */
    uint32 leaf;
} soc_sbx_g2p3_ipv4daeven_t;

    /** ipv4dapayload entry contents. */
typedef struct soc_sbx_g2p3_ipv4dapayload_s {
    /**
     * forwarding table base index; the final forwarding table
     * index is ftidx + ((1<< ecmpmask-1) & ppe aggr hash)
     */
    uint32 ftidx;
    /**
     * equal cost multipath (ECMP) set size; if ecmpmask=0, then
     * the route is not an ECMP route
     */
    uint32 ecmpmask;
    /**
     * destination VID for the route; this field is compared
     * with the source VID to determine if an IP redirect
     * exception message should be generated
     */
    uint32 vid;
} soc_sbx_g2p3_ipv4dapayload_t;

    /** Maps a port to the FT entry that will forward to that egress port. */
typedef struct soc_sbx_g2p3_p2fti_s {
    /** FT index. */
    uint32 ftidx;
} soc_sbx_g2p3_p2fti_t;

    /** UTG-defined generic policer entry. */
typedef struct soc_sbx_g2p3_policer_s {
    /** cbsbytes */
    uint32 cbsbytes;
    /** cirkbps */
    uint32 cirkbps;
    /** ebsbytes */
    uint32 ebsbytes;
    /** eirkbps */
    uint32 eirkbps;
    /** mode */
    uint32 mode;
    /** lenshift */
    uint32 lenshift;
    /** colorblind */
    uint32 colorblind;
    /** dropred */
    uint32 dropred;
    /** coupling */
    uint32 coupling;
    /** nodebit */
    uint32 nodebit;
} soc_sbx_g2p3_policer_t;

    /** UTG-defined generic timer entry. */
typedef struct soc_sbx_g2p3_timer_s {
    /** ms */
    uint32 ms;
    /** started */
    uint32 started;
    /** ucodereset */
    uint32 ucodereset;
    /** interrupt */
    uint32 interrupt;
} soc_sbx_g2p3_timer_t;

    /** UTG-defined generic sequence generator entry. */
typedef struct soc_sbx_g2p3_sequence_s {
    /** seqnum */
    uint32 seqnum;
} soc_sbx_g2p3_sequence_t;

/* Find a memory bank member by address */
int soc_sbx_g2p3_memory_bank_find(
                soc_sbx_g2p3_table_manager_t *tm,
                soc_sbx_g2p3_memory_desc_t *md,
                int addr, char **name, int *offset, int *iscnt);

/* Generic policer set (internal use only) */
extern int soc_sbx_g2p3_generic_policer_set(int unit,
                int pid, int policer,
                soc_sbx_g2p3_policer_t *p);

/* Generic policer get (internal use only) */
extern int soc_sbx_g2p3_generic_policer_get(int unit,
                int pid, int policer,
                soc_sbx_g2p3_policer_t *p);

/* Generic policer delete (internal use only) */
extern int soc_sbx_g2p3_generic_policer_delete(int unit, int pid, int policer);

/* Generic timer set (internal use only) */
extern int soc_sbx_g2p3_generic_timer_set(int unit,
                int pid, int timer,
                soc_sbx_g2p3_timer_t *p);

/* Generic timer get (internal use only) */
extern int soc_sbx_g2p3_generic_timer_get(int unit,
                int pid, int timer,
                soc_sbx_g2p3_timer_t *p);

/* Generic timer delete (internal use only) */
extern int soc_sbx_g2p3_generic_timer_delete(int unit, int pid, int timer);

/* Generic sequence set (internal use only) */
extern int soc_sbx_g2p3_generic_sequence_set(int unit,
                int pid, int sequence,
                soc_sbx_g2p3_sequence_t *p);

/* Generic sequence get (internal use only) */
extern int soc_sbx_g2p3_generic_sequence_get(int unit,
                int pid, int sequence,
                soc_sbx_g2p3_sequence_t *p);

/* Generic sequence delete (internal use only) */
extern int soc_sbx_g2p3_generic_sequence_delete(int unit, int pid, int sequence);

/**
 * Microcode accessor uninitialization function.
 *
 * @param[in]  unit chip unit number
 */
extern int soc_sbx_g2p3_uninit(int unit);

/**
 * LPM table accessor uninitialization function (external implementation).
 *
 * @param[in]  unit chip unit number
 * @state[in]  LPM instance state structure pointer
 */
extern int soc_sbx_g2p3_lpm_uninit_ext(int unit, void *state);

/**
 * EML table accessor uninitialization function (external implementation).
 *
 * @param[in]  unit chip unit number
 * @state[in]  EML instance state structure pointer
 */
extern int soc_sbx_g2p3_eml_uninit_ext(int unit, void *state);

/**
 * EM32 table accessor uninitialization function (external implementation).
 *
 * @param[in]  unit chip unit number
 * @state[in]  EM32 instance state structure pointer
 */
extern int soc_sbx_g2p3_em32_uninit_ext(int unit, void *state);

/**
 * Microcode accessor initialization function.
 *
 * @param[in]  unit chip unit number
 */
extern int soc_sbx_g2p3_init(int unit);

/**
 * Microcode accessor complex table initialization function.
 *
 * Call this function after the general initialization is
 *   complete and all desired table resizing is performed.
 *   Complex table initialization usually requires some form of writing
 *   to the table data structures which means they must be placed in
 *   their proper locations before this initialization is called.
 * 
 * Unlike the generic _init function, if this function returns an error,
 *   the caller must call the _uninit() function if desired, to return
 *   the microcode accessor subsystem to a clean, uninitialized state.
 *
 * @param[in]  unit chip unit number
 */
extern int soc_sbx_g2p3_complex_init(int unit);


/**
 * Microcode accessor complex table recovery function.
 *
 * Call this function during a warm reboot, after the the general 
 *   initialization is complete and all desired table resizing is 
 *   performed.  The recovery process requires all table locations for
 *   device memory in order to reconstruct the necessary software state.
 *
 * @param[in]  unit chip unit number
 */
extern int soc_sbx_g2p3_complex_recover(int unit);


/**
 * LPM table initialization function (external).
 *
 * This function must initialize the LPM table, and stuff the state pointer.
 *
 * @param[in]     unit chip unit number
 * @param[out]    state pointer to LPM instance state structure pointer
 * @param[in]     name complex table name
 * @param[in]     ncbanks number of slices + payload banks
 * @param[in]     cbanks array of slice + payload bank descriptors
 * @param[in]     esize unpacked entry size, in bytes
 * @param[in]     pack entry pack function
 * @param[in]     dentry default entry
 */
extern int soc_sbx_g2p3_lpm_init_ext(int unit,
                void **state, char *name, int ncbanks,
                soc_sbx_g2p3_complex_bank_desc_t *cbanks, int esize,
                soc_sbx_g2p3_complex_pack_f_t pack, void *dentry);

/**
 * EML table initialization function (external).
 *
 * This function must initialize the EML table, and stuff the state pointer.
 * 
 * @param[in]     unit chip unit number
 * @param[out]    state pointer to LPM instance state structure pointer
 * @param[in]     name complex table name
 * @param[in]     ncbanks number of slices + payload banks
 * @param[in]     cbanks array of slice + payload bank descriptors
 * @param[in]     saltwidth number of bits of salt in L2 hash
 */
extern int soc_sbx_g2p3_eml_init_ext(int unit,
                void **state, char *name,
                int ncbanks, soc_sbx_g2p3_complex_bank_desc_t *cbanks,
                int saltwidth, int agepos, int agewidth,
                int dontagepos, int align);

/**
 * EML table recovery function (external).
 *
 * This function must recover the EML table state.
 *
 * @param[in]     unit chip unit number
 * @param[in]    state pointer to EML instance state structure pointer
 */
extern int soc_sbx_g2p3_eml_recover_ext(int unit, 
               void *state);


/**
 * EM32 table initialization function (external).
 *
 * This function must initialize the EM32 table, and stuff the state pointer.
 *
 * The implementation of this function should get the bank parameters
 * (size, base and memory port) for each slice and payload bank using
 * the table bank parameters accessor.
 * 
 * @param[in]     unit chip unit number
 * @param[out]    state pointer to EM32 instance state structure pointer
 * @param[in]     name complex table name
 * @param[in]     ncbanks number of slices + payload banks
 * @param[in]     cbanks array of slice + payload bank descriptors
 */
extern int soc_sbx_g2p3_em32_init_ext(int unit,
                void **state, char *name,
                int ncbanks, soc_sbx_g2p3_complex_bank_desc_t *cbanks);

/**
 * EM32 table recovery function (external).
 *
 * This function must recover the EM32 table state.
 *
 * @param[in]     unit chip unit number
 * @param[in]    state pointer to EM32 instance state structure pointer
 */
extern int soc_sbx_g2p3_em32_recover_ext(int unit,
                void *state);

/**
 * Restore microcode push-down parameters
 *
 * Call this function after reloading microcode to restore globals and
 * table placement information that may have been updated during operation.
 *
 * @param[in]  unit chip unit number
 */
extern int soc_sbx_g2p3_reload(int unit);

/**
 * Recover microcode state from hardware.
 *
 * Call this function after warm booting microcode to restore internal state.
 * Underlying microcode access object must be recovered prior to calling.
 *
 * @param[in]  unit chip unit number
 */
extern int soc_sbx_g2p3_recover(int unit);

/**
 * Get memory parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  mid memory index (also CPU DMA memory port number)
 * @param[out] mp memory parameters
 */
extern int soc_sbx_g2p3_memory_params_get(int unit, int mid,
                soc_sbx_g2p3_memory_params_t *mp);

/**
 * Set memory size.
 *
 * Currently, the memory size is not used for anything.
 *
 * @param[in]  unit chip unit number
 * @param[in]  mid memory index (also CPU DMA memory port number)
 * @param[in]  size memory size, in words
 */
extern int soc_sbx_g2p3_memory_size_set(int unit, int mid, int size)
;

/*
 * Shared constant accessors
 */

/**
 * Get constant max_ports value.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_max_ports_get(int unit, uint32 *vp);

/**
 * Get constant ipv4_vrf_bits value.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_ipv4_vrf_bits_get(int unit, uint32 *vp);

/**
 * Get constant EXC_IP_CHECKSUM_IDX value.
 *
 * Microcode workaround for Broadshield IPv4 Checksum error.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exc_ip_checksum_idx_get(int unit, uint32 *vp);

/**
 * Get constant EXC_STP_BLOCKED_IDX value.
 *
 * Ingress STP blocked exception index.  The `nominal' copy
 * of packets dropped when the STP state is `learning' also
 * use this exception index.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exc_stp_blocked_idx_get(int unit, uint32 *vp);

/**
 * Get constant EXC_SMAC_DROP_IDX value.
 *
 * Ingress SMAC drop exception index.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exc_smac_drop_idx_get(int unit, uint32 *vp);

/**
 * Get constant EXC_SMAC_UNKNOWN_IDX value.
 *
 * Ingress unknown SMAC drop exception index.  This exception
 * is enabled per-VLAN in the v2e table.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exc_smac_unknown_idx_get(int unit, uint32 *vp);

/**
 * Get constant EXC_MAC_HAIRPIN_IDX value.
 *
 * Ingress hairpin exception index.  This exception is
 * triggered when the destination MAC PID is equal to the
 * source PID.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exc_mac_hairpin_idx_get(int unit, uint32 *vp);

/**
 * Get constant EXC_DMAC_DROP_IDX value.
 *
 * Ingress DMAC drop exception index.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exc_dmac_drop_idx_get(int unit, uint32 *vp);

/**
 * Get constant EXC_TTL_EXPIRED_IDX value.
 *
 * Egress TTL expired exception index.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exc_ttl_expired_idx_get(int unit, uint32 *vp);

/**
 * Get constant EXC_EGR_STP_BLOCKED_IDX value.
 *
 * Egress STP blocked exception index.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exc_egr_stp_blocked_idx_get(int unit, uint32 *vp);

/**
 * Get constant EXC_SPLIT_IDX value.
 *
 * Egress split horizon exception index.  Also called a
 * a <i>source knock-out</i> exception.  This
 * exception is triggered 
 * when the ingress PID in the ERH is equal to the egress
 * PID (either from the physical port or the ETE).
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exc_split_idx_get(int unit, uint32 *vp);

/**
 * Get constant EXC_MTU_IDX value.
 *
 * Egress MTU exceeded index.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exc_mtu_idx_get(int unit, uint32 *vp);

/**
 * Get constant EXC_OAM_MISMATCH value.
 *
 * OAM CCM field mismatch exception index.
 * This exception is triggered when
 * a field in a CCM differs from what is expected (configured
 * into the OAM database).  A mismatch would typically happen
 * if a service was incorrectly cross-connected somewhere
 * in the network.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exc_oam_mismatch_get(int unit, uint32 *vp);

/**
 * Get constant EXC_OAM_LEARN value.
 *
 * OAM CCM learn exception index.
 * This exception is triggered when a CCM is received on a
 * service that is configured for OAM but the sending endpoint
 * is not configured into the OAM database.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exc_oam_learn_get(int unit, uint32 *vp);

/**
 * Get constant EXC_OAM_NO_ENDPOINT value.
 *
 * OAM CCM unknown endpoint exception index.
 * This exception is triggered when a CCM is received on a
 * service that is configured for OAM but at an MD level
 * that is unexpected (neither configured to peer nor
 * forward).
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exc_oam_no_endpoint_get(int unit, uint32 *vp);

/**
 * Get constant EXC_OAM_TYPE value.
 *
 * OAM unexpected message type exception index.
 * This exception is triggered when an OAM endpoint entry
 * is found for this OAM packet, and the OAM packet header
 * opCode (or MPLS function type) does not match the endpoint
 * entry's endpointType (or funcType) field.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exc_oam_type_get(int unit, uint32 *vp);

/**
 * Get constant EXC_OAM_RDI value.
 *
 * OAM CCM message RDI bit did not match RDI state in the
 * endpoint record.  Or a previous RDI state change exception
 * has not been acknowledged by the application and another
 * CCM message has arrived from the same endpoint.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exc_oam_rdi_get(int unit, uint32 *vp);

/**
 * Get constant EXC_VLAN_DROP_IDX value.
 *
 * VLAN must be dropped exception index.
 * This exception is triggered when a packet arrives on the
 * <tt>blackhole_vlan</tt>.  This exception is used both
 * directly by the microcode, for IP and MPLS forwarding, and
 * implicitly, by SDK configuration of the blackhole VLAN 
 * flood forwarding table entry, for bridging forwarding.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exc_vlan_drop_idx_get(int unit, uint32 *vp);

/**
 * Get constant EXC_V4MC_RPF_CHECK_IDX value.
 *
 * Ingress V4 Multicast RPF Check Fail exception index. This
 * exception is used directly by the microcode if the ingress
 * multicast packet does not match with the path on which it 
 * arrived.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exc_v4mc_rpf_check_idx_get(int unit, uint32 *vp);

/**
 * Get constant EXC_URPF_DROP_IDX value.
 *
 * Unicast RPF check failed.
 * Exception happens only if STRICT/LOOSE mode configured.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exc_urpf_drop_idx_get(int unit, uint32 *vp);

/**
 * Get constant EXC_IP_SA_DROP_IDX value.
 *
 * IP Source Address matched, and drop flag is set
 * Per source filter can be set using this
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exc_ip_sa_drop_idx_get(int unit, uint32 *vp);

/**
 * Get constant EXC_MIM_BAD_FORMAT_IDX value.
 *
 * MIM Packet doesn't have the expected format.
 * Either BTAG or ITAG is missing.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exc_mim_bad_format_idx_get(int unit, uint32 *vp);

/**
 * Get constant EXC_ISID2E_MISS_IDX value.
 *
 * The ISID don't have an entry in ISID2E Table.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exc_isid2e_miss_idx_get(int unit, uint32 *vp);

/**
 * Get constant EXC_OAM_THRESHOLD_EXCEEDED value.
 *
 * LM processing detected an interval whose frame loss
 * and frame received counts exceede the configured
 * threshold ratio.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exc_oam_threshold_exceeded_get(int unit, uint32 *vp);

/**
 * Get constant EXC_OAM_COPY_TO_HOST value.
 *
 * Host application requested this packet be sent up.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exc_oam_copy_to_host_get(int unit, uint32 *vp);

/**
 * Get constant EXC_OAM_PARAM_CHANGE value.
 *
 * A BFD Control Packet was received and validated,
 * and either its Poll bit was set, or a paramter within
 * the Control Packet differs the microcode Endpoint Entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exc_oam_param_change_get(int unit, uint32 *vp);

/**
 * Get constant EXC_BAD_OUTER_LABEL_IDX value.
 *
 * MPLS TP Outer label is incorrect or not configured
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exc_bad_outer_label_idx_get(int unit, uint32 *vp);

/**
 * Get constant EXC_BAD_INNER_LABEL_IDX value.
 *
 * MPLS TP Inner label is incorrect or not configured
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exc_bad_inner_label_idx_get(int unit, uint32 *vp);

/**
 * Get constant EXC_LSP_PING_IDX value.
 *
 * MPLS LSP Ping request received
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exc_lsp_ping_idx_get(int unit, uint32 *vp);

/**
 * Get constant EXC_TOO_MANY_LABELS_IDX value.
 *
 * MPLS TP cannot handle more than 2 labels. It can handle an additional optional GAL label on non-pwe3 LSP
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exc_too_many_labels_idx_get(int unit, uint32 *vp);

/**
 * Get constant EXC_EGR_DROP_TAGGED_IDX value.
 *
 * Egress drop tagged packet exception index.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exc_egr_drop_tagged_idx_get(int unit, uint32 *vp);

/**
 * Get constant EXC_EGR_DROP_UNTAGGED_IDX value.
 *
 * Egress drop untagged packet exception index.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exc_egr_drop_untagged_idx_get(int unit, uint32 *vp);

/**
 * Get constant EXC_EGR_OAM_LINK_IDX value.
 *
 * Egress OAM Link Loopback packet exception index.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exc_egr_oam_link_idx_get(int unit, uint32 *vp);

/**
 * Get constant EXC_OAM_EP_INVALID_IDX value.
 *
 * No valid endpoint entry for received OAM message.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exc_oam_ep_invalid_idx_get(int unit, uint32 *vp);

/**
 * Get constant EXC_DCN_IDX value.
 *
 * DCN Management Commuication or Signaling Communication message.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exc_dcn_idx_get(int unit, uint32 *vp);

/**
 * Get constant EXC_MPLS_FILTER_IDX value.
 *
 * MPLS is disabled on the port hence mpls packets are filtered
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exc_mpls_filter_idx_get(int unit, uint32 *vp);

/**
 * Get constant EXC_MIN_FREE_EXCEPTION value.
 *
 * Minimum unused exception index.
 * Exceptions between this value and <tt>MAX_FREE_EXCEPTION</tt>
 * can be used arbitrarily by software for FTE-based
 * exception indexes.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exc_min_free_exception_get(int unit, uint32 *vp);

/**
 * Get constant MAX_FREE_EXCEPTION value.
 *
 * Maximum unused exception index.
 * Exceptions between <tt>MAX_FREE_EXCEPTION</tt> and this
 * value and can be used arbitrarily by software for FTE-based
 * exception indexes.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_max_free_exception_get(int unit, uint32 *vp);

/**
 * Get constant EXC_SMAC_LEARN_IDX value.
 *
 * Unknown SMAC exception index.
 * This exception is signalled when a (VLAN, SMAC) pair is
 * either not present in the MAC table, or is present with a
 * different PID than where the packet was received.
 * <br><br>A learning exception packet can be generated
 * in addition to normal forwarding or any other
 * exception packets.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exc_smac_learn_idx_get(int unit, uint32 *vp);

/**
 * Get constant EXC_PIM_IDX value.
 *
 * PIM protocol message exception index.
 * This exception is signalled when PIM snooping is enabled
 * on a VLAN and the packet is a PIM protocol message.
 * <br><br>A PIM exception packet can be generated in
 * addition to normal forwarding or any other
 * exception packets.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exc_pim_idx_get(int unit, uint32 *vp);

/**
 * Get constant EXC_IGMP_IDX value.
 *
 * IGMP protocol message exception index.
 * This exception is signalled when IGMP snooping is enabled
 * on a VLAN and the packet is a PIM protocol message.
 * <br><br>An IGMP exception packet can be generated in
 * addition to normal forwarding or any other
 * exception packets.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exc_igmp_idx_get(int unit, uint32 *vp);

/**
 * Get constant EXC_RT_COPY_IDX value.
 *
 * IFP copy exception index.
 * This exception is signalled when a packet matches an
 * IFP rule with the copy bit set.
 * <br><br>An IFP copy exception packet can be generated in
 * addition to normal forwarding or any other
 * exception packets.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exc_rt_copy_idx_get(int unit, uint32 *vp);

/**
 * Get constant EXC_L2CP_COPY_IDX value.
 *
 * L2CP copy exception index.
 * This exception is signalled when an L2CP table entry
 * copy bit is set.
 * <br><br>An L2CP copy exception packet can be generated in
 * addition to normal forwarding or any other
 * exception packets.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exc_l2cp_copy_idx_get(int unit, uint32 *vp);

/**
 * Get constant EXC_DMAC_COPY_IDX value.
 *
 * DMAC copy exception index.
 * This exception is signalled when a DMAC table entry
 * copy bit is set.
 * <br><br>A DMAC copy exception packet can be generated in
 * addition to normal forwarding or any other
 * exception packets.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exc_dmac_copy_idx_get(int unit, uint32 *vp);

/**
 * Get constant EXC_IPREDIRECT_IDX value.
 *
 * IP redirect exception index.
 * This exception is signalled when an IP-forwarded packet
 * arrives on the same VLAN (interface) it is sent on.
 * This signal is typically used to send an ICMP
 * redirect message to the packet source.
 * <br><br>An IP redirect exception packet can be generated in
 * addition to normal forwarding or any other
 * exception packets.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exc_ipredirect_idx_get(int unit, uint32 *vp);

/**
 * Get constant EXC_BMAC_LEARN_IDX value.
 *
 * Unknown BMAC exception index (for MiM).
 * This exception is signalled when a (BVLAN, BSMAC) pair is
 * either not present in the MAC table, or is present with a
 * different PID than where the packet was received.
 * <br><br>A learning exception packet can be generated
 * in addition to normal forwarding or any other
 * exception packets.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exc_bmac_learn_idx_get(int unit, uint32 *vp);

/**
 * Get constant EXC_COPY_MAX_IDX value.
 *
 * HIDE
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exc_copy_max_idx_get(int unit, uint32 *vp);

/**
 * Get constant HTYPE_ERH value.
 *
 * PPE/PED ERH header code.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_htype_erh_get(int unit, uint32 *vp);

/**
 * Get constant HTYPE_ETYPE value.
 *
 * PPE/PED Ingress Ethertype header code.
 * Only the ingress processing splits the Ethernet header
 * and Ethertype fields.  Egress processing does not use a
 * separate Ethertype header code.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_htype_etype_get(int unit, uint32 *vp);

/**
 * Get constant HTYPE_ETH value.
 *
 * HIDE
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_htype_eth_get(int unit, uint32 *vp);

/**
 * Get constant HTYPE_IETH value.
 *
 * PPE/PED Ingress Ethernet header code.
 * The PPE/PED ingress Ethernet header includes only DMAC and
 * SMAC fields.  Ethertypes are parsed separately, or included
 * in <tt>HTYPE_VTAG</tt> or <tt>HTYPE_MIM</tt> headers, 
 * and 802.1 length fields are included in <tt>HTYPE_LLC</tt>
 * and <tt>HTYPE_SNAP</tt> headers.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_htype_ieth_get(int unit, uint32 *vp);

/**
 * Get constant HTYPE_LLC value.
 *
 * PPE/PED Ingress LLC header code.
 * The PPE/PED ingress LLC header includes only the packet
 * length field.  The SSAP, DSAP and control bytes fall under
 * the next header, which is guaranteed to be
 * <tt>HTYPE_UNKN</tt>.
 * <br><br>An LLC header is only parsed if the packet is not
 * a SNAP packet.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_htype_llc_get(int unit, uint32 *vp);

/**
 * Get constant HTYPE_SNAP value.
 *
 * PPE/PED Ingress SNAP header code.
 * The PPE/PED ingress SNAP header includes packet length, 
 * SSAP, DSAP, control byte and OUI.  The subsequent Ethertype
 * is parsed as a separate <tt>HTYPE_ETYPE</tt> header.
 * <br><br>A SNAP header includes both LLC and SNAP
 * information.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_htype_snap_get(int unit, uint32 *vp);

/**
 * Get constant HTYPE_VTAG value.
 *
 * PPE/PED VLAN tag header code.
 * A VLAN tag header for ingress processing includes the TPID
 * and the tag information.
 * <br><br>A VLAN tag header for egress
 * processing includes the tag information and the
 * <i>following</i> Ethertype.  In addition, the egress
 * processing will only parse at most one VLAN tag.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_htype_vtag_get(int unit, uint32 *vp);

/**
 * Get constant HTYPE_DVTAG value.
 *
 * PPE/PED Data VLAN tag header code.
 * A VLAN tag header including the TPID and tag information
 * that is not relevant for VLAN tag processing.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_htype_dvtag_get(int unit, uint32 *vp);

/**
 * Get constant HTYPE_MPLS value.
 *
 * PPE/PED MPLS label header code.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_htype_mpls_get(int unit, uint32 *vp);

/**
 * Get constant HTYPE_IPV4 value.
 *
 * PPE/PED IPv4 header code.
 * An IPv4 header includes the IP header itself, and whatever
 * options are contained within the header.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_htype_ipv4_get(int unit, uint32 *vp);

/**
 * Get constant HTYPE_IPV6 value.
 *
 * PPE/PED IPv6 header code.
 * An IPv6 header includes the IPv6 header, but does not
 * include any option headers.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_htype_ipv6_get(int unit, uint32 *vp);

/**
 * Get constant HTYPE_ACH value.
 *
 * PPE/PED ACH header code.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_htype_ach_get(int unit, uint32 *vp);

/**
 * Get constant HTYPE_MIM value.
 *
 * PPE/PED Mac-In-Mac tag header code.
 * The PPE/PED MAC-in-MAC header includes the 802.1ah
 * Mac-in-Mac I-Tag Ethertype and the I-Tag tag information
 * (I-Tag and PCP).
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_htype_mim_get(int unit, uint32 *vp);

/**
 * Get constant HTYPE_ELEN value.
 *
 * PED Embedded Length header code.
 * The first byte of this header is the length of the
 * remainder of the header.  This header is used by
 * egress processing to add encapsulation data to 
 * packets.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_htype_elen_get(int unit, uint32 *vp);

/**
 * Get constant HTYPE_UNKN value.
 *
 * PPE/PED Unknown header code.
 * All header parsing must end with an unknown header.  This
 * header includes all remaining, unparsed data from the
 * header record.  On ingress, the unknown header marks
 * the beginning of layer-4 (TCP, UDP, etc) fields, and this
 * marking is used for assembling the IFP classification key.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_htype_unkn_get(int unit, uint32 *vp);

/**
 * Get constant TRAP_OAMLABELPRESENT value.
 *
 * PPE variable flag for MPLS packets with an OAM Label, or
 * PPE variable flag for CCM packets in the up direction.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_trap_oamlabelpresent_get(int unit, uint32 *vp);

/**
 * Get constant TRAP_LINKLOOPBACK value.
 *
 * PPE variable flag for 802.3ah link OAM loopback packets.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_trap_linkloopback_get(int unit, uint32 *vp);

/**
 * Get constant LSMAC_TABLE_SIZE value.
 *
 * Maximum ingress PPE local station entries.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_lsmac_table_size_get(int unit, uint32 *vp);

/**
 * Get constant L2CPMAC_TABLE_SIZE value.
 *
 * Maximum ingress PPE L2CP 5 byte MAC address prefixes.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_l2cpmac_table_size_get(int unit, uint32 *vp);

/**
 * Get constant OAMUPMAC_TABLE_SIZE value.
 *
 * Maximum egress OAM Local Station MAC address matches.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oamupmac_table_size_get(int unit, uint32 *vp);

/**
 * Get constant OAMEPREMAP_C2_TABLE_SIZE value.
 *
 * Table size on Caladan2 devices.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oamepremap_c2_table_size_get(int unit, uint32 *vp);

/**
 * Get constant OAMMULTIPLIER_C2_TABLE_SIZE value.
 *
 * Table size on Caladan2 devices.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oammultiplier_c2_table_size_get(int unit, uint32 *vp);

/**
 * Get constant EGRCTR_CA_COUNTER_SIZE value.
 *
 * Egress counter size on Caladan devices.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_egrctr_ca_counter_size_get(int unit, uint32 *vp);

/**
 * Get constant MAC_CA_TABLE_SIZE value.
 *
 * Egress counter size on Caladan devices.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_mac_ca_table_size_get(int unit, uint32 *vp);

/**
 * Get constant PTYPE_UNKNOWN_UNICAST value.
 *
 * Ingress unknown unicast typed policing & counting offset.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_ptype_unknown_unicast_get(int unit, uint32 *vp);

/**
 * Get constant PTYPE_KNOWN_UNICAST value.
 *
 * Ingress known unicast typed policing & counting offset.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_ptype_known_unicast_get(int unit, uint32 *vp);

/**
 * Get constant PTYPE_MULTICAST value.
 *
 * Ingress multicast typed policing & counting offset.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_ptype_multicast_get(int unit, uint32 *vp);

/**
 * Get constant PTYPE_BROADCAST value.
 *
 * Ingress broadcast typed policing & counting offset.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_ptype_broadcast_get(int unit, uint32 *vp);

/**
 * Get constant PTYPE_LAST value.
 *
 * Ingress maximum typed policing & counting offset.
 * This value is used by the SDK to manage counter and policer
 * resources for typed counting and policing.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_ptype_last_get(int unit, uint32 *vp);

/**
 * Get constant CUCKOO_TYPE_PVV value.
 *
 * EM32 pvv2e entry type code.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_cuckoo_type_pvv_get(int unit, uint32 *vp);

/**
 * Get constant CUCKOO_TYPE_ISID value.
 *
 * EM32 MiM isid2e entry type code.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_cuckoo_type_isid_get(int unit, uint32 *vp);

/**
 * Get constant CUCKOO_TYPE_PVD value.
 *
 * EM32 OAM pvd2e entry type code.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_cuckoo_type_pvd_get(int unit, uint32 *vp);

/**
 * Get constant CUCKOO_TYPE_MAIDMEP value.
 *
 * EM32 OAM maidmep2e entry type code.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_cuckoo_type_maidmep_get(int unit, uint32 *vp);

/**
 * Get constant CUCKOO_TYPE_SHIFT value.
 *
 * EM32 entry type code shift.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_cuckoo_type_shift_get(int unit, uint32 *vp);

/**
 * Get constant OAM_EP_SUBTYPE_CCM value.
 *
 * Endpoint subtype CCM.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_ep_subtype_ccm_get(int unit, uint32 *vp);

/**
 * Get constant OAM_EP_SUBTYPE_LM value.
 *
 * Endpoint subtype LM.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_ep_subtype_lm_get(int unit, uint32 *vp);

/**
 * Get constant OAM_EP_SUBTYPE_DM value.
 *
 * Endpoint subtype DM.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_ep_subtype_dm_get(int unit, uint32 *vp);

/**
 * Get constant OAM_EP_SUBTYPE_SHIFT value.
 *
 * oamMdlevelType table index offset for subtype.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_ep_subtype_shift_get(int unit, uint32 *vp);

/**
 * Get constant OAM_TYPE_INVALID value.
 *
 * OAM Network Type Invalid.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_type_invalid_get(int unit, uint32 *vp);

/**
 * Get constant OAM_TYPE_ENET value.
 *
 * OAM Network Type Ethernet.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_type_enet_get(int unit, uint32 *vp);

/**
 * Get constant OAM_TYPE_MPLS_PWE value.
 *
 * OAM Network Type MPLS (PWE).
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_type_mpls_pwe_get(int unit, uint32 *vp);

/**
 * Get constant OAM_TYPE_MPLS_LSP value.
 *
 * OAM Network Type MPLS (LSP).
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_type_mpls_lsp_get(int unit, uint32 *vp);

/**
 * Get constant OAM_FUNCTION_UNUSED value.
 *
 * Unused (invalid) Endpoint Entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_function_unused_get(int unit, uint32 *vp);

/**
 * Get constant OAM_FUNCTION_BFD value.
 *
 * BFD entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_function_bfd_get(int unit, uint32 *vp);

/**
 * Get constant OAM_FUNCTION_LM value.
 *
 * Single and Dual ended LM entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_function_lm_get(int unit, uint32 *vp);

/**
 * Get constant OAM_FUNCTION_DM value.
 *
 * One and Two way DM entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_function_dm_get(int unit, uint32 *vp);

/**
 * Get constant OAM_FUNCTION_CCM_FIRST value.
 *
 * CCM Local First entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_function_ccm_first_get(int unit, uint32 *vp);

/**
 * Get constant OAM_FUNCTION_CCM_SECOND value.
 *
 * CCM Local Second entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_function_ccm_second_get(int unit, uint32 *vp);

/**
 * Get constant OAM_FUNCTION_CCM_PEER value.
 *
 * CCM Peer (remote) entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_function_ccm_peer_get(int unit, uint32 *vp);

/**
 * Get constant OAM_FUNCTION_PSC value.
 *
 * PSC entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_function_psc_get(int unit, uint32 *vp);

/**
 * Get constant OAM_FUNCTION_PM value.
 *
 * Upper two bits of the function field.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_function_pm_get(int unit, uint32 *vp);

/**
 * Get constant OAM_FUNCTION_CCM_LOCAL value.
 *
 * Upper two bits of the function field.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_function_ccm_local_get(int unit, uint32 *vp);

/**
 * Get constant OAM_NUM_ENDPOINTS value.
 *
 * Maximum number of supported OAM endpoints.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_num_endpoints_get(int unit, uint32 *vp);

/**
 * Get constant OAM_MAX_CALENDAR value.
 *
 * Length of OAM transmit calendar.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_max_calendar_get(int unit, uint32 *vp);

/**
 * Get constant OAM_BUBBLE_TIMEOUT value.
 *
 * OAM transmit bubble timeout value.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_bubble_timeout_get(int unit, uint32 *vp);

/**
 * Get constant OAM_LIST_MGR_SIZE value.
 *
 * Number of entries in the list manager.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_list_mgr_size_get(int unit, uint32 *vp);

/**
 * Get constant OAM_LIST_MGR_SIZE_CA value.
 *
 * Number of entries in the list manager.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_list_mgr_size_ca_get(int unit, uint32 *vp);

/**
 * Get constant OAM_BUBBLE_TIMER_ADDR value.
 *
 * Service Processor address of bubble-timer period.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_bubble_timer_addr_get(int unit, uint32 *vp);

/**
 * Get constant OAM_LIST_MGR_ADDR value.
 *
 * Service Processor address of list-manager access.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_list_mgr_addr_get(int unit, uint32 *vp);

/**
 * Get constant OAM_INTERVAL1 value.
 *
 * OAM 3.3 ms interval (in ms).
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_interval1_get(int unit, uint32 *vp);

/**
 * Get constant OAM_INTERVAL2 value.
 *
 * OAM 10 ms interval (in ms).
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_interval2_get(int unit, uint32 *vp);

/**
 * Get constant OAM_INTERVAL3 value.
 *
 * OAM 100 ms interval (in ms).
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_interval3_get(int unit, uint32 *vp);

/**
 * Get constant OAM_INTERVAL4 value.
 *
 * OAM 1 sec interval (in ms).
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_interval4_get(int unit, uint32 *vp);

/**
 * Get constant OAM_INTERVAL5 value.
 *
 * OAM 10 sec interval (in ms).
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_interval5_get(int unit, uint32 *vp);

/**
 * Get constant OAM_INTERVAL6 value.
 *
 * OAM 1 min interval (in ms).
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_interval6_get(int unit, uint32 *vp);

/**
 * Get constant OAM_INTERVAL7 value.
 *
 * OAM 10 min interval (in ms).
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_interval7_get(int unit, uint32 *vp);

/**
 * Get constant OAM_REMOTE_EP_BASE value.
 *
 * OAM Local Endpoint reserved entries.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_remote_ep_base_get(int unit, uint32 *vp);

/**
 * Get constant MAX_QOS_PROFILE_INDEX value.
 *
 * Maximum Qos profile index.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_max_qos_profile_index_get(int unit, uint32 *vp);

/**
 * Get constant MAX_QOS_MAP_TABLE value.
 *
 * Maximum Qos map tables.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_max_qos_map_table_get(int unit, uint32 *vp);

/**
 * Get constant MAX_QOS_REMARK_TABLE value.
 *
 * Maximum Pri remark tables.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_max_qos_remark_table_get(int unit, uint32 *vp);

/**
 * Get constant MAX_L2CP_TYPES value.
 *
 * Maximum L2CP types.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_max_l2cp_types_get(int unit, uint32 *vp);

/**
 * Get constant MAX_L2CP_SUBTYPES value.
 *
 * Maximum L2CP sub-types.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_max_l2cp_subtypes_get(int unit, uint32 *vp);

/**
 * Get constant URPF_DEFAULT_PID value.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_urpf_default_pid_get(int unit, uint32 *vp);

/**
 * Get constant stpstate_forward value.
 *
 * forwarding spanning tree state
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_stpstate_forward_get(int unit, uint32 *vp);

/**
 * Get constant stpstate_block value.
 *
 * blocked spanning tree state
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_stpstate_block_get(int unit, uint32 *vp);

/**
 * Get constant stpstate_learn value.
 *
 * learning spanning tree state
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_stpstate_learn_get(int unit, uint32 *vp);

/**
 * Get constant mplstp_loopback_oam value.
 *
 * MPLSTP OAM loop back, loops back OAM packet only
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_mplstp_loopback_oam_get(int unit, uint32 *vp);

/**
 * Get constant mplstp_loopback_full value.
 *
 * MPLSTP OAM Full loopback, loops back OAM & Data packets
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_mplstp_loopback_full_get(int unit, uint32 *vp);

/**
 * Get constant mplstp_loopback_none value.
 *
 * Disable MPLSTP OAM loop back
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_mplstp_loopback_none_get(int unit, uint32 *vp);

/**
 * Get constant label_lsr value.
 *
 * Tunnel label is a LSR
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_label_lsr_get(int unit, uint32 *vp);

/**
 * Get constant label_eth_pwe3 value.
 *
 * label denotes its an Ethernet Pseudowire
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_label_eth_pwe3_get(int unit, uint32 *vp);

/**
 * Get constant label_ler value.
 *
 * Routing tunnel label is terminated in this hop
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_label_ler_get(int unit, uint32 *vp);

/**
 * Get constant label_ces_pwe3 value.
 *
 * label denotes CES ECID, used for CES PW Handoff.Difference from regular PW is that the packet has not outerEthernet Encapsulation header
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_label_ces_pwe3_get(int unit, uint32 *vp);

/*
 * Global value accessors
 */

/**
 * Set global contexts value.
 *
 * Number of Context switches used in program.
 * The value is initialized to the assembler 
 * max context constraint.
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_contexts_set(int unit, uint32 v);

/**
 * Get global contexts value.
 *
 * Number of Context switches used in program.
 * The value is initialized to the assembler 
 * max context constraint.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_contexts_get(int unit, uint32 *vp);

/**
 * Set global tpid0 value.
 *
 * Egress encapsulation TPID1 value (typically for CTAG)
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_tpid0_set(int unit, uint32 v);

/**
 * Get global tpid0 value.
 *
 * Egress encapsulation TPID1 value (typically for CTAG)
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_tpid0_get(int unit, uint32 *vp);

/**
 * Set global tpid1 value.
 *
 * Egress encapsulation TPID1 value (typically for 
 * 802.1ad SVID)
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_tpid1_set(int unit, uint32 v);

/**
 * Get global tpid1 value.
 *
 * Egress encapsulation TPID1 value (typically for 
 * 802.1ad SVID)
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_tpid1_get(int unit, uint32 *vp);

/**
 * Set global tpid2 value.
 *
 * Egress encapsulation TPID2 value (typically for 
 * a proprietary SVID, e.g. 0x9100 or 0x8100)
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_tpid2_set(int unit, uint32 v);

/**
 * Get global tpid2 value.
 *
 * Egress encapsulation TPID2 value (typically for 
 * a proprietary SVID, e.g. 0x9100 or 0x8100)
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_tpid2_get(int unit, uint32 *vp);

/**
 * Set global defitag value.
 *
 * Default ingress customer tag.  This includes the entire
 * 32-bit tag field, but the only `user servicable' portion is
 * the TPID, which should be kept in sync with the CTPID.
 * It is not anticipated that this value will ever be changed.
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_defitag_set(int unit, uint32 v);

/**
 * Get global defitag value.
 *
 * Default ingress customer tag.  This includes the entire
 * 32-bit tag field, but the only `user servicable' portion is
 * the TPID, which should be kept in sync with the CTPID.
 * It is not anticipated that this value will ever be changed.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_defitag_get(int unit, uint32 *vp);

/**
 * Set global age value.
 *
 * The timestamp written to a SMAC table entry when it is hit.
 * This value should be advanced by the host CPU each time a
 * MAC aging scan is performed.  MAC table entries with age
 * stamps enough older than the current age are eligable to be
 * removed from the MAC table (all under CPU control).
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_age_set(int unit, uint32 v);

/**
 * Get global age value.
 *
 * The timestamp written to a SMAC table entry when it is hit.
 * This value should be advanced by the host CPU each time a
 * MAC aging scan is performed.  MAC table entries with age
 * stamps enough older than the current age are eligable to be
 * removed from the MAC table (all under CPU control).
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_age_get(int unit, uint32 *vp);

/**
 * Set global labelcuckoo_abseed value.
 *
 * The A/B bank bit, and the 31-bit seed for the right half
 * EM32 hash table
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_labelcuckoo_abseed_set(int unit, uint32 v);

/**
 * Get global labelcuckoo_abseed value.
 *
 * The A/B bank bit, and the 31-bit seed for the right half
 * EM32 hash table
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_labelcuckoo_abseed_get(int unit, uint32 *vp);

/**
 * Set global cuckoo_abseed value.
 *
 * The A/B bank bit, and the 31-bit seed for the right half
 * of the EM32 hash table (including pvv2e, isid2e, oampv2e
 * and oammaidmep2e entries).  This value is maintained by the
 * EM32 management code.
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_cuckoo_abseed_set(int unit, uint32 v);

/**
 * Get global cuckoo_abseed value.
 *
 * The A/B bank bit, and the 31-bit seed for the right half
 * of the EM32 hash table (including pvv2e, isid2e, oampv2e
 * and oammaidmep2e entries).  This value is maintained by the
 * EM32 management code.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_cuckoo_abseed_get(int unit, uint32 *vp);

/**
 * Set global node value.
 *
 * SDK module identifier for an FE.
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_node_set(int unit, uint32 v);

/**
 * Get global node value.
 *
 * SDK module identifier for an FE.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_node_get(int unit, uint32 *vp);

/**
 * Set global vlan_ft_base value.
 *
 * Base index of per-VLAN flood forwarding table entries.
 * If a system requires fewer than the maximum number of
 * MAC forwarding port identifiers (PIDs), this value can
 * be reduced.  Reducing this value could either increase
 * the number of FT entries available for other purposes
 * (e.g. L2CP, IFP, MPLS or IP forwarding), or reduce the
 * total number of forwarding entries required.
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_vlan_ft_base_set(int unit, uint32 v);

/**
 * Get global vlan_ft_base value.
 *
 * Base index of per-VLAN flood forwarding table entries.
 * If a system requires fewer than the maximum number of
 * MAC forwarding port identifiers (PIDs), this value can
 * be reduced.  Reducing this value could either increase
 * the number of FT entries available for other purposes
 * (e.g. L2CP, IFP, MPLS or IP forwarding), or reduce the
 * total number of forwarding entries required.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_vlan_ft_base_get(int unit, uint32 *vp);

/**
 * Set global vpws_vlan value.
 *
 * HIDE
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_vpws_vlan_set(int unit, uint32 v);

/**
 * Get global vpws_vlan value.
 *
 * HIDE
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_vpws_vlan_get(int unit, uint32 *vp);

/**
 * Set global vpws_ft_offset value.
 *
 * HIDE
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_vpws_ft_offset_set(int unit, uint32 v);

/**
 * Get global vpws_ft_offset value.
 *
 * HIDE
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_vpws_ft_offset_get(int unit, uint32 *vp);

/**
 * Set global eex_mirror0 value.
 *
 * The FE hardware mirror index identifier used to
 * send egress exception packets on ports <= 12 to the CPU.
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_eex_mirror0_set(int unit, uint32 v);

/**
 * Get global eex_mirror0 value.
 *
 * The FE hardware mirror index identifier used to
 * send egress exception packets on ports <= 12 to the CPU.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_eex_mirror0_get(int unit, uint32 *vp);

/**
 * Set global eex_mirror1 value.
 *
 * The FE hardware mirror index identifier used to
 * send egress exception packets on ports > 12 to the CPU.
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_eex_mirror1_set(int unit, uint32 v);

/**
 * Get global eex_mirror1 value.
 *
 * The FE hardware mirror index identifier used to
 * send egress exception packets on ports > 12 to the CPU.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_eex_mirror1_get(int unit, uint32 *vp);

/**
 * Set global max_pids value.
 *
 * The maximum forwarding port identifier value.  This
 * value is used to determine the first lp table entry
 * associated with an MPLS label.  The lp table address for
 * an MPLS label will be label[15:0] + GLOBAL_MAX_PIDS.
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_max_pids_set(int unit, uint32 v);

/**
 * Get global max_pids value.
 *
 * The maximum forwarding port identifier value.  This
 * value is used to determine the first lp table entry
 * associated with an MPLS label.  The lp table address for
 * an MPLS label will be label[15:0] + GLOBAL_MAX_PIDS.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_max_pids_get(int unit, uint32 *vp);

/**
 * Set global mc_ft_offset value.
 *
 * The value added to the flood FT index for multicast
 * packets.  This allows different
 * flooding functions for unknown unicast and unknown 
 * L2 multicast packets.  Set this value to 0 to use
 * the same flooding FT entries for all unknown traffic.
 * Set it to the maximum number of active VLANs to provide
 * different flood FT entries for unknown unicast and
 * unknown multicast packets.
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_mc_ft_offset_set(int unit, uint32 v);

/**
 * Get global mc_ft_offset value.
 *
 * The value added to the flood FT index for multicast
 * packets.  This allows different
 * flooding functions for unknown unicast and unknown 
 * L2 multicast packets.  Set this value to 0 to use
 * the same flooding FT entries for all unknown traffic.
 * Set it to the maximum number of active VLANs to provide
 * different flood FT entries for unknown unicast and
 * unknown multicast packets.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_mc_ft_offset_get(int unit, uint32 *vp);

/**
 * Set global oam_drop_bit value.
 *
 * Drop terminated OAM continuity check messages.  This bit
 * is only set to 0 for microcode testing purpose.
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_oam_drop_bit_set(int unit, uint32 v);

/**
 * Get global oam_drop_bit value.
 *
 * Drop terminated OAM continuity check messages.  This bit
 * is only set to 0 for microcode testing purpose.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_drop_bit_get(int unit, uint32 *vp);

/**
 * Set global oam_enet_continue_byte value.
 *
 * The number of bytes read from ped dscr (no erh) for Enet CCM frames.
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_oam_enet_continue_byte_set(int unit, uint32 v);

/**
 * Get global oam_enet_continue_byte value.
 *
 * The number of bytes read from ped dscr (no erh) for Enet CCM frames.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_enet_continue_byte_get(int unit, uint32 *vp);

/**
 * Set global oam_mpls_continue_byte value.
 *
 * The number of bytes read from ped dscr (no erh) for MPLS CC frames.
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_oam_mpls_continue_byte_set(int unit, uint32 v);

/**
 * Get global oam_mpls_continue_byte value.
 *
 * The number of bytes read from ped dscr (no erh) for MPLS CC frames.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_mpls_continue_byte_get(int unit, uint32 *vp);

/**
 * Set global oam_enet_frame_len value.
 *
 * The total number of bytes in the packet (no erh)
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_oam_enet_frame_len_set(int unit, uint32 v);

/**
 * Get global oam_enet_frame_len value.
 *
 * The total number of bytes in the packet (no erh)
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_enet_frame_len_get(int unit, uint32 *vp);

/**
 * Set global oam_mpls_frame_len value.
 *
 * The total number of bytes in the packet (no erh)
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_oam_mpls_frame_len_set(int unit, uint32 v);

/**
 * Get global oam_mpls_frame_len value.
 *
 * The total number of bytes in the packet (no erh)
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_mpls_frame_len_get(int unit, uint32 *vp);

/**
 * Set global oam_source_queue value.
 *
 * This is the source queue for bubbles
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_oam_source_queue_set(int unit, uint32 v);

/**
 * Get global oam_source_queue value.
 *
 * This is the source queue for bubbles
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_source_queue_get(int unit, uint32 *vp);

/**
 * Set global oam_dest_queue value.
 *
 * Destination queue
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_oam_dest_queue_set(int unit, uint32 v);

/**
 * Get global oam_dest_queue value.
 *
 * Destination queue
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_dest_queue_get(int unit, uint32 *vp);

/**
 * Set global oam_source_buffer value.
 *
 * This is a special buffer alocated for OAM packets
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_oam_source_buffer_set(int unit, uint32 v);

/**
 * Get global oam_source_buffer value.
 *
 * This is a special buffer alocated for OAM packets
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_source_buffer_get(int unit, uint32 *vp);

/**
 * Set global oam_bubble_timer_offset value.
 *
 * All ones turns the timer off.  This value will be
 * updated when the bubble timer is turned on.
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_oam_bubble_timer_offset_set(int unit, uint32 v);

/**
 * Get global oam_bubble_timer_offset value.
 *
 * All ones turns the timer off.  This value will be
 * updated when the bubble timer is turned on.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_bubble_timer_offset_get(int unit, uint32 *vp);

/**
 * Set global oam_sa_lm value.
 *
 * Code used by Egress PPE to detect OAM LM frames.
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_oam_sa_lm_set(int unit, uint32 v);

/**
 * Get global oam_sa_lm value.
 *
 * Code used by Egress PPE to detect OAM LM frames.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_sa_lm_get(int unit, uint32 *vp);

/**
 * Set global oam_sa_dm value.
 *
 * Code used by Egress PPE to detect OAM DM frames.
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_oam_sa_dm_set(int unit, uint32 v);

/**
 * Get global oam_sa_dm value.
 *
 * Code used by Egress PPE to detect OAM DM frames.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_sa_dm_get(int unit, uint32 *vp);

/**
 * Set global oam_mpls_sa_lm value.
 *
 * Code used by Egress PPE to detect OAM MPLS LM frames.
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_oam_mpls_sa_lm_set(int unit, uint32 v);

/**
 * Get global oam_mpls_sa_lm value.
 *
 * Code used by Egress PPE to detect OAM MPLS LM frames.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_mpls_sa_lm_get(int unit, uint32 *vp);

/**
 * Set global oam_mpls_sa_dm value.
 *
 * Code used by Egress PPE to detect OAM MPLS DM frames.
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_oam_mpls_sa_dm_set(int unit, uint32 v);

/**
 * Get global oam_mpls_sa_dm value.
 *
 * Code used by Egress PPE to detect OAM MPLS DM frames.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_mpls_sa_dm_get(int unit, uint32 *vp);

/**
 * Set global oam_pwe_ip_sa value.
 *
 * For CV-Type IP/UDP Encap; IP SA for all BFD endpoints.
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_oam_pwe_ip_sa_set(int unit, uint32 v);

/**
 * Get global oam_pwe_ip_sa value.
 *
 * For CV-Type IP/UDP Encap; IP SA for all BFD endpoints.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_pwe_ip_sa_get(int unit, uint32 *vp);

/**
 * Set global oam_pwe_udp_dest_port value.
 *
 * For CV-Type IP/UDP Encap; UDP Src Port for all BFD endpoints.
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_oam_pwe_udp_dest_port_set(int unit, uint32 v);

/**
 * Get global oam_pwe_udp_dest_port value.
 *
 * For CV-Type IP/UDP Encap; UDP Src Port for all BFD endpoints.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_pwe_udp_dest_port_get(int unit, uint32 *vp);

/**
 * Set global oam_mirror_index value.
 *
 * Egress mirror index to be used by egress OAM stream
 * to mirror down-MEP loopkup misses back into ingress
 * OAM receive stream for up-MEP lookup.
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_oam_mirror_index_set(int unit, uint32 v);

/**
 * Get global oam_mirror_index value.
 *
 * Egress mirror index to be used by egress OAM stream
 * to mirror down-MEP loopkup misses back into ingress
 * OAM receive stream for up-MEP lookup.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_mirror_index_get(int unit, uint32 *vp);

/**
 * Set global oam_loopback_qid value.
 *
 * The QID used to route packets back to ingress.
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_oam_loopback_qid_set(int unit, uint32 v);

/**
 * Get global oam_loopback_qid value.
 *
 * The QID used to route packets back to ingress.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_loopback_qid_get(int unit, uint32 *vp);

/**
 * Set global oam_sa_4lo value.
 *
 * This SMAC is applied to all OAM packets being generated
 * in micro-code.  For down MEPs this temporary SMAC will
 * be over-written in egress processing using the SMAC index
 * in the ETE.  The ETE will point to the SMAC provided in
 * Endpoint-Info structure when the endpoint was created.
 * For up MEPs, this SMAC isnt just temporary, it will be
 * the SMAC on the packet as it is transmitted.  Furthermore,
 * for all up MIPs this is the SMAC that will be used for
 * Local Station Match.  Since this SMAC is shared among
 * all up MEPs, they should all use the same SMAC in the
 * Endpoint-Info structure when configuring up MEP/MIPs.
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_oam_sa_4lo_set(int unit, uint32 v);

/**
 * Get global oam_sa_4lo value.
 *
 * This SMAC is applied to all OAM packets being generated
 * in micro-code.  For down MEPs this temporary SMAC will
 * be over-written in egress processing using the SMAC index
 * in the ETE.  The ETE will point to the SMAC provided in
 * Endpoint-Info structure when the endpoint was created.
 * For up MEPs, this SMAC isnt just temporary, it will be
 * the SMAC on the packet as it is transmitted.  Furthermore,
 * for all up MIPs this is the SMAC that will be used for
 * Local Station Match.  Since this SMAC is shared among
 * all up MEPs, they should all use the same SMAC in the
 * Endpoint-Info structure when configuring up MEP/MIPs.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_sa_4lo_get(int unit, uint32 *vp);

/**
 * Set global oam_sa_2hi value.
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_oam_sa_2hi_set(int unit, uint32 v);

/**
 * Get global oam_sa_2hi value.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_sa_2hi_get(int unit, uint32 *vp);

/**
 * Set global oam_sa_4lo_aux value.
 *
 * Second SMAC for appliction to use for up MIP LSM.
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_oam_sa_4lo_aux_set(int unit, uint32 v);

/**
 * Get global oam_sa_4lo_aux value.
 *
 * Second SMAC for appliction to use for up MIP LSM.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_sa_4lo_aux_get(int unit, uint32 *vp);

/**
 * Set global oam_sa_2hi_aux value.
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_oam_sa_2hi_aux_set(int unit, uint32 v);

/**
 * Get global oam_sa_2hi_aux value.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_sa_2hi_aux_get(int unit, uint32 *vp);

/**
 * Set global oam_bfd_state_table value.
 *
 * Received BFD Control Packets contain the peer
 * (or remote) endpoint's state.  If the peer's state
 * changes, it might trigger the local endpoint's state
 * to change as well.  This table is a bit mask used to
 * signal to the microcode that the peer state and the
 * local state should result in the BFD control packet
 * being sent up to the host application.  The mask is
 * formed by assigning a value (0 or 1) to each combination
 * of peer state and local state.  0 is a nop, 1 says to
 * exception the packet to the host.  The bits are
 * arranged:  (action << peer_state) << (local_state * 4).
 * The values of 'state' are from the BFD base spec:
 * Admin-down = 0
 * Down       = 1
 * Init       = 2
 * Up         = 3
 * peer:   3 2 1 0 3 2 1 0 3 2 1 0 3 2 1 0
 * local:  3 3 3 3 2 2 2 2 1 1 1 1 0 0 0 0
 * action: 0 0 1 1 1 1 0 1 0 1 1 0 0 0 0 0 = 0x3D60
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_oam_bfd_state_table_set(int unit, uint32 v);

/**
 * Get global oam_bfd_state_table value.
 *
 * Received BFD Control Packets contain the peer
 * (or remote) endpoint's state.  If the peer's state
 * changes, it might trigger the local endpoint's state
 * to change as well.  This table is a bit mask used to
 * signal to the microcode that the peer state and the
 * local state should result in the BFD control packet
 * being sent up to the host application.  The mask is
 * formed by assigning a value (0 or 1) to each combination
 * of peer state and local state.  0 is a nop, 1 says to
 * exception the packet to the host.  The bits are
 * arranged:  (action << peer_state) << (local_state * 4).
 * The values of 'state' are from the BFD base spec:
 * Admin-down = 0
 * Down       = 1
 * Init       = 2
 * Up         = 3
 * peer:   3 2 1 0 3 2 1 0 3 2 1 0 3 2 1 0
 * local:  3 3 3 3 2 2 2 2 1 1 1 1 0 0 0 0
 * action: 0 0 1 1 1 1 0 1 0 1 1 0 0 0 0 0 = 0x3D60
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_bfd_state_table_get(int unit, uint32 *vp);

/**
 * Set global oam_bfd_rdi_diag_code value.
 *
 * This value is used by the host application to select
 * which BFD Control Packet Diag-Code (0 through 31) is
 * used to indicate RDI.  When the local BFD endpoint
 * entry is configured to transmit RDI it will set this
 * value in the Control Packet's Diag field.  Similarly,
 * the RX ucode will signal to the host application
 * (exception packet) that the peer BFD endpoint has
 * signaled RDI when this value is set in the CP's Diag
 * field.
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_oam_bfd_rdi_diag_code_set(int unit, uint32 v);

/**
 * Get global oam_bfd_rdi_diag_code value.
 *
 * This value is used by the host application to select
 * which BFD Control Packet Diag-Code (0 through 31) is
 * used to indicate RDI.  When the local BFD endpoint
 * entry is configured to transmit RDI it will set this
 * value in the Control Packet's Diag field.  Similarly,
 * the RX ucode will signal to the host application
 * (exception packet) that the peer BFD endpoint has
 * signaled RDI when this value is set in the CP's Diag
 * field.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_bfd_rdi_diag_code_get(int unit, uint32 *vp);

/**
 * Set global oam_tx_packets_per_bubble value.
 *
 * This value determines the max number of packets the
 * TX ucode will transmit for every bubble.
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_oam_tx_packets_per_bubble_set(int unit, uint32 v);

/**
 * Get global oam_tx_packets_per_bubble value.
 *
 * This value determines the max number of packets the
 * TX ucode will transmit for every bubble.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_tx_packets_per_bubble_get(int unit, uint32 *vp);

/**
 * Set global oam_tx_packets_per_bubble_ca value.
 *
 * This value determines the max number of packets the
 * TX ucode will transmit for every bubble (caladan 1).
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_oam_tx_packets_per_bubble_ca_set(int unit, uint32 v);

/**
 * Get global oam_tx_packets_per_bubble_ca value.
 *
 * This value determines the max number of packets the
 * TX ucode will transmit for every bubble (caladan 1).
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_tx_packets_per_bubble_ca_get(int unit, uint32 *vp);

/**
 * Set global oam_psc_rx_filter value.
 *
 * This is the PSC RX Filter value.  The RX Filter is
 * used to drop the all burst packets after the first.
 * The first burst packet received will go to the host
 * application (exception path) and all other PSC messages
 * received from this tunnel within the rx filter time
 * will be dropped.  The exception being that if there
 * is a change in the received PSC message from the 
 * previously received PSC message, then it is assumed
 * that a new burst has been started, the message
 * containing the change will be exceptioned to the host,
 * and the rx filter period will be re-started.  Currently
 * this filter time is set to 1 second.
 * 3.3 ms * 303 = 1 sec.
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_oam_psc_rx_filter_set(int unit, uint32 v);

/**
 * Get global oam_psc_rx_filter value.
 *
 * This is the PSC RX Filter value.  The RX Filter is
 * used to drop the all burst packets after the first.
 * The first burst packet received will go to the host
 * application (exception path) and all other PSC messages
 * received from this tunnel within the rx filter time
 * will be dropped.  The exception being that if there
 * is a change in the received PSC message from the 
 * previously received PSC message, then it is assumed
 * that a new burst has been started, the message
 * containing the change will be exceptioned to the host,
 * and the rx filter period will be re-started.  Currently
 * this filter time is set to 1 second.
 * 3.3 ms * 303 = 1 sec.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_psc_rx_filter_get(int unit, uint32 *vp);

/**
 * Set global oam_local_fe_qid value.
 *
 * Used internally by the OAM ucode for up MEP PM
 * endpoints.  This QID needs to be any valid QID on
 * the local FE that can be used to forward OAM PM
 * messages back to the same FE's egress stream for
 * further OAM PM processing.
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_oam_local_fe_qid_set(int unit, uint32 v);

/**
 * Get global oam_local_fe_qid value.
 *
 * Used internally by the OAM ucode for up MEP PM
 * endpoints.  This QID needs to be any valid QID on
 * the local FE that can be used to forward OAM PM
 * messages back to the same FE's egress stream for
 * further OAM PM processing.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oam_local_fe_qid_get(int unit, uint32 *vp);

/**
 * Set global blackhole_vlan value.
 *
 * Packets on this VLAN are dropped.
 * The IP and MPLS forwarding microcode explicitly test
 * a VLAN against this value to determine whether a
 * <tt>EXC_VLAN_DROP_IDX</tt> should be taken.  Bridging
 * forwarding microcode
 * implicitly uses this value by having the SDK configure
 * its flooding FTE to take a <tt>EXC_VLAN_DROP_IDX</tt>
 * exception.  Drop tagged, drop untagged, and ingress VLAN
 * filtering behaviors are implemented by selectively
 * configuring <tt>pv2e</tt> and <tt>pvv2e</tt> entries
 * with this blackhole VLAN.
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_blackhole_vlan_set(int unit, uint32 v);

/**
 * Get global blackhole_vlan value.
 *
 * Packets on this VLAN are dropped.
 * The IP and MPLS forwarding microcode explicitly test
 * a VLAN against this value to determine whether a
 * <tt>EXC_VLAN_DROP_IDX</tt> should be taken.  Bridging
 * forwarding microcode
 * implicitly uses this value by having the SDK configure
 * its flooding FTE to take a <tt>EXC_VLAN_DROP_IDX</tt>
 * exception.  Drop tagged, drop untagged, and ingress VLAN
 * filtering behaviors are implemented by selectively
 * configuring <tt>pv2e</tt> and <tt>pvv2e</tt> entries
 * with this blackhole VLAN.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_blackhole_vlan_get(int unit, uint32 *vp);

/**
 * Set global igmp_proxy_mode value.
 *
 * IPv4 IGMP and IPv6 MLD packets are redirected.
 * There are two modes of operations to choose from:
 * transparent snooping and proxy mode.
 * When configured as proxy, IGMP/MLD packets are not
 * forwarded but redirected to CPU.
 * When configured as transparent snoop, IGMP/MLD packets
 * are forwarded and a copy is made/sent to CPU.
 * Snoop/Proxy can be diabled per vlan basis
 * via <tt>v2e</tt> entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_igmp_proxy_mode_set(int unit, uint32 v);

/**
 * Get global igmp_proxy_mode value.
 *
 * IPv4 IGMP and IPv6 MLD packets are redirected.
 * There are two modes of operations to choose from:
 * transparent snooping and proxy mode.
 * When configured as proxy, IGMP/MLD packets are not
 * forwarded but redirected to CPU.
 * When configured as transparent snoop, IGMP/MLD packets
 * are forwarded and a copy is made/sent to CPU.
 * Snoop/Proxy can be diabled per vlan basis
 * via <tt>v2e</tt> entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_igmp_proxy_mode_get(int unit, uint32 *vp);

/**
 * Set global static_lag value.
 *
 * VLAN based static LAG is enabled.
 * There are two modes of operations to choose from:
 * hash based LAG and VLAN based static LAG.
 * When configured as has based LAG, LAG port will be
 * selected based on hash value.
 * When configured as VLAN based static LAG,
 * LAG port can be selected per vlan basis
 * via <tt>v2e</tt> entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_static_lag_set(int unit, uint32 v);

/**
 * Get global static_lag value.
 *
 * VLAN based static LAG is enabled.
 * There are two modes of operations to choose from:
 * hash based LAG and VLAN based static LAG.
 * When configured as has based LAG, LAG port will be
 * selected based on hash value.
 * When configured as VLAN based static LAG,
 * LAG port can be selected per vlan basis
 * via <tt>v2e</tt> entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_static_lag_get(int unit, uint32 *vp);

/**
 * Set global ipv4_checksum_mode value.
 *
 * IPv4 Header Checksum validatation in microcode. 
 * A value of 0 disables the check. 
 * A value of 5 will enable the check for IPv4 
 * Header without options.
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_ipv4_checksum_mode_set(int unit, uint32 v);

/**
 * Get global ipv4_checksum_mode value.
 *
 * IPv4 Header Checksum validatation in microcode. 
 * A value of 0 disables the check. 
 * A value of 5 will enable the check for IPv4 
 * Header without options.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_ipv4_checksum_mode_get(int unit, uint32 *vp);

/**
 * Set global exit_filter_on_btag value.
 *
 * Classification on BTAG on MiM Tunnel Exit.
 * By default, CTAG is used for classification.
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_exit_filter_on_btag_set(int unit, uint32 v);

/**
 * Get global exit_filter_on_btag value.
 *
 * Classification on BTAG on MiM Tunnel Exit.
 * By default, CTAG is used for classification.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_exit_filter_on_btag_get(int unit, uint32 *vp);

/**
 * Set global switch_meter_adjust value.
 *
 * Per Packet adjustment for metering and rate control
 * generally used to account for IPG.
 * Number of bytes to add to packet length.
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_switch_meter_adjust_set(int unit, uint32 v);

/**
 * Get global switch_meter_adjust value.
 *
 * Per Packet adjustment for metering and rate control
 * generally used to account for IPG.
 * Number of bytes to add to packet length.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_switch_meter_adjust_get(int unit, uint32 *vp);

/**
 * Set global rc1_rule_startidx value.
 *
 * Starting Rule index in RC1.
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_rc1_rule_startidx_set(int unit, uint32 v);

/**
 * Get global rc1_rule_startidx value.
 *
 * Starting Rule index in RC1.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_rc1_rule_startidx_get(int unit, uint32 *vp);

/**
 * Set global ipv6_acl_enable value.
 *
 * Enable IPv6 ACL processing
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_ipv6_acl_enable_set(int unit, uint32 v);

/**
 * Get global ipv6_acl_enable value.
 *
 * Enable IPv6 ACL processing
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_ipv6_acl_enable_get(int unit, uint32 *vp);

/**
 * Set global oi2eoff value.
 *
 * Offset of oi2e from evp2e.
 * This global is used for internal microcode purposes.
 * It is defined as a global, rather than using
 * UTG-generated base addresses, to permit resizing of the
 * evp2e table (for systems with fewer ports).
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_oi2eoff_set(int unit, uint32 v);

/**
 * Get global oi2eoff value.
 *
 * Offset of oi2e from evp2e.
 * This global is used for internal microcode purposes.
 * It is defined as a global, rather than using
 * UTG-generated base addresses, to permit resizing of the
 * evp2e table (for systems with fewer ports).
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_oi2eoff_get(int unit, uint32 *vp);

/**
 * Set global ete0plus1 value.
 *
 * ETE 0 base plus 1.  This value is used as a microcode
 * optimization
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_ete0plus1_set(int unit, uint32 v);

/**
 * Get global ete0plus1 value.
 *
 * ETE 0 base plus 1.  This value is used as a microcode
 * optimization
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_ete0plus1_get(int unit, uint32 *vp);

/**
 * Set global ete1plus1 value.
 *
 * ETE 1 base plus 1.  This value is used as a microcode
 * optimization
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2p3_ete1plus1_set(int unit, uint32 v);

/**
 * Get global ete1plus1 value.
 *
 * ETE 1 base plus 1.  This value is used as a microcode
 * optimization
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2p3_ete1plus1_get(int unit, uint32 *vp);

/*
 * Table state accessors
 */

/* Table state accessors for portdata20 */

/**
 * Get portdata20 table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_portdata20_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get portdata20 table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_portdata20_table_size_get(int unit);

/**
 * Set portdata20 table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_portdata20_table_size_set(int unit, int size);

/* Table state accessors for portdata25 */

/**
 * Get portdata25 table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_portdata25_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get portdata25 table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_portdata25_table_size_get(int unit);

/**
 * Set portdata25 table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_portdata25_table_size_set(int unit, int size);

/* Table state accessors for qos */

/**
 * Get qos table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_qos_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get qos table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_qos_table_size_get(int unit);

/**
 * Set qos table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_qos_table_size_set(int unit, int size);

/* Table state accessors for dscp_qos */

/**
 * Get dscp_qos table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_dscp_qos_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get dscp_qos table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_dscp_qos_table_size_get(int unit);

/**
 * Set dscp_qos table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_dscp_qos_table_size_set(int unit, int size);

/* Table state accessors for irt */

/**
 * Get irt table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_irt_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get irt table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_irt_table_size_get(int unit);

/**
 * Set irt table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_irt_table_size_set(int unit, int size);

/* Table state accessors for rt_mt */

/**
 * Get rt_mt table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_rt_mt_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get rt_mt table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_rt_mt_table_size_get(int unit);

/**
 * Set rt_mt table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_rt_mt_table_size_set(int unit, int size);

/* Table state accessors for rt_rr0 */

/**
 * Get rt_rr0 table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_rt_rr0_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get rt_rr0 table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_rt_rr0_table_size_get(int unit);

/**
 * Set rt_rr0 table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_rt_rr0_table_size_set(int unit, int size);

/* Table state accessors for rt_rr1 */

/**
 * Get rt_rr1 table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_rt_rr1_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get rt_rr1 table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_rt_rr1_table_size_get(int unit);

/**
 * Set rt_rr1 table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_rt_rr1_table_size_set(int unit, int size);

/* Table state accessors for lag */

/**
 * Get lag table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_lag_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get lag table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_lag_table_size_get(int unit);

/**
 * Set lag table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_lag_table_size_set(int unit, int size);

/* Table state accessors for rr */

/**
 * Get rr table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_rr_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get rr table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_rr_table_size_get(int unit);

/**
 * Set rr table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_rr_table_size_set(int unit, int size);

/* Table state accessors for xt */

/**
 * Get xt table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_xt_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get xt table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_xt_table_size_get(int unit);

/**
 * Set xt table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_xt_table_size_set(int unit, int size);

/* Table state accessors for mirror */

/**
 * Get mirror table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_mirror_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get mirror table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_mirror_table_size_get(int unit);

/**
 * Set mirror table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_mirror_table_size_set(int unit, int size);

/* Table state accessors for emirror20 */

/**
 * Get emirror20 table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_emirror20_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get emirror20 table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_emirror20_table_size_get(int unit);

/**
 * Set emirror20 table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_emirror20_table_size_set(int unit, int size);

/* Table state accessors for emirror25 */

/**
 * Get emirror25 table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_emirror25_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get emirror25 table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_emirror25_table_size_get(int unit);

/**
 * Set emirror25 table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_emirror25_table_size_set(int unit, int size);

/* Table state accessors for mac */

/**
 * Get mac table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_mac_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get mac table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_mac_table_size_get(int unit);

/**
 * Set mac table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_mac_table_size_set(int unit, int size);

/**
 * Get complex table state structure for mac
 *
 * @param[in]   unit chip unit
 * @return      complex table instance state structure
 */
extern void *soc_sbx_g2p3_mac_complex_state_get(int unit);

/* Table state accessors for ipv6dhost */

/**
 * Get ipv6dhost table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_ipv6dhost_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get ipv6dhost table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_ipv6dhost_table_size_get(int unit);

/**
 * Set ipv6dhost table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_ipv6dhost_table_size_set(int unit, int size);

/**
 * Get complex table state structure for ipv6dhost
 *
 * @param[in]   unit chip unit
 * @return      complex table instance state structure
 */
extern void *soc_sbx_g2p3_ipv6dhost_complex_state_get(int unit);

/* Table state accessors for mst */

/**
 * Get mst table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_mst_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get mst table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_mst_table_size_get(int unit);

/**
 * Set mst table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_mst_table_size_set(int unit, int size);

/* Table state accessors for pv2e */

/**
 * Get pv2e table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_pv2e_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get pv2e table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_pv2e_table_size_get(int unit);

/**
 * Set pv2e table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_pv2e_table_size_set(int unit, int size);

/* Table state accessors for p2appdata */

/**
 * Get p2appdata table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_p2appdata_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get p2appdata table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_p2appdata_table_size_get(int unit);

/**
 * Set p2appdata table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_p2appdata_table_size_set(int unit, int size);

/* Table state accessors for pv2appdata */

/**
 * Get pv2appdata table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_pv2appdata_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get pv2appdata table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_pv2appdata_table_size_get(int unit);

/**
 * Set pv2appdata table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_pv2appdata_table_size_set(int unit, int size);

/* Table state accessors for ipv6shost */

/**
 * Get ipv6shost table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_ipv6shost_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get ipv6shost table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_ipv6shost_table_size_get(int unit);

/**
 * Set ipv6shost table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_ipv6shost_table_size_set(int unit, int size);

/**
 * Get complex table state structure for ipv6shost
 *
 * @param[in]   unit chip unit
 * @return      complex table instance state structure
 */
extern void *soc_sbx_g2p3_ipv6shost_complex_state_get(int unit);

/* Table state accessors for cuckoo */

/**
 * Get cuckoo table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_cuckoo_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get cuckoo table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_cuckoo_table_size_get(int unit);

/**
 * Set cuckoo table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_cuckoo_table_size_set(int unit, int size);

/**
 * Get complex table state structure for cuckoo
 *
 * @param[in]   unit chip unit
 * @return      complex table instance state structure
 */
extern void *soc_sbx_g2p3_cuckoo_complex_state_get(int unit);

/* Table state accessors for outerlabelcuckoo */

/**
 * Get outerlabelcuckoo table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_outerlabelcuckoo_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get outerlabelcuckoo table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_outerlabelcuckoo_table_size_get(int unit);

/**
 * Set outerlabelcuckoo table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_outerlabelcuckoo_table_size_set(int unit, int size);

/**
 * Get complex table state structure for outerlabelcuckoo
 *
 * @param[in]   unit chip unit
 * @return      complex table instance state structure
 */
extern void *soc_sbx_g2p3_outerlabelcuckoo_complex_state_get(int unit);

/* Table state accessors for innerlabelcuckoo */

/**
 * Get innerlabelcuckoo table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_innerlabelcuckoo_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get innerlabelcuckoo table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_innerlabelcuckoo_table_size_get(int unit);

/**
 * Set innerlabelcuckoo table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_innerlabelcuckoo_table_size_set(int unit, int size);

/**
 * Get complex table state structure for innerlabelcuckoo
 *
 * @param[in]   unit chip unit
 * @return      complex table instance state structure
 */
extern void *soc_sbx_g2p3_innerlabelcuckoo_complex_state_get(int unit);

/* Table state accessors for v2e */

/**
 * Get v2e table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_v2e_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get v2e table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_v2e_table_size_get(int unit);

/**
 * Set v2e table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_v2e_table_size_set(int unit, int size);

/* Table state accessors for v2e1 */

/**
 * Get v2e1 table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_v2e1_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get v2e1 table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_v2e1_table_size_get(int unit);

/**
 * Set v2e1 table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_v2e1_table_size_set(int unit, int size);

/* Table state accessors for lp */

/**
 * Get lp table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_lp_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get lp table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_lp_table_size_get(int unit);

/**
 * Set lp table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_lp_table_size_set(int unit, int size);

/* Table state accessors for l2e */

/**
 * Get l2e table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_l2e_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get l2e table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_l2e_table_size_get(int unit);

/**
 * Set l2e table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_l2e_table_size_set(int unit, int size);

/* Table state accessors for l2cp */

/**
 * Get l2cp table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_l2cp_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get l2cp table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_l2cp_table_size_get(int unit);

/**
 * Set l2cp table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_l2cp_table_size_set(int unit, int size);

/* Table state accessors for l2cpslow */

/**
 * Get l2cpslow table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_l2cpslow_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get l2cpslow table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_l2cpslow_table_size_get(int unit);

/**
 * Set l2cpslow table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_l2cpslow_table_size_set(int unit, int size);

/* Table state accessors for l2cpnop */

/**
 * Get l2cpnop table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_l2cpnop_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get l2cpnop table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_l2cpnop_table_size_get(int unit);

/**
 * Set l2cpnop table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_l2cpnop_table_size_set(int unit, int size);

/* Table state accessors for ft */

/**
 * Get ft table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_ft_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get ft table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_ft_table_size_get(int unit);

/**
 * Set ft table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_ft_table_size_set(int unit, int size);

/* Table state accessors for OamTimerCalendar */

/**
 * Get OamTimerCalendar table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_oamtimercalendar_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get OamTimerCalendar table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_oamtimercalendar_table_size_get(int unit);

/**
 * Set OamTimerCalendar table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_oamtimercalendar_table_size_set(int unit, int size);

/* Table state accessors for OamPortMdLevel2Etc */

/**
 * Get OamPortMdLevel2Etc table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_oamportmdlevel2etc_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get OamPortMdLevel2Etc table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_oamportmdlevel2etc_table_size_get(int unit);

/**
 * Set OamPortMdLevel2Etc table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_oamportmdlevel2etc_table_size_set(int unit, int size);

/* Table state accessors for ipv6mcsg */

/**
 * Get ipv6mcsg table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_ipv6mcsg_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get ipv6mcsg table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_ipv6mcsg_table_size_get(int unit);

/**
 * Set ipv6mcsg table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_ipv6mcsg_table_size_set(int unit, int size);

/**
 * Get complex table state structure for ipv6mcsg
 *
 * @param[in]   unit chip unit
 * @return      complex table instance state structure
 */
extern void *soc_sbx_g2p3_ipv6mcsg_complex_state_get(int unit);

/* Table state accessors for ipv6mcg */

/**
 * Get ipv6mcg table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_ipv6mcg_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get ipv6mcg table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_ipv6mcg_table_size_get(int unit);

/**
 * Set ipv6mcg table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_ipv6mcg_table_size_set(int unit, int size);

/**
 * Get complex table state structure for ipv6mcg
 *
 * @param[in]   unit chip unit
 * @return      complex table instance state structure
 */
extern void *soc_sbx_g2p3_ipv6mcg_complex_state_get(int unit);

/* Table state accessors for ipv4mcg */

/**
 * Get ipv4mcg table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_ipv4mcg_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get ipv4mcg table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_ipv4mcg_table_size_get(int unit);

/**
 * Set ipv4mcg table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_ipv4mcg_table_size_set(int unit, int size);

/**
 * Get complex table state structure for ipv4mcg
 *
 * @param[in]   unit chip unit
 * @return      complex table instance state structure
 */
extern void *soc_sbx_g2p3_ipv4mcg_complex_state_get(int unit);

/* Table state accessors for ipv4mcsg */

/**
 * Get ipv4mcsg table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_ipv4mcsg_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get ipv4mcsg table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_ipv4mcsg_table_size_get(int unit);

/**
 * Set ipv4mcsg table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_ipv4mcsg_table_size_set(int unit, int size);

/**
 * Get complex table state structure for ipv4mcsg
 *
 * @param[in]   unit chip unit
 * @return      complex table instance state structure
 */
extern void *soc_sbx_g2p3_ipv4mcsg_complex_state_get(int unit);

/* Table state accessors for ipv4sa */

/**
 * Get ipv4sa table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_ipv4sa_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get ipv4sa table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_ipv4sa_table_size_get(int unit);

/**
 * Set ipv4sa table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_ipv4sa_table_size_set(int unit, int size);

/**
 * Get complex table state structure for ipv4sa
 *
 * @param[in]   unit chip unit
 * @return      complex table instance state structure
 */
extern void *soc_sbx_g2p3_ipv4sa_complex_state_get(int unit);

/* Table state accessors for evp2e */

/**
 * Get evp2e table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_evp2e_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get evp2e table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_evp2e_table_size_get(int unit);

/**
 * Set evp2e table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_evp2e_table_size_set(int unit, int size);

/* Table state accessors for oi2e */

/**
 * Get oi2e table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_oi2e_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get oi2e table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_oi2e_table_size_get(int unit);

/**
 * Set oi2e table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_oi2e_table_size_set(int unit, int size);

/* Table state accessors for ete */

/**
 * Get ete table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_ete_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get ete table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_ete_table_size_get(int unit);

/**
 * Set ete table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_ete_table_size_set(int unit, int size);

/* Table state accessors for oamEp */

/**
 * Get oamEp table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_oamep_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get oamEp table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_oamep_table_size_get(int unit);

/**
 * Set oamEp table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_oamep_table_size_set(int unit, int size);

/* Table state accessors for remark */

/**
 * Get remark table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_remark_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get remark table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_remark_table_size_get(int unit);

/**
 * Set remark table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_remark_table_size_set(int unit, int size);

/* Table state accessors for epv2e */

/**
 * Get epv2e table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_epv2e_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get epv2e table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_epv2e_table_size_get(int unit);

/**
 * Set epv2e table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_epv2e_table_size_set(int unit, int size);

/* Table state accessors for esmac */

/**
 * Get esmac table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_esmac_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get esmac table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_esmac_table_size_get(int unit);

/**
 * Set esmac table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_esmac_table_size_set(int unit, int size);

/* Table state accessors for ert */

/**
 * Get ert table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_ert_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get ert table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_ert_table_size_get(int unit);

/**
 * Set ert table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_ert_table_size_set(int unit, int size);

/* Table state accessors for oamMultiplier */

/**
 * Get oamMultiplier table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_oammultiplier_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get oamMultiplier table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_oammultiplier_table_size_get(int unit);

/**
 * Set oamMultiplier table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_oammultiplier_table_size_set(int unit, int size);

/* Table state accessors for oamEpRemap */

/**
 * Get oamEpRemap table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_oamepremap_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get oamEpRemap table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_oamepremap_table_size_get(int unit);

/**
 * Set oamEpRemap table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_oamepremap_table_size_set(int unit, int size);

/* Table state accessors for ipv6da */

/**
 * Get ipv6da table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_ipv6da_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get ipv6da table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_ipv6da_table_size_get(int unit);

/**
 * Set ipv6da table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_ipv6da_table_size_set(int unit, int size);

/**
 * Get complex table state structure for ipv6da
 *
 * @param[in]   unit chip unit
 * @return      complex table instance state structure
 */
extern void *soc_sbx_g2p3_ipv6da_complex_state_get(int unit);

/* Table state accessors for ipv6sa */

/**
 * Get ipv6sa table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_ipv6sa_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get ipv6sa table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_ipv6sa_table_size_get(int unit);

/**
 * Set ipv6sa table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_ipv6sa_table_size_set(int unit, int size);

/**
 * Get complex table state structure for ipv6sa
 *
 * @param[in]   unit chip unit
 * @return      complex table instance state structure
 */
extern void *soc_sbx_g2p3_ipv6sa_complex_state_get(int unit);

/* Table state accessors for ipv4da */

/**
 * Get ipv4da table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_ipv4da_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get ipv4da table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_ipv4da_table_size_get(int unit);

/**
 * Set ipv4da table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_ipv4da_table_size_set(int unit, int size);

/**
 * Get complex table state structure for ipv4da
 *
 * @param[in]   unit chip unit
 * @return      complex table instance state structure
 */
extern void *soc_sbx_g2p3_ipv4da_complex_state_get(int unit);

/* Table state accessors for P2FTI */

/**
 * Get P2FTI table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2p3_p2fti_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p);

/**
 * Get P2FTI table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2p3_p2fti_table_size_get(int unit);

/**
 * Set P2FTI table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2p3_p2fti_table_size_set(int unit, int size);
  
/*
 * LPM complex table external entry accessors
 */
typedef uint8 soc_sbx_g2p3_lpm_t;
int soc_sbx_g2p3_lpm_add_ext(int unit, void *cstate,
                int iprefixbits,
                uint8 *ikey,
                void *e);
int soc_sbx_g2p3_lpm_renew_ext(int unit, void *cstate,
                int iprefixbits,
                uint8 *ikey,
                void *e);
int soc_sbx_g2p3_lpm_get_ext(int unit, void *cstate,
                int iprefixbits,
                uint8 *ikey,
                void *e);
int soc_sbx_g2p3_lpm_remove_ext(int unit, void *cstate,
                int iprefixbits,
                uint8 *ikey);
int soc_sbx_g2p3_lpm_commit_ext(int unit, void *cstate, int runlength);
int soc_sbx_g2p3_lpm_first_ext(int unit, void *cstate,
                int *iprefixbits,
                uint8 *ikey);
int soc_sbx_g2p3_lpm_next_ext(int unit, void *cstate,
                int iprefixbits,
                uint8 *ikey,
                int *niprefixbits,
                uint8 *nikey);
  
/*
 * EML complex table external entry accessors
 */
typedef uint8 soc_sbx_g2p3_eml_t;
int soc_sbx_g2p3_eml_add_ext(int unit, void *cstate,
                uint8 *ikey,
                void *epacked);
int soc_sbx_g2p3_eml_update_ext(int unit, void *cstate,
                uint8 *ikey,
                void *epacked);
int soc_sbx_g2p3_eml_get_ext(int unit, void *cstate,
                uint8 *ikey,
                void *epacked);
int soc_sbx_g2p3_eml_remove_ext(int unit, void *cstate,
                uint8 *ikey);
int soc_sbx_g2p3_eml_commit_ext(int unit, void *cstate, int runlength);
int soc_sbx_g2p3_eml_first_ext(int unit, void *cstate,
                uint8 *ikey);
int soc_sbx_g2p3_eml_next_ext(int unit, void *cstate,
                uint8 *ikey,
                uint8 *nikey);
  
/*
 * EM32 complex table external entry accessors
 */
typedef uint8 soc_sbx_g2p3_em32_t;
int soc_sbx_g2p3_em32_add_ext(int unit, void *cstate,
                uint8 *ikey,
                void *epacked);
int soc_sbx_g2p3_em32_renew_ext(int unit, void *cstate,
                uint8 *ikey,
                void *epacked);
int soc_sbx_g2p3_em32_get_ext(int unit, void *cstate,
                uint8 *ikey,
                void *epacked);
int soc_sbx_g2p3_em32_remove_ext(int unit, void *cstate,
                uint8 *ikey);
int soc_sbx_g2p3_em32_commit_ext(int unit, void *cstate, int runlength);
int soc_sbx_g2p3_em32_first_ext(int unit, void *cstate,
                uint8 *ikey);
int soc_sbx_g2p3_em32_next_ext(int unit, void *cstate,
                uint8 *ikey,
                uint8 *nikey);

/*
 * Entry accessors
 */

/*
 * Entry accessors for p2e
 */

/**
 * Initialize p2e entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_p2e_t_init(
    soc_sbx_g2p3_p2e_t *e);

/**
 * Get p2e entry size.
 *
 * Use this function for storage management of the
 * p2e table, because its entries have variable size
 *
 * @param[in]  unit chip unit number
 * @return     entry size, in words
 */
extern int soc_sbx_g2p3_p2e_size(int unit);

/**
 * Pack p2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_p2e_pack(int unit,
    soc_sbx_g2p3_p2e_t *e, uint8 *b, int bsz);

/**
 * Unpack p2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_p2e_unpack(int unit,
                soc_sbx_g2p3_p2e_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_p2e_index_check(int unit,
                int *vindex,
                int iport);

extern int soc_sbx_g2p3_p2e_entry_check(int unit,
                soc_sbx_g2p3_p2e_t *e);

/**
 * Synchronously set p2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iport microcode port number
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_p2e_set(int unit,
                int iport,
                soc_sbx_g2p3_p2e_t *e);

extern int soc_sbx_g2p3_p2e_set_ext(int unit,
                int iport,
                soc_sbx_g2p3_p2e_t *e);

/**
 *  Get p2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iport microcode port number
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_p2e_get(int unit,
                int iport,
                soc_sbx_g2p3_p2e_t *e);

extern int soc_sbx_g2p3_p2e_get_ext(int unit,
                int iport,
                soc_sbx_g2p3_p2e_t *e);

/*
 * Entry accessors for ep2e
 */

/**
 * Initialize ep2e entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ep2e_t_init(
    soc_sbx_g2p3_ep2e_t *e);

/**
 * Get ep2e entry size.
 *
 * Use this function for storage management of the
 * ep2e table, because its entries have variable size
 *
 * @param[in]  unit chip unit number
 * @return     entry size, in words
 */
extern int soc_sbx_g2p3_ep2e_size(int unit);

/**
 * Pack ep2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ep2e_pack(int unit,
    soc_sbx_g2p3_ep2e_t *e, uint8 *b, int bsz);

/**
 * Unpack ep2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ep2e_unpack(int unit,
                soc_sbx_g2p3_ep2e_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ep2e_index_check(int unit,
                int *vindex,
                int iport);

extern int soc_sbx_g2p3_ep2e_entry_check(int unit,
                soc_sbx_g2p3_ep2e_t *e);

/**
 * Synchronously set ep2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iport microcode port number
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ep2e_set(int unit,
                int iport,
                soc_sbx_g2p3_ep2e_t *e);

extern int soc_sbx_g2p3_ep2e_set_ext(int unit,
                int iport,
                soc_sbx_g2p3_ep2e_t *e);

/**
 *  Get ep2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iport microcode port number
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ep2e_get(int unit,
                int iport,
                soc_sbx_g2p3_ep2e_t *e);

extern int soc_sbx_g2p3_ep2e_get_ext(int unit,
                int iport,
                soc_sbx_g2p3_ep2e_t *e);

/*
 * Entry accessors for p2e20
 */

/**
 * Initialize p2e20 entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_p2e20_t_init(
    soc_sbx_g2p3_p2e20_t *e);

/**
 * Pack p2e20 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_p2e20_pack(int unit,
    soc_sbx_g2p3_p2e20_t *e, uint8 *b, int bsz);

/**
 * Unpack p2e20 entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_p2e20_unpack(int unit,
                soc_sbx_g2p3_p2e20_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_p2e20_index_check(int unit,
                int *vindex,
                int iport);

extern int soc_sbx_g2p3_p2e20_entry_check(int unit,
                soc_sbx_g2p3_p2e20_t *e);

/**
 * p2e20 table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of p2e20 elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  iport 
 */
extern int soc_sbx_g2p3_p2e20_entry_table_size_get(int unit,
                int *tsize,
                int iport);

/**
 * Synchronously set p2e20 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iport 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_p2e20_set(int unit,
                int iport,
                soc_sbx_g2p3_p2e20_t *e);


extern int soc_sbx_g2p3_p2e20_set_hook(int unit,
                int *sset, int *key,
                int iport,
                soc_sbx_g2p3_p2e20_t *e);

/**
 *  Get p2e20 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iport 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_p2e20_get(int unit,
                int iport,
                soc_sbx_g2p3_p2e20_t *e);


extern int soc_sbx_g2p3_p2e20_get_hook(int unit,
                int *sset, int *key,
                int iport);

/*
 * Entry accessors for ep2e20
 */

/**
 * Initialize ep2e20 entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ep2e20_t_init(
    soc_sbx_g2p3_ep2e20_t *e);

/**
 * Pack ep2e20 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ep2e20_pack(int unit,
    soc_sbx_g2p3_ep2e20_t *e, uint8 *b, int bsz);

/**
 * Unpack ep2e20 entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ep2e20_unpack(int unit,
                soc_sbx_g2p3_ep2e20_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ep2e20_index_check(int unit,
                int *vindex,
                int iport);

extern int soc_sbx_g2p3_ep2e20_entry_check(int unit,
                soc_sbx_g2p3_ep2e20_t *e);

/**
 * ep2e20 table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of ep2e20 elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  iport 
 */
extern int soc_sbx_g2p3_ep2e20_entry_table_size_get(int unit,
                int *tsize,
                int iport);

/**
 * Synchronously set ep2e20 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iport 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ep2e20_set(int unit,
                int iport,
                soc_sbx_g2p3_ep2e20_t *e);


extern int soc_sbx_g2p3_ep2e20_set_hook(int unit,
                int *sset, int *key,
                int iport,
                soc_sbx_g2p3_ep2e20_t *e);

/**
 *  Get ep2e20 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iport 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ep2e20_get(int unit,
                int iport,
                soc_sbx_g2p3_ep2e20_t *e);


extern int soc_sbx_g2p3_ep2e20_get_hook(int unit,
                int *sset, int *key,
                int iport);

/*
 * Entry accessors for p2e25
 */

/**
 * Initialize p2e25 entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_p2e25_t_init(
    soc_sbx_g2p3_p2e25_t *e);

/**
 * Pack p2e25 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_p2e25_pack(int unit,
    soc_sbx_g2p3_p2e25_t *e, uint8 *b, int bsz);

/**
 * Unpack p2e25 entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_p2e25_unpack(int unit,
                soc_sbx_g2p3_p2e25_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_p2e25_index_check(int unit,
                int *vindex,
                int iport);

extern int soc_sbx_g2p3_p2e25_entry_check(int unit,
                soc_sbx_g2p3_p2e25_t *e);

/**
 * p2e25 table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of p2e25 elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  iport 
 */
extern int soc_sbx_g2p3_p2e25_entry_table_size_get(int unit,
                int *tsize,
                int iport);

/**
 * Synchronously set p2e25 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iport 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_p2e25_set(int unit,
                int iport,
                soc_sbx_g2p3_p2e25_t *e);


extern int soc_sbx_g2p3_p2e25_set_hook(int unit,
                int *sset, int *key,
                int iport,
                soc_sbx_g2p3_p2e25_t *e);

/**
 *  Get p2e25 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iport 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_p2e25_get(int unit,
                int iport,
                soc_sbx_g2p3_p2e25_t *e);


extern int soc_sbx_g2p3_p2e25_get_hook(int unit,
                int *sset, int *key,
                int iport);

/*
 * Entry accessors for ep2e25
 */

/**
 * Initialize ep2e25 entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ep2e25_t_init(
    soc_sbx_g2p3_ep2e25_t *e);

/**
 * Pack ep2e25 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ep2e25_pack(int unit,
    soc_sbx_g2p3_ep2e25_t *e, uint8 *b, int bsz);

/**
 * Unpack ep2e25 entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ep2e25_unpack(int unit,
                soc_sbx_g2p3_ep2e25_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ep2e25_index_check(int unit,
                int *vindex,
                int iport);

extern int soc_sbx_g2p3_ep2e25_entry_check(int unit,
                soc_sbx_g2p3_ep2e25_t *e);

/**
 * ep2e25 table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of ep2e25 elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  iport 
 */
extern int soc_sbx_g2p3_ep2e25_entry_table_size_get(int unit,
                int *tsize,
                int iport);

/**
 * Synchronously set ep2e25 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iport 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ep2e25_set(int unit,
                int iport,
                soc_sbx_g2p3_ep2e25_t *e);


extern int soc_sbx_g2p3_ep2e25_set_hook(int unit,
                int *sset, int *key,
                int iport,
                soc_sbx_g2p3_ep2e25_t *e);

/**
 *  Get ep2e25 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iport 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ep2e25_get(int unit,
                int iport,
                soc_sbx_g2p3_ep2e25_t *e);


extern int soc_sbx_g2p3_ep2e25_get_hook(int unit,
                int *sset, int *key,
                int iport);

/*
 * Entry accessors for tpid
 */

/**
 * Initialize tpid entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_tpid_t_init(
    soc_sbx_g2p3_tpid_t *e);

/**
 * Get tpid entry size.
 *
 * Use this function for storage management of the
 * tpid table, because its entries have variable size
 *
 * @param[in]  unit chip unit number
 * @return     entry size, in words
 */
extern int soc_sbx_g2p3_tpid_size(int unit);

/**
 * Pack tpid entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_tpid_pack(int unit,
    soc_sbx_g2p3_tpid_t *e, uint8 *b, int bsz);

/**
 * Unpack tpid entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_tpid_unpack(int unit,
                soc_sbx_g2p3_tpid_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_tpid_index_check(int unit,
                int *vindex,
                int itpidi);

extern int soc_sbx_g2p3_tpid_entry_check(int unit,
                soc_sbx_g2p3_tpid_t *e);

/**
 * Synchronously set tpid entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  itpidi TPID number;  0: CTPID, 1: STPID0, 2: STPID1
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_tpid_set(int unit,
                int itpidi,
                soc_sbx_g2p3_tpid_t *e);

extern int soc_sbx_g2p3_tpid_set_ext(int unit,
                int itpidi,
                soc_sbx_g2p3_tpid_t *e);

/**
 *  Get tpid entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  itpidi TPID number;  0: CTPID, 1: STPID0, 2: STPID1
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_tpid_get(int unit,
                int itpidi,
                soc_sbx_g2p3_tpid_t *e);

extern int soc_sbx_g2p3_tpid_get_ext(int unit,
                int itpidi,
                soc_sbx_g2p3_tpid_t *e);

/*
 * Entry accessors for oam_rx
 */

/**
 * Initialize oam_rx entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_oam_rx_t_init(
    soc_sbx_g2p3_oam_rx_t *e);

/**
 * Get oam_rx entry size.
 *
 * Use this function for storage management of the
 * oam_rx table, because its entries have variable size
 *
 * @param[in]  unit chip unit number
 * @return     entry size, in words
 */
extern int soc_sbx_g2p3_oam_rx_size(int unit);

/**
 * Pack oam_rx entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_oam_rx_pack(int unit,
    soc_sbx_g2p3_oam_rx_t *e, uint8 *b, int bsz);

/**
 * Unpack oam_rx entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_oam_rx_unpack(int unit,
                soc_sbx_g2p3_oam_rx_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_oam_rx_index_check(int unit,
                int *vindex,
                int irule);

extern int soc_sbx_g2p3_oam_rx_entry_check(int unit,
                soc_sbx_g2p3_oam_rx_t *e);

/**
 * Synchronously set oam_rx entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule Ignored.  This index is an artifact of current
 * infrastructure limitations and will be removed.
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_oam_rx_set(int unit,
                int irule,
                soc_sbx_g2p3_oam_rx_t *e);

extern int soc_sbx_g2p3_oam_rx_set_ext(int unit,
                int irule,
                soc_sbx_g2p3_oam_rx_t *e);

/**
 *  Get oam_rx entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule Ignored.  This index is an artifact of current
 * infrastructure limitations and will be removed.
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_oam_rx_get(int unit,
                int irule,
                soc_sbx_g2p3_oam_rx_t *e);

extern int soc_sbx_g2p3_oam_rx_get_ext(int unit,
                int irule,
                soc_sbx_g2p3_oam_rx_t *e);

/*
 * Entry accessors for oam_tx
 */

/**
 * Initialize oam_tx entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_oam_tx_t_init(
    soc_sbx_g2p3_oam_tx_t *e);

/**
 * Get oam_tx entry size.
 *
 * Use this function for storage management of the
 * oam_tx table, because its entries have variable size
 *
 * @param[in]  unit chip unit number
 * @return     entry size, in words
 */
extern int soc_sbx_g2p3_oam_tx_size(int unit);

/**
 * Pack oam_tx entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_oam_tx_pack(int unit,
    soc_sbx_g2p3_oam_tx_t *e, uint8 *b, int bsz);

/**
 * Unpack oam_tx entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_oam_tx_unpack(int unit,
                soc_sbx_g2p3_oam_tx_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_oam_tx_index_check(int unit,
                int *vindex,
                int irule);

extern int soc_sbx_g2p3_oam_tx_entry_check(int unit,
                soc_sbx_g2p3_oam_tx_t *e);

/**
 * Synchronously set oam_tx entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_oam_tx_set(int unit,
                int irule,
                soc_sbx_g2p3_oam_tx_t *e);

extern int soc_sbx_g2p3_oam_tx_set_ext(int unit,
                int irule,
                soc_sbx_g2p3_oam_tx_t *e);

/**
 *  Get oam_tx entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_oam_tx_get(int unit,
                int irule,
                soc_sbx_g2p3_oam_tx_t *e);

extern int soc_sbx_g2p3_oam_tx_get_ext(int unit,
                int irule,
                soc_sbx_g2p3_oam_tx_t *e);

/*
 * Entry accessors for lsmac
 */

/**
 * Initialize lsmac entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_lsmac_t_init(
    soc_sbx_g2p3_lsmac_t *e);

/**
 * Get lsmac entry size.
 *
 * Use this function for storage management of the
 * lsmac table, because its entries have variable size
 *
 * @param[in]  unit chip unit number
 * @return     entry size, in words
 */
extern int soc_sbx_g2p3_lsmac_size(int unit);

/**
 * Pack lsmac entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_lsmac_pack(int unit,
    soc_sbx_g2p3_lsmac_t *e, uint8 *b, int bsz);

/**
 * Unpack lsmac entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_lsmac_unpack(int unit,
                soc_sbx_g2p3_lsmac_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_lsmac_index_check(int unit,
                int *vindex,
                int ilsi);

extern int soc_sbx_g2p3_lsmac_entry_check(int unit,
                soc_sbx_g2p3_lsmac_t *e);

/**
 * Synchronously set lsmac entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ilsi local station MAC table entry number
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_lsmac_set(int unit,
                int ilsi,
                soc_sbx_g2p3_lsmac_t *e);

extern int soc_sbx_g2p3_lsmac_set_ext(int unit,
                int ilsi,
                soc_sbx_g2p3_lsmac_t *e);

/**
 *  Get lsmac entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ilsi local station MAC table entry number
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_lsmac_get(int unit,
                int ilsi,
                soc_sbx_g2p3_lsmac_t *e);

extern int soc_sbx_g2p3_lsmac_get_ext(int unit,
                int ilsi,
                soc_sbx_g2p3_lsmac_t *e);

/*
 * Entry accessors for l2cpmac
 */

/**
 * Initialize l2cpmac entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_l2cpmac_t_init(
    soc_sbx_g2p3_l2cpmac_t *e);

/**
 * Get l2cpmac entry size.
 *
 * Use this function for storage management of the
 * l2cpmac table, because its entries have variable size
 *
 * @param[in]  unit chip unit number
 * @return     entry size, in words
 */
extern int soc_sbx_g2p3_l2cpmac_size(int unit);

/**
 * Pack l2cpmac entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_l2cpmac_pack(int unit,
    soc_sbx_g2p3_l2cpmac_t *e, uint8 *b, int bsz);

/**
 * Unpack l2cpmac entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_l2cpmac_unpack(int unit,
                soc_sbx_g2p3_l2cpmac_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_l2cpmac_index_check(int unit,
                int *vindex,
                int ilsi);

extern int soc_sbx_g2p3_l2cpmac_entry_check(int unit,
                soc_sbx_g2p3_l2cpmac_t *e);

/**
 * Synchronously set l2cpmac entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ilsi L2CP MAC base address entry number
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_l2cpmac_set(int unit,
                int ilsi,
                soc_sbx_g2p3_l2cpmac_t *e);

extern int soc_sbx_g2p3_l2cpmac_set_ext(int unit,
                int ilsi,
                soc_sbx_g2p3_l2cpmac_t *e);

/**
 *  Get l2cpmac entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ilsi L2CP MAC base address entry number
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_l2cpmac_get(int unit,
                int ilsi,
                soc_sbx_g2p3_l2cpmac_t *e);

extern int soc_sbx_g2p3_l2cpmac_get_ext(int unit,
                int ilsi,
                soc_sbx_g2p3_l2cpmac_t *e);

/*
 * Entry accessors for oamupmac
 */

/**
 * Initialize oamupmac entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_oamupmac_t_init(
    soc_sbx_g2p3_oamupmac_t *e);

/**
 * Get oamupmac entry size.
 *
 * Use this function for storage management of the
 * oamupmac table, because its entries have variable size
 *
 * @param[in]  unit chip unit number
 * @return     entry size, in words
 */
extern int soc_sbx_g2p3_oamupmac_size(int unit);

/**
 * Pack oamupmac entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_oamupmac_pack(int unit,
    soc_sbx_g2p3_oamupmac_t *e, uint8 *b, int bsz);

/**
 * Unpack oamupmac entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_oamupmac_unpack(int unit,
                soc_sbx_g2p3_oamupmac_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_oamupmac_index_check(int unit,
                int *vindex,
                int ilsi);

extern int soc_sbx_g2p3_oamupmac_entry_check(int unit,
                soc_sbx_g2p3_oamupmac_t *e);

/**
 * Synchronously set oamupmac entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ilsi OAM UP Local Station Match entry number
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_oamupmac_set(int unit,
                int ilsi,
                soc_sbx_g2p3_oamupmac_t *e);

extern int soc_sbx_g2p3_oamupmac_set_ext(int unit,
                int ilsi,
                soc_sbx_g2p3_oamupmac_t *e);

/**
 *  Get oamupmac entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ilsi OAM UP Local Station Match entry number
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_oamupmac_get(int unit,
                int ilsi,
                soc_sbx_g2p3_oamupmac_t *e);

extern int soc_sbx_g2p3_oamupmac_get_ext(int unit,
                int ilsi,
                soc_sbx_g2p3_oamupmac_t *e);

/*
 * Entry accessors for qos
 */

/**
 * Initialize qos entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_qos_t_init(
    soc_sbx_g2p3_qos_t *e);

/**
 * Pack qos entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_qos_pack(int unit,
    soc_sbx_g2p3_qos_t *e, uint8 *b, int bsz);

/**
 * Unpack qos entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_qos_unpack(int unit,
                soc_sbx_g2p3_qos_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_qos_index_check(int unit,
                int *vindex,
                int ide,
                int ipri,
                int iprof);

extern int soc_sbx_g2p3_qos_entry_check(int unit,
                soc_sbx_g2p3_qos_t *e);

/**
 * qos table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of qos elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  ide packet discard-eligible (DE) or CFI bit, or 0 if 
 * MPLS EXP is used for QoS determination
 * @param[in]  ipri packet Ethernet priority, or MPLS EXP
 * @param[in]  iprof QoS mapping profile.  Each QoS profile contains a full 16
 * unique QoS mapping entries.  The QoS mapping profile
 * effectively selects one of a set of individual QoS mapping
 * subtables.
 */
extern int soc_sbx_g2p3_qos_entry_table_size_get(int unit,
                int *tsize,
                int ide,
                int ipri,
                int iprof);

/**
 * Synchronously set qos entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ide packet discard-eligible (DE) or CFI bit, or 0 if 
 * MPLS EXP is used for QoS determination
 * @param[in]  ipri packet Ethernet priority, or MPLS EXP
 * @param[in]  iprof QoS mapping profile.  Each QoS profile contains a full 16
 * unique QoS mapping entries.  The QoS mapping profile
 * effectively selects one of a set of individual QoS mapping
 * subtables.
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_qos_set(int unit,
                int ide,
                int ipri,
                int iprof,
                soc_sbx_g2p3_qos_t *e);

/**
 *  Get qos entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ide packet discard-eligible (DE) or CFI bit, or 0 if 
 * MPLS EXP is used for QoS determination
 * @param[in]  ipri packet Ethernet priority, or MPLS EXP
 * @param[in]  iprof QoS mapping profile.  Each QoS profile contains a full 16
 * unique QoS mapping entries.  The QoS mapping profile
 * effectively selects one of a set of individual QoS mapping
 * subtables.
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_qos_get(int unit,
                int ide,
                int ipri,
                int iprof,
                soc_sbx_g2p3_qos_t *e);

/*
 * Entry accessors for dscp_qos
 */

/**
 * Initialize dscp_qos entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_dscp_qos_t_init(
    soc_sbx_g2p3_dscp_qos_t *e);

/**
 * Pack dscp_qos entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_dscp_qos_pack(int unit,
    soc_sbx_g2p3_dscp_qos_t *e, uint8 *b, int bsz);

/**
 * Unpack dscp_qos entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_dscp_qos_unpack(int unit,
                soc_sbx_g2p3_dscp_qos_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_dscp_qos_index_check(int unit,
                int *vindex,
                int idscp,
                int iprof);

extern int soc_sbx_g2p3_dscp_qos_entry_check(int unit,
                soc_sbx_g2p3_dscp_qos_t *e);

/**
 * dscp_qos table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of dscp_qos elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  idscp IPv4 DSCP
 * @param[in]  iprof QoS mapping profile.  Each QoS profile contains a full 16
 *                    unique QoS mapping entries.  The QoS mapping profile
 *                    effectively selects one of a set of individual QoS mapping
 *                    subtables.
 */
extern int soc_sbx_g2p3_dscp_qos_entry_table_size_get(int unit,
                int *tsize,
                int idscp,
                int iprof);

/**
 * Synchronously set dscp_qos entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  idscp IPv4 DSCP
 * @param[in]  iprof QoS mapping profile.  Each QoS profile contains a full 16
 *                    unique QoS mapping entries.  The QoS mapping profile
 *                    effectively selects one of a set of individual QoS mapping
 *                    subtables.
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_dscp_qos_set(int unit,
                int idscp,
                int iprof,
                soc_sbx_g2p3_dscp_qos_t *e);

/**
 *  Get dscp_qos entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  idscp IPv4 DSCP
 * @param[in]  iprof QoS mapping profile.  Each QoS profile contains a full 16
 *                    unique QoS mapping entries.  The QoS mapping profile
 *                    effectively selects one of a set of individual QoS mapping
 *                    subtables.
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_dscp_qos_get(int unit,
                int idscp,
                int iprof,
                soc_sbx_g2p3_dscp_qos_t *e);

/*
 * Entry accessors for irt
 */

/**
 * Initialize irt entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_irt_t_init(
    soc_sbx_g2p3_irt_t *e);

/**
 * Pack irt entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_irt_pack(int unit,
    soc_sbx_g2p3_irt_t *e, uint8 *b, int bsz);

/**
 * Unpack irt entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_irt_unpack(int unit,
                soc_sbx_g2p3_irt_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_irt_index_check(int unit,
                int *vindex,
                int irule);

extern int soc_sbx_g2p3_irt_entry_check(int unit,
                soc_sbx_g2p3_irt_t *e);

/**
 * irt table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of irt elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  irule ingress rule table index
 */
extern int soc_sbx_g2p3_irt_entry_table_size_get(int unit,
                int *tsize,
                int irule);

/**
 * Synchronously set irt entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule ingress rule table index
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_irt_set(int unit,
                int irule,
                soc_sbx_g2p3_irt_t *e);

/**
 *  Get irt entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule ingress rule table index
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_irt_get(int unit,
                int irule,
                soc_sbx_g2p3_irt_t *e);

/*
 * Entry accessors for irt_wrap
 */

/**
 * Initialize irt_wrap entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_irt_wrap_t_init(
    soc_sbx_g2p3_irt_wrap_t *e);

/**
 * Get irt_wrap entry size.
 *
 * Use this function for storage management of the
 * irt_wrap table, because its entries have variable size
 *
 * @param[in]  unit chip unit number
 * @return     entry size, in words
 */
extern int soc_sbx_g2p3_irt_wrap_size(int unit);

/**
 * Pack irt_wrap entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_irt_wrap_pack(int unit,
    soc_sbx_g2p3_irt_wrap_t *e, uint8 *b, int bsz);

/**
 * Unpack irt_wrap entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_irt_wrap_unpack(int unit,
                soc_sbx_g2p3_irt_wrap_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_irt_wrap_index_check(int unit,
                int *vindex,
                int irule);

extern int soc_sbx_g2p3_irt_wrap_entry_check(int unit,
                soc_sbx_g2p3_irt_wrap_t *e);

/**
 * Synchronously set irt_wrap entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_irt_wrap_set(int unit,
                int irule,
                soc_sbx_g2p3_irt_wrap_t *e);

extern int soc_sbx_g2p3_irt_wrap_set_ext(int unit,
                int irule,
                soc_sbx_g2p3_irt_wrap_t *e);

/**
 *  Get irt_wrap entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_irt_wrap_get(int unit,
                int irule,
                soc_sbx_g2p3_irt_wrap_t *e);

extern int soc_sbx_g2p3_irt_wrap_get_ext(int unit,
                int irule,
                soc_sbx_g2p3_irt_wrap_t *e);

/*
 * Entry accessors for rt_mt
 */

/**
 * Initialize rt_mt entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_rt_mt_t_init(
    soc_sbx_g2p3_rt_mt_t *e);

/**
 * Pack rt_mt entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_rt_mt_pack(int unit,
    soc_sbx_g2p3_rt_mt_t *e, uint8 *b, int bsz);

/**
 * Unpack rt_mt entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_rt_mt_unpack(int unit,
                soc_sbx_g2p3_rt_mt_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_rt_mt_index_check(int unit,
                int *vindex,
                int irule);

extern int soc_sbx_g2p3_rt_mt_entry_check(int unit,
                soc_sbx_g2p3_rt_mt_t *e);

/**
 * rt_mt table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of rt_mt elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  irule ingress rule table index
 */
extern int soc_sbx_g2p3_rt_mt_entry_table_size_get(int unit,
                int *tsize,
                int irule);

/**
 * Synchronously set rt_mt entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule ingress rule table index
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_rt_mt_set(int unit,
                int irule,
                soc_sbx_g2p3_rt_mt_t *e);

/**
 *  Get rt_mt entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule ingress rule table index
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_rt_mt_get(int unit,
                int irule,
                soc_sbx_g2p3_rt_mt_t *e);

/*
 * Entry accessors for rt_rr0
 */

/**
 * Initialize rt_rr0 entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_rt_rr0_t_init(
    soc_sbx_g2p3_rt_rr0_t *e);

/**
 * Pack rt_rr0 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_rt_rr0_pack(int unit,
    soc_sbx_g2p3_rt_rr0_t *e, uint8 *b, int bsz);

/**
 * Unpack rt_rr0 entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_rt_rr0_unpack(int unit,
                soc_sbx_g2p3_rt_rr0_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_rt_rr0_index_check(int unit,
                int *vindex,
                int irule);

extern int soc_sbx_g2p3_rt_rr0_entry_check(int unit,
                soc_sbx_g2p3_rt_rr0_t *e);

/**
 * rt_rr0 table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of rt_rr0 elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  irule 
 */
extern int soc_sbx_g2p3_rt_rr0_entry_table_size_get(int unit,
                int *tsize,
                int irule);

/**
 * Synchronously set rt_rr0 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_rt_rr0_set(int unit,
                int irule,
                soc_sbx_g2p3_rt_rr0_t *e);

/**
 *  Get rt_rr0 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_rt_rr0_get(int unit,
                int irule,
                soc_sbx_g2p3_rt_rr0_t *e);

/*
 * Entry accessors for rt_rr1
 */

/**
 * Initialize rt_rr1 entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_rt_rr1_t_init(
    soc_sbx_g2p3_rt_rr1_t *e);

/**
 * Pack rt_rr1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_rt_rr1_pack(int unit,
    soc_sbx_g2p3_rt_rr1_t *e, uint8 *b, int bsz);

/**
 * Unpack rt_rr1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_rt_rr1_unpack(int unit,
                soc_sbx_g2p3_rt_rr1_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_rt_rr1_index_check(int unit,
                int *vindex,
                int irule);

extern int soc_sbx_g2p3_rt_rr1_entry_check(int unit,
                soc_sbx_g2p3_rt_rr1_t *e);

/**
 * rt_rr1 table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of rt_rr1 elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  irule 
 */
extern int soc_sbx_g2p3_rt_rr1_entry_table_size_get(int unit,
                int *tsize,
                int irule);

/**
 * Synchronously set rt_rr1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_rt_rr1_set(int unit,
                int irule,
                soc_sbx_g2p3_rt_rr1_t *e);

/**
 *  Get rt_rr1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_rt_rr1_get(int unit,
                int irule,
                soc_sbx_g2p3_rt_rr1_t *e);

/*
 * Entry accessors for lag
 */

/**
 * Initialize lag entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_lag_t_init(
    soc_sbx_g2p3_lag_t *e);

/**
 * Pack lag entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_lag_pack(int unit,
    soc_sbx_g2p3_lag_t *e, uint8 *b, int bsz);

/**
 * Unpack lag entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_lag_unpack(int unit,
                soc_sbx_g2p3_lag_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_lag_index_check(int unit,
                int *vindex,
                int ilagi);

extern int soc_sbx_g2p3_lag_entry_check(int unit,
                soc_sbx_g2p3_lag_t *e);

/**
 * lag table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of lag elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  ilagi lag table index
 */
extern int soc_sbx_g2p3_lag_entry_table_size_get(int unit,
                int *tsize,
                int ilagi);

/**
 * Synchronously set lag entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ilagi lag table index
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_lag_set(int unit,
                int ilagi,
                soc_sbx_g2p3_lag_t *e);

/**
 *  Get lag entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ilagi lag table index
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_lag_get(int unit,
                int ilagi,
                soc_sbx_g2p3_lag_t *e);

/*
 * Entry accessors for rr
 */

/**
 * Initialize rr entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_rr_t_init(
    soc_sbx_g2p3_rr_t *e);

/**
 * Pack rr entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_rr_pack(int unit,
    soc_sbx_g2p3_rr_t *e, uint8 *b, int bsz);

/**
 * Unpack rr entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_rr_unpack(int unit,
                soc_sbx_g2p3_rr_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_rr_index_check(int unit,
                int *vindex,
                int irri);

extern int soc_sbx_g2p3_rr_entry_check(int unit,
                soc_sbx_g2p3_rr_t *e);

/**
 * rr table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of rr elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  irri rerouting index
 */
extern int soc_sbx_g2p3_rr_entry_table_size_get(int unit,
                int *tsize,
                int irri);

/**
 * Synchronously set rr entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irri rerouting index
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_rr_set(int unit,
                int irri,
                soc_sbx_g2p3_rr_t *e);

/**
 *  Get rr entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irri rerouting index
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_rr_get(int unit,
                int irri,
                soc_sbx_g2p3_rr_t *e);

/*
 * Entry accessors for xt
 */

/**
 * Initialize xt entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_xt_t_init(
    soc_sbx_g2p3_xt_t *e);

/**
 * Pack xt entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_xt_pack(int unit,
    soc_sbx_g2p3_xt_t *e, uint8 *b, int bsz);

/**
 * Unpack xt entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_xt_unpack(int unit,
                soc_sbx_g2p3_xt_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_xt_index_check(int unit,
                int *vindex,
                int ixi);

extern int soc_sbx_g2p3_xt_entry_check(int unit,
                soc_sbx_g2p3_xt_t *e);

/**
 * xt table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of xt elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  ixi exception index
 */
extern int soc_sbx_g2p3_xt_entry_table_size_get(int unit,
                int *tsize,
                int ixi);

/**
 * Synchronously set xt entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ixi exception index
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_xt_set(int unit,
                int ixi,
                soc_sbx_g2p3_xt_t *e);

/**
 *  Get xt entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ixi exception index
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_xt_get(int unit,
                int ixi,
                soc_sbx_g2p3_xt_t *e);

/*
 * Entry accessors for mirror
 */

/**
 * Initialize mirror entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_mirror_t_init(
    soc_sbx_g2p3_mirror_t *e);

/**
 * Pack mirror entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_mirror_pack(int unit,
    soc_sbx_g2p3_mirror_t *e, uint8 *b, int bsz);

/**
 * Unpack mirror entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_mirror_unpack(int unit,
                soc_sbx_g2p3_mirror_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_mirror_index_check(int unit,
                int *vindex,
                int imi);

extern int soc_sbx_g2p3_mirror_entry_check(int unit,
                soc_sbx_g2p3_mirror_t *e);

/**
 * mirror table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of mirror elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  imi mirror table index
 */
extern int soc_sbx_g2p3_mirror_entry_table_size_get(int unit,
                int *tsize,
                int imi);

/**
 * Synchronously set mirror entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  imi mirror table index
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_mirror_set(int unit,
                int imi,
                soc_sbx_g2p3_mirror_t *e);

/**
 *  Get mirror entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  imi mirror table index
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_mirror_get(int unit,
                int imi,
                soc_sbx_g2p3_mirror_t *e);

/*
 * Entry accessors for emirror
 */

/**
 * Initialize emirror entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_emirror_t_init(
    soc_sbx_g2p3_emirror_t *e);

/**
 * Get emirror entry size.
 *
 * Use this function for storage management of the
 * emirror table, because its entries have variable size
 *
 * @param[in]  unit chip unit number
 * @return     entry size, in words
 */
extern int soc_sbx_g2p3_emirror_size(int unit);

/**
 * Pack emirror entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_emirror_pack(int unit,
    soc_sbx_g2p3_emirror_t *e, uint8 *b, int bsz);

/**
 * Unpack emirror entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_emirror_unpack(int unit,
                soc_sbx_g2p3_emirror_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_emirror_index_check(int unit,
                int *vindex,
                int imirror);

extern int soc_sbx_g2p3_emirror_entry_check(int unit,
                soc_sbx_g2p3_emirror_t *e);

/**
 * Synchronously set emirror entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  imirror egress mirror index; unlike ingress mirroring, egress
 * mirroring selects one of 16 FE hardware mirrors; on the
 * BCM88020, to direct an egress mirrored flow some place
 * other than a port on the local FE, an unused port
 * must be put into loopback mode, and the ingress
 * packet processing configured to direct all looped
 * packets to the mirror port or tunnel; the BCM88025
 * supports arbitrary forwarding of hardware mirrored
 * traffic so using port loopback is not necessary
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_emirror_set(int unit,
                int imirror,
                soc_sbx_g2p3_emirror_t *e);

extern int soc_sbx_g2p3_emirror_set_ext(int unit,
                int imirror,
                soc_sbx_g2p3_emirror_t *e);

/**
 *  Get emirror entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  imirror egress mirror index; unlike ingress mirroring, egress
 * mirroring selects one of 16 FE hardware mirrors; on the
 * BCM88020, to direct an egress mirrored flow some place
 * other than a port on the local FE, an unused port
 * must be put into loopback mode, and the ingress
 * packet processing configured to direct all looped
 * packets to the mirror port or tunnel; the BCM88025
 * supports arbitrary forwarding of hardware mirrored
 * traffic so using port loopback is not necessary
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_emirror_get(int unit,
                int imirror,
                soc_sbx_g2p3_emirror_t *e);

extern int soc_sbx_g2p3_emirror_get_ext(int unit,
                int imirror,
                soc_sbx_g2p3_emirror_t *e);

/*
 * Entry accessors for emirror20
 */

/**
 * Initialize emirror20 entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_emirror20_t_init(
    soc_sbx_g2p3_emirror20_t *e);

/**
 * Pack emirror20 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_emirror20_pack(int unit,
    soc_sbx_g2p3_emirror20_t *e, uint8 *b, int bsz);

/**
 * Unpack emirror20 entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_emirror20_unpack(int unit,
                soc_sbx_g2p3_emirror20_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_emirror20_index_check(int unit,
                int *vindex,
                int imirror);

extern int soc_sbx_g2p3_emirror20_entry_check(int unit,
                soc_sbx_g2p3_emirror20_t *e);

/**
 * emirror20 table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of emirror20 elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  imirror 
 */
extern int soc_sbx_g2p3_emirror20_entry_table_size_get(int unit,
                int *tsize,
                int imirror);

/**
 * Synchronously set emirror20 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  imirror 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_emirror20_set(int unit,
                int imirror,
                soc_sbx_g2p3_emirror20_t *e);

/**
 *  Get emirror20 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  imirror 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_emirror20_get(int unit,
                int imirror,
                soc_sbx_g2p3_emirror20_t *e);

/*
 * Entry accessors for emirror25
 */

/**
 * Initialize emirror25 entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_emirror25_t_init(
    soc_sbx_g2p3_emirror25_t *e);

/**
 * Pack emirror25 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_emirror25_pack(int unit,
    soc_sbx_g2p3_emirror25_t *e, uint8 *b, int bsz);

/**
 * Unpack emirror25 entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_emirror25_unpack(int unit,
                soc_sbx_g2p3_emirror25_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_emirror25_index_check(int unit,
                int *vindex,
                int imirror);

extern int soc_sbx_g2p3_emirror25_entry_check(int unit,
                soc_sbx_g2p3_emirror25_t *e);

/**
 * emirror25 table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of emirror25 elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  imirror 
 */
extern int soc_sbx_g2p3_emirror25_entry_table_size_get(int unit,
                int *tsize,
                int imirror);

/**
 * Synchronously set emirror25 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  imirror 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_emirror25_set(int unit,
                int imirror,
                soc_sbx_g2p3_emirror25_t *e);

/**
 *  Get emirror25 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  imirror 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_emirror25_get(int unit,
                int imirror,
                soc_sbx_g2p3_emirror25_t *e);

/*
 * Entry accessors for emll1
 */

/**
 * Initialize emll1 entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_emll1_t_init(
    soc_sbx_g2p3_emll1_t *e);

/**
 * Get emll1 entry size.
 *
 * Use this function for storage management of the
 * emll1 table, because its entries have variable size
 *
 * @param[in]  unit chip unit number
 * @return     entry size, in words
 */
extern int soc_sbx_g2p3_emll1_size(int unit);

/**
 * Pack emll1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_emll1_pack(int unit,
    soc_sbx_g2p3_emll1_t *e, uint8 *b, int bsz);

/**
 * Unpack emll1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_emll1_unpack(int unit,
                soc_sbx_g2p3_emll1_t *e, uint8 *b, int bsz);

/*
 * Entry accessors for mac
 */

/**
 * Initialize mac entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_mac_t_init(
    soc_sbx_g2p3_mac_t *e);

/**
 * Pack mac entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_mac_pack(int unit,
    soc_sbx_g2p3_mac_t *e, uint8 *b, int bsz);

/**
 * Unpack mac entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_mac_unpack(int unit,
                soc_sbx_g2p3_mac_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_mac_index_check(int unit,
                int *vindex,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan,
                int ibmac);

extern int soc_sbx_g2p3_mac_index_unpack(int unit,
                int *vindex,
                soc_sbx_g2p3_6_byte_t imac,
                int *ivlan,
                int *ibmac);

extern int soc_sbx_g2p3_mac_entry_check(int unit,
                soc_sbx_g2p3_mac_t *e);

/**
 * Synchronously set mac entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  imac 
 * @param[in]  ivlan 
 * @param[in]  ibmac 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_mac_set(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan,
                int ibmac,
                soc_sbx_g2p3_mac_t *e);

/**
 * Batch add mac entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  imac 
 * @param[in]  ivlan 
 * @param[in]  ibmac 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_mac_add(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan,
                int ibmac,
                soc_sbx_g2p3_mac_t *e);

/**
 *  Get mac entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  imac 
 * @param[in]  ivlan 
 * @param[in]  ibmac 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_mac_get(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan,
                int ibmac,
                soc_sbx_g2p3_mac_t *e);

/**
 * Synchronously update mac entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  imac 
 * @param[in]  ivlan 
 * @param[in]  ibmac 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_mac_update(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan,
                int ibmac,
                soc_sbx_g2p3_mac_t *e);

/**
 * Synchronously delete mac entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  imac 
 * @param[in]  ivlan 
 * @param[in]  ibmac 
 */
extern int soc_sbx_g2p3_mac_delete(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan,
                int ibmac);

/**
 * Batch remove mac entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  imac 
 * @param[in]  ivlan 
 * @param[in]  ibmac 
 */
extern int soc_sbx_g2p3_mac_remove(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan,
                int ibmac);

/**
 * mac get first entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  imac 
 * @param[in]  ivlan 
 * @param[in]  ibmac 
 * @retval     SOC_E_NOT_FOUND no entries
 */
extern int soc_sbx_g2p3_mac_first(int unit,
                soc_sbx_g2p3_6_byte_t nimac,
                int *nivlan,
                int *nibmac);
/**
 * mac get next entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  imac 
 * @param[in]  ivlan 
 * @param[in]  ibmac 
 * @param[out] nimac next 
 * @param[out] nivlan next 
 * @param[out] nibmac next 
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_mac_next(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan,
                int ibmac,
                soc_sbx_g2p3_6_byte_t nimac,
                int *nivlan,
                int *nibmac);

/* Batch commit for mac */
/**
 * mac batch commit.
 *
 * @param[in]  unit chip unit number
 * @param[in]  runlength number of elements to commit (-1 means commit all)
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_mac_commit(int unit, int runlength);

/*
 * Entry accessors for macl1
 */

/**
 * Initialize macl1 entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_macl1_t_init(
    soc_sbx_g2p3_macl1_t *e);

/**
 * Pack macl1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_macl1_pack(int unit,
    soc_sbx_g2p3_macl1_t *e, uint8 *b, int bsz);

/**
 * Unpack macl1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_macl1_unpack(int unit,
                soc_sbx_g2p3_macl1_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_macl1_index_check(int unit,
                int *vindex,
                int il1i);

extern int soc_sbx_g2p3_macl1_entry_check(int unit,
                soc_sbx_g2p3_macl1_t *e);

/**
 * macl1 table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of macl1 elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  il1i 
 */
extern int soc_sbx_g2p3_macl1_entry_table_size_get(int unit,
                int *tsize,
                int il1i);

/**
 * Synchronously set macl1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  il1i 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_macl1_set(int unit,
                int il1i,
                soc_sbx_g2p3_macl1_t *e);

/**
 *  Get macl1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  il1i 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_macl1_get(int unit,
                int il1i,
                soc_sbx_g2p3_macl1_t *e);

/*
 * Entry accessors for macl2
 */

/**
 * Initialize macl2 entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_macl2_t_init(
    soc_sbx_g2p3_macl2_t *e);

/**
 * Pack macl2 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_macl2_pack(int unit,
    soc_sbx_g2p3_macl2_t *e, uint8 *b, int bsz);

/**
 * Unpack macl2 entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_macl2_unpack(int unit,
                soc_sbx_g2p3_macl2_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_macl2_index_check(int unit,
                int *vindex,
                int imaci);

extern int soc_sbx_g2p3_macl2_entry_check(int unit,
                soc_sbx_g2p3_macl2_t *e);

/**
 * macl2 table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of macl2 elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  imaci 
 */
extern int soc_sbx_g2p3_macl2_entry_table_size_get(int unit,
                int *tsize,
                int imaci);

/**
 * Synchronously set macl2 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  imaci 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_macl2_set(int unit,
                int imaci,
                soc_sbx_g2p3_macl2_t *e);

/**
 *  Get macl2 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  imaci 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_macl2_get(int unit,
                int imaci,
                soc_sbx_g2p3_macl2_t *e);

/*
 * Entry accessors for ipv6dhost
 */

/**
 * Initialize ipv6dhost entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ipv6dhost_t_init(
    soc_sbx_g2p3_ipv6dhost_t *e);

/**
 * Pack ipv6dhost entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ipv6dhost_pack(int unit,
    soc_sbx_g2p3_ipv6dhost_t *e, uint8 *b, int bsz);

/**
 * Unpack ipv6dhost entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ipv6dhost_unpack(int unit,
                soc_sbx_g2p3_ipv6dhost_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ipv6dhost_index_check(int unit,
                int *vindex,
                soc_sbx_g2p3_16_byte_t iip);

extern int soc_sbx_g2p3_ipv6dhost_index_unpack(int unit,
                int *vindex,
                soc_sbx_g2p3_16_byte_t iip);

extern int soc_sbx_g2p3_ipv6dhost_entry_check(int unit,
                soc_sbx_g2p3_ipv6dhost_t *e);

/**
 * Synchronously set ipv6dhost entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iip 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv6dhost_set(int unit,
                soc_sbx_g2p3_16_byte_t iip,
                soc_sbx_g2p3_ipv6dhost_t *e);

/**
 * Batch add ipv6dhost entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  iip 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv6dhost_add(int unit,
                soc_sbx_g2p3_16_byte_t iip,
                soc_sbx_g2p3_ipv6dhost_t *e);

/**
 *  Get ipv6dhost entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iip 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ipv6dhost_get(int unit,
                soc_sbx_g2p3_16_byte_t iip,
                soc_sbx_g2p3_ipv6dhost_t *e);

/**
 * Synchronously update ipv6dhost entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iip 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv6dhost_update(int unit,
                soc_sbx_g2p3_16_byte_t iip,
                soc_sbx_g2p3_ipv6dhost_t *e);

/**
 * Synchronously delete ipv6dhost entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iip 
 */
extern int soc_sbx_g2p3_ipv6dhost_delete(int unit,
                soc_sbx_g2p3_16_byte_t iip);

/**
 * Batch remove ipv6dhost entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  iip 
 */
extern int soc_sbx_g2p3_ipv6dhost_remove(int unit,
                soc_sbx_g2p3_16_byte_t iip);

/**
 * ipv6dhost get first entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iip 
 * @retval     SOC_E_NOT_FOUND no entries
 */
extern int soc_sbx_g2p3_ipv6dhost_first(int unit,
                soc_sbx_g2p3_16_byte_t niip);
/**
 * ipv6dhost get next entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iip 
 * @param[out] niip next 
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_ipv6dhost_next(int unit,
                soc_sbx_g2p3_16_byte_t iip,
                soc_sbx_g2p3_16_byte_t niip);

/* Batch commit for ipv6dhost */
/**
 * ipv6dhost batch commit.
 *
 * @param[in]  unit chip unit number
 * @param[in]  runlength number of elements to commit (-1 means commit all)
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_ipv6dhost_commit(int unit, int runlength);

/*
 * Entry accessors for ipv6dhostl1
 */

/**
 * Initialize ipv6dhostl1 entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ipv6dhostl1_t_init(
    soc_sbx_g2p3_ipv6dhostl1_t *e);

/**
 * Pack ipv6dhostl1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ipv6dhostl1_pack(int unit,
    soc_sbx_g2p3_ipv6dhostl1_t *e, uint8 *b, int bsz);

/**
 * Unpack ipv6dhostl1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ipv6dhostl1_unpack(int unit,
                soc_sbx_g2p3_ipv6dhostl1_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ipv6dhostl1_index_check(int unit,
                int *vindex,
                int il1i);

extern int soc_sbx_g2p3_ipv6dhostl1_entry_check(int unit,
                soc_sbx_g2p3_ipv6dhostl1_t *e);

/**
 * ipv6dhostl1 table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of ipv6dhostl1 elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  il1i 
 */
extern int soc_sbx_g2p3_ipv6dhostl1_entry_table_size_get(int unit,
                int *tsize,
                int il1i);

/**
 * Synchronously set ipv6dhostl1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  il1i 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv6dhostl1_set(int unit,
                int il1i,
                soc_sbx_g2p3_ipv6dhostl1_t *e);

/**
 *  Get ipv6dhostl1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  il1i 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ipv6dhostl1_get(int unit,
                int il1i,
                soc_sbx_g2p3_ipv6dhostl1_t *e);

/*
 * Entry accessors for ipv6dhostl2
 */

/**
 * Initialize ipv6dhostl2 entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ipv6dhostl2_t_init(
    soc_sbx_g2p3_ipv6dhostl2_t *e);

/**
 * Pack ipv6dhostl2 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ipv6dhostl2_pack(int unit,
    soc_sbx_g2p3_ipv6dhostl2_t *e, uint8 *b, int bsz);

/**
 * Unpack ipv6dhostl2 entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ipv6dhostl2_unpack(int unit,
                soc_sbx_g2p3_ipv6dhostl2_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ipv6dhostl2_index_check(int unit,
                int *vindex,
                int ihosti);

extern int soc_sbx_g2p3_ipv6dhostl2_entry_check(int unit,
                soc_sbx_g2p3_ipv6dhostl2_t *e);

/**
 * ipv6dhostl2 table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of ipv6dhostl2 elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  ihosti 
 */
extern int soc_sbx_g2p3_ipv6dhostl2_entry_table_size_get(int unit,
                int *tsize,
                int ihosti);

/**
 * Synchronously set ipv6dhostl2 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ihosti 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv6dhostl2_set(int unit,
                int ihosti,
                soc_sbx_g2p3_ipv6dhostl2_t *e);

/**
 *  Get ipv6dhostl2 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ihosti 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ipv6dhostl2_get(int unit,
                int ihosti,
                soc_sbx_g2p3_ipv6dhostl2_t *e);

/*
 * Entry accessors for mst
 */

/**
 * Initialize mst entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_mst_t_init(
    soc_sbx_g2p3_mst_t *e);

/**
 * Pack mst entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_mst_pack(int unit,
    soc_sbx_g2p3_mst_t *e, uint8 *b, int bsz);

/**
 * Unpack mst entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_mst_unpack(int unit,
                soc_sbx_g2p3_mst_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_mst_index_check(int unit,
                int *vindex,
                int imsti);

extern int soc_sbx_g2p3_mst_entry_check(int unit,
                soc_sbx_g2p3_mst_t *e);

/**
 * mst table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of mst elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  imsti mst index; the SWS buffer for the nominal packet is used
 * for the index.  This is guaranteed to be unique among all
 * packets in the FE, and is passed to all replication
 * processing
 */
extern int soc_sbx_g2p3_mst_entry_table_size_get(int unit,
                int *tsize,
                int imsti);

/**
 * Synchronously set mst entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  imsti mst index; the SWS buffer for the nominal packet is used
 * for the index.  This is guaranteed to be unique among all
 * packets in the FE, and is passed to all replication
 * processing
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_mst_set(int unit,
                int imsti,
                soc_sbx_g2p3_mst_t *e);

/**
 *  Get mst entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  imsti mst index; the SWS buffer for the nominal packet is used
 * for the index.  This is guaranteed to be unique among all
 * packets in the FE, and is passed to all replication
 * processing
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_mst_get(int unit,
                int imsti,
                soc_sbx_g2p3_mst_t *e);

/*
 * Entry accessors for pv2e
 */

/**
 * Initialize pv2e entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_pv2e_t_init(
    soc_sbx_g2p3_pv2e_t *e);

/**
 * Pack pv2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_pv2e_pack(int unit,
    soc_sbx_g2p3_pv2e_t *e, uint8 *b, int bsz);

/**
 * Unpack pv2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_pv2e_unpack(int unit,
                soc_sbx_g2p3_pv2e_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_pv2e_index_check(int unit,
                int *vindex,
                int ivid,
                int iport);

extern int soc_sbx_g2p3_pv2e_entry_check(int unit,
                soc_sbx_g2p3_pv2e_t *e);

/**
 * pv2e table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of pv2e elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  ivid ingress packet VID
 * @param[in]  iport ingress port
 */
extern int soc_sbx_g2p3_pv2e_entry_table_size_get(int unit,
                int *tsize,
                int ivid,
                int iport);

/**
 * Synchronously set pv2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ivid ingress packet VID
 * @param[in]  iport ingress port
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_pv2e_set(int unit,
                int ivid,
                int iport,
                soc_sbx_g2p3_pv2e_t *e);

/**
 * pv2e.lpi fast set function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ivid ingress packet VID
 * @param[in]  iport ingress port
 * @param[in]  eivid ending ingress packet VID
 * @param[in]  eiport ending ingress port
 * @param[in]  sets array of set flags for lpi (NULL means set all)
 * @param[in]  vs array of new values for lpi
 * @param[in]  vcount array size of vs
 */
extern int soc_sbx_g2p3_pv2e_lpi_fast_set(int unit,
                int ivid,
                int iport,
                int eivid,
                int eiport,
                int *sets,
                uint32 *vs,
                int vcount);

/**
 * pv2e.lpi fast get function.
 *
 * @param[in]   unit chip unit number
 * @param[in]  ivid ingress packet VID
 * @param[in]  iport ingress port
 * @param[in]  eivid ending ingress packet VID
 * @param[in]  eiport ending ingress port
 * @param[out]  vs array of values for lpi
 * @param[in]   vcount array size of vs
 */
extern int soc_sbx_g2p3_pv2e_lpi_fast_get(int unit,
                int ivid,
                int iport,
                int eivid,
                int eiport,
                uint32 *vs,
                int vcount);

/**
 * pv2e.vlan fast set function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ivid ingress packet VID
 * @param[in]  iport ingress port
 * @param[in]  eivid ending ingress packet VID
 * @param[in]  eiport ending ingress port
 * @param[in]  sets array of set flags for vlan (NULL means set all)
 * @param[in]  vs array of new values for vlan
 * @param[in]  vcount array size of vs
 */
extern int soc_sbx_g2p3_pv2e_vlan_fast_set(int unit,
                int ivid,
                int iport,
                int eivid,
                int eiport,
                int *sets,
                uint32 *vs,
                int vcount);

/**
 * pv2e.vlan fast get function.
 *
 * @param[in]   unit chip unit number
 * @param[in]  ivid ingress packet VID
 * @param[in]  iport ingress port
 * @param[in]  eivid ending ingress packet VID
 * @param[in]  eiport ending ingress port
 * @param[out]  vs array of values for vlan
 * @param[in]   vcount array size of vs
 */
extern int soc_sbx_g2p3_pv2e_vlan_fast_get(int unit,
                int ivid,
                int iport,
                int eivid,
                int eiport,
                uint32 *vs,
                int vcount);

/**
 * pv2e.stpstate fast set function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ivid ingress packet VID
 * @param[in]  iport ingress port
 * @param[in]  eivid ending ingress packet VID
 * @param[in]  eiport ending ingress port
 * @param[in]  sets array of set flags for stpstate (NULL means set all)
 * @param[in]  vs array of new values for stpstate
 * @param[in]  vcount array size of vs
 */
extern int soc_sbx_g2p3_pv2e_stpstate_fast_set(int unit,
                int ivid,
                int iport,
                int eivid,
                int eiport,
                int *sets,
                uint32 *vs,
                int vcount);

/**
 * pv2e.stpstate fast get function.
 *
 * @param[in]   unit chip unit number
 * @param[in]  ivid ingress packet VID
 * @param[in]  iport ingress port
 * @param[in]  eivid ending ingress packet VID
 * @param[in]  eiport ending ingress port
 * @param[out]  vs array of values for stpstate
 * @param[in]   vcount array size of vs
 */
extern int soc_sbx_g2p3_pv2e_stpstate_fast_get(int unit,
                int ivid,
                int iport,
                int eivid,
                int eiport,
                uint32 *vs,
                int vcount);

/**
 * pv2e.untagged_strip fast get function.
 *
 * @param[in]   unit chip unit number
 * @param[in]  ivid ingress packet VID
 * @param[in]  iport ingress port
 * @param[in]  eivid ending ingress packet VID
 * @param[in]  eiport ending ingress port
 * @param[out]  vs array of values for untagged_strip
 * @param[in]   vcount array size of vs
 */
extern int soc_sbx_g2p3_pv2e_untagged_strip_fast_get(int unit,
                int ivid,
                int iport,
                int eivid,
                int eiport,
                uint32 *vs,
                int vcount);

/**
 *  Get pv2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ivid ingress packet VID
 * @param[in]  iport ingress port
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_pv2e_get(int unit,
                int ivid,
                int iport,
                soc_sbx_g2p3_pv2e_t *e);

/*
 * Entry accessors for p2appdata
 */

/**
 * Initialize p2appdata entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_p2appdata_t_init(
    soc_sbx_g2p3_p2appdata_t *e);

/**
 * Pack p2appdata entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_p2appdata_pack(int unit,
    soc_sbx_g2p3_p2appdata_t *e, uint8 *b, int bsz);

/**
 * Unpack p2appdata entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_p2appdata_unpack(int unit,
                soc_sbx_g2p3_p2appdata_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_p2appdata_index_check(int unit,
                int *vindex,
                int iport);

extern int soc_sbx_g2p3_p2appdata_entry_check(int unit,
                soc_sbx_g2p3_p2appdata_t *e);

/**
 * p2appdata table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of p2appdata elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  iport port
 */
extern int soc_sbx_g2p3_p2appdata_entry_table_size_get(int unit,
                int *tsize,
                int iport);

/**
 * Synchronously set p2appdata entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iport port
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_p2appdata_set(int unit,
                int iport,
                soc_sbx_g2p3_p2appdata_t *e);

/**
 *  Get p2appdata entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iport port
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_p2appdata_get(int unit,
                int iport,
                soc_sbx_g2p3_p2appdata_t *e);

/*
 * Entry accessors for pv2appdata
 */

/**
 * Initialize pv2appdata entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_pv2appdata_t_init(
    soc_sbx_g2p3_pv2appdata_t *e);

/**
 * Pack pv2appdata entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_pv2appdata_pack(int unit,
    soc_sbx_g2p3_pv2appdata_t *e, uint8 *b, int bsz);

/**
 * Unpack pv2appdata entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_pv2appdata_unpack(int unit,
                soc_sbx_g2p3_pv2appdata_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_pv2appdata_index_check(int unit,
                int *vindex,
                int ivid,
                int iport);

extern int soc_sbx_g2p3_pv2appdata_entry_check(int unit,
                soc_sbx_g2p3_pv2appdata_t *e);

/**
 * pv2appdata table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of pv2appdata elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  ivid VLAN identifier
 * @param[in]  iport port
 */
extern int soc_sbx_g2p3_pv2appdata_entry_table_size_get(int unit,
                int *tsize,
                int ivid,
                int iport);

/**
 * Synchronously set pv2appdata entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ivid VLAN identifier
 * @param[in]  iport port
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_pv2appdata_set(int unit,
                int ivid,
                int iport,
                soc_sbx_g2p3_pv2appdata_t *e);

/**
 * pv2appdata.member fast get function.
 *
 * @param[in]   unit chip unit number
 * @param[in]  ivid VLAN identifier
 * @param[in]  iport port
 * @param[in]  eivid ending VLAN identifier
 * @param[in]  eiport ending port
 * @param[out]  vs array of values for member
 * @param[in]   vcount array size of vs
 */
extern int soc_sbx_g2p3_pv2appdata_member_fast_get(int unit,
                int ivid,
                int iport,
                int eivid,
                int eiport,
                uint32 *vs,
                int vcount);

/**
 *  Get pv2appdata entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ivid VLAN identifier
 * @param[in]  iport port
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_pv2appdata_get(int unit,
                int ivid,
                int iport,
                soc_sbx_g2p3_pv2appdata_t *e);

/*
 * Entry accessors for ipv6shost
 */

/**
 * Initialize ipv6shost entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ipv6shost_t_init(
    soc_sbx_g2p3_ipv6shost_t *e);

/**
 * Pack ipv6shost entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ipv6shost_pack(int unit,
    soc_sbx_g2p3_ipv6shost_t *e, uint8 *b, int bsz);

/**
 * Unpack ipv6shost entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ipv6shost_unpack(int unit,
                soc_sbx_g2p3_ipv6shost_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ipv6shost_index_check(int unit,
                int *vindex,
                soc_sbx_g2p3_16_byte_t iip);

extern int soc_sbx_g2p3_ipv6shost_index_unpack(int unit,
                int *vindex,
                soc_sbx_g2p3_16_byte_t iip);

extern int soc_sbx_g2p3_ipv6shost_entry_check(int unit,
                soc_sbx_g2p3_ipv6shost_t *e);

/**
 * Synchronously set ipv6shost entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iip 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv6shost_set(int unit,
                soc_sbx_g2p3_16_byte_t iip,
                soc_sbx_g2p3_ipv6shost_t *e);

/**
 * Batch add ipv6shost entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  iip 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv6shost_add(int unit,
                soc_sbx_g2p3_16_byte_t iip,
                soc_sbx_g2p3_ipv6shost_t *e);

/**
 *  Get ipv6shost entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iip 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ipv6shost_get(int unit,
                soc_sbx_g2p3_16_byte_t iip,
                soc_sbx_g2p3_ipv6shost_t *e);

/**
 * Synchronously update ipv6shost entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iip 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv6shost_update(int unit,
                soc_sbx_g2p3_16_byte_t iip,
                soc_sbx_g2p3_ipv6shost_t *e);

/**
 * Synchronously delete ipv6shost entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iip 
 */
extern int soc_sbx_g2p3_ipv6shost_delete(int unit,
                soc_sbx_g2p3_16_byte_t iip);

/**
 * Batch remove ipv6shost entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  iip 
 */
extern int soc_sbx_g2p3_ipv6shost_remove(int unit,
                soc_sbx_g2p3_16_byte_t iip);

/**
 * ipv6shost get first entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iip 
 * @retval     SOC_E_NOT_FOUND no entries
 */
extern int soc_sbx_g2p3_ipv6shost_first(int unit,
                soc_sbx_g2p3_16_byte_t niip);
/**
 * ipv6shost get next entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iip 
 * @param[out] niip next 
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_ipv6shost_next(int unit,
                soc_sbx_g2p3_16_byte_t iip,
                soc_sbx_g2p3_16_byte_t niip);

/* Batch commit for ipv6shost */
/**
 * ipv6shost batch commit.
 *
 * @param[in]  unit chip unit number
 * @param[in]  runlength number of elements to commit (-1 means commit all)
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_ipv6shost_commit(int unit, int runlength);

/*
 * Entry accessors for ipv6shostl1
 */

/**
 * Initialize ipv6shostl1 entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ipv6shostl1_t_init(
    soc_sbx_g2p3_ipv6shostl1_t *e);

/**
 * Pack ipv6shostl1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ipv6shostl1_pack(int unit,
    soc_sbx_g2p3_ipv6shostl1_t *e, uint8 *b, int bsz);

/**
 * Unpack ipv6shostl1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ipv6shostl1_unpack(int unit,
                soc_sbx_g2p3_ipv6shostl1_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ipv6shostl1_index_check(int unit,
                int *vindex,
                int il1i);

extern int soc_sbx_g2p3_ipv6shostl1_entry_check(int unit,
                soc_sbx_g2p3_ipv6shostl1_t *e);

/**
 * ipv6shostl1 table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of ipv6shostl1 elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  il1i 
 */
extern int soc_sbx_g2p3_ipv6shostl1_entry_table_size_get(int unit,
                int *tsize,
                int il1i);

/**
 * Synchronously set ipv6shostl1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  il1i 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv6shostl1_set(int unit,
                int il1i,
                soc_sbx_g2p3_ipv6shostl1_t *e);

/**
 *  Get ipv6shostl1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  il1i 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ipv6shostl1_get(int unit,
                int il1i,
                soc_sbx_g2p3_ipv6shostl1_t *e);

/*
 * Entry accessors for ipv6shostl2
 */

/**
 * Initialize ipv6shostl2 entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ipv6shostl2_t_init(
    soc_sbx_g2p3_ipv6shostl2_t *e);

/**
 * Pack ipv6shostl2 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ipv6shostl2_pack(int unit,
    soc_sbx_g2p3_ipv6shostl2_t *e, uint8 *b, int bsz);

/**
 * Unpack ipv6shostl2 entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ipv6shostl2_unpack(int unit,
                soc_sbx_g2p3_ipv6shostl2_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ipv6shostl2_index_check(int unit,
                int *vindex,
                int ihosti);

extern int soc_sbx_g2p3_ipv6shostl2_entry_check(int unit,
                soc_sbx_g2p3_ipv6shostl2_t *e);

/**
 * ipv6shostl2 table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of ipv6shostl2 elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  ihosti 
 */
extern int soc_sbx_g2p3_ipv6shostl2_entry_table_size_get(int unit,
                int *tsize,
                int ihosti);

/**
 * Synchronously set ipv6shostl2 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ihosti 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv6shostl2_set(int unit,
                int ihosti,
                soc_sbx_g2p3_ipv6shostl2_t *e);

/**
 *  Get ipv6shostl2 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ihosti 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ipv6shostl2_get(int unit,
                int ihosti,
                soc_sbx_g2p3_ipv6shostl2_t *e);

/*
 * Entry accessors for pvv2e
 */

/**
 * Initialize pvv2e entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_pvv2e_t_init(
    soc_sbx_g2p3_pvv2e_t *e);

/**
 * Get pvv2e entry size.
 *
 * Use this function for storage management of the
 * pvv2e table, because its entries have variable size
 *
 * @param[in]  unit chip unit number
 * @return     entry size, in words
 */
extern int soc_sbx_g2p3_pvv2e_size(int unit);

/**
 * Pack pvv2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_pvv2e_pack(int unit,
    soc_sbx_g2p3_pvv2e_t *e, uint8 *b, int bsz);

/**
 * Unpack pvv2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_pvv2e_unpack(int unit,
                soc_sbx_g2p3_pvv2e_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_pvv2e_index_check(int unit,
                int *vindex,
                int iivid,
                int iovid,
                int iport);

extern int soc_sbx_g2p3_pvv2e_entry_check(int unit,
                soc_sbx_g2p3_pvv2e_t *e);

/**
 * Synchronously set pvv2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iivid inner vlan identifier; use 0xfff for packets without an
 * inner tag
 * @param[in]  iovid outer vlan identifier
 * @param[in]  iport port
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_pvv2e_set(int unit,
                int iivid,
                int iovid,
                int iport,
                soc_sbx_g2p3_pvv2e_t *e);

/**
 * Batch add pvv2e entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  iivid inner vlan identifier; use 0xfff for packets without an
 * inner tag
 * @param[in]  iovid outer vlan identifier
 * @param[in]  iport port
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_pvv2e_add(int unit,
                int iivid,
                int iovid,
                int iport,
                soc_sbx_g2p3_pvv2e_t *e);

extern int soc_sbx_g2p3_pvv2e_add_ext(int unit,
                int iivid,
                int iovid,
                int iport,
                soc_sbx_g2p3_pvv2e_t *e);

/**
 *  Get pvv2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iivid inner vlan identifier; use 0xfff for packets without an
 * inner tag
 * @param[in]  iovid outer vlan identifier
 * @param[in]  iport port
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_pvv2e_get(int unit,
                int iivid,
                int iovid,
                int iport,
                soc_sbx_g2p3_pvv2e_t *e);

extern int soc_sbx_g2p3_pvv2e_get_ext(int unit,
                int iivid,
                int iovid,
                int iport,
                soc_sbx_g2p3_pvv2e_t *e);

/**
 * Synchronously update pvv2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iivid inner vlan identifier; use 0xfff for packets without an
 * inner tag
 * @param[in]  iovid outer vlan identifier
 * @param[in]  iport port
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_pvv2e_update(int unit,
                int iivid,
                int iovid,
                int iport,
                soc_sbx_g2p3_pvv2e_t *e);

/**
 * Batch renew pvv2e entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  iivid inner vlan identifier; use 0xfff for packets without an
 * inner tag
 * @param[in]  iovid outer vlan identifier
 * @param[in]  iport port
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_pvv2e_renew(int unit,
                int iivid,
                int iovid,
                int iport,
                soc_sbx_g2p3_pvv2e_t *e);

extern int soc_sbx_g2p3_pvv2e_renew_ext(int unit,
                int iivid,
                int iovid,
                int iport,
                soc_sbx_g2p3_pvv2e_t *e);

/**
 * Synchronously delete pvv2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iivid inner vlan identifier; use 0xfff for packets without an
 * inner tag
 * @param[in]  iovid outer vlan identifier
 * @param[in]  iport port
 */
extern int soc_sbx_g2p3_pvv2e_delete(int unit,
                int iivid,
                int iovid,
                int iport);

/**
 * Batch remove pvv2e entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  iivid inner vlan identifier; use 0xfff for packets without an
 * inner tag
 * @param[in]  iovid outer vlan identifier
 * @param[in]  iport port
 */
extern int soc_sbx_g2p3_pvv2e_remove(int unit,
                int iivid,
                int iovid,
                int iport);

extern int soc_sbx_g2p3_pvv2e_remove_ext(int unit,
                int iivid,
                int iovid,
                int iport);

/**
 * pvv2e get first entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iivid inner vlan identifier; use 0xfff for packets without an
 * inner tag
 * @param[in]  iovid outer vlan identifier
 * @param[in]  iport port
 * @retval     SOC_E_NOT_FOUND no entries
 */
extern int soc_sbx_g2p3_pvv2e_first(int unit,
                int *niivid,
                int *niovid,
                int *niport);
extern int soc_sbx_g2p3_pvv2e_first_ext(int unit,
                int *niivid,
                int *niovid,
                int *niport);
/**
 * pvv2e get next entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iivid inner vlan identifier; use 0xfff for packets without an
 * inner tag
 * @param[in]  iovid outer vlan identifier
 * @param[in]  iport port
 * @param[out] niivid next inner vlan identifier; use 0xfff for packets without an
 * inner tag
 * @param[out] niovid next outer vlan identifier
 * @param[out] niport next port
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_pvv2e_next(int unit,
                int iivid,
                int iovid,
                int iport,
                int *niivid,
                int *niovid,
                int *niport);
extern int soc_sbx_g2p3_pvv2e_next_ext(int unit,
                int iivid,
                int iovid,
                int iport,
                int *niivid,
                int *niovid,
                int *niport);

/* Batch commit for pvv2e */
/**
 * pvv2e batch commit.
 *
 * @param[in]  unit chip unit number
 * @param[in]  runlength number of elements to commit (-1 means commit all)
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_pvv2e_commit(int unit, int runlength);
extern int soc_sbx_g2p3_pvv2e_commit_ext(int unit, int runlength);

/*
 * Entry accessors for pvv2epack
 */

/**
 * Initialize pvv2epack entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_pvv2epack_t_init(
    soc_sbx_g2p3_pvv2epack_t *e);

/**
 * Get pvv2epack entry size.
 *
 * Use this function for storage management of the
 * pvv2epack table, because its entries have variable size
 *
 * @param[in]  unit chip unit number
 * @return     entry size, in words
 */
extern int soc_sbx_g2p3_pvv2epack_size(int unit);

/**
 * Pack pvv2epack entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_pvv2epack_pack(int unit,
    soc_sbx_g2p3_pvv2epack_t *e, uint8 *b, int bsz);

/**
 * Unpack pvv2epack entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_pvv2epack_unpack(int unit,
                soc_sbx_g2p3_pvv2epack_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_pvv2epack_index_check(int unit,
                int *vindex,
                int iovid,
                int iport,
                int iivid);

extern int soc_sbx_g2p3_pvv2epack_index_unpack(int unit,
                int *vindex,
                int *iovid,
                int *iport,
                int *iivid);

extern int soc_sbx_g2p3_pvv2epack_entry_check(int unit,
                soc_sbx_g2p3_pvv2epack_t *e);

/**
 * Synchronously set pvv2epack entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iovid 
 * @param[in]  iport 
 * @param[in]  iivid 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_pvv2epack_set(int unit,
                int iovid,
                int iport,
                int iivid,
                soc_sbx_g2p3_pvv2epack_t *e);

/**
 * Batch add pvv2epack entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  iovid 
 * @param[in]  iport 
 * @param[in]  iivid 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_pvv2epack_add(int unit,
                int iovid,
                int iport,
                int iivid,
                soc_sbx_g2p3_pvv2epack_t *e);

extern int soc_sbx_g2p3_pvv2epack_add_ext(int unit,
                uint8 *ikey,
                void *epacked);

/**
 *  Get pvv2epack entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iovid 
 * @param[in]  iport 
 * @param[in]  iivid 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_pvv2epack_get(int unit,
                int iovid,
                int iport,
                int iivid,
                soc_sbx_g2p3_pvv2epack_t *e);

extern int soc_sbx_g2p3_pvv2epack_get_ext(int unit,
                uint8 *ikey,
                void *epacked);

/**
 * Synchronously update pvv2epack entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iovid 
 * @param[in]  iport 
 * @param[in]  iivid 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_pvv2epack_update(int unit,
                int iovid,
                int iport,
                int iivid,
                soc_sbx_g2p3_pvv2epack_t *e);

/**
 * Batch renew pvv2epack entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  iovid 
 * @param[in]  iport 
 * @param[in]  iivid 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_pvv2epack_renew(int unit,
                int iovid,
                int iport,
                int iivid,
                soc_sbx_g2p3_pvv2epack_t *e);

extern int soc_sbx_g2p3_pvv2epack_renew_ext(int unit,
                uint8 *ikey,
                void *epacked);

/**
 * Synchronously delete pvv2epack entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iovid 
 * @param[in]  iport 
 * @param[in]  iivid 
 */
extern int soc_sbx_g2p3_pvv2epack_delete(int unit,
                int iovid,
                int iport,
                int iivid);

/**
 * Batch remove pvv2epack entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  iovid 
 * @param[in]  iport 
 * @param[in]  iivid 
 */
extern int soc_sbx_g2p3_pvv2epack_remove(int unit,
                int iovid,
                int iport,
                int iivid);

extern int soc_sbx_g2p3_pvv2epack_remove_ext(int unit,
                uint8 *ikey);

/**
 * pvv2epack get first entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iovid 
 * @param[in]  iport 
 * @param[in]  iivid 
 * @retval     SOC_E_NOT_FOUND no entries
 */
extern int soc_sbx_g2p3_pvv2epack_first(int unit,
                int *niovid,
                int *niport,
                int *niivid);
extern int soc_sbx_g2p3_pvv2epack_first_ext(int unit,
                uint8 *nikey);
/**
 * pvv2epack get next entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iovid 
 * @param[in]  iport 
 * @param[in]  iivid 
 * @param[out] niovid next 
 * @param[out] niport next 
 * @param[out] niivid next 
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_pvv2epack_next(int unit,
                int iovid,
                int iport,
                int iivid,
                int *niovid,
                int *niport,
                int *niivid);
extern int soc_sbx_g2p3_pvv2epack_next_ext(int unit,
                uint8 *ikey,
                uint8 *nikey);

/* Batch commit for pvv2epack */
/**
 * pvv2epack batch commit.
 *
 * @param[in]  unit chip unit number
 * @param[in]  runlength number of elements to commit (-1 means commit all)
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_pvv2epack_commit(int unit, int runlength);
extern int soc_sbx_g2p3_pvv2epack_commit_ext(int unit, int runlength);

/*
 * Entry accessors for isid2e
 */

/**
 * Initialize isid2e entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_isid2e_t_init(
    soc_sbx_g2p3_isid2e_t *e);

/**
 * Get isid2e entry size.
 *
 * Use this function for storage management of the
 * isid2e table, because its entries have variable size
 *
 * @param[in]  unit chip unit number
 * @return     entry size, in words
 */
extern int soc_sbx_g2p3_isid2e_size(int unit);

/**
 * Pack isid2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_isid2e_pack(int unit,
    soc_sbx_g2p3_isid2e_t *e, uint8 *b, int bsz);

/**
 * Unpack isid2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_isid2e_unpack(int unit,
                soc_sbx_g2p3_isid2e_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_isid2e_index_check(int unit,
                int *vindex,
                int iisid);

extern int soc_sbx_g2p3_isid2e_index_unpack(int unit,
                int *vindex,
                int *iisid);

extern int soc_sbx_g2p3_isid2e_entry_check(int unit,
                soc_sbx_g2p3_isid2e_t *e);

/**
 * Synchronously set isid2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iisid Backbone Service Instance Identifier of the backbone 
 * service instance
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_isid2e_set(int unit,
                int iisid,
                soc_sbx_g2p3_isid2e_t *e);

/**
 * Batch add isid2e entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  iisid Backbone Service Instance Identifier of the backbone 
 * service instance
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_isid2e_add(int unit,
                int iisid,
                soc_sbx_g2p3_isid2e_t *e);

extern int soc_sbx_g2p3_isid2e_add_ext(int unit,
                uint8 *ikey,
                void *epacked);

/**
 *  Get isid2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iisid Backbone Service Instance Identifier of the backbone 
 * service instance
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_isid2e_get(int unit,
                int iisid,
                soc_sbx_g2p3_isid2e_t *e);

extern int soc_sbx_g2p3_isid2e_get_ext(int unit,
                uint8 *ikey,
                void *epacked);

/**
 * Synchronously update isid2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iisid Backbone Service Instance Identifier of the backbone 
 * service instance
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_isid2e_update(int unit,
                int iisid,
                soc_sbx_g2p3_isid2e_t *e);

/**
 * Batch renew isid2e entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  iisid Backbone Service Instance Identifier of the backbone 
 * service instance
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_isid2e_renew(int unit,
                int iisid,
                soc_sbx_g2p3_isid2e_t *e);

extern int soc_sbx_g2p3_isid2e_renew_ext(int unit,
                uint8 *ikey,
                void *epacked);

/**
 * Synchronously delete isid2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iisid Backbone Service Instance Identifier of the backbone 
 * service instance
 */
extern int soc_sbx_g2p3_isid2e_delete(int unit,
                int iisid);

/**
 * Batch remove isid2e entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  iisid Backbone Service Instance Identifier of the backbone 
 * service instance
 */
extern int soc_sbx_g2p3_isid2e_remove(int unit,
                int iisid);

extern int soc_sbx_g2p3_isid2e_remove_ext(int unit,
                uint8 *ikey);

/**
 * isid2e get first entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iisid Backbone Service Instance Identifier of the backbone 
 * service instance
 * @retval     SOC_E_NOT_FOUND no entries
 */
extern int soc_sbx_g2p3_isid2e_first(int unit,
                int *niisid);
extern int soc_sbx_g2p3_isid2e_first_ext(int unit,
                uint8 *nikey);
/**
 * isid2e get next entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iisid Backbone Service Instance Identifier of the backbone 
 * service instance
 * @param[out] niisid next Backbone Service Instance Identifier of the backbone 
 * service instance
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_isid2e_next(int unit,
                int iisid,
                int *niisid);
extern int soc_sbx_g2p3_isid2e_next_ext(int unit,
                uint8 *ikey,
                uint8 *nikey);

/* Batch commit for isid2e */
/**
 * isid2e batch commit.
 *
 * @param[in]  unit chip unit number
 * @param[in]  runlength number of elements to commit (-1 means commit all)
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_isid2e_commit(int unit, int runlength);
extern int soc_sbx_g2p3_isid2e_commit_ext(int unit, int runlength);

/*
 * Entry accessors for oampvd2e
 */

/**
 * Initialize oampvd2e entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_oampvd2e_t_init(
    soc_sbx_g2p3_oampvd2e_t *e);

/**
 * Get oampvd2e entry size.
 *
 * Use this function for storage management of the
 * oampvd2e table, because its entries have variable size
 *
 * @param[in]  unit chip unit number
 * @return     entry size, in words
 */
extern int soc_sbx_g2p3_oampvd2e_size(int unit);

/**
 * Pack oampvd2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_oampvd2e_pack(int unit,
    soc_sbx_g2p3_oampvd2e_t *e, uint8 *b, int bsz);

/**
 * Unpack oampvd2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_oampvd2e_unpack(int unit,
                soc_sbx_g2p3_oampvd2e_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_oampvd2e_index_check(int unit,
                int *vindex,
                int iport,
                int ivid,
                int idir,
                int itag);

extern int soc_sbx_g2p3_oampvd2e_index_unpack(int unit,
                int *vindex,
                int *iport,
                int *ivid,
                int *idir,
                int *itag);

extern int soc_sbx_g2p3_oampvd2e_entry_check(int unit,
                soc_sbx_g2p3_oampvd2e_t *e);

/**
 * Synchronously set oampvd2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iport ingress port
 * @param[in]  ivid ingress VLAN identifier (VID)
 * @param[in]  idir OAM maintenence direction (up if dir=1)
 * @param[in]  itag Tag selection for up direction lookup (inner if tag=1)
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_oampvd2e_set(int unit,
                int iport,
                int ivid,
                int idir,
                int itag,
                soc_sbx_g2p3_oampvd2e_t *e);

/**
 * Batch add oampvd2e entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  iport ingress port
 * @param[in]  ivid ingress VLAN identifier (VID)
 * @param[in]  idir OAM maintenence direction (up if dir=1)
 * @param[in]  itag Tag selection for up direction lookup (inner if tag=1)
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_oampvd2e_add(int unit,
                int iport,
                int ivid,
                int idir,
                int itag,
                soc_sbx_g2p3_oampvd2e_t *e);

extern int soc_sbx_g2p3_oampvd2e_add_ext(int unit,
                uint8 *ikey,
                void *epacked);

/**
 *  Get oampvd2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iport ingress port
 * @param[in]  ivid ingress VLAN identifier (VID)
 * @param[in]  idir OAM maintenence direction (up if dir=1)
 * @param[in]  itag Tag selection for up direction lookup (inner if tag=1)
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_oampvd2e_get(int unit,
                int iport,
                int ivid,
                int idir,
                int itag,
                soc_sbx_g2p3_oampvd2e_t *e);

extern int soc_sbx_g2p3_oampvd2e_get_ext(int unit,
                uint8 *ikey,
                void *epacked);

/**
 * Synchronously update oampvd2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iport ingress port
 * @param[in]  ivid ingress VLAN identifier (VID)
 * @param[in]  idir OAM maintenence direction (up if dir=1)
 * @param[in]  itag Tag selection for up direction lookup (inner if tag=1)
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_oampvd2e_update(int unit,
                int iport,
                int ivid,
                int idir,
                int itag,
                soc_sbx_g2p3_oampvd2e_t *e);

/**
 * Batch renew oampvd2e entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  iport ingress port
 * @param[in]  ivid ingress VLAN identifier (VID)
 * @param[in]  idir OAM maintenence direction (up if dir=1)
 * @param[in]  itag Tag selection for up direction lookup (inner if tag=1)
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_oampvd2e_renew(int unit,
                int iport,
                int ivid,
                int idir,
                int itag,
                soc_sbx_g2p3_oampvd2e_t *e);

extern int soc_sbx_g2p3_oampvd2e_renew_ext(int unit,
                uint8 *ikey,
                void *epacked);

/**
 * Synchronously delete oampvd2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iport ingress port
 * @param[in]  ivid ingress VLAN identifier (VID)
 * @param[in]  idir OAM maintenence direction (up if dir=1)
 * @param[in]  itag Tag selection for up direction lookup (inner if tag=1)
 */
extern int soc_sbx_g2p3_oampvd2e_delete(int unit,
                int iport,
                int ivid,
                int idir,
                int itag);

/**
 * Batch remove oampvd2e entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  iport ingress port
 * @param[in]  ivid ingress VLAN identifier (VID)
 * @param[in]  idir OAM maintenence direction (up if dir=1)
 * @param[in]  itag Tag selection for up direction lookup (inner if tag=1)
 */
extern int soc_sbx_g2p3_oampvd2e_remove(int unit,
                int iport,
                int ivid,
                int idir,
                int itag);

extern int soc_sbx_g2p3_oampvd2e_remove_ext(int unit,
                uint8 *ikey);

/**
 * oampvd2e get first entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iport ingress port
 * @param[in]  ivid ingress VLAN identifier (VID)
 * @param[in]  idir OAM maintenence direction (up if dir=1)
 * @param[in]  itag Tag selection for up direction lookup (inner if tag=1)
 * @retval     SOC_E_NOT_FOUND no entries
 */
extern int soc_sbx_g2p3_oampvd2e_first(int unit,
                int *niport,
                int *nivid,
                int *nidir,
                int *nitag);
extern int soc_sbx_g2p3_oampvd2e_first_ext(int unit,
                uint8 *nikey);
/**
 * oampvd2e get next entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iport ingress port
 * @param[in]  ivid ingress VLAN identifier (VID)
 * @param[in]  idir OAM maintenence direction (up if dir=1)
 * @param[in]  itag Tag selection for up direction lookup (inner if tag=1)
 * @param[out] niport next ingress port
 * @param[out] nivid next ingress VLAN identifier (VID)
 * @param[out] nidir next OAM maintenence direction (up if dir=1)
 * @param[out] nitag next Tag selection for up direction lookup (inner if tag=1)
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_oampvd2e_next(int unit,
                int iport,
                int ivid,
                int idir,
                int itag,
                int *niport,
                int *nivid,
                int *nidir,
                int *nitag);
extern int soc_sbx_g2p3_oampvd2e_next_ext(int unit,
                uint8 *ikey,
                uint8 *nikey);

/* Batch commit for oampvd2e */
/**
 * oampvd2e batch commit.
 *
 * @param[in]  unit chip unit number
 * @param[in]  runlength number of elements to commit (-1 means commit all)
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_oampvd2e_commit(int unit, int runlength);
extern int soc_sbx_g2p3_oampvd2e_commit_ext(int unit, int runlength);

/*
 * Entry accessors for oammaidmep2e
 */

/**
 * Initialize oammaidmep2e entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_oammaidmep2e_t_init(
    soc_sbx_g2p3_oammaidmep2e_t *e);

/**
 * Get oammaidmep2e entry size.
 *
 * Use this function for storage management of the
 * oammaidmep2e table, because its entries have variable size
 *
 * @param[in]  unit chip unit number
 * @return     entry size, in words
 */
extern int soc_sbx_g2p3_oammaidmep2e_size(int unit);

/**
 * Pack oammaidmep2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_oammaidmep2e_pack(int unit,
    soc_sbx_g2p3_oammaidmep2e_t *e, uint8 *b, int bsz);

/**
 * Unpack oammaidmep2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_oammaidmep2e_unpack(int unit,
                soc_sbx_g2p3_oammaidmep2e_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_oammaidmep2e_index_check(int unit,
                int *vindex,
                int imaid,
                int imepid);

extern int soc_sbx_g2p3_oammaidmep2e_index_unpack(int unit,
                int *vindex,
                int *imaid,
                int *imepid);

extern int soc_sbx_g2p3_oammaidmep2e_entry_check(int unit,
                soc_sbx_g2p3_oammaidmep2e_t *e);

/**
 * Synchronously set oammaidmep2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  imaid This is the index of the local endpoint entry.
 * @param[in]  imepid This is the peer MEP's ID.
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_oammaidmep2e_set(int unit,
                int imaid,
                int imepid,
                soc_sbx_g2p3_oammaidmep2e_t *e);

/**
 * Batch add oammaidmep2e entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  imaid This is the index of the local endpoint entry.
 * @param[in]  imepid This is the peer MEP's ID.
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_oammaidmep2e_add(int unit,
                int imaid,
                int imepid,
                soc_sbx_g2p3_oammaidmep2e_t *e);

extern int soc_sbx_g2p3_oammaidmep2e_add_ext(int unit,
                uint8 *ikey,
                void *epacked);

/**
 *  Get oammaidmep2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  imaid This is the index of the local endpoint entry.
 * @param[in]  imepid This is the peer MEP's ID.
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_oammaidmep2e_get(int unit,
                int imaid,
                int imepid,
                soc_sbx_g2p3_oammaidmep2e_t *e);

extern int soc_sbx_g2p3_oammaidmep2e_get_ext(int unit,
                uint8 *ikey,
                void *epacked);

/**
 * Synchronously update oammaidmep2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  imaid This is the index of the local endpoint entry.
 * @param[in]  imepid This is the peer MEP's ID.
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_oammaidmep2e_update(int unit,
                int imaid,
                int imepid,
                soc_sbx_g2p3_oammaidmep2e_t *e);

/**
 * Batch renew oammaidmep2e entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  imaid This is the index of the local endpoint entry.
 * @param[in]  imepid This is the peer MEP's ID.
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_oammaidmep2e_renew(int unit,
                int imaid,
                int imepid,
                soc_sbx_g2p3_oammaidmep2e_t *e);

extern int soc_sbx_g2p3_oammaidmep2e_renew_ext(int unit,
                uint8 *ikey,
                void *epacked);

/**
 * Synchronously delete oammaidmep2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  imaid This is the index of the local endpoint entry.
 * @param[in]  imepid This is the peer MEP's ID.
 */
extern int soc_sbx_g2p3_oammaidmep2e_delete(int unit,
                int imaid,
                int imepid);

/**
 * Batch remove oammaidmep2e entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  imaid This is the index of the local endpoint entry.
 * @param[in]  imepid This is the peer MEP's ID.
 */
extern int soc_sbx_g2p3_oammaidmep2e_remove(int unit,
                int imaid,
                int imepid);

extern int soc_sbx_g2p3_oammaidmep2e_remove_ext(int unit,
                uint8 *ikey);

/**
 * oammaidmep2e get first entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  imaid This is the index of the local endpoint entry.
 * @param[in]  imepid This is the peer MEP's ID.
 * @retval     SOC_E_NOT_FOUND no entries
 */
extern int soc_sbx_g2p3_oammaidmep2e_first(int unit,
                int *nimaid,
                int *nimepid);
extern int soc_sbx_g2p3_oammaidmep2e_first_ext(int unit,
                uint8 *nikey);
/**
 * oammaidmep2e get next entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  imaid This is the index of the local endpoint entry.
 * @param[in]  imepid This is the peer MEP's ID.
 * @param[out] nimaid next This is the index of the local endpoint entry.
 * @param[out] nimepid next This is the peer MEP's ID.
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_oammaidmep2e_next(int unit,
                int imaid,
                int imepid,
                int *nimaid,
                int *nimepid);
extern int soc_sbx_g2p3_oammaidmep2e_next_ext(int unit,
                uint8 *ikey,
                uint8 *nikey);

/* Batch commit for oammaidmep2e */
/**
 * oammaidmep2e batch commit.
 *
 * @param[in]  unit chip unit number
 * @param[in]  runlength number of elements to commit (-1 means commit all)
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_oammaidmep2e_commit(int unit, int runlength);
extern int soc_sbx_g2p3_oammaidmep2e_commit_ext(int unit, int runlength);

/*
 * Entry accessors for cuckoo
 */

/**
 * Initialize cuckoo entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_cuckoo_t_init(
    soc_sbx_g2p3_cuckoo_t *e);

/**
 * Pack cuckoo entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_cuckoo_pack(int unit,
    soc_sbx_g2p3_cuckoo_t *e, uint8 *b, int bsz);

/**
 * Unpack cuckoo entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_cuckoo_unpack(int unit,
                soc_sbx_g2p3_cuckoo_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_cuckoo_index_check(int unit,
                int *vindex,
                int ikey,
                int itype);

extern int soc_sbx_g2p3_cuckoo_index_unpack(int unit,
                int *vindex,
                int *ikey,
                int *itype);

extern int soc_sbx_g2p3_cuckoo_entry_check(int unit,
                soc_sbx_g2p3_cuckoo_t *e);

/**
 * Synchronously set cuckoo entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ikey 
 * @param[in]  itype 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_cuckoo_set(int unit,
                int ikey,
                int itype,
                soc_sbx_g2p3_cuckoo_t *e);

/**
 * Batch add cuckoo entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  ikey 
 * @param[in]  itype 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_cuckoo_add(int unit,
                int ikey,
                int itype,
                soc_sbx_g2p3_cuckoo_t *e);

/**
 *  Get cuckoo entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ikey 
 * @param[in]  itype 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_cuckoo_get(int unit,
                int ikey,
                int itype,
                soc_sbx_g2p3_cuckoo_t *e);

/**
 * Synchronously update cuckoo entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ikey 
 * @param[in]  itype 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_cuckoo_update(int unit,
                int ikey,
                int itype,
                soc_sbx_g2p3_cuckoo_t *e);

/**
 * Batch renew cuckoo entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  ikey 
 * @param[in]  itype 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_cuckoo_renew(int unit,
                int ikey,
                int itype,
                soc_sbx_g2p3_cuckoo_t *e);

/**
 * Synchronously delete cuckoo entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ikey 
 * @param[in]  itype 
 */
extern int soc_sbx_g2p3_cuckoo_delete(int unit,
                int ikey,
                int itype);

/**
 * Batch remove cuckoo entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  ikey 
 * @param[in]  itype 
 */
extern int soc_sbx_g2p3_cuckoo_remove(int unit,
                int ikey,
                int itype);

/**
 * cuckoo get first entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ikey 
 * @param[in]  itype 
 * @retval     SOC_E_NOT_FOUND no entries
 */
extern int soc_sbx_g2p3_cuckoo_first(int unit,
                int *nikey,
                int *nitype);
/**
 * cuckoo get next entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ikey 
 * @param[in]  itype 
 * @param[out] nikey next 
 * @param[out] nitype next 
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_cuckoo_next(int unit,
                int ikey,
                int itype,
                int *nikey,
                int *nitype);

/* Batch commit for cuckoo */
/**
 * cuckoo batch commit.
 *
 * @param[in]  unit chip unit number
 * @param[in]  runlength number of elements to commit (-1 means commit all)
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_cuckoo_commit(int unit, int runlength);

/*
 * Entry accessors for left
 */

/**
 * Initialize left entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_left_t_init(
    soc_sbx_g2p3_left_t *e);

/**
 * Pack left entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_left_pack(int unit,
    soc_sbx_g2p3_left_t *e, uint8 *b, int bsz);

/**
 * Unpack left entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_left_unpack(int unit,
                soc_sbx_g2p3_left_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_left_index_check(int unit,
                int *vindex,
                int ili);

extern int soc_sbx_g2p3_left_entry_check(int unit,
                soc_sbx_g2p3_left_t *e);

/**
 * left table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of left elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  ili 
 */
extern int soc_sbx_g2p3_left_entry_table_size_get(int unit,
                int *tsize,
                int ili);

/**
 * Synchronously set left entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ili 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_left_set(int unit,
                int ili,
                soc_sbx_g2p3_left_t *e);

/**
 *  Get left entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ili 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_left_get(int unit,
                int ili,
                soc_sbx_g2p3_left_t *e);

/*
 * Entry accessors for right
 */

/**
 * Initialize right entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_right_t_init(
    soc_sbx_g2p3_right_t *e);

/**
 * Pack right entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_right_pack(int unit,
    soc_sbx_g2p3_right_t *e, uint8 *b, int bsz);

/**
 * Unpack right entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_right_unpack(int unit,
                soc_sbx_g2p3_right_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_right_index_check(int unit,
                int *vindex,
                int iri);

extern int soc_sbx_g2p3_right_entry_check(int unit,
                soc_sbx_g2p3_right_t *e);

/**
 * right table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of right elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  iri 
 */
extern int soc_sbx_g2p3_right_entry_table_size_get(int unit,
                int *tsize,
                int iri);

/**
 * Synchronously set right entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iri 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_right_set(int unit,
                int iri,
                soc_sbx_g2p3_right_t *e);

/**
 *  Get right entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iri 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_right_get(int unit,
                int iri,
                soc_sbx_g2p3_right_t *e);

/*
 * Entry accessors for outerlabelcuckoo
 */

/**
 * Initialize outerlabelcuckoo entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_outerlabelcuckoo_t_init(
    soc_sbx_g2p3_outerlabelcuckoo_t *e);

/**
 * Pack outerlabelcuckoo entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_outerlabelcuckoo_pack(int unit,
    soc_sbx_g2p3_outerlabelcuckoo_t *e, uint8 *b, int bsz);

/**
 * Unpack outerlabelcuckoo entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_outerlabelcuckoo_unpack(int unit,
                soc_sbx_g2p3_outerlabelcuckoo_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_outerlabelcuckoo_index_check(int unit,
                int *vindex,
                int ikey,
                int itype);

extern int soc_sbx_g2p3_outerlabelcuckoo_index_unpack(int unit,
                int *vindex,
                int *ikey,
                int *itype);

extern int soc_sbx_g2p3_outerlabelcuckoo_entry_check(int unit,
                soc_sbx_g2p3_outerlabelcuckoo_t *e);

/**
 * Synchronously set outerlabelcuckoo entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ikey 
 * @param[in]  itype 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_outerlabelcuckoo_set(int unit,
                int ikey,
                int itype,
                soc_sbx_g2p3_outerlabelcuckoo_t *e);

/**
 * Batch add outerlabelcuckoo entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  ikey 
 * @param[in]  itype 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_outerlabelcuckoo_add(int unit,
                int ikey,
                int itype,
                soc_sbx_g2p3_outerlabelcuckoo_t *e);

/**
 *  Get outerlabelcuckoo entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ikey 
 * @param[in]  itype 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_outerlabelcuckoo_get(int unit,
                int ikey,
                int itype,
                soc_sbx_g2p3_outerlabelcuckoo_t *e);

/**
 * Synchronously update outerlabelcuckoo entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ikey 
 * @param[in]  itype 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_outerlabelcuckoo_update(int unit,
                int ikey,
                int itype,
                soc_sbx_g2p3_outerlabelcuckoo_t *e);

/**
 * Batch renew outerlabelcuckoo entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  ikey 
 * @param[in]  itype 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_outerlabelcuckoo_renew(int unit,
                int ikey,
                int itype,
                soc_sbx_g2p3_outerlabelcuckoo_t *e);

/**
 * Synchronously delete outerlabelcuckoo entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ikey 
 * @param[in]  itype 
 */
extern int soc_sbx_g2p3_outerlabelcuckoo_delete(int unit,
                int ikey,
                int itype);

/**
 * Batch remove outerlabelcuckoo entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  ikey 
 * @param[in]  itype 
 */
extern int soc_sbx_g2p3_outerlabelcuckoo_remove(int unit,
                int ikey,
                int itype);

/**
 * outerlabelcuckoo get first entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ikey 
 * @param[in]  itype 
 * @retval     SOC_E_NOT_FOUND no entries
 */
extern int soc_sbx_g2p3_outerlabelcuckoo_first(int unit,
                int *nikey,
                int *nitype);
/**
 * outerlabelcuckoo get next entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ikey 
 * @param[in]  itype 
 * @param[out] nikey next 
 * @param[out] nitype next 
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_outerlabelcuckoo_next(int unit,
                int ikey,
                int itype,
                int *nikey,
                int *nitype);

/* Batch commit for outerlabelcuckoo */
/**
 * outerlabelcuckoo batch commit.
 *
 * @param[in]  unit chip unit number
 * @param[in]  runlength number of elements to commit (-1 means commit all)
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_outerlabelcuckoo_commit(int unit, int runlength);

/*
 * Entry accessors for outerlabelleft
 */

/**
 * Initialize outerlabelleft entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_outerlabelleft_t_init(
    soc_sbx_g2p3_outerlabelleft_t *e);

/**
 * Pack outerlabelleft entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_outerlabelleft_pack(int unit,
    soc_sbx_g2p3_outerlabelleft_t *e, uint8 *b, int bsz);

/**
 * Unpack outerlabelleft entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_outerlabelleft_unpack(int unit,
                soc_sbx_g2p3_outerlabelleft_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_outerlabelleft_index_check(int unit,
                int *vindex,
                int ili);

extern int soc_sbx_g2p3_outerlabelleft_entry_check(int unit,
                soc_sbx_g2p3_outerlabelleft_t *e);

/**
 * outerlabelleft table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of outerlabelleft elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  ili 
 */
extern int soc_sbx_g2p3_outerlabelleft_entry_table_size_get(int unit,
                int *tsize,
                int ili);

/**
 * Synchronously set outerlabelleft entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ili 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_outerlabelleft_set(int unit,
                int ili,
                soc_sbx_g2p3_outerlabelleft_t *e);

/**
 *  Get outerlabelleft entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ili 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_outerlabelleft_get(int unit,
                int ili,
                soc_sbx_g2p3_outerlabelleft_t *e);

/*
 * Entry accessors for outerlabelright
 */

/**
 * Initialize outerlabelright entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_outerlabelright_t_init(
    soc_sbx_g2p3_outerlabelright_t *e);

/**
 * Pack outerlabelright entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_outerlabelright_pack(int unit,
    soc_sbx_g2p3_outerlabelright_t *e, uint8 *b, int bsz);

/**
 * Unpack outerlabelright entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_outerlabelright_unpack(int unit,
                soc_sbx_g2p3_outerlabelright_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_outerlabelright_index_check(int unit,
                int *vindex,
                int iri);

extern int soc_sbx_g2p3_outerlabelright_entry_check(int unit,
                soc_sbx_g2p3_outerlabelright_t *e);

/**
 * outerlabelright table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of outerlabelright elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  iri 
 */
extern int soc_sbx_g2p3_outerlabelright_entry_table_size_get(int unit,
                int *tsize,
                int iri);

/**
 * Synchronously set outerlabelright entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iri 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_outerlabelright_set(int unit,
                int iri,
                soc_sbx_g2p3_outerlabelright_t *e);

/**
 *  Get outerlabelright entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iri 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_outerlabelright_get(int unit,
                int iri,
                soc_sbx_g2p3_outerlabelright_t *e);

/*
 * Entry accessors for innerlabelcuckoo
 */

/**
 * Initialize innerlabelcuckoo entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_innerlabelcuckoo_t_init(
    soc_sbx_g2p3_innerlabelcuckoo_t *e);

/**
 * Pack innerlabelcuckoo entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_innerlabelcuckoo_pack(int unit,
    soc_sbx_g2p3_innerlabelcuckoo_t *e, uint8 *b, int bsz);

/**
 * Unpack innerlabelcuckoo entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_innerlabelcuckoo_unpack(int unit,
                soc_sbx_g2p3_innerlabelcuckoo_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_innerlabelcuckoo_index_check(int unit,
                int *vindex,
                int ikey,
                int itype);

extern int soc_sbx_g2p3_innerlabelcuckoo_index_unpack(int unit,
                int *vindex,
                int *ikey,
                int *itype);

extern int soc_sbx_g2p3_innerlabelcuckoo_entry_check(int unit,
                soc_sbx_g2p3_innerlabelcuckoo_t *e);

/**
 * Synchronously set innerlabelcuckoo entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ikey 
 * @param[in]  itype 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_innerlabelcuckoo_set(int unit,
                int ikey,
                int itype,
                soc_sbx_g2p3_innerlabelcuckoo_t *e);

/**
 * Batch add innerlabelcuckoo entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  ikey 
 * @param[in]  itype 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_innerlabelcuckoo_add(int unit,
                int ikey,
                int itype,
                soc_sbx_g2p3_innerlabelcuckoo_t *e);

/**
 *  Get innerlabelcuckoo entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ikey 
 * @param[in]  itype 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_innerlabelcuckoo_get(int unit,
                int ikey,
                int itype,
                soc_sbx_g2p3_innerlabelcuckoo_t *e);

/**
 * Synchronously update innerlabelcuckoo entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ikey 
 * @param[in]  itype 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_innerlabelcuckoo_update(int unit,
                int ikey,
                int itype,
                soc_sbx_g2p3_innerlabelcuckoo_t *e);

/**
 * Batch renew innerlabelcuckoo entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  ikey 
 * @param[in]  itype 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_innerlabelcuckoo_renew(int unit,
                int ikey,
                int itype,
                soc_sbx_g2p3_innerlabelcuckoo_t *e);

/**
 * Synchronously delete innerlabelcuckoo entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ikey 
 * @param[in]  itype 
 */
extern int soc_sbx_g2p3_innerlabelcuckoo_delete(int unit,
                int ikey,
                int itype);

/**
 * Batch remove innerlabelcuckoo entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  ikey 
 * @param[in]  itype 
 */
extern int soc_sbx_g2p3_innerlabelcuckoo_remove(int unit,
                int ikey,
                int itype);

/**
 * innerlabelcuckoo get first entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ikey 
 * @param[in]  itype 
 * @retval     SOC_E_NOT_FOUND no entries
 */
extern int soc_sbx_g2p3_innerlabelcuckoo_first(int unit,
                int *nikey,
                int *nitype);
/**
 * innerlabelcuckoo get next entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ikey 
 * @param[in]  itype 
 * @param[out] nikey next 
 * @param[out] nitype next 
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_innerlabelcuckoo_next(int unit,
                int ikey,
                int itype,
                int *nikey,
                int *nitype);

/* Batch commit for innerlabelcuckoo */
/**
 * innerlabelcuckoo batch commit.
 *
 * @param[in]  unit chip unit number
 * @param[in]  runlength number of elements to commit (-1 means commit all)
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_innerlabelcuckoo_commit(int unit, int runlength);

/*
 * Entry accessors for innerlabelleft
 */

/**
 * Initialize innerlabelleft entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_innerlabelleft_t_init(
    soc_sbx_g2p3_innerlabelleft_t *e);

/**
 * Pack innerlabelleft entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_innerlabelleft_pack(int unit,
    soc_sbx_g2p3_innerlabelleft_t *e, uint8 *b, int bsz);

/**
 * Unpack innerlabelleft entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_innerlabelleft_unpack(int unit,
                soc_sbx_g2p3_innerlabelleft_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_innerlabelleft_index_check(int unit,
                int *vindex,
                int ili);

extern int soc_sbx_g2p3_innerlabelleft_entry_check(int unit,
                soc_sbx_g2p3_innerlabelleft_t *e);

/**
 * innerlabelleft table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of innerlabelleft elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  ili 
 */
extern int soc_sbx_g2p3_innerlabelleft_entry_table_size_get(int unit,
                int *tsize,
                int ili);

/**
 * Synchronously set innerlabelleft entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ili 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_innerlabelleft_set(int unit,
                int ili,
                soc_sbx_g2p3_innerlabelleft_t *e);

/**
 *  Get innerlabelleft entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ili 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_innerlabelleft_get(int unit,
                int ili,
                soc_sbx_g2p3_innerlabelleft_t *e);

/*
 * Entry accessors for innerlabelright
 */

/**
 * Initialize innerlabelright entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_innerlabelright_t_init(
    soc_sbx_g2p3_innerlabelright_t *e);

/**
 * Pack innerlabelright entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_innerlabelright_pack(int unit,
    soc_sbx_g2p3_innerlabelright_t *e, uint8 *b, int bsz);

/**
 * Unpack innerlabelright entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_innerlabelright_unpack(int unit,
                soc_sbx_g2p3_innerlabelright_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_innerlabelright_index_check(int unit,
                int *vindex,
                int iri);

extern int soc_sbx_g2p3_innerlabelright_entry_check(int unit,
                soc_sbx_g2p3_innerlabelright_t *e);

/**
 * innerlabelright table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of innerlabelright elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  iri 
 */
extern int soc_sbx_g2p3_innerlabelright_entry_table_size_get(int unit,
                int *tsize,
                int iri);

/**
 * Synchronously set innerlabelright entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iri 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_innerlabelright_set(int unit,
                int iri,
                soc_sbx_g2p3_innerlabelright_t *e);

/**
 *  Get innerlabelright entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iri 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_innerlabelright_get(int unit,
                int iri,
                soc_sbx_g2p3_innerlabelright_t *e);

/*
 * Entry accessors for label2e
 */

/**
 * Initialize label2e entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_label2e_t_init(
    soc_sbx_g2p3_label2e_t *e);

/**
 * Get label2e entry size.
 *
 * Use this function for storage management of the
 * label2e table, because its entries have variable size
 *
 * @param[in]  unit chip unit number
 * @return     entry size, in words
 */
extern int soc_sbx_g2p3_label2e_size(int unit);

/**
 * Pack label2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_label2e_pack(int unit,
    soc_sbx_g2p3_label2e_t *e, uint8 *b, int bsz);

/**
 * Unpack label2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_label2e_unpack(int unit,
                soc_sbx_g2p3_label2e_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_label2e_index_check(int unit,
                int *vindex,
                int ilabel);

extern int soc_sbx_g2p3_label2e_index_unpack(int unit,
                int *vindex,
                int *ilabel);

extern int soc_sbx_g2p3_label2e_entry_check(int unit,
                soc_sbx_g2p3_label2e_t *e);

/**
 * Synchronously set label2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ilabel MPLS Platform label
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_label2e_set(int unit,
                int ilabel,
                soc_sbx_g2p3_label2e_t *e);

/**
 * Batch add label2e entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  ilabel MPLS Platform label
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_label2e_add(int unit,
                int ilabel,
                soc_sbx_g2p3_label2e_t *e);

extern int soc_sbx_g2p3_label2e_add_ext(int unit,
                uint8 *ikey,
                void *epacked);

/**
 *  Get label2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ilabel MPLS Platform label
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_label2e_get(int unit,
                int ilabel,
                soc_sbx_g2p3_label2e_t *e);

extern int soc_sbx_g2p3_label2e_get_ext(int unit,
                uint8 *ikey,
                void *epacked);

/**
 * Synchronously update label2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ilabel MPLS Platform label
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_label2e_update(int unit,
                int ilabel,
                soc_sbx_g2p3_label2e_t *e);

/**
 * Batch renew label2e entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  ilabel MPLS Platform label
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_label2e_renew(int unit,
                int ilabel,
                soc_sbx_g2p3_label2e_t *e);

extern int soc_sbx_g2p3_label2e_renew_ext(int unit,
                uint8 *ikey,
                void *epacked);

/**
 * Synchronously delete label2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ilabel MPLS Platform label
 */
extern int soc_sbx_g2p3_label2e_delete(int unit,
                int ilabel);

/**
 * Batch remove label2e entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  ilabel MPLS Platform label
 */
extern int soc_sbx_g2p3_label2e_remove(int unit,
                int ilabel);

extern int soc_sbx_g2p3_label2e_remove_ext(int unit,
                uint8 *ikey);

/**
 * label2e get first entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ilabel MPLS Platform label
 * @retval     SOC_E_NOT_FOUND no entries
 */
extern int soc_sbx_g2p3_label2e_first(int unit,
                int *nilabel);
extern int soc_sbx_g2p3_label2e_first_ext(int unit,
                uint8 *nikey);
/**
 * label2e get next entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ilabel MPLS Platform label
 * @param[out] nilabel next MPLS Platform label
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_label2e_next(int unit,
                int ilabel,
                int *nilabel);
extern int soc_sbx_g2p3_label2e_next_ext(int unit,
                uint8 *ikey,
                uint8 *nikey);

/* Batch commit for label2e */
/**
 * label2e batch commit.
 *
 * @param[in]  unit chip unit number
 * @param[in]  runlength number of elements to commit (-1 means commit all)
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_label2e_commit(int unit, int runlength);
extern int soc_sbx_g2p3_label2e_commit_ext(int unit, int runlength);

/*
 * Entry accessors for tagged_mpls
 */

/**
 * Initialize tagged_mpls entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_tagged_mpls_t_init(
    soc_sbx_g2p3_tagged_mpls_t *e);

/**
 * Get tagged_mpls entry size.
 *
 * Use this function for storage management of the
 * tagged_mpls table, because its entries have variable size
 *
 * @param[in]  unit chip unit number
 * @return     entry size, in words
 */
extern int soc_sbx_g2p3_tagged_mpls_size(int unit);

/**
 * Pack tagged_mpls entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_tagged_mpls_pack(int unit,
    soc_sbx_g2p3_tagged_mpls_t *e, uint8 *b, int bsz);

/**
 * Unpack tagged_mpls entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_tagged_mpls_unpack(int unit,
                soc_sbx_g2p3_tagged_mpls_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_tagged_mpls_index_check(int unit,
                int *vindex,
                int irule);

extern int soc_sbx_g2p3_tagged_mpls_entry_check(int unit,
                soc_sbx_g2p3_tagged_mpls_t *e);

/**
 * Synchronously set tagged_mpls entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule Ignored.  This index is an artifact of current
 * infrastructure limitations and will be removed.
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_tagged_mpls_set(int unit,
                int irule,
                soc_sbx_g2p3_tagged_mpls_t *e);

extern int soc_sbx_g2p3_tagged_mpls_set_ext(int unit,
                int irule,
                soc_sbx_g2p3_tagged_mpls_t *e);

/**
 *  Get tagged_mpls entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule Ignored.  This index is an artifact of current
 * infrastructure limitations and will be removed.
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_tagged_mpls_get(int unit,
                int irule,
                soc_sbx_g2p3_tagged_mpls_t *e);

extern int soc_sbx_g2p3_tagged_mpls_get_ext(int unit,
                int irule,
                soc_sbx_g2p3_tagged_mpls_t *e);

/*
 * Entry accessors for v2e
 */

/**
 * Initialize v2e entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_v2e_t_init(
    soc_sbx_g2p3_v2e_t *e);

/**
 * Pack v2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_v2e_pack(int unit,
    soc_sbx_g2p3_v2e_t *e, uint8 *b, int bsz);

/**
 * Unpack v2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_v2e_unpack(int unit,
                soc_sbx_g2p3_v2e_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_v2e_index_check(int unit,
                int *vindex,
                int ivlan);

extern int soc_sbx_g2p3_v2e_entry_check(int unit,
                soc_sbx_g2p3_v2e_t *e);

/**
 * v2e table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of v2e elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  ivlan internal VLAN (virtual switching instance or VSI) identifier
 */
extern int soc_sbx_g2p3_v2e_entry_table_size_get(int unit,
                int *tsize,
                int ivlan);

/**
 * Synchronously set v2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ivlan internal VLAN (virtual switching instance or VSI) identifier
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_v2e_set(int unit,
                int ivlan,
                soc_sbx_g2p3_v2e_t *e);

/**
 * v2e.forceflood fast set function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ivlan internal VLAN (virtual switching instance or VSI) identifier
 * @param[in]  eivlan ending internal VLAN (virtual switching instance or VSI) identifier
 * @param[in]  sets array of set flags for forceflood (NULL means set all)
 * @param[in]  vs array of new values for forceflood
 * @param[in]  vcount array size of vs
 */
extern int soc_sbx_g2p3_v2e_forceflood_fast_set(int unit,
                int ivlan,
                int eivlan,
                int *sets,
                uint32 *vs,
                int vcount);

/**
 *  Get v2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ivlan internal VLAN (virtual switching instance or VSI) identifier
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_v2e_get(int unit,
                int ivlan,
                soc_sbx_g2p3_v2e_t *e);

/*
 * Entry accessors for v2e1
 */

/**
 * Initialize v2e1 entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_v2e1_t_init(
    soc_sbx_g2p3_v2e1_t *e);

/**
 * Pack v2e1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_v2e1_pack(int unit,
    soc_sbx_g2p3_v2e1_t *e, uint8 *b, int bsz);

/**
 * Unpack v2e1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_v2e1_unpack(int unit,
                soc_sbx_g2p3_v2e1_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_v2e1_index_check(int unit,
                int *vindex,
                int ivlan);

extern int soc_sbx_g2p3_v2e1_entry_check(int unit,
                soc_sbx_g2p3_v2e1_t *e);

/**
 * v2e1 table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of v2e1 elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  ivlan internal VLAN identifier
 */
extern int soc_sbx_g2p3_v2e1_entry_table_size_get(int unit,
                int *tsize,
                int ivlan);

/**
 * Synchronously set v2e1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ivlan internal VLAN identifier
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_v2e1_set(int unit,
                int ivlan,
                soc_sbx_g2p3_v2e1_t *e);

/**
 *  Get v2e1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ivlan internal VLAN identifier
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_v2e1_get(int unit,
                int ivlan,
                soc_sbx_g2p3_v2e1_t *e);

/*
 * Entry accessors for lp
 */

/**
 * Initialize lp entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_lp_t_init(
    soc_sbx_g2p3_lp_t *e);

/**
 * Pack lp entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_lp_pack(int unit,
    soc_sbx_g2p3_lp_t *e, uint8 *b, int bsz);

/**
 * Unpack lp entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_lp_unpack(int unit,
                soc_sbx_g2p3_lp_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_lp_index_check(int unit,
                int *vindex,
                int ilpi);

extern int soc_sbx_g2p3_lp_entry_check(int unit,
                soc_sbx_g2p3_lp_t *e);

/**
 * lp table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of lp elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  ilpi logical port table index
 */
extern int soc_sbx_g2p3_lp_entry_table_size_get(int unit,
                int *tsize,
                int ilpi);

/**
 * Synchronously set lp entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ilpi logical port table index
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_lp_set(int unit,
                int ilpi,
                soc_sbx_g2p3_lp_t *e);

/**
 * lp.policer fast get function.
 *
 * @param[in]   unit chip unit number
 * @param[in]  ilpi logical port table index
 * @param[in]  eilpi ending logical port table index
 * @param[out]  vs array of values for policer
 * @param[in]   vcount array size of vs
 */
extern int soc_sbx_g2p3_lp_policer_fast_get(int unit,
                int ilpi,
                int eilpi,
                uint32 *vs,
                int vcount);

/**
 *  Get lp entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ilpi logical port table index
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_lp_get(int unit,
                int ilpi,
                soc_sbx_g2p3_lp_t *e);

/*
 * Entry accessors for l2e
 */

/**
 * Initialize l2e entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_l2e_t_init(
    soc_sbx_g2p3_l2e_t *e);

/**
 * Pack l2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_l2e_pack(int unit,
    soc_sbx_g2p3_l2e_t *e, uint8 *b, int bsz);

/**
 * Unpack l2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_l2e_unpack(int unit,
                soc_sbx_g2p3_l2e_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_l2e_index_check(int unit,
                int *vindex,
                int ilabel);

extern int soc_sbx_g2p3_l2e_entry_check(int unit,
                soc_sbx_g2p3_l2e_t *e);

/**
 * l2e table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of l2e elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  ilabel the least significant bits of the MPLS label
 */
extern int soc_sbx_g2p3_l2e_entry_table_size_get(int unit,
                int *tsize,
                int ilabel);

/**
 * Synchronously set l2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ilabel the least significant bits of the MPLS label
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_l2e_set(int unit,
                int ilabel,
                soc_sbx_g2p3_l2e_t *e);

/**
 *  Get l2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ilabel the least significant bits of the MPLS label
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_l2e_get(int unit,
                int ilabel,
                soc_sbx_g2p3_l2e_t *e);

/*
 * Entry accessors for l2cp
 */

/**
 * Initialize l2cp entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_l2cp_t_init(
    soc_sbx_g2p3_l2cp_t *e);

/**
 * Pack l2cp entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_l2cp_pack(int unit,
    soc_sbx_g2p3_l2cp_t *e, uint8 *b, int bsz);

/**
 * Unpack l2cp entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_l2cp_unpack(int unit,
                soc_sbx_g2p3_l2cp_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_l2cp_index_check(int unit,
                int *vindex,
                int ilsb,
                int iport);

extern int soc_sbx_g2p3_l2cp_entry_check(int unit,
                soc_sbx_g2p3_l2cp_t *e);

/**
 * l2cp table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of l2cp elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  ilsb L2CP packet DMAC least significant byte
 * @param[in]  iport ingress port
 */
extern int soc_sbx_g2p3_l2cp_entry_table_size_get(int unit,
                int *tsize,
                int ilsb,
                int iport);

/**
 * Synchronously set l2cp entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ilsb L2CP packet DMAC least significant byte
 * @param[in]  iport ingress port
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_l2cp_set(int unit,
                int ilsb,
                int iport,
                soc_sbx_g2p3_l2cp_t *e);

/**
 *  Get l2cp entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ilsb L2CP packet DMAC least significant byte
 * @param[in]  iport ingress port
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_l2cp_get(int unit,
                int ilsb,
                int iport,
                soc_sbx_g2p3_l2cp_t *e);

/*
 * Entry accessors for l2cpslow
 */

/**
 * Initialize l2cpslow entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_l2cpslow_t_init(
    soc_sbx_g2p3_l2cpslow_t *e);

/**
 * Pack l2cpslow entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_l2cpslow_pack(int unit,
    soc_sbx_g2p3_l2cpslow_t *e, uint8 *b, int bsz);

/**
 * Unpack l2cpslow entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_l2cpslow_unpack(int unit,
                soc_sbx_g2p3_l2cpslow_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_l2cpslow_index_check(int unit,
                int *vindex,
                int isubcode,
                int iport);

extern int soc_sbx_g2p3_l2cpslow_entry_check(int unit,
                soc_sbx_g2p3_l2cpslow_t *e);

/**
 * l2cpslow table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of l2cpslow elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  isubcode L2CP slow protocol subcode
 * @param[in]  iport ingress port
 */
extern int soc_sbx_g2p3_l2cpslow_entry_table_size_get(int unit,
                int *tsize,
                int isubcode,
                int iport);

/**
 * Synchronously set l2cpslow entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  isubcode L2CP slow protocol subcode
 * @param[in]  iport ingress port
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_l2cpslow_set(int unit,
                int isubcode,
                int iport,
                soc_sbx_g2p3_l2cpslow_t *e);

/**
 *  Get l2cpslow entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  isubcode L2CP slow protocol subcode
 * @param[in]  iport ingress port
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_l2cpslow_get(int unit,
                int isubcode,
                int iport,
                soc_sbx_g2p3_l2cpslow_t *e);

/*
 * Entry accessors for l2cpnop
 */

/**
 * Initialize l2cpnop entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_l2cpnop_t_init(
    soc_sbx_g2p3_l2cpnop_t *e);

/**
 * Pack l2cpnop entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_l2cpnop_pack(int unit,
    soc_sbx_g2p3_l2cpnop_t *e, uint8 *b, int bsz);

/**
 * Unpack l2cpnop entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_l2cpnop_unpack(int unit,
                soc_sbx_g2p3_l2cpnop_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_l2cpnop_index_check(int unit,
                int *vindex,
                int ii);

extern int soc_sbx_g2p3_l2cpnop_entry_check(int unit,
                soc_sbx_g2p3_l2cpnop_t *e);

/**
 * l2cpnop table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of l2cpnop elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  ii HIDE
 */
extern int soc_sbx_g2p3_l2cpnop_entry_table_size_get(int unit,
                int *tsize,
                int ii);

/**
 * Synchronously set l2cpnop entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ii HIDE
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_l2cpnop_set(int unit,
                int ii,
                soc_sbx_g2p3_l2cpnop_t *e);

/**
 *  Get l2cpnop entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ii HIDE
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_l2cpnop_get(int unit,
                int ii,
                soc_sbx_g2p3_l2cpnop_t *e);

/*
 * Entry accessors for ft
 */

/**
 * Initialize ft entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ft_t_init(
    soc_sbx_g2p3_ft_t *e);

/**
 * Pack ft entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ft_pack(int unit,
    soc_sbx_g2p3_ft_t *e, uint8 *b, int bsz);

/**
 * Unpack ft entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ft_unpack(int unit,
                soc_sbx_g2p3_ft_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ft_index_check(int unit,
                int *vindex,
                int ifti);

extern int soc_sbx_g2p3_ft_entry_check(int unit,
                soc_sbx_g2p3_ft_t *e);

/**
 * ft table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of ft elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  ifti forwarding table index
 */
extern int soc_sbx_g2p3_ft_entry_table_size_get(int unit,
                int *tsize,
                int ifti);

/**
 * Synchronously set ft entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ifti forwarding table index
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ft_set(int unit,
                int ifti,
                soc_sbx_g2p3_ft_t *e);

/**
 *  Get ft entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ifti forwarding table index
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ft_get(int unit,
                int ifti,
                soc_sbx_g2p3_ft_t *e);

/*
 * Entry accessors for OamTimerCalendar
 */

/**
 * Initialize OamTimerCalendar entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_oamtimercalendar_t_init(
    soc_sbx_g2p3_oamtimercalendar_t *e);

/**
 * Pack OamTimerCalendar entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_oamtimercalendar_pack(int unit,
    soc_sbx_g2p3_oamtimercalendar_t *e, uint8 *b, int bsz);

/**
 * Unpack OamTimerCalendar entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_oamtimercalendar_unpack(int unit,
                soc_sbx_g2p3_oamtimercalendar_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_oamtimercalendar_index_check(int unit,
                int *vindex,
                int ilistmgrindex);

extern int soc_sbx_g2p3_oamtimercalendar_entry_check(int unit,
                soc_sbx_g2p3_oamtimercalendar_t *e);

/**
 * OamTimerCalendar table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of OamTimerCalendar elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  ilistmgrindex The index into this table is returned by the Service Processor
 * list-manager.
 */
extern int soc_sbx_g2p3_oamtimercalendar_entry_table_size_get(int unit,
                int *tsize,
                int ilistmgrindex);

/**
 * Synchronously set OamTimerCalendar entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ilistmgrindex The index into this table is returned by the Service Processor
 * list-manager.
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_oamtimercalendar_set(int unit,
                int ilistmgrindex,
                soc_sbx_g2p3_oamtimercalendar_t *e);

/**
 *  Get OamTimerCalendar entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ilistmgrindex The index into this table is returned by the Service Processor
 * list-manager.
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_oamtimercalendar_get(int unit,
                int ilistmgrindex,
                soc_sbx_g2p3_oamtimercalendar_t *e);

/*
 * Entry accessors for OamPortMdLevel2Etc
 */

/**
 * Initialize OamPortMdLevel2Etc entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_oamportmdlevel2etc_t_init(
    soc_sbx_g2p3_oamportmdlevel2etc_t *e);

/**
 * Pack OamPortMdLevel2Etc entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_oamportmdlevel2etc_pack(int unit,
    soc_sbx_g2p3_oamportmdlevel2etc_t *e, uint8 *b, int bsz);

/**
 * Unpack OamPortMdLevel2Etc entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_oamportmdlevel2etc_unpack(int unit,
                soc_sbx_g2p3_oamportmdlevel2etc_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_oamportmdlevel2etc_index_check(int unit,
                int *vindex,
                int iportmd);

extern int soc_sbx_g2p3_oamportmdlevel2etc_entry_check(int unit,
                soc_sbx_g2p3_oamportmdlevel2etc_t *e);

/**
 * OamPortMdLevel2Etc table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of OamPortMdLevel2Etc elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  iportmd Index is Port and MdLevel.
 */
extern int soc_sbx_g2p3_oamportmdlevel2etc_entry_table_size_get(int unit,
                int *tsize,
                int iportmd);

/**
 * Synchronously set OamPortMdLevel2Etc entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iportmd Index is Port and MdLevel.
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_oamportmdlevel2etc_set(int unit,
                int iportmd,
                soc_sbx_g2p3_oamportmdlevel2etc_t *e);

/**
 *  Get OamPortMdLevel2Etc entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iportmd Index is Port and MdLevel.
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_oamportmdlevel2etc_get(int unit,
                int iportmd,
                soc_sbx_g2p3_oamportmdlevel2etc_t *e);

/*
 * Entry accessors for v4uc_str_sel
 */

/**
 * Initialize v4uc_str_sel entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_v4uc_str_sel_t_init(
    soc_sbx_g2p3_v4uc_str_sel_t *e);

/**
 * Get v4uc_str_sel entry size.
 *
 * Use this function for storage management of the
 * v4uc_str_sel table, because its entries have variable size
 *
 * @param[in]  unit chip unit number
 * @return     entry size, in words
 */
extern int soc_sbx_g2p3_v4uc_str_sel_size(int unit);

/**
 * Pack v4uc_str_sel entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_v4uc_str_sel_pack(int unit,
    soc_sbx_g2p3_v4uc_str_sel_t *e, uint8 *b, int bsz);

/**
 * Unpack v4uc_str_sel entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_v4uc_str_sel_unpack(int unit,
                soc_sbx_g2p3_v4uc_str_sel_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_v4uc_str_sel_index_check(int unit,
                int *vindex,
                int irule);

extern int soc_sbx_g2p3_v4uc_str_sel_entry_check(int unit,
                soc_sbx_g2p3_v4uc_str_sel_t *e);

/**
 * Synchronously set v4uc_str_sel entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule Ignored.  This index is an artifact of current
 * infrastructure limitations and will be removed.
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_v4uc_str_sel_set(int unit,
                int irule,
                soc_sbx_g2p3_v4uc_str_sel_t *e);

extern int soc_sbx_g2p3_v4uc_str_sel_set_ext(int unit,
                int irule,
                soc_sbx_g2p3_v4uc_str_sel_t *e);

/**
 *  Get v4uc_str_sel entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule Ignored.  This index is an artifact of current
 * infrastructure limitations and will be removed.
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_v4uc_str_sel_get(int unit,
                int irule,
                soc_sbx_g2p3_v4uc_str_sel_t *e);

extern int soc_sbx_g2p3_v4uc_str_sel_get_ext(int unit,
                int irule,
                soc_sbx_g2p3_v4uc_str_sel_t *e);

/*
 * Entry accessors for cmac
 */

/**
 * Initialize cmac entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_cmac_t_init(
    soc_sbx_g2p3_cmac_t *e);

/**
 * Get cmac entry size.
 *
 * Use this function for storage management of the
 * cmac table, because its entries have variable size
 *
 * @param[in]  unit chip unit number
 * @return     entry size, in words
 */
extern int soc_sbx_g2p3_cmac_size(int unit);

/**
 * Pack cmac entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_cmac_pack(int unit,
    soc_sbx_g2p3_cmac_t *e, uint8 *b, int bsz);

/**
 * Unpack cmac entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_cmac_unpack(int unit,
                soc_sbx_g2p3_cmac_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_cmac_index_check(int unit,
                int *vindex,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan);

extern int soc_sbx_g2p3_cmac_entry_check(int unit,
                soc_sbx_g2p3_cmac_t *e);

/**
 * Synchronously set cmac entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  imac 
 * @param[in]  ivlan 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_cmac_set(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan,
                soc_sbx_g2p3_cmac_t *e);

/**
 * Batch add cmac entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  imac 
 * @param[in]  ivlan 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_cmac_add(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan,
                soc_sbx_g2p3_cmac_t *e);

extern int soc_sbx_g2p3_cmac_add_ext(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan,
                soc_sbx_g2p3_cmac_t *e);

/**
 *  Get cmac entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  imac 
 * @param[in]  ivlan 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_cmac_get(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan,
                soc_sbx_g2p3_cmac_t *e);

extern int soc_sbx_g2p3_cmac_get_ext(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan,
                soc_sbx_g2p3_cmac_t *e);

/**
 * Synchronously update cmac entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  imac 
 * @param[in]  ivlan 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_cmac_update(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan,
                soc_sbx_g2p3_cmac_t *e);

extern int soc_sbx_g2p3_cmac_update_ext(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan,
                soc_sbx_g2p3_cmac_t *e);

/**
 * Synchronously delete cmac entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  imac 
 * @param[in]  ivlan 
 */
extern int soc_sbx_g2p3_cmac_delete(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan);

/**
 * Batch remove cmac entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  imac 
 * @param[in]  ivlan 
 */
extern int soc_sbx_g2p3_cmac_remove(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan);

extern int soc_sbx_g2p3_cmac_remove_ext(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan);

/**
 * cmac get first entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  imac 
 * @param[in]  ivlan 
 * @retval     SOC_E_NOT_FOUND no entries
 */
extern int soc_sbx_g2p3_cmac_first(int unit,
                soc_sbx_g2p3_6_byte_t nimac,
                int *nivlan);
extern int soc_sbx_g2p3_cmac_first_ext(int unit,
                soc_sbx_g2p3_6_byte_t nimac,
                int *nivlan);
/**
 * cmac get next entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  imac 
 * @param[in]  ivlan 
 * @param[out] nimac next 
 * @param[out] nivlan next 
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_cmac_next(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan,
                soc_sbx_g2p3_6_byte_t nimac,
                int *nivlan);
extern int soc_sbx_g2p3_cmac_next_ext(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan,
                soc_sbx_g2p3_6_byte_t nimac,
                int *nivlan);

/* Batch commit for cmac */
/**
 * cmac batch commit.
 *
 * @param[in]  unit chip unit number
 * @param[in]  runlength number of elements to commit (-1 means commit all)
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_cmac_commit(int unit, int runlength);
extern int soc_sbx_g2p3_cmac_commit_ext(int unit, int runlength);

/*
 * Entry accessors for bmac
 */

/**
 * Initialize bmac entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_bmac_t_init(
    soc_sbx_g2p3_bmac_t *e);

/**
 * Get bmac entry size.
 *
 * Use this function for storage management of the
 * bmac table, because its entries have variable size
 *
 * @param[in]  unit chip unit number
 * @return     entry size, in words
 */
extern int soc_sbx_g2p3_bmac_size(int unit);

/**
 * Pack bmac entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_bmac_pack(int unit,
    soc_sbx_g2p3_bmac_t *e, uint8 *b, int bsz);

/**
 * Unpack bmac entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_bmac_unpack(int unit,
                soc_sbx_g2p3_bmac_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_bmac_index_check(int unit,
                int *vindex,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan);

extern int soc_sbx_g2p3_bmac_entry_check(int unit,
                soc_sbx_g2p3_bmac_t *e);

/**
 * Synchronously set bmac entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  imac 
 * @param[in]  ivlan 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_bmac_set(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan,
                soc_sbx_g2p3_bmac_t *e);

/**
 * Batch add bmac entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  imac 
 * @param[in]  ivlan 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_bmac_add(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan,
                soc_sbx_g2p3_bmac_t *e);

extern int soc_sbx_g2p3_bmac_add_ext(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan,
                soc_sbx_g2p3_bmac_t *e);

/**
 *  Get bmac entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  imac 
 * @param[in]  ivlan 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_bmac_get(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan,
                soc_sbx_g2p3_bmac_t *e);

extern int soc_sbx_g2p3_bmac_get_ext(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan,
                soc_sbx_g2p3_bmac_t *e);

/**
 * Synchronously update bmac entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  imac 
 * @param[in]  ivlan 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_bmac_update(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan,
                soc_sbx_g2p3_bmac_t *e);

extern int soc_sbx_g2p3_bmac_update_ext(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan,
                soc_sbx_g2p3_bmac_t *e);

/**
 * Synchronously delete bmac entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  imac 
 * @param[in]  ivlan 
 */
extern int soc_sbx_g2p3_bmac_delete(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan);

/**
 * Batch remove bmac entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  imac 
 * @param[in]  ivlan 
 */
extern int soc_sbx_g2p3_bmac_remove(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan);

extern int soc_sbx_g2p3_bmac_remove_ext(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan);

/**
 * bmac get first entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  imac 
 * @param[in]  ivlan 
 * @retval     SOC_E_NOT_FOUND no entries
 */
extern int soc_sbx_g2p3_bmac_first(int unit,
                soc_sbx_g2p3_6_byte_t nimac,
                int *nivlan);
extern int soc_sbx_g2p3_bmac_first_ext(int unit,
                soc_sbx_g2p3_6_byte_t nimac,
                int *nivlan);
/**
 * bmac get next entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  imac 
 * @param[in]  ivlan 
 * @param[out] nimac next 
 * @param[out] nivlan next 
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_bmac_next(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan,
                soc_sbx_g2p3_6_byte_t nimac,
                int *nivlan);
extern int soc_sbx_g2p3_bmac_next_ext(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan,
                soc_sbx_g2p3_6_byte_t nimac,
                int *nivlan);

/* Batch commit for bmac */
/**
 * bmac batch commit.
 *
 * @param[in]  unit chip unit number
 * @param[in]  runlength number of elements to commit (-1 means commit all)
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_bmac_commit(int unit, int runlength);
extern int soc_sbx_g2p3_bmac_commit_ext(int unit, int runlength);

/*
 * Entry accessors for ipv6mcsg
 */

/**
 * Initialize ipv6mcsg entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ipv6mcsg_t_init(
    soc_sbx_g2p3_ipv6mcsg_t *e);

/**
 * Pack ipv6mcsg entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ipv6mcsg_pack(int unit,
    soc_sbx_g2p3_ipv6mcsg_t *e, uint8 *b, int bsz);

/**
 * Unpack ipv6mcsg entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ipv6mcsg_unpack(int unit,
                soc_sbx_g2p3_ipv6mcsg_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ipv6mcsg_index_check(int unit,
                int *vindex,
                soc_sbx_g2p3_16_byte_t ig,
                soc_sbx_g2p3_16_byte_t is,
                int ivlan);

extern int soc_sbx_g2p3_ipv6mcsg_index_unpack(int unit,
                int *vindex,
                soc_sbx_g2p3_16_byte_t ig,
                soc_sbx_g2p3_16_byte_t is,
                int *ivlan);

extern int soc_sbx_g2p3_ipv6mcsg_entry_check(int unit,
                soc_sbx_g2p3_ipv6mcsg_t *e);

/**
 * Synchronously set ipv6mcsg entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ig 
 * @param[in]  is 
 * @param[in]  ivlan 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv6mcsg_set(int unit,
                soc_sbx_g2p3_16_byte_t ig,
                soc_sbx_g2p3_16_byte_t is,
                int ivlan,
                soc_sbx_g2p3_ipv6mcsg_t *e);

/**
 * Batch add ipv6mcsg entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  ig 
 * @param[in]  is 
 * @param[in]  ivlan 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv6mcsg_add(int unit,
                soc_sbx_g2p3_16_byte_t ig,
                soc_sbx_g2p3_16_byte_t is,
                int ivlan,
                soc_sbx_g2p3_ipv6mcsg_t *e);

/**
 *  Get ipv6mcsg entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ig 
 * @param[in]  is 
 * @param[in]  ivlan 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ipv6mcsg_get(int unit,
                soc_sbx_g2p3_16_byte_t ig,
                soc_sbx_g2p3_16_byte_t is,
                int ivlan,
                soc_sbx_g2p3_ipv6mcsg_t *e);

/**
 * Synchronously update ipv6mcsg entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ig 
 * @param[in]  is 
 * @param[in]  ivlan 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv6mcsg_update(int unit,
                soc_sbx_g2p3_16_byte_t ig,
                soc_sbx_g2p3_16_byte_t is,
                int ivlan,
                soc_sbx_g2p3_ipv6mcsg_t *e);

/**
 * Synchronously delete ipv6mcsg entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ig 
 * @param[in]  is 
 * @param[in]  ivlan 
 */
extern int soc_sbx_g2p3_ipv6mcsg_delete(int unit,
                soc_sbx_g2p3_16_byte_t ig,
                soc_sbx_g2p3_16_byte_t is,
                int ivlan);

/**
 * Batch remove ipv6mcsg entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  ig 
 * @param[in]  is 
 * @param[in]  ivlan 
 */
extern int soc_sbx_g2p3_ipv6mcsg_remove(int unit,
                soc_sbx_g2p3_16_byte_t ig,
                soc_sbx_g2p3_16_byte_t is,
                int ivlan);

/**
 * ipv6mcsg get first entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ig 
 * @param[in]  is 
 * @param[in]  ivlan 
 * @retval     SOC_E_NOT_FOUND no entries
 */
extern int soc_sbx_g2p3_ipv6mcsg_first(int unit,
                soc_sbx_g2p3_16_byte_t nig,
                soc_sbx_g2p3_16_byte_t nis,
                int *nivlan);
/**
 * ipv6mcsg get next entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ig 
 * @param[in]  is 
 * @param[in]  ivlan 
 * @param[out] nig next 
 * @param[out] nis next 
 * @param[out] nivlan next 
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_ipv6mcsg_next(int unit,
                soc_sbx_g2p3_16_byte_t ig,
                soc_sbx_g2p3_16_byte_t is,
                int ivlan,
                soc_sbx_g2p3_16_byte_t nig,
                soc_sbx_g2p3_16_byte_t nis,
                int *nivlan);

/* Batch commit for ipv6mcsg */
/**
 * ipv6mcsg batch commit.
 *
 * @param[in]  unit chip unit number
 * @param[in]  runlength number of elements to commit (-1 means commit all)
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_ipv6mcsg_commit(int unit, int runlength);

/*
 * Entry accessors for ipv6mcsgl1
 */

/**
 * Initialize ipv6mcsgl1 entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ipv6mcsgl1_t_init(
    soc_sbx_g2p3_ipv6mcsgl1_t *e);

/**
 * Pack ipv6mcsgl1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ipv6mcsgl1_pack(int unit,
    soc_sbx_g2p3_ipv6mcsgl1_t *e, uint8 *b, int bsz);

/**
 * Unpack ipv6mcsgl1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ipv6mcsgl1_unpack(int unit,
                soc_sbx_g2p3_ipv6mcsgl1_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ipv6mcsgl1_index_check(int unit,
                int *vindex,
                int il1i);

extern int soc_sbx_g2p3_ipv6mcsgl1_entry_check(int unit,
                soc_sbx_g2p3_ipv6mcsgl1_t *e);

/**
 * ipv6mcsgl1 table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of ipv6mcsgl1 elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  il1i 
 */
extern int soc_sbx_g2p3_ipv6mcsgl1_entry_table_size_get(int unit,
                int *tsize,
                int il1i);

/**
 * Synchronously set ipv6mcsgl1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  il1i 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv6mcsgl1_set(int unit,
                int il1i,
                soc_sbx_g2p3_ipv6mcsgl1_t *e);

/**
 *  Get ipv6mcsgl1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  il1i 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ipv6mcsgl1_get(int unit,
                int il1i,
                soc_sbx_g2p3_ipv6mcsgl1_t *e);

/*
 * Entry accessors for ipv6mcsgl2
 */

/**
 * Initialize ipv6mcsgl2 entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ipv6mcsgl2_t_init(
    soc_sbx_g2p3_ipv6mcsgl2_t *e);

/**
 * Pack ipv6mcsgl2 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ipv6mcsgl2_pack(int unit,
    soc_sbx_g2p3_ipv6mcsgl2_t *e, uint8 *b, int bsz);

/**
 * Unpack ipv6mcsgl2 entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ipv6mcsgl2_unpack(int unit,
                soc_sbx_g2p3_ipv6mcsgl2_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ipv6mcsgl2_index_check(int unit,
                int *vindex,
                int imcgi);

extern int soc_sbx_g2p3_ipv6mcsgl2_entry_check(int unit,
                soc_sbx_g2p3_ipv6mcsgl2_t *e);

/**
 * ipv6mcsgl2 table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of ipv6mcsgl2 elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  imcgi 
 */
extern int soc_sbx_g2p3_ipv6mcsgl2_entry_table_size_get(int unit,
                int *tsize,
                int imcgi);

/**
 * Synchronously set ipv6mcsgl2 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  imcgi 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv6mcsgl2_set(int unit,
                int imcgi,
                soc_sbx_g2p3_ipv6mcsgl2_t *e);

/**
 *  Get ipv6mcsgl2 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  imcgi 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ipv6mcsgl2_get(int unit,
                int imcgi,
                soc_sbx_g2p3_ipv6mcsgl2_t *e);

/*
 * Entry accessors for ipv6mcg
 */

/**
 * Initialize ipv6mcg entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ipv6mcg_t_init(
    soc_sbx_g2p3_ipv6mcg_t *e);

/**
 * Pack ipv6mcg entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ipv6mcg_pack(int unit,
    soc_sbx_g2p3_ipv6mcg_t *e, uint8 *b, int bsz);

/**
 * Unpack ipv6mcg entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ipv6mcg_unpack(int unit,
                soc_sbx_g2p3_ipv6mcg_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ipv6mcg_index_check(int unit,
                int *vindex,
                soc_sbx_g2p3_16_byte_t ig,
                int ivlan);

extern int soc_sbx_g2p3_ipv6mcg_index_unpack(int unit,
                int *vindex,
                soc_sbx_g2p3_16_byte_t ig,
                int *ivlan);

extern int soc_sbx_g2p3_ipv6mcg_entry_check(int unit,
                soc_sbx_g2p3_ipv6mcg_t *e);

/**
 * Synchronously set ipv6mcg entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ig 
 * @param[in]  ivlan 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv6mcg_set(int unit,
                soc_sbx_g2p3_16_byte_t ig,
                int ivlan,
                soc_sbx_g2p3_ipv6mcg_t *e);

/**
 * Batch add ipv6mcg entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  ig 
 * @param[in]  ivlan 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv6mcg_add(int unit,
                soc_sbx_g2p3_16_byte_t ig,
                int ivlan,
                soc_sbx_g2p3_ipv6mcg_t *e);

/**
 *  Get ipv6mcg entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ig 
 * @param[in]  ivlan 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ipv6mcg_get(int unit,
                soc_sbx_g2p3_16_byte_t ig,
                int ivlan,
                soc_sbx_g2p3_ipv6mcg_t *e);

/**
 * Synchronously update ipv6mcg entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ig 
 * @param[in]  ivlan 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv6mcg_update(int unit,
                soc_sbx_g2p3_16_byte_t ig,
                int ivlan,
                soc_sbx_g2p3_ipv6mcg_t *e);

/**
 * Synchronously delete ipv6mcg entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ig 
 * @param[in]  ivlan 
 */
extern int soc_sbx_g2p3_ipv6mcg_delete(int unit,
                soc_sbx_g2p3_16_byte_t ig,
                int ivlan);

/**
 * Batch remove ipv6mcg entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  ig 
 * @param[in]  ivlan 
 */
extern int soc_sbx_g2p3_ipv6mcg_remove(int unit,
                soc_sbx_g2p3_16_byte_t ig,
                int ivlan);

/**
 * ipv6mcg get first entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ig 
 * @param[in]  ivlan 
 * @retval     SOC_E_NOT_FOUND no entries
 */
extern int soc_sbx_g2p3_ipv6mcg_first(int unit,
                soc_sbx_g2p3_16_byte_t nig,
                int *nivlan);
/**
 * ipv6mcg get next entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ig 
 * @param[in]  ivlan 
 * @param[out] nig next 
 * @param[out] nivlan next 
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_ipv6mcg_next(int unit,
                soc_sbx_g2p3_16_byte_t ig,
                int ivlan,
                soc_sbx_g2p3_16_byte_t nig,
                int *nivlan);

/* Batch commit for ipv6mcg */
/**
 * ipv6mcg batch commit.
 *
 * @param[in]  unit chip unit number
 * @param[in]  runlength number of elements to commit (-1 means commit all)
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_ipv6mcg_commit(int unit, int runlength);

/*
 * Entry accessors for ipv6mcgl1
 */

/**
 * Initialize ipv6mcgl1 entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ipv6mcgl1_t_init(
    soc_sbx_g2p3_ipv6mcgl1_t *e);

/**
 * Pack ipv6mcgl1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ipv6mcgl1_pack(int unit,
    soc_sbx_g2p3_ipv6mcgl1_t *e, uint8 *b, int bsz);

/**
 * Unpack ipv6mcgl1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ipv6mcgl1_unpack(int unit,
                soc_sbx_g2p3_ipv6mcgl1_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ipv6mcgl1_index_check(int unit,
                int *vindex,
                int il1i);

extern int soc_sbx_g2p3_ipv6mcgl1_entry_check(int unit,
                soc_sbx_g2p3_ipv6mcgl1_t *e);

/**
 * ipv6mcgl1 table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of ipv6mcgl1 elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  il1i 
 */
extern int soc_sbx_g2p3_ipv6mcgl1_entry_table_size_get(int unit,
                int *tsize,
                int il1i);

/**
 * Synchronously set ipv6mcgl1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  il1i 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv6mcgl1_set(int unit,
                int il1i,
                soc_sbx_g2p3_ipv6mcgl1_t *e);

/**
 *  Get ipv6mcgl1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  il1i 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ipv6mcgl1_get(int unit,
                int il1i,
                soc_sbx_g2p3_ipv6mcgl1_t *e);

/*
 * Entry accessors for ipv6mcgl2
 */

/**
 * Initialize ipv6mcgl2 entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ipv6mcgl2_t_init(
    soc_sbx_g2p3_ipv6mcgl2_t *e);

/**
 * Pack ipv6mcgl2 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ipv6mcgl2_pack(int unit,
    soc_sbx_g2p3_ipv6mcgl2_t *e, uint8 *b, int bsz);

/**
 * Unpack ipv6mcgl2 entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ipv6mcgl2_unpack(int unit,
                soc_sbx_g2p3_ipv6mcgl2_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ipv6mcgl2_index_check(int unit,
                int *vindex,
                int imcgi);

extern int soc_sbx_g2p3_ipv6mcgl2_entry_check(int unit,
                soc_sbx_g2p3_ipv6mcgl2_t *e);

/**
 * ipv6mcgl2 table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of ipv6mcgl2 elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  imcgi 
 */
extern int soc_sbx_g2p3_ipv6mcgl2_entry_table_size_get(int unit,
                int *tsize,
                int imcgi);

/**
 * Synchronously set ipv6mcgl2 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  imcgi 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv6mcgl2_set(int unit,
                int imcgi,
                soc_sbx_g2p3_ipv6mcgl2_t *e);

/**
 *  Get ipv6mcgl2 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  imcgi 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ipv6mcgl2_get(int unit,
                int imcgi,
                soc_sbx_g2p3_ipv6mcgl2_t *e);

/*
 * Entry accessors for ipv4mcg
 */

/**
 * Initialize ipv4mcg entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ipv4mcg_t_init(
    soc_sbx_g2p3_ipv4mcg_t *e);

/**
 * Pack ipv4mcg entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ipv4mcg_pack(int unit,
    soc_sbx_g2p3_ipv4mcg_t *e, uint8 *b, int bsz);

/**
 * Unpack ipv4mcg entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ipv4mcg_unpack(int unit,
                soc_sbx_g2p3_ipv4mcg_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ipv4mcg_index_check(int unit,
                int *vindex,
                int ig,
                int ivlan);

extern int soc_sbx_g2p3_ipv4mcg_index_unpack(int unit,
                int *vindex,
                int *ig,
                int *ivlan);

extern int soc_sbx_g2p3_ipv4mcg_entry_check(int unit,
                soc_sbx_g2p3_ipv4mcg_t *e);

/**
 * Synchronously set ipv4mcg entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ig 
 * @param[in]  ivlan 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv4mcg_set(int unit,
                int ig,
                int ivlan,
                soc_sbx_g2p3_ipv4mcg_t *e);

/**
 * Batch add ipv4mcg entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  ig 
 * @param[in]  ivlan 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv4mcg_add(int unit,
                int ig,
                int ivlan,
                soc_sbx_g2p3_ipv4mcg_t *e);

/**
 *  Get ipv4mcg entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ig 
 * @param[in]  ivlan 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ipv4mcg_get(int unit,
                int ig,
                int ivlan,
                soc_sbx_g2p3_ipv4mcg_t *e);

/**
 * Synchronously update ipv4mcg entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ig 
 * @param[in]  ivlan 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv4mcg_update(int unit,
                int ig,
                int ivlan,
                soc_sbx_g2p3_ipv4mcg_t *e);

/**
 * Synchronously delete ipv4mcg entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ig 
 * @param[in]  ivlan 
 */
extern int soc_sbx_g2p3_ipv4mcg_delete(int unit,
                int ig,
                int ivlan);

/**
 * Batch remove ipv4mcg entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  ig 
 * @param[in]  ivlan 
 */
extern int soc_sbx_g2p3_ipv4mcg_remove(int unit,
                int ig,
                int ivlan);

/**
 * ipv4mcg get first entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ig 
 * @param[in]  ivlan 
 * @retval     SOC_E_NOT_FOUND no entries
 */
extern int soc_sbx_g2p3_ipv4mcg_first(int unit,
                int *nig,
                int *nivlan);
/**
 * ipv4mcg get next entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ig 
 * @param[in]  ivlan 
 * @param[out] nig next 
 * @param[out] nivlan next 
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_ipv4mcg_next(int unit,
                int ig,
                int ivlan,
                int *nig,
                int *nivlan);

/* Batch commit for ipv4mcg */
/**
 * ipv4mcg batch commit.
 *
 * @param[in]  unit chip unit number
 * @param[in]  runlength number of elements to commit (-1 means commit all)
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_ipv4mcg_commit(int unit, int runlength);

/*
 * Entry accessors for ipv4mcgl1
 */

/**
 * Initialize ipv4mcgl1 entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ipv4mcgl1_t_init(
    soc_sbx_g2p3_ipv4mcgl1_t *e);

/**
 * Pack ipv4mcgl1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ipv4mcgl1_pack(int unit,
    soc_sbx_g2p3_ipv4mcgl1_t *e, uint8 *b, int bsz);

/**
 * Unpack ipv4mcgl1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ipv4mcgl1_unpack(int unit,
                soc_sbx_g2p3_ipv4mcgl1_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ipv4mcgl1_index_check(int unit,
                int *vindex,
                int il1i);

extern int soc_sbx_g2p3_ipv4mcgl1_entry_check(int unit,
                soc_sbx_g2p3_ipv4mcgl1_t *e);

/**
 * ipv4mcgl1 table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of ipv4mcgl1 elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  il1i 
 */
extern int soc_sbx_g2p3_ipv4mcgl1_entry_table_size_get(int unit,
                int *tsize,
                int il1i);

/**
 * Synchronously set ipv4mcgl1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  il1i 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv4mcgl1_set(int unit,
                int il1i,
                soc_sbx_g2p3_ipv4mcgl1_t *e);

/**
 *  Get ipv4mcgl1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  il1i 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ipv4mcgl1_get(int unit,
                int il1i,
                soc_sbx_g2p3_ipv4mcgl1_t *e);

/*
 * Entry accessors for ipv4mcgl2
 */

/**
 * Initialize ipv4mcgl2 entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ipv4mcgl2_t_init(
    soc_sbx_g2p3_ipv4mcgl2_t *e);

/**
 * Pack ipv4mcgl2 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ipv4mcgl2_pack(int unit,
    soc_sbx_g2p3_ipv4mcgl2_t *e, uint8 *b, int bsz);

/**
 * Unpack ipv4mcgl2 entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ipv4mcgl2_unpack(int unit,
                soc_sbx_g2p3_ipv4mcgl2_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ipv4mcgl2_index_check(int unit,
                int *vindex,
                int imcgi);

extern int soc_sbx_g2p3_ipv4mcgl2_entry_check(int unit,
                soc_sbx_g2p3_ipv4mcgl2_t *e);

/**
 * ipv4mcgl2 table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of ipv4mcgl2 elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  imcgi 
 */
extern int soc_sbx_g2p3_ipv4mcgl2_entry_table_size_get(int unit,
                int *tsize,
                int imcgi);

/**
 * Synchronously set ipv4mcgl2 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  imcgi 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv4mcgl2_set(int unit,
                int imcgi,
                soc_sbx_g2p3_ipv4mcgl2_t *e);

/**
 *  Get ipv4mcgl2 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  imcgi 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ipv4mcgl2_get(int unit,
                int imcgi,
                soc_sbx_g2p3_ipv4mcgl2_t *e);

/*
 * Entry accessors for ipv4mcsg
 */

/**
 * Initialize ipv4mcsg entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ipv4mcsg_t_init(
    soc_sbx_g2p3_ipv4mcsg_t *e);

/**
 * Pack ipv4mcsg entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ipv4mcsg_pack(int unit,
    soc_sbx_g2p3_ipv4mcsg_t *e, uint8 *b, int bsz);

/**
 * Unpack ipv4mcsg entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ipv4mcsg_unpack(int unit,
                soc_sbx_g2p3_ipv4mcsg_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ipv4mcsg_index_check(int unit,
                int *vindex,
                int ig,
                int is,
                int ivlan);

extern int soc_sbx_g2p3_ipv4mcsg_index_unpack(int unit,
                int *vindex,
                int *ig,
                int *is,
                int *ivlan);

extern int soc_sbx_g2p3_ipv4mcsg_entry_check(int unit,
                soc_sbx_g2p3_ipv4mcsg_t *e);

/**
 * Synchronously set ipv4mcsg entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ig 
 * @param[in]  is 
 * @param[in]  ivlan 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv4mcsg_set(int unit,
                int ig,
                int is,
                int ivlan,
                soc_sbx_g2p3_ipv4mcsg_t *e);

/**
 * Batch add ipv4mcsg entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  ig 
 * @param[in]  is 
 * @param[in]  ivlan 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv4mcsg_add(int unit,
                int ig,
                int is,
                int ivlan,
                soc_sbx_g2p3_ipv4mcsg_t *e);

/**
 *  Get ipv4mcsg entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ig 
 * @param[in]  is 
 * @param[in]  ivlan 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ipv4mcsg_get(int unit,
                int ig,
                int is,
                int ivlan,
                soc_sbx_g2p3_ipv4mcsg_t *e);

/**
 * Synchronously update ipv4mcsg entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ig 
 * @param[in]  is 
 * @param[in]  ivlan 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv4mcsg_update(int unit,
                int ig,
                int is,
                int ivlan,
                soc_sbx_g2p3_ipv4mcsg_t *e);

/**
 * Synchronously delete ipv4mcsg entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ig 
 * @param[in]  is 
 * @param[in]  ivlan 
 */
extern int soc_sbx_g2p3_ipv4mcsg_delete(int unit,
                int ig,
                int is,
                int ivlan);

/**
 * Batch remove ipv4mcsg entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  ig 
 * @param[in]  is 
 * @param[in]  ivlan 
 */
extern int soc_sbx_g2p3_ipv4mcsg_remove(int unit,
                int ig,
                int is,
                int ivlan);

/**
 * ipv4mcsg get first entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ig 
 * @param[in]  is 
 * @param[in]  ivlan 
 * @retval     SOC_E_NOT_FOUND no entries
 */
extern int soc_sbx_g2p3_ipv4mcsg_first(int unit,
                int *nig,
                int *nis,
                int *nivlan);
/**
 * ipv4mcsg get next entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ig 
 * @param[in]  is 
 * @param[in]  ivlan 
 * @param[out] nig next 
 * @param[out] nis next 
 * @param[out] nivlan next 
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_ipv4mcsg_next(int unit,
                int ig,
                int is,
                int ivlan,
                int *nig,
                int *nis,
                int *nivlan);

/* Batch commit for ipv4mcsg */
/**
 * ipv4mcsg batch commit.
 *
 * @param[in]  unit chip unit number
 * @param[in]  runlength number of elements to commit (-1 means commit all)
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_ipv4mcsg_commit(int unit, int runlength);

/*
 * Entry accessors for ipv4mcsgl1
 */

/**
 * Initialize ipv4mcsgl1 entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ipv4mcsgl1_t_init(
    soc_sbx_g2p3_ipv4mcsgl1_t *e);

/**
 * Pack ipv4mcsgl1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ipv4mcsgl1_pack(int unit,
    soc_sbx_g2p3_ipv4mcsgl1_t *e, uint8 *b, int bsz);

/**
 * Unpack ipv4mcsgl1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ipv4mcsgl1_unpack(int unit,
                soc_sbx_g2p3_ipv4mcsgl1_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ipv4mcsgl1_index_check(int unit,
                int *vindex,
                int il1i);

extern int soc_sbx_g2p3_ipv4mcsgl1_entry_check(int unit,
                soc_sbx_g2p3_ipv4mcsgl1_t *e);

/**
 * ipv4mcsgl1 table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of ipv4mcsgl1 elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  il1i 
 */
extern int soc_sbx_g2p3_ipv4mcsgl1_entry_table_size_get(int unit,
                int *tsize,
                int il1i);

/**
 * Synchronously set ipv4mcsgl1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  il1i 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv4mcsgl1_set(int unit,
                int il1i,
                soc_sbx_g2p3_ipv4mcsgl1_t *e);

/**
 *  Get ipv4mcsgl1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  il1i 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ipv4mcsgl1_get(int unit,
                int il1i,
                soc_sbx_g2p3_ipv4mcsgl1_t *e);

/*
 * Entry accessors for ipv4mcsgl2
 */

/**
 * Initialize ipv4mcsgl2 entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ipv4mcsgl2_t_init(
    soc_sbx_g2p3_ipv4mcsgl2_t *e);

/**
 * Pack ipv4mcsgl2 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ipv4mcsgl2_pack(int unit,
    soc_sbx_g2p3_ipv4mcsgl2_t *e, uint8 *b, int bsz);

/**
 * Unpack ipv4mcsgl2 entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ipv4mcsgl2_unpack(int unit,
                soc_sbx_g2p3_ipv4mcsgl2_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ipv4mcsgl2_index_check(int unit,
                int *vindex,
                int imcgi);

extern int soc_sbx_g2p3_ipv4mcsgl2_entry_check(int unit,
                soc_sbx_g2p3_ipv4mcsgl2_t *e);

/**
 * ipv4mcsgl2 table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of ipv4mcsgl2 elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  imcgi 
 */
extern int soc_sbx_g2p3_ipv4mcsgl2_entry_table_size_get(int unit,
                int *tsize,
                int imcgi);

/**
 * Synchronously set ipv4mcsgl2 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  imcgi 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv4mcsgl2_set(int unit,
                int imcgi,
                soc_sbx_g2p3_ipv4mcsgl2_t *e);

/**
 *  Get ipv4mcsgl2 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  imcgi 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ipv4mcsgl2_get(int unit,
                int imcgi,
                soc_sbx_g2p3_ipv4mcsgl2_t *e);

/*
 * Entry accessors for lpmnode
 */

/**
 * Initialize lpmnode entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_lpmnode_t_init(
    soc_sbx_g2p3_lpmnode_t *e);

/**
 * Get lpmnode entry size.
 *
 * Use this function for storage management of the
 * lpmnode table, because its entries have variable size
 *
 * @param[in]  unit chip unit number
 * @return     entry size, in words
 */
extern int soc_sbx_g2p3_lpmnode_size(int unit);

/**
 * Pack lpmnode entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_lpmnode_pack(int unit,
    soc_sbx_g2p3_lpmnode_t *e, uint8 *b, int bsz);

/**
 * Unpack lpmnode entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_lpmnode_unpack(int unit,
                soc_sbx_g2p3_lpmnode_t *e, uint8 *b, int bsz);

/*
 * Entry accessors for ipv4sa
 */

/**
 * Initialize ipv4sa entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ipv4sa_t_init(
    soc_sbx_g2p3_ipv4sa_t *e);

/**
 * Pack ipv4sa entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ipv4sa_pack(int unit,
    soc_sbx_g2p3_ipv4sa_t *e, uint8 *b, int bsz);

/**
 * Unpack ipv4sa entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ipv4sa_unpack(int unit,
                soc_sbx_g2p3_ipv4sa_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ipv4sa_index_check(int unit,
                int *vindex,
                int iprefixbits,
                int iip,
                int iipcxt);

extern int soc_sbx_g2p3_ipv4sa_index_unpack(int unit,
                int *vindex,
                int *iprefixbits,
                int *iip,
                int *iipcxt);

extern int soc_sbx_g2p3_ipv4sa_entry_check(int unit,
                soc_sbx_g2p3_ipv4sa_t *e);

/**
 * Synchronously set ipv4sa entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iprefixbits LPM prefix length, in bits
 * @param[in]  iip 
 * @param[in]  iipcxt 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv4sa_set(int unit,
                int iprefixbits,
                int iip,
                int iipcxt,
                soc_sbx_g2p3_ipv4sa_t *e);

/**
 * Batch add ipv4sa entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  iprefixbits LPM prefix length, in bits
 * @param[in]  iip 
 * @param[in]  iipcxt 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv4sa_add(int unit,
                int iprefixbits,
                int iip,
                int iipcxt,
                soc_sbx_g2p3_ipv4sa_t *e);

/**
 *  Get ipv4sa entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iprefixbits LPM prefix length, in bits
 * @param[in]  iip 
 * @param[in]  iipcxt 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ipv4sa_get(int unit,
                int iprefixbits,
                int iip,
                int iipcxt,
                soc_sbx_g2p3_ipv4sa_t *e);

/**
 * Synchronously update ipv4sa entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iprefixbits LPM prefix length, in bits
 * @param[in]  iip 
 * @param[in]  iipcxt 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv4sa_update(int unit,
                int iprefixbits,
                int iip,
                int iipcxt,
                soc_sbx_g2p3_ipv4sa_t *e);

/**
 * Batch renew ipv4sa entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  iprefixbits LPM prefix length, in bits
 * @param[in]  iip 
 * @param[in]  iipcxt 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv4sa_renew(int unit,
                int iprefixbits,
                int iip,
                int iipcxt,
                soc_sbx_g2p3_ipv4sa_t *e);

/**
 * Synchronously delete ipv4sa entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iprefixbits LPM prefix length, in bits
 * @param[in]  iip 
 * @param[in]  iipcxt 
 */
extern int soc_sbx_g2p3_ipv4sa_delete(int unit,
                int iprefixbits,
                int iip,
                int iipcxt);

/**
 * Batch remove ipv4sa entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  iprefixbits LPM prefix length, in bits
 * @param[in]  iip 
 * @param[in]  iipcxt 
 */
extern int soc_sbx_g2p3_ipv4sa_remove(int unit,
                int iprefixbits,
                int iip,
                int iipcxt);

/**
 * ipv4sa get first entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iprefixbits LPM prefix length, in bits
 * @param[in]  iip 
 * @param[in]  iipcxt 
 * @retval     SOC_E_NOT_FOUND no entries
 */
extern int soc_sbx_g2p3_ipv4sa_first(int unit,
                int *niprefixbits,
                int *niip,
                int *niipcxt);
/**
 * ipv4sa get next entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iprefixbits LPM prefix length, in bits
 * @param[in]  iip 
 * @param[in]  iipcxt 
 * @param[out] niprefixbits next LPM prefix length, in bits
 * @param[out] niip next 
 * @param[out] niipcxt next 
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_ipv4sa_next(int unit,
                int iprefixbits,
                int iip,
                int iipcxt,
                int *niprefixbits,
                int *niip,
                int *niipcxt);

/* Batch commit for ipv4sa */
/**
 * ipv4sa batch commit.
 *
 * @param[in]  unit chip unit number
 * @param[in]  runlength number of elements to commit (-1 means commit all)
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_ipv4sa_commit(int unit, int runlength);

/*
 * Entry accessors for ipv4sal0
 */

/**
 * Initialize ipv4sal0 entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ipv4sal0_t_init(
    soc_sbx_g2p3_ipv4sal0_t *e);

/**
 * Pack ipv4sal0 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ipv4sal0_pack(int unit,
    soc_sbx_g2p3_ipv4sal0_t *e, uint8 *b, int bsz);

/**
 * Unpack ipv4sal0 entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ipv4sal0_unpack(int unit,
                soc_sbx_g2p3_ipv4sal0_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ipv4sal0_index_check(int unit,
                int *vindex,
                int iaddr);

extern int soc_sbx_g2p3_ipv4sal0_entry_check(int unit,
                soc_sbx_g2p3_ipv4sal0_t *e);

/**
 * ipv4sal0 table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of ipv4sal0 elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  iaddr the most significant bits of the IP VRF concatenated
 * with the IP SA
 */
extern int soc_sbx_g2p3_ipv4sal0_entry_table_size_get(int unit,
                int *tsize,
                int iaddr);

/**
 * Synchronously set ipv4sal0 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iaddr the most significant bits of the IP VRF concatenated
 * with the IP SA
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv4sal0_set(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv4sal0_t *e);

/**
 *  Get ipv4sal0 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iaddr the most significant bits of the IP VRF concatenated
 * with the IP SA
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ipv4sal0_get(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv4sal0_t *e);

/*
 * Entry accessors for ipv4saodd
 */

/**
 * Initialize ipv4saodd entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ipv4saodd_t_init(
    soc_sbx_g2p3_ipv4saodd_t *e);

/**
 * Pack ipv4saodd entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ipv4saodd_pack(int unit,
    soc_sbx_g2p3_ipv4saodd_t *e, uint8 *b, int bsz);

/**
 * Unpack ipv4saodd entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ipv4saodd_unpack(int unit,
                soc_sbx_g2p3_ipv4saodd_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ipv4saodd_index_check(int unit,
                int *vindex,
                int iaddr);

extern int soc_sbx_g2p3_ipv4saodd_entry_check(int unit,
                soc_sbx_g2p3_ipv4saodd_t *e);

/**
 * ipv4saodd table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of ipv4saodd elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  iaddr the base address of the next layer table plus the next
 * most significant bits of the IP VRF concatenated with the
 * IP SA, or plus 0 if no singleton miss or plus 1 if
 * singleton match
 */
extern int soc_sbx_g2p3_ipv4saodd_entry_table_size_get(int unit,
                int *tsize,
                int iaddr);

/**
 * Synchronously set ipv4saodd entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iaddr the base address of the next layer table plus the next
 * most significant bits of the IP VRF concatenated with the
 * IP SA, or plus 0 if no singleton miss or plus 1 if
 * singleton match
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv4saodd_set(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv4saodd_t *e);

/**
 *  Get ipv4saodd entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iaddr the base address of the next layer table plus the next
 * most significant bits of the IP VRF concatenated with the
 * IP SA, or plus 0 if no singleton miss or plus 1 if
 * singleton match
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ipv4saodd_get(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv4saodd_t *e);

/*
 * Entry accessors for ipv4saeven
 */

/**
 * Initialize ipv4saeven entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ipv4saeven_t_init(
    soc_sbx_g2p3_ipv4saeven_t *e);

/**
 * Pack ipv4saeven entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ipv4saeven_pack(int unit,
    soc_sbx_g2p3_ipv4saeven_t *e, uint8 *b, int bsz);

/**
 * Unpack ipv4saeven entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ipv4saeven_unpack(int unit,
                soc_sbx_g2p3_ipv4saeven_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ipv4saeven_index_check(int unit,
                int *vindex,
                int iaddr);

extern int soc_sbx_g2p3_ipv4saeven_entry_check(int unit,
                soc_sbx_g2p3_ipv4saeven_t *e);

/**
 * ipv4saeven table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of ipv4saeven elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  iaddr the base address of the next layer table plus the next
 * most significant bits of the IP VRF concatenated with the
 * IP SA, or plus 0 if no singleton miss or plus 1 if
 * singleton match
 */
extern int soc_sbx_g2p3_ipv4saeven_entry_table_size_get(int unit,
                int *tsize,
                int iaddr);

/**
 * Synchronously set ipv4saeven entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iaddr the base address of the next layer table plus the next
 * most significant bits of the IP VRF concatenated with the
 * IP SA, or plus 0 if no singleton miss or plus 1 if
 * singleton match
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv4saeven_set(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv4saeven_t *e);

/**
 *  Get ipv4saeven entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iaddr the base address of the next layer table plus the next
 * most significant bits of the IP VRF concatenated with the
 * IP SA, or plus 0 if no singleton miss or plus 1 if
 * singleton match
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ipv4saeven_get(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv4saeven_t *e);

/*
 * Entry accessors for ipv4sapayload
 */

/**
 * Initialize ipv4sapayload entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ipv4sapayload_t_init(
    soc_sbx_g2p3_ipv4sapayload_t *e);

/**
 * Pack ipv4sapayload entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ipv4sapayload_pack(int unit,
    soc_sbx_g2p3_ipv4sapayload_t *e, uint8 *b, int bsz);

/**
 * Unpack ipv4sapayload entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ipv4sapayload_unpack(int unit,
                soc_sbx_g2p3_ipv4sapayload_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ipv4sapayload_index_check(int unit,
                int *vindex,
                int iaddr);

extern int soc_sbx_g2p3_ipv4sapayload_entry_check(int unit,
                soc_sbx_g2p3_ipv4sapayload_t *e);

/**
 * ipv4sapayload table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of ipv4sapayload elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  iaddr index into IPv4 SA payload table
 */
extern int soc_sbx_g2p3_ipv4sapayload_entry_table_size_get(int unit,
                int *tsize,
                int iaddr);

/**
 * Synchronously set ipv4sapayload entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iaddr index into IPv4 SA payload table
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv4sapayload_set(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv4sapayload_t *e);

/**
 *  Get ipv4sapayload entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iaddr index into IPv4 SA payload table
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ipv4sapayload_get(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv4sapayload_t *e);

/*
 * Entry accessors for ifp
 */

/**
 * Initialize ifp entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ifp_t_init(
    soc_sbx_g2p3_ifp_t *e);

/**
 * Get ifp entry size.
 *
 * Use this function for storage management of the
 * ifp table, because its entries have variable size
 *
 * @param[in]  unit chip unit number
 * @return     entry size, in words
 */
extern int soc_sbx_g2p3_ifp_size(int unit);

/**
 * Pack ifp entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ifp_pack(int unit,
    soc_sbx_g2p3_ifp_t *e, uint8 *b, int bsz);

/**
 * Unpack ifp entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ifp_unpack(int unit,
                soc_sbx_g2p3_ifp_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ifp_index_check(int unit,
                int *vindex,
                int irule);

extern int soc_sbx_g2p3_ifp_entry_check(int unit,
                soc_sbx_g2p3_ifp_t *e);

/**
 * Synchronously set ifp entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule rule index; lower numbers have higher matching priority
 * and rule numbers must be contiguous
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ifp_set(int unit,
                int irule,
                soc_sbx_g2p3_ifp_t *e);

/**
 * Batch add ifp entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule rule index; lower numbers have higher matching priority
 * and rule numbers must be contiguous
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ifp_add(int unit,
                int irule,
                soc_sbx_g2p3_ifp_t *e);

extern int soc_sbx_g2p3_ifp_add_ext(int unit,
                int irule,
                soc_sbx_g2p3_ifp_t *e);

/**
 *  Get ifp entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule rule index; lower numbers have higher matching priority
 * and rule numbers must be contiguous
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ifp_get(int unit,
                int irule,
                soc_sbx_g2p3_ifp_t *e);

extern int soc_sbx_g2p3_ifp_get_ext(int unit,
                int irule,
                soc_sbx_g2p3_ifp_t *e);

/**
 * Synchronously update ifp entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule rule index; lower numbers have higher matching priority
 * and rule numbers must be contiguous
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ifp_update(int unit,
                int irule,
                soc_sbx_g2p3_ifp_t *e);

extern int soc_sbx_g2p3_ifp_update_ext(int unit,
                int irule,
                soc_sbx_g2p3_ifp_t *e);

/**
 * Synchronously delete ifp entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule rule index; lower numbers have higher matching priority
 * and rule numbers must be contiguous
 */
extern int soc_sbx_g2p3_ifp_delete(int unit,
                int irule);

/**
 * Batch remove ifp entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule rule index; lower numbers have higher matching priority
 * and rule numbers must be contiguous
 */
extern int soc_sbx_g2p3_ifp_remove(int unit,
                int irule);

extern int soc_sbx_g2p3_ifp_remove_ext(int unit,
                int irule);

/**
 * ifp get first entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule rule index; lower numbers have higher matching priority
 * and rule numbers must be contiguous
 * @retval     SOC_E_NOT_FOUND no entries
 */
extern int soc_sbx_g2p3_ifp_first(int unit,
                int *nirule);
extern int soc_sbx_g2p3_ifp_first_ext(int unit,
                int *nirule);
/**
 * ifp get next entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule rule index; lower numbers have higher matching priority
 * and rule numbers must be contiguous
 * @param[out] nirule next rule index; lower numbers have higher matching priority
 * and rule numbers must be contiguous
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_ifp_next(int unit,
                int irule,
                int *nirule);
extern int soc_sbx_g2p3_ifp_next_ext(int unit,
                int irule,
                int *nirule);

/* Batch commit for ifp */
/**
 * ifp batch commit.
 *
 * @param[in]  unit chip unit number
 * @param[in]  runlength number of elements to commit (-1 means commit all)
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_ifp_commit(int unit, int runlength);
extern int soc_sbx_g2p3_ifp_commit_ext(int unit, int runlength);

/*
 * Entry accessors for ifp_v6
 */

/**
 * Initialize ifp_v6 entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ifp_v6_t_init(
    soc_sbx_g2p3_ifp_v6_t *e);

/**
 * Get ifp_v6 entry size.
 *
 * Use this function for storage management of the
 * ifp_v6 table, because its entries have variable size
 *
 * @param[in]  unit chip unit number
 * @return     entry size, in words
 */
extern int soc_sbx_g2p3_ifp_v6_size(int unit);

/**
 * Pack ifp_v6 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ifp_v6_pack(int unit,
    soc_sbx_g2p3_ifp_v6_t *e, uint8 *b, int bsz);

/**
 * Unpack ifp_v6 entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ifp_v6_unpack(int unit,
                soc_sbx_g2p3_ifp_v6_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ifp_v6_index_check(int unit,
                int *vindex,
                int irule);

extern int soc_sbx_g2p3_ifp_v6_entry_check(int unit,
                soc_sbx_g2p3_ifp_v6_t *e);

/**
 * Synchronously set ifp_v6 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule rule index; lower numbers have higher matching priority
 * and rule numbers must be contiguous
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ifp_v6_set(int unit,
                int irule,
                soc_sbx_g2p3_ifp_v6_t *e);

/**
 * Batch add ifp_v6 entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule rule index; lower numbers have higher matching priority
 * and rule numbers must be contiguous
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ifp_v6_add(int unit,
                int irule,
                soc_sbx_g2p3_ifp_v6_t *e);

extern int soc_sbx_g2p3_ifp_v6_add_ext(int unit,
                int irule,
                soc_sbx_g2p3_ifp_v6_t *e);

/**
 *  Get ifp_v6 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule rule index; lower numbers have higher matching priority
 * and rule numbers must be contiguous
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ifp_v6_get(int unit,
                int irule,
                soc_sbx_g2p3_ifp_v6_t *e);

extern int soc_sbx_g2p3_ifp_v6_get_ext(int unit,
                int irule,
                soc_sbx_g2p3_ifp_v6_t *e);

/**
 * Synchronously update ifp_v6 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule rule index; lower numbers have higher matching priority
 * and rule numbers must be contiguous
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ifp_v6_update(int unit,
                int irule,
                soc_sbx_g2p3_ifp_v6_t *e);

extern int soc_sbx_g2p3_ifp_v6_update_ext(int unit,
                int irule,
                soc_sbx_g2p3_ifp_v6_t *e);

/**
 * Synchronously delete ifp_v6 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule rule index; lower numbers have higher matching priority
 * and rule numbers must be contiguous
 */
extern int soc_sbx_g2p3_ifp_v6_delete(int unit,
                int irule);

/**
 * Batch remove ifp_v6 entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule rule index; lower numbers have higher matching priority
 * and rule numbers must be contiguous
 */
extern int soc_sbx_g2p3_ifp_v6_remove(int unit,
                int irule);

extern int soc_sbx_g2p3_ifp_v6_remove_ext(int unit,
                int irule);

/**
 * ifp_v6 get first entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule rule index; lower numbers have higher matching priority
 * and rule numbers must be contiguous
 * @retval     SOC_E_NOT_FOUND no entries
 */
extern int soc_sbx_g2p3_ifp_v6_first(int unit,
                int *nirule);
extern int soc_sbx_g2p3_ifp_v6_first_ext(int unit,
                int *nirule);
/**
 * ifp_v6 get next entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule rule index; lower numbers have higher matching priority
 * and rule numbers must be contiguous
 * @param[out] nirule next rule index; lower numbers have higher matching priority
 * and rule numbers must be contiguous
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_ifp_v6_next(int unit,
                int irule,
                int *nirule);
extern int soc_sbx_g2p3_ifp_v6_next_ext(int unit,
                int irule,
                int *nirule);

/* Batch commit for ifp_v6 */
/**
 * ifp_v6 batch commit.
 *
 * @param[in]  unit chip unit number
 * @param[in]  runlength number of elements to commit (-1 means commit all)
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_ifp_v6_commit(int unit, int runlength);
extern int soc_sbx_g2p3_ifp_v6_commit_ext(int unit, int runlength);

/*
 * Entry accessors for evp2e
 */

/**
 * Initialize evp2e entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_evp2e_t_init(
    soc_sbx_g2p3_evp2e_t *e);

/**
 * Pack evp2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_evp2e_pack(int unit,
    soc_sbx_g2p3_evp2e_t *e, uint8 *b, int bsz);

/**
 * Unpack evp2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_evp2e_unpack(int unit,
                soc_sbx_g2p3_evp2e_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_evp2e_index_check(int unit,
                int *vindex,
                int ivlan,
                int iport);

extern int soc_sbx_g2p3_evp2e_entry_check(int unit,
                soc_sbx_g2p3_evp2e_t *e);

/**
 * evp2e table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of evp2e elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  ivlan internal VLAN identifier
 * @param[in]  iport egress port
 */
extern int soc_sbx_g2p3_evp2e_entry_table_size_get(int unit,
                int *tsize,
                int ivlan,
                int iport);

/**
 * Synchronously set evp2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ivlan internal VLAN identifier
 * @param[in]  iport egress port
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_evp2e_set(int unit,
                int ivlan,
                int iport,
                soc_sbx_g2p3_evp2e_t *e);

/**
 *  Get evp2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ivlan internal VLAN identifier
 * @param[in]  iport egress port
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_evp2e_get(int unit,
                int ivlan,
                int iport,
                soc_sbx_g2p3_evp2e_t *e);

/*
 * Entry accessors for oi2e
 */

/**
 * Initialize oi2e entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_oi2e_t_init(
    soc_sbx_g2p3_oi2e_t *e);

/**
 * Pack oi2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_oi2e_pack(int unit,
    soc_sbx_g2p3_oi2e_t *e, uint8 *b, int bsz);

/**
 * Unpack oi2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_oi2e_unpack(int unit,
                soc_sbx_g2p3_oi2e_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_oi2e_index_check(int unit,
                int *vindex,
                int ioi);

extern int soc_sbx_g2p3_oi2e_entry_check(int unit,
                soc_sbx_g2p3_oi2e_t *e);

/**
 * oi2e table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of oi2e elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  ioi egress editing output header index - 8K
 */
extern int soc_sbx_g2p3_oi2e_entry_table_size_get(int unit,
                int *tsize,
                int ioi);

/**
 * Synchronously set oi2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ioi egress editing output header index - 8K
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_oi2e_set(int unit,
                int ioi,
                soc_sbx_g2p3_oi2e_t *e);

/**
 *  Get oi2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ioi egress editing output header index - 8K
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_oi2e_get(int unit,
                int ioi,
                soc_sbx_g2p3_oi2e_t *e);

/*
 * Entry accessors for eteencap
 */

/**
 * Initialize eteencap entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_eteencap_t_init(
    soc_sbx_g2p3_eteencap_t *e);

/**
 * Get eteencap entry size.
 *
 * Use this function for storage management of the
 * eteencap table, because its entries have variable size
 *
 * @param[in]  unit chip unit number
 * @return     entry size, in words
 */
extern int soc_sbx_g2p3_eteencap_size(int unit);

/**
 * Pack eteencap entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_eteencap_pack(int unit,
    soc_sbx_g2p3_eteencap_t *e, uint8 *b, int bsz);

/**
 * Unpack eteencap entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_eteencap_unpack(int unit,
                soc_sbx_g2p3_eteencap_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_eteencap_index_check(int unit,
                int *vindex,
                int ietei);

extern int soc_sbx_g2p3_eteencap_entry_check(int unit,
                soc_sbx_g2p3_eteencap_t *e);

/**
 * eteencap table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of eteencap elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  ietei ETE index
 */
extern int soc_sbx_g2p3_eteencap_entry_table_size_get(int unit,
                int *tsize,
                int ietei);

/**
 * Synchronously set eteencap entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ietei ETE index
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_eteencap_set(int unit,
                int ietei,
                soc_sbx_g2p3_eteencap_t *e);

/**
 *  Get eteencap entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ietei ETE index
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_eteencap_get(int unit,
                int ietei,
                soc_sbx_g2p3_eteencap_t *e);

/*
 * Entry accessors for etel2
 */

/**
 * Initialize etel2 entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_etel2_t_init(
    soc_sbx_g2p3_etel2_t *e);

/**
 * Get etel2 entry size.
 *
 * Use this function for storage management of the
 * etel2 table, because its entries have variable size
 *
 * @param[in]  unit chip unit number
 * @return     entry size, in words
 */
extern int soc_sbx_g2p3_etel2_size(int unit);

/**
 * Pack etel2 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_etel2_pack(int unit,
    soc_sbx_g2p3_etel2_t *e, uint8 *b, int bsz);

/**
 * Unpack etel2 entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_etel2_unpack(int unit,
                soc_sbx_g2p3_etel2_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_etel2_index_check(int unit,
                int *vindex,
                int ietei);

extern int soc_sbx_g2p3_etel2_entry_check(int unit,
                soc_sbx_g2p3_etel2_t *e);

/**
 * etel2 table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of etel2 elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  ietei ETE index
 */
extern int soc_sbx_g2p3_etel2_entry_table_size_get(int unit,
                int *tsize,
                int ietei);

/**
 * Synchronously set etel2 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ietei ETE index
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_etel2_set(int unit,
                int ietei,
                soc_sbx_g2p3_etel2_t *e);

/**
 *  Get etel2 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ietei ETE index
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_etel2_get(int unit,
                int ietei,
                soc_sbx_g2p3_etel2_t *e);

/*
 * Entry accessors for oamEp
 */

/**
 * Initialize oamEp entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_oamep_t_init(
    soc_sbx_g2p3_oamep_t *e);

/**
 * Pack oamEp entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_oamep_pack(int unit,
    soc_sbx_g2p3_oamep_t *e, uint8 *b, int bsz);

/**
 * Unpack oamEp entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_oamep_unpack(int unit,
                soc_sbx_g2p3_oamep_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_oamep_index_check(int unit,
                int *vindex,
                int iepidx);

extern int soc_sbx_g2p3_oamep_entry_check(int unit,
                soc_sbx_g2p3_oamep_t *e);

/**
 * oamEp table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of oamEp elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  iepidx OAM Endpoint Table index.
 */
extern int soc_sbx_g2p3_oamep_entry_table_size_get(int unit,
                int *tsize,
                int iepidx);

/**
 * Synchronously set oamEp entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iepidx OAM Endpoint Table index.
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_oamep_set(int unit,
                int iepidx,
                soc_sbx_g2p3_oamep_t *e);

/**
 *  Get oamEp entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iepidx OAM Endpoint Table index.
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_oamep_get(int unit,
                int iepidx,
                soc_sbx_g2p3_oamep_t *e);

/*
 * Entry accessors for remark
 */

/**
 * Initialize remark entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_remark_t_init(
    soc_sbx_g2p3_remark_t *e);

/**
 * Pack remark entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_remark_pack(int unit,
    soc_sbx_g2p3_remark_t *e, uint8 *b, int bsz);

/**
 * Unpack remark entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_remark_unpack(int unit,
                soc_sbx_g2p3_remark_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_remark_index_check(int unit,
                int *vindex,
                int ie,
                int idp,
                int icos,
                int iprof);

extern int soc_sbx_g2p3_remark_entry_check(int unit,
                soc_sbx_g2p3_remark_t *e);

/**
 * remark table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of remark elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  ie fabric ECN packet marking indicator (erh.e)
 * @param[in]  idp packet remark discard eligibility indication; 0: green,
 *                    1: yellow, 2: red (erh.rdp)
 * @param[in]  icos packet remark class of service (erh.rcos)
 * @param[in]  iprof remark table profile indication
 */
extern int soc_sbx_g2p3_remark_entry_table_size_get(int unit,
                int *tsize,
                int ie,
                int idp,
                int icos,
                int iprof);

/**
 * Synchronously set remark entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ie fabric ECN packet marking indicator (erh.e)
 * @param[in]  idp packet remark discard eligibility indication; 0: green,
 *                    1: yellow, 2: red (erh.rdp)
 * @param[in]  icos packet remark class of service (erh.rcos)
 * @param[in]  iprof remark table profile indication
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_remark_set(int unit,
                int ie,
                int idp,
                int icos,
                int iprof,
                soc_sbx_g2p3_remark_t *e);

/**
 *  Get remark entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ie fabric ECN packet marking indicator (erh.e)
 * @param[in]  idp packet remark discard eligibility indication; 0: green,
 *                    1: yellow, 2: red (erh.rdp)
 * @param[in]  icos packet remark class of service (erh.rcos)
 * @param[in]  iprof remark table profile indication
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_remark_get(int unit,
                int ie,
                int idp,
                int icos,
                int iprof,
                soc_sbx_g2p3_remark_t *e);

/*
 * Entry accessors for epv2e
 */

/**
 * Initialize epv2e entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_epv2e_t_init(
    soc_sbx_g2p3_epv2e_t *e);

/**
 * Pack epv2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_epv2e_pack(int unit,
    soc_sbx_g2p3_epv2e_t *e, uint8 *b, int bsz);

/**
 * Unpack epv2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_epv2e_unpack(int unit,
                soc_sbx_g2p3_epv2e_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_epv2e_index_check(int unit,
                int *vindex,
                int ivid,
                int iport);

extern int soc_sbx_g2p3_epv2e_entry_check(int unit,
                soc_sbx_g2p3_epv2e_t *e);

/**
 * epv2e table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of epv2e elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  ivid outer VLAN identifier
 * @param[in]  iport egress port
 */
extern int soc_sbx_g2p3_epv2e_entry_table_size_get(int unit,
                int *tsize,
                int ivid,
                int iport);

/**
 * Synchronously set epv2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ivid outer VLAN identifier
 * @param[in]  iport egress port
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_epv2e_set(int unit,
                int ivid,
                int iport,
                soc_sbx_g2p3_epv2e_t *e);

/**
 * epv2e.drop fast set function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ivid outer VLAN identifier
 * @param[in]  iport egress port
 * @param[in]  eivid ending outer VLAN identifier
 * @param[in]  eiport ending egress port
 * @param[in]  sets array of set flags for drop (NULL means set all)
 * @param[in]  vs array of new values for drop
 * @param[in]  vcount array size of vs
 */
extern int soc_sbx_g2p3_epv2e_drop_fast_set(int unit,
                int ivid,
                int iport,
                int eivid,
                int eiport,
                int *sets,
                uint32 *vs,
                int vcount);

/**
 * epv2e.strip fast set function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ivid outer VLAN identifier
 * @param[in]  iport egress port
 * @param[in]  eivid ending outer VLAN identifier
 * @param[in]  eiport ending egress port
 * @param[in]  sets array of set flags for strip (NULL means set all)
 * @param[in]  vs array of new values for strip
 * @param[in]  vcount array size of vs
 */
extern int soc_sbx_g2p3_epv2e_strip_fast_set(int unit,
                int ivid,
                int iport,
                int eivid,
                int eiport,
                int *sets,
                uint32 *vs,
                int vcount);

/**
 *  Get epv2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ivid outer VLAN identifier
 * @param[in]  iport egress port
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_epv2e_get(int unit,
                int ivid,
                int iport,
                soc_sbx_g2p3_epv2e_t *e);

/*
 * Entry accessors for esmac
 */

/**
 * Initialize esmac entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_esmac_t_init(
    soc_sbx_g2p3_esmac_t *e);

/**
 * Pack esmac entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_esmac_pack(int unit,
    soc_sbx_g2p3_esmac_t *e, uint8 *b, int bsz);

/**
 * Unpack esmac entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_esmac_unpack(int unit,
                soc_sbx_g2p3_esmac_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_esmac_index_check(int unit,
                int *vindex,
                int ismaci);

extern int soc_sbx_g2p3_esmac_entry_check(int unit,
                soc_sbx_g2p3_esmac_t *e);

/**
 * esmac table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of esmac elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  ismaci local station SMAC index
 */
extern int soc_sbx_g2p3_esmac_entry_table_size_get(int unit,
                int *tsize,
                int ismaci);

/**
 * Synchronously set esmac entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ismaci local station SMAC index
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_esmac_set(int unit,
                int ismaci,
                soc_sbx_g2p3_esmac_t *e);

/**
 *  Get esmac entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ismaci local station SMAC index
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_esmac_get(int unit,
                int ismaci,
                soc_sbx_g2p3_esmac_t *e);

/*
 * Entry accessors for ert
 */

/**
 * Initialize ert entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ert_t_init(
    soc_sbx_g2p3_ert_t *e);

/**
 * Pack ert entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ert_pack(int unit,
    soc_sbx_g2p3_ert_t *e, uint8 *b, int bsz);

/**
 * Unpack ert entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ert_unpack(int unit,
                soc_sbx_g2p3_ert_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ert_index_check(int unit,
                int *vindex,
                int irule);

extern int soc_sbx_g2p3_ert_entry_check(int unit,
                soc_sbx_g2p3_ert_t *e);

/**
 * ert table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of ert elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  irule egress rule table index
 */
extern int soc_sbx_g2p3_ert_entry_table_size_get(int unit,
                int *tsize,
                int irule);

/**
 * Synchronously set ert entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule egress rule table index
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ert_set(int unit,
                int irule,
                soc_sbx_g2p3_ert_t *e);

/**
 *  Get ert entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule egress rule table index
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ert_get(int unit,
                int irule,
                soc_sbx_g2p3_ert_t *e);

/*
 * Entry accessors for ert_wrap
 */

/**
 * Initialize ert_wrap entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ert_wrap_t_init(
    soc_sbx_g2p3_ert_wrap_t *e);

/**
 * Get ert_wrap entry size.
 *
 * Use this function for storage management of the
 * ert_wrap table, because its entries have variable size
 *
 * @param[in]  unit chip unit number
 * @return     entry size, in words
 */
extern int soc_sbx_g2p3_ert_wrap_size(int unit);

/**
 * Pack ert_wrap entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ert_wrap_pack(int unit,
    soc_sbx_g2p3_ert_wrap_t *e, uint8 *b, int bsz);

/**
 * Unpack ert_wrap entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ert_wrap_unpack(int unit,
                soc_sbx_g2p3_ert_wrap_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ert_wrap_index_check(int unit,
                int *vindex,
                int irule);

extern int soc_sbx_g2p3_ert_wrap_entry_check(int unit,
                soc_sbx_g2p3_ert_wrap_t *e);

/**
 * Synchronously set ert_wrap entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule egress rule table index
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ert_wrap_set(int unit,
                int irule,
                soc_sbx_g2p3_ert_wrap_t *e);

extern int soc_sbx_g2p3_ert_wrap_set_ext(int unit,
                int irule,
                soc_sbx_g2p3_ert_wrap_t *e);

/**
 *  Get ert_wrap entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule egress rule table index
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ert_wrap_get(int unit,
                int irule,
                soc_sbx_g2p3_ert_wrap_t *e);

extern int soc_sbx_g2p3_ert_wrap_get_ext(int unit,
                int irule,
                soc_sbx_g2p3_ert_wrap_t *e);

/*
 * Entry accessors for v4mc_str_sel
 */

/**
 * Initialize v4mc_str_sel entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_v4mc_str_sel_t_init(
    soc_sbx_g2p3_v4mc_str_sel_t *e);

/**
 * Get v4mc_str_sel entry size.
 *
 * Use this function for storage management of the
 * v4mc_str_sel table, because its entries have variable size
 *
 * @param[in]  unit chip unit number
 * @return     entry size, in words
 */
extern int soc_sbx_g2p3_v4mc_str_sel_size(int unit);

/**
 * Pack v4mc_str_sel entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_v4mc_str_sel_pack(int unit,
    soc_sbx_g2p3_v4mc_str_sel_t *e, uint8 *b, int bsz);

/**
 * Unpack v4mc_str_sel entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_v4mc_str_sel_unpack(int unit,
                soc_sbx_g2p3_v4mc_str_sel_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_v4mc_str_sel_index_check(int unit,
                int *vindex,
                int irule);

extern int soc_sbx_g2p3_v4mc_str_sel_entry_check(int unit,
                soc_sbx_g2p3_v4mc_str_sel_t *e);

/**
 * Synchronously set v4mc_str_sel entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule Ignored.  This index is an artifact of current
 * infrastructure limitations and will be removed.
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_v4mc_str_sel_set(int unit,
                int irule,
                soc_sbx_g2p3_v4mc_str_sel_t *e);

extern int soc_sbx_g2p3_v4mc_str_sel_set_ext(int unit,
                int irule,
                soc_sbx_g2p3_v4mc_str_sel_t *e);

/**
 *  Get v4mc_str_sel entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule Ignored.  This index is an artifact of current
 * infrastructure limitations and will be removed.
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_v4mc_str_sel_get(int unit,
                int irule,
                soc_sbx_g2p3_v4mc_str_sel_t *e);

extern int soc_sbx_g2p3_v4mc_str_sel_get_ext(int unit,
                int irule,
                soc_sbx_g2p3_v4mc_str_sel_t *e);

/*
 * Entry accessors for efp
 */

/**
 * Initialize efp entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_efp_t_init(
    soc_sbx_g2p3_efp_t *e);

/**
 * Get efp entry size.
 *
 * Use this function for storage management of the
 * efp table, because its entries have variable size
 *
 * @param[in]  unit chip unit number
 * @return     entry size, in words
 */
extern int soc_sbx_g2p3_efp_size(int unit);

/**
 * Pack efp entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_efp_pack(int unit,
    soc_sbx_g2p3_efp_t *e, uint8 *b, int bsz);

/**
 * Unpack efp entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_efp_unpack(int unit,
                soc_sbx_g2p3_efp_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_efp_index_check(int unit,
                int *vindex,
                int irule);

extern int soc_sbx_g2p3_efp_entry_check(int unit,
                soc_sbx_g2p3_efp_t *e);

/**
 * Synchronously set efp entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule rule index; lower numbers have higher matching priority
 * and rule numbers must be contiguous
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_efp_set(int unit,
                int irule,
                soc_sbx_g2p3_efp_t *e);

/**
 * Batch add efp entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule rule index; lower numbers have higher matching priority
 * and rule numbers must be contiguous
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_efp_add(int unit,
                int irule,
                soc_sbx_g2p3_efp_t *e);

extern int soc_sbx_g2p3_efp_add_ext(int unit,
                int irule,
                soc_sbx_g2p3_efp_t *e);

/**
 *  Get efp entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule rule index; lower numbers have higher matching priority
 * and rule numbers must be contiguous
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_efp_get(int unit,
                int irule,
                soc_sbx_g2p3_efp_t *e);

extern int soc_sbx_g2p3_efp_get_ext(int unit,
                int irule,
                soc_sbx_g2p3_efp_t *e);

/**
 * Synchronously update efp entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule rule index; lower numbers have higher matching priority
 * and rule numbers must be contiguous
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_efp_update(int unit,
                int irule,
                soc_sbx_g2p3_efp_t *e);

extern int soc_sbx_g2p3_efp_update_ext(int unit,
                int irule,
                soc_sbx_g2p3_efp_t *e);

/**
 * Synchronously delete efp entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule rule index; lower numbers have higher matching priority
 * and rule numbers must be contiguous
 */
extern int soc_sbx_g2p3_efp_delete(int unit,
                int irule);

/**
 * Batch remove efp entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule rule index; lower numbers have higher matching priority
 * and rule numbers must be contiguous
 */
extern int soc_sbx_g2p3_efp_remove(int unit,
                int irule);

extern int soc_sbx_g2p3_efp_remove_ext(int unit,
                int irule);

/**
 * efp get first entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule rule index; lower numbers have higher matching priority
 * and rule numbers must be contiguous
 * @retval     SOC_E_NOT_FOUND no entries
 */
extern int soc_sbx_g2p3_efp_first(int unit,
                int *nirule);
extern int soc_sbx_g2p3_efp_first_ext(int unit,
                int *nirule);
/**
 * efp get next entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule rule index; lower numbers have higher matching priority
 * and rule numbers must be contiguous
 * @param[out] nirule next rule index; lower numbers have higher matching priority
 * and rule numbers must be contiguous
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_efp_next(int unit,
                int irule,
                int *nirule);
extern int soc_sbx_g2p3_efp_next_ext(int unit,
                int irule,
                int *nirule);

/* Batch commit for efp */
/**
 * efp batch commit.
 *
 * @param[in]  unit chip unit number
 * @param[in]  runlength number of elements to commit (-1 means commit all)
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_efp_commit(int unit, int runlength);
extern int soc_sbx_g2p3_efp_commit_ext(int unit, int runlength);

/*
 * Entry accessors for efp_v6
 */

/**
 * Initialize efp_v6 entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_efp_v6_t_init(
    soc_sbx_g2p3_efp_v6_t *e);

/**
 * Get efp_v6 entry size.
 *
 * Use this function for storage management of the
 * efp_v6 table, because its entries have variable size
 *
 * @param[in]  unit chip unit number
 * @return     entry size, in words
 */
extern int soc_sbx_g2p3_efp_v6_size(int unit);

/**
 * Pack efp_v6 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_efp_v6_pack(int unit,
    soc_sbx_g2p3_efp_v6_t *e, uint8 *b, int bsz);

/**
 * Unpack efp_v6 entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_efp_v6_unpack(int unit,
                soc_sbx_g2p3_efp_v6_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_efp_v6_index_check(int unit,
                int *vindex,
                int irule);

extern int soc_sbx_g2p3_efp_v6_entry_check(int unit,
                soc_sbx_g2p3_efp_v6_t *e);

/**
 * Synchronously set efp_v6 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule rule index; lower numbers have higher matching priority
 * and rule numbers must be contiguous
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_efp_v6_set(int unit,
                int irule,
                soc_sbx_g2p3_efp_v6_t *e);

/**
 * Batch add efp_v6 entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule rule index; lower numbers have higher matching priority
 * and rule numbers must be contiguous
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_efp_v6_add(int unit,
                int irule,
                soc_sbx_g2p3_efp_v6_t *e);

extern int soc_sbx_g2p3_efp_v6_add_ext(int unit,
                int irule,
                soc_sbx_g2p3_efp_v6_t *e);

/**
 *  Get efp_v6 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule rule index; lower numbers have higher matching priority
 * and rule numbers must be contiguous
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_efp_v6_get(int unit,
                int irule,
                soc_sbx_g2p3_efp_v6_t *e);

extern int soc_sbx_g2p3_efp_v6_get_ext(int unit,
                int irule,
                soc_sbx_g2p3_efp_v6_t *e);

/**
 * Synchronously update efp_v6 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule rule index; lower numbers have higher matching priority
 * and rule numbers must be contiguous
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_efp_v6_update(int unit,
                int irule,
                soc_sbx_g2p3_efp_v6_t *e);

extern int soc_sbx_g2p3_efp_v6_update_ext(int unit,
                int irule,
                soc_sbx_g2p3_efp_v6_t *e);

/**
 * Synchronously delete efp_v6 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule rule index; lower numbers have higher matching priority
 * and rule numbers must be contiguous
 */
extern int soc_sbx_g2p3_efp_v6_delete(int unit,
                int irule);

/**
 * Batch remove efp_v6 entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule rule index; lower numbers have higher matching priority
 * and rule numbers must be contiguous
 */
extern int soc_sbx_g2p3_efp_v6_remove(int unit,
                int irule);

extern int soc_sbx_g2p3_efp_v6_remove_ext(int unit,
                int irule);

/**
 * efp_v6 get first entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule rule index; lower numbers have higher matching priority
 * and rule numbers must be contiguous
 * @retval     SOC_E_NOT_FOUND no entries
 */
extern int soc_sbx_g2p3_efp_v6_first(int unit,
                int *nirule);
extern int soc_sbx_g2p3_efp_v6_first_ext(int unit,
                int *nirule);
/**
 * efp_v6 get next entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  irule rule index; lower numbers have higher matching priority
 * and rule numbers must be contiguous
 * @param[out] nirule next rule index; lower numbers have higher matching priority
 * and rule numbers must be contiguous
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_efp_v6_next(int unit,
                int irule,
                int *nirule);
extern int soc_sbx_g2p3_efp_v6_next_ext(int unit,
                int irule,
                int *nirule);

/* Batch commit for efp_v6 */
/**
 * efp_v6 batch commit.
 *
 * @param[in]  unit chip unit number
 * @param[in]  runlength number of elements to commit (-1 means commit all)
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_efp_v6_commit(int unit, int runlength);
extern int soc_sbx_g2p3_efp_v6_commit_ext(int unit, int runlength);

/*
 * Entry accessors for oamMultiplier
 */

/**
 * Initialize oamMultiplier entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_oammultiplier_t_init(
    soc_sbx_g2p3_oammultiplier_t *e);

/**
 * Pack oamMultiplier entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_oammultiplier_pack(int unit,
    soc_sbx_g2p3_oammultiplier_t *e, uint8 *b, int bsz);

/**
 * Unpack oamMultiplier entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_oammultiplier_unpack(int unit,
                soc_sbx_g2p3_oammultiplier_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_oammultiplier_index_check(int unit,
                int *vindex,
                int ilosscount,
                int ithreshold);

extern int soc_sbx_g2p3_oammultiplier_entry_check(int unit,
                soc_sbx_g2p3_oammultiplier_t *e);

/**
 * oamMultiplier table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of oamMultiplier elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  ilosscount Number of lost frames.
 * @param[in]  ithreshold One of eight tables populated with values calculated
 *                    using the configured threshold ratio.
 */
extern int soc_sbx_g2p3_oammultiplier_entry_table_size_get(int unit,
                int *tsize,
                int ilosscount,
                int ithreshold);

/**
 * Synchronously set oamMultiplier entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ilosscount Number of lost frames.
 * @param[in]  ithreshold One of eight tables populated with values calculated
 *                    using the configured threshold ratio.
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_oammultiplier_set(int unit,
                int ilosscount,
                int ithreshold,
                soc_sbx_g2p3_oammultiplier_t *e);

/**
 *  Get oamMultiplier entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ilosscount Number of lost frames.
 * @param[in]  ithreshold One of eight tables populated with values calculated
 *                    using the configured threshold ratio.
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_oammultiplier_get(int unit,
                int ilosscount,
                int ithreshold,
                soc_sbx_g2p3_oammultiplier_t *e);

/*
 * Entry accessors for oamEpRemap
 */

/**
 * Initialize oamEpRemap entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_oamepremap_t_init(
    soc_sbx_g2p3_oamepremap_t *e);

/**
 * Pack oamEpRemap entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_oamepremap_pack(int unit,
    soc_sbx_g2p3_oamepremap_t *e, uint8 *b, int bsz);

/**
 * Unpack oamEpRemap entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_oamepremap_unpack(int unit,
                soc_sbx_g2p3_oamepremap_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_oamepremap_index_check(int unit,
                int *vindex,
                int iendpoint,
                int imdlevel,
                int itype);

extern int soc_sbx_g2p3_oamepremap_entry_check(int unit,
                soc_sbx_g2p3_oamepremap_t *e);

/**
 * oamEpRemap table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of oamEpRemap elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  iendpoint 13 bit endpoint index from OamInstance or PortMdLevel2etc.
 * @param[in]  imdlevel 3 bit MD Level value from packet header.
 * @param[in]  itype 2 bit type (0=CCM, 1=LM, 2=DM).
 */
extern int soc_sbx_g2p3_oamepremap_entry_table_size_get(int unit,
                int *tsize,
                int iendpoint,
                int imdlevel,
                int itype);

/**
 * Synchronously set oamEpRemap entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iendpoint 13 bit endpoint index from OamInstance or PortMdLevel2etc.
 * @param[in]  imdlevel 3 bit MD Level value from packet header.
 * @param[in]  itype 2 bit type (0=CCM, 1=LM, 2=DM).
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_oamepremap_set(int unit,
                int iendpoint,
                int imdlevel,
                int itype,
                soc_sbx_g2p3_oamepremap_t *e);

/**
 *  Get oamEpRemap entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iendpoint 13 bit endpoint index from OamInstance or PortMdLevel2etc.
 * @param[in]  imdlevel 3 bit MD Level value from packet header.
 * @param[in]  itype 2 bit type (0=CCM, 1=LM, 2=DM).
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_oamepremap_get(int unit,
                int iendpoint,
                int imdlevel,
                int itype,
                soc_sbx_g2p3_oamepremap_t *e);

/*
 * Entry accessors for ipv6da
 */

/**
 * Initialize ipv6da entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ipv6da_t_init(
    soc_sbx_g2p3_ipv6da_t *e);

/**
 * Pack ipv6da entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ipv6da_pack(int unit,
    soc_sbx_g2p3_ipv6da_t *e, uint8 *b, int bsz);

/**
 * Unpack ipv6da entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ipv6da_unpack(int unit,
                soc_sbx_g2p3_ipv6da_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ipv6da_index_check(int unit,
                int *vindex,
                int iprefixbits,
                soc_sbx_g2p3_8_byte_t iip);

extern int soc_sbx_g2p3_ipv6da_index_unpack(int unit,
                int *vindex,
                int *iprefixbits,
                soc_sbx_g2p3_8_byte_t iip);

extern int soc_sbx_g2p3_ipv6da_entry_check(int unit,
                soc_sbx_g2p3_ipv6da_t *e);

/**
 * Synchronously set ipv6da entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iprefixbits LPM prefix length, in bits
 * @param[in]  iip 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv6da_set(int unit,
                int iprefixbits,
                soc_sbx_g2p3_8_byte_t iip,
                soc_sbx_g2p3_ipv6da_t *e);

/**
 * Batch add ipv6da entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  iprefixbits LPM prefix length, in bits
 * @param[in]  iip 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv6da_add(int unit,
                int iprefixbits,
                soc_sbx_g2p3_8_byte_t iip,
                soc_sbx_g2p3_ipv6da_t *e);

/**
 *  Get ipv6da entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iprefixbits LPM prefix length, in bits
 * @param[in]  iip 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ipv6da_get(int unit,
                int iprefixbits,
                soc_sbx_g2p3_8_byte_t iip,
                soc_sbx_g2p3_ipv6da_t *e);

/**
 * Synchronously update ipv6da entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iprefixbits LPM prefix length, in bits
 * @param[in]  iip 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv6da_update(int unit,
                int iprefixbits,
                soc_sbx_g2p3_8_byte_t iip,
                soc_sbx_g2p3_ipv6da_t *e);

/**
 * Batch renew ipv6da entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  iprefixbits LPM prefix length, in bits
 * @param[in]  iip 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv6da_renew(int unit,
                int iprefixbits,
                soc_sbx_g2p3_8_byte_t iip,
                soc_sbx_g2p3_ipv6da_t *e);

/**
 * Synchronously delete ipv6da entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iprefixbits LPM prefix length, in bits
 * @param[in]  iip 
 */
extern int soc_sbx_g2p3_ipv6da_delete(int unit,
                int iprefixbits,
                soc_sbx_g2p3_8_byte_t iip);

/**
 * Batch remove ipv6da entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  iprefixbits LPM prefix length, in bits
 * @param[in]  iip 
 */
extern int soc_sbx_g2p3_ipv6da_remove(int unit,
                int iprefixbits,
                soc_sbx_g2p3_8_byte_t iip);

/**
 * ipv6da get first entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iprefixbits LPM prefix length, in bits
 * @param[in]  iip 
 * @retval     SOC_E_NOT_FOUND no entries
 */
extern int soc_sbx_g2p3_ipv6da_first(int unit,
                int *niprefixbits,
                soc_sbx_g2p3_8_byte_t niip);
/**
 * ipv6da get next entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iprefixbits LPM prefix length, in bits
 * @param[in]  iip 
 * @param[out] niprefixbits next LPM prefix length, in bits
 * @param[out] niip next 
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_ipv6da_next(int unit,
                int iprefixbits,
                soc_sbx_g2p3_8_byte_t iip,
                int *niprefixbits,
                soc_sbx_g2p3_8_byte_t niip);

/* Batch commit for ipv6da */
/**
 * ipv6da batch commit.
 *
 * @param[in]  unit chip unit number
 * @param[in]  runlength number of elements to commit (-1 means commit all)
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_ipv6da_commit(int unit, int runlength);

/*
 * Entry accessors for ipv6dal0
 */

/**
 * Initialize ipv6dal0 entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ipv6dal0_t_init(
    soc_sbx_g2p3_ipv6dal0_t *e);

/**
 * Pack ipv6dal0 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ipv6dal0_pack(int unit,
    soc_sbx_g2p3_ipv6dal0_t *e, uint8 *b, int bsz);

/**
 * Unpack ipv6dal0 entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ipv6dal0_unpack(int unit,
                soc_sbx_g2p3_ipv6dal0_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ipv6dal0_index_check(int unit,
                int *vindex,
                int iaddr);

extern int soc_sbx_g2p3_ipv6dal0_entry_check(int unit,
                soc_sbx_g2p3_ipv6dal0_t *e);

/**
 * ipv6dal0 table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of ipv6dal0 elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  iaddr the most significant bits of the IP VRF concatenated
 * with the IP DA
 */
extern int soc_sbx_g2p3_ipv6dal0_entry_table_size_get(int unit,
                int *tsize,
                int iaddr);

/**
 * Synchronously set ipv6dal0 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iaddr the most significant bits of the IP VRF concatenated
 * with the IP DA
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv6dal0_set(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv6dal0_t *e);

/**
 *  Get ipv6dal0 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iaddr the most significant bits of the IP VRF concatenated
 * with the IP DA
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ipv6dal0_get(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv6dal0_t *e);

/*
 * Entry accessors for ipv6daodd
 */

/**
 * Initialize ipv6daodd entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ipv6daodd_t_init(
    soc_sbx_g2p3_ipv6daodd_t *e);

/**
 * Pack ipv6daodd entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ipv6daodd_pack(int unit,
    soc_sbx_g2p3_ipv6daodd_t *e, uint8 *b, int bsz);

/**
 * Unpack ipv6daodd entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ipv6daodd_unpack(int unit,
                soc_sbx_g2p3_ipv6daodd_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ipv6daodd_index_check(int unit,
                int *vindex,
                int iaddr);

extern int soc_sbx_g2p3_ipv6daodd_entry_check(int unit,
                soc_sbx_g2p3_ipv6daodd_t *e);

/**
 * ipv6daodd table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of ipv6daodd elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  iaddr the base address of the next layer table plus the next
 * next slice of IP DA, or plus 0 if singleton match 
 * or plus 1 if singleton miss
 */
extern int soc_sbx_g2p3_ipv6daodd_entry_table_size_get(int unit,
                int *tsize,
                int iaddr);

/**
 * Synchronously set ipv6daodd entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iaddr the base address of the next layer table plus the next
 * next slice of IP DA, or plus 0 if singleton match 
 * or plus 1 if singleton miss
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv6daodd_set(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv6daodd_t *e);

/**
 *  Get ipv6daodd entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iaddr the base address of the next layer table plus the next
 * next slice of IP DA, or plus 0 if singleton match 
 * or plus 1 if singleton miss
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ipv6daodd_get(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv6daodd_t *e);

/*
 * Entry accessors for ipv6daeven
 */

/**
 * Initialize ipv6daeven entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ipv6daeven_t_init(
    soc_sbx_g2p3_ipv6daeven_t *e);

/**
 * Pack ipv6daeven entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ipv6daeven_pack(int unit,
    soc_sbx_g2p3_ipv6daeven_t *e, uint8 *b, int bsz);

/**
 * Unpack ipv6daeven entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ipv6daeven_unpack(int unit,
                soc_sbx_g2p3_ipv6daeven_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ipv6daeven_index_check(int unit,
                int *vindex,
                int iaddr);

extern int soc_sbx_g2p3_ipv6daeven_entry_check(int unit,
                soc_sbx_g2p3_ipv6daeven_t *e);

/**
 * ipv6daeven table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of ipv6daeven elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  iaddr the base address of the next layer table plus the next
 * next slice of IP DA, or plus 0 if singleton match 
 * or plus 1 if singleton miss
 */
extern int soc_sbx_g2p3_ipv6daeven_entry_table_size_get(int unit,
                int *tsize,
                int iaddr);

/**
 * Synchronously set ipv6daeven entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iaddr the base address of the next layer table plus the next
 * next slice of IP DA, or plus 0 if singleton match 
 * or plus 1 if singleton miss
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv6daeven_set(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv6daeven_t *e);

/**
 *  Get ipv6daeven entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iaddr the base address of the next layer table plus the next
 * next slice of IP DA, or plus 0 if singleton match 
 * or plus 1 if singleton miss
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ipv6daeven_get(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv6daeven_t *e);

/*
 * Entry accessors for ipv6dapayload
 */

/**
 * Initialize ipv6dapayload entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ipv6dapayload_t_init(
    soc_sbx_g2p3_ipv6dapayload_t *e);

/**
 * Pack ipv6dapayload entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ipv6dapayload_pack(int unit,
    soc_sbx_g2p3_ipv6dapayload_t *e, uint8 *b, int bsz);

/**
 * Unpack ipv6dapayload entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ipv6dapayload_unpack(int unit,
                soc_sbx_g2p3_ipv6dapayload_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ipv6dapayload_index_check(int unit,
                int *vindex,
                int iaddr);

extern int soc_sbx_g2p3_ipv6dapayload_entry_check(int unit,
                soc_sbx_g2p3_ipv6dapayload_t *e);

/**
 * ipv6dapayload table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of ipv6dapayload elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  iaddr index into IPv6 DA payload table
 */
extern int soc_sbx_g2p3_ipv6dapayload_entry_table_size_get(int unit,
                int *tsize,
                int iaddr);

/**
 * Synchronously set ipv6dapayload entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iaddr index into IPv6 DA payload table
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv6dapayload_set(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv6dapayload_t *e);

/**
 *  Get ipv6dapayload entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iaddr index into IPv6 DA payload table
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ipv6dapayload_get(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv6dapayload_t *e);

/*
 * Entry accessors for ipv6sa
 */

/**
 * Initialize ipv6sa entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ipv6sa_t_init(
    soc_sbx_g2p3_ipv6sa_t *e);

/**
 * Pack ipv6sa entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ipv6sa_pack(int unit,
    soc_sbx_g2p3_ipv6sa_t *e, uint8 *b, int bsz);

/**
 * Unpack ipv6sa entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ipv6sa_unpack(int unit,
                soc_sbx_g2p3_ipv6sa_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ipv6sa_index_check(int unit,
                int *vindex,
                int iprefixbits,
                soc_sbx_g2p3_8_byte_t iip);

extern int soc_sbx_g2p3_ipv6sa_index_unpack(int unit,
                int *vindex,
                int *iprefixbits,
                soc_sbx_g2p3_8_byte_t iip);

extern int soc_sbx_g2p3_ipv6sa_entry_check(int unit,
                soc_sbx_g2p3_ipv6sa_t *e);

/**
 * Synchronously set ipv6sa entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iprefixbits LPM prefix length, in bits
 * @param[in]  iip 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv6sa_set(int unit,
                int iprefixbits,
                soc_sbx_g2p3_8_byte_t iip,
                soc_sbx_g2p3_ipv6sa_t *e);

/**
 * Batch add ipv6sa entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  iprefixbits LPM prefix length, in bits
 * @param[in]  iip 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv6sa_add(int unit,
                int iprefixbits,
                soc_sbx_g2p3_8_byte_t iip,
                soc_sbx_g2p3_ipv6sa_t *e);

/**
 *  Get ipv6sa entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iprefixbits LPM prefix length, in bits
 * @param[in]  iip 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ipv6sa_get(int unit,
                int iprefixbits,
                soc_sbx_g2p3_8_byte_t iip,
                soc_sbx_g2p3_ipv6sa_t *e);

/**
 * Synchronously update ipv6sa entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iprefixbits LPM prefix length, in bits
 * @param[in]  iip 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv6sa_update(int unit,
                int iprefixbits,
                soc_sbx_g2p3_8_byte_t iip,
                soc_sbx_g2p3_ipv6sa_t *e);

/**
 * Batch renew ipv6sa entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  iprefixbits LPM prefix length, in bits
 * @param[in]  iip 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv6sa_renew(int unit,
                int iprefixbits,
                soc_sbx_g2p3_8_byte_t iip,
                soc_sbx_g2p3_ipv6sa_t *e);

/**
 * Synchronously delete ipv6sa entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iprefixbits LPM prefix length, in bits
 * @param[in]  iip 
 */
extern int soc_sbx_g2p3_ipv6sa_delete(int unit,
                int iprefixbits,
                soc_sbx_g2p3_8_byte_t iip);

/**
 * Batch remove ipv6sa entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  iprefixbits LPM prefix length, in bits
 * @param[in]  iip 
 */
extern int soc_sbx_g2p3_ipv6sa_remove(int unit,
                int iprefixbits,
                soc_sbx_g2p3_8_byte_t iip);

/**
 * ipv6sa get first entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iprefixbits LPM prefix length, in bits
 * @param[in]  iip 
 * @retval     SOC_E_NOT_FOUND no entries
 */
extern int soc_sbx_g2p3_ipv6sa_first(int unit,
                int *niprefixbits,
                soc_sbx_g2p3_8_byte_t niip);
/**
 * ipv6sa get next entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iprefixbits LPM prefix length, in bits
 * @param[in]  iip 
 * @param[out] niprefixbits next LPM prefix length, in bits
 * @param[out] niip next 
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_ipv6sa_next(int unit,
                int iprefixbits,
                soc_sbx_g2p3_8_byte_t iip,
                int *niprefixbits,
                soc_sbx_g2p3_8_byte_t niip);

/* Batch commit for ipv6sa */
/**
 * ipv6sa batch commit.
 *
 * @param[in]  unit chip unit number
 * @param[in]  runlength number of elements to commit (-1 means commit all)
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_ipv6sa_commit(int unit, int runlength);

/*
 * Entry accessors for ipv6sal0
 */

/**
 * Initialize ipv6sal0 entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ipv6sal0_t_init(
    soc_sbx_g2p3_ipv6sal0_t *e);

/**
 * Pack ipv6sal0 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ipv6sal0_pack(int unit,
    soc_sbx_g2p3_ipv6sal0_t *e, uint8 *b, int bsz);

/**
 * Unpack ipv6sal0 entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ipv6sal0_unpack(int unit,
                soc_sbx_g2p3_ipv6sal0_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ipv6sal0_index_check(int unit,
                int *vindex,
                int iaddr);

extern int soc_sbx_g2p3_ipv6sal0_entry_check(int unit,
                soc_sbx_g2p3_ipv6sal0_t *e);

/**
 * ipv6sal0 table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of ipv6sal0 elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  iaddr the most significant bits of the IP VRF concatenated
 * with the IP SA
 */
extern int soc_sbx_g2p3_ipv6sal0_entry_table_size_get(int unit,
                int *tsize,
                int iaddr);

/**
 * Synchronously set ipv6sal0 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iaddr the most significant bits of the IP VRF concatenated
 * with the IP SA
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv6sal0_set(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv6sal0_t *e);

/**
 *  Get ipv6sal0 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iaddr the most significant bits of the IP VRF concatenated
 * with the IP SA
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ipv6sal0_get(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv6sal0_t *e);

/*
 * Entry accessors for ipv6saodd
 */

/**
 * Initialize ipv6saodd entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ipv6saodd_t_init(
    soc_sbx_g2p3_ipv6saodd_t *e);

/**
 * Pack ipv6saodd entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ipv6saodd_pack(int unit,
    soc_sbx_g2p3_ipv6saodd_t *e, uint8 *b, int bsz);

/**
 * Unpack ipv6saodd entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ipv6saodd_unpack(int unit,
                soc_sbx_g2p3_ipv6saodd_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ipv6saodd_index_check(int unit,
                int *vindex,
                int iaddr);

extern int soc_sbx_g2p3_ipv6saodd_entry_check(int unit,
                soc_sbx_g2p3_ipv6saodd_t *e);

/**
 * ipv6saodd table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of ipv6saodd elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  iaddr the base address of the next layer table plus the next
 * next slice of IP SA, or plus 0 if singleton match 
 * or plus 1 if singleton miss
 */
extern int soc_sbx_g2p3_ipv6saodd_entry_table_size_get(int unit,
                int *tsize,
                int iaddr);

/**
 * Synchronously set ipv6saodd entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iaddr the base address of the next layer table plus the next
 * next slice of IP SA, or plus 0 if singleton match 
 * or plus 1 if singleton miss
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv6saodd_set(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv6saodd_t *e);

/**
 *  Get ipv6saodd entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iaddr the base address of the next layer table plus the next
 * next slice of IP SA, or plus 0 if singleton match 
 * or plus 1 if singleton miss
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ipv6saodd_get(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv6saodd_t *e);

/*
 * Entry accessors for ipv6saeven
 */

/**
 * Initialize ipv6saeven entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ipv6saeven_t_init(
    soc_sbx_g2p3_ipv6saeven_t *e);

/**
 * Pack ipv6saeven entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ipv6saeven_pack(int unit,
    soc_sbx_g2p3_ipv6saeven_t *e, uint8 *b, int bsz);

/**
 * Unpack ipv6saeven entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ipv6saeven_unpack(int unit,
                soc_sbx_g2p3_ipv6saeven_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ipv6saeven_index_check(int unit,
                int *vindex,
                int iaddr);

extern int soc_sbx_g2p3_ipv6saeven_entry_check(int unit,
                soc_sbx_g2p3_ipv6saeven_t *e);

/**
 * ipv6saeven table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of ipv6saeven elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  iaddr the base address of the next layer table plus the next
 * next slice of IP SA, or plus 0 if singleton match 
 * or plus 1 if singleton miss
 */
extern int soc_sbx_g2p3_ipv6saeven_entry_table_size_get(int unit,
                int *tsize,
                int iaddr);

/**
 * Synchronously set ipv6saeven entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iaddr the base address of the next layer table plus the next
 * next slice of IP SA, or plus 0 if singleton match 
 * or plus 1 if singleton miss
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv6saeven_set(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv6saeven_t *e);

/**
 *  Get ipv6saeven entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iaddr the base address of the next layer table plus the next
 * next slice of IP SA, or plus 0 if singleton match 
 * or plus 1 if singleton miss
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ipv6saeven_get(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv6saeven_t *e);

/*
 * Entry accessors for ipv6sapayload
 */

/**
 * Initialize ipv6sapayload entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ipv6sapayload_t_init(
    soc_sbx_g2p3_ipv6sapayload_t *e);

/**
 * Pack ipv6sapayload entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ipv6sapayload_pack(int unit,
    soc_sbx_g2p3_ipv6sapayload_t *e, uint8 *b, int bsz);

/**
 * Unpack ipv6sapayload entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ipv6sapayload_unpack(int unit,
                soc_sbx_g2p3_ipv6sapayload_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ipv6sapayload_index_check(int unit,
                int *vindex,
                int iaddr);

extern int soc_sbx_g2p3_ipv6sapayload_entry_check(int unit,
                soc_sbx_g2p3_ipv6sapayload_t *e);

/**
 * ipv6sapayload table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of ipv6sapayload elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  iaddr index into IPv6 SA payload table
 */
extern int soc_sbx_g2p3_ipv6sapayload_entry_table_size_get(int unit,
                int *tsize,
                int iaddr);

/**
 * Synchronously set ipv6sapayload entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iaddr index into IPv6 SA payload table
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv6sapayload_set(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv6sapayload_t *e);

/**
 *  Get ipv6sapayload entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iaddr index into IPv6 SA payload table
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ipv6sapayload_get(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv6sapayload_t *e);

/*
 * Entry accessors for ipv4da
 */

/**
 * Initialize ipv4da entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ipv4da_t_init(
    soc_sbx_g2p3_ipv4da_t *e);

/**
 * Pack ipv4da entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ipv4da_pack(int unit,
    soc_sbx_g2p3_ipv4da_t *e, uint8 *b, int bsz);

/**
 * Unpack ipv4da entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ipv4da_unpack(int unit,
                soc_sbx_g2p3_ipv4da_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ipv4da_index_check(int unit,
                int *vindex,
                int iprefixbits,
                int iip,
                int iipcxt);

extern int soc_sbx_g2p3_ipv4da_index_unpack(int unit,
                int *vindex,
                int *iprefixbits,
                int *iip,
                int *iipcxt);

extern int soc_sbx_g2p3_ipv4da_entry_check(int unit,
                soc_sbx_g2p3_ipv4da_t *e);

/**
 * Synchronously set ipv4da entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iprefixbits LPM prefix length, in bits
 * @param[in]  iip 
 * @param[in]  iipcxt 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv4da_set(int unit,
                int iprefixbits,
                int iip,
                int iipcxt,
                soc_sbx_g2p3_ipv4da_t *e);

/**
 * Batch add ipv4da entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  iprefixbits LPM prefix length, in bits
 * @param[in]  iip 
 * @param[in]  iipcxt 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv4da_add(int unit,
                int iprefixbits,
                int iip,
                int iipcxt,
                soc_sbx_g2p3_ipv4da_t *e);

/**
 *  Get ipv4da entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iprefixbits LPM prefix length, in bits
 * @param[in]  iip 
 * @param[in]  iipcxt 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ipv4da_get(int unit,
                int iprefixbits,
                int iip,
                int iipcxt,
                soc_sbx_g2p3_ipv4da_t *e);

/**
 * Synchronously update ipv4da entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iprefixbits LPM prefix length, in bits
 * @param[in]  iip 
 * @param[in]  iipcxt 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv4da_update(int unit,
                int iprefixbits,
                int iip,
                int iipcxt,
                soc_sbx_g2p3_ipv4da_t *e);

/**
 * Batch renew ipv4da entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  iprefixbits LPM prefix length, in bits
 * @param[in]  iip 
 * @param[in]  iipcxt 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv4da_renew(int unit,
                int iprefixbits,
                int iip,
                int iipcxt,
                soc_sbx_g2p3_ipv4da_t *e);

/**
 * Synchronously delete ipv4da entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iprefixbits LPM prefix length, in bits
 * @param[in]  iip 
 * @param[in]  iipcxt 
 */
extern int soc_sbx_g2p3_ipv4da_delete(int unit,
                int iprefixbits,
                int iip,
                int iipcxt);

/**
 * Batch remove ipv4da entry.
 *
 * forwarding table is not updated until a commit is performed
 *
 * @param[in]  unit chip unit number
 * @param[in]  iprefixbits LPM prefix length, in bits
 * @param[in]  iip 
 * @param[in]  iipcxt 
 */
extern int soc_sbx_g2p3_ipv4da_remove(int unit,
                int iprefixbits,
                int iip,
                int iipcxt);

/**
 * ipv4da get first entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iprefixbits LPM prefix length, in bits
 * @param[in]  iip 
 * @param[in]  iipcxt 
 * @retval     SOC_E_NOT_FOUND no entries
 */
extern int soc_sbx_g2p3_ipv4da_first(int unit,
                int *niprefixbits,
                int *niip,
                int *niipcxt);
/**
 * ipv4da get next entry iterator function.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iprefixbits LPM prefix length, in bits
 * @param[in]  iip 
 * @param[in]  iipcxt 
 * @param[out] niprefixbits next LPM prefix length, in bits
 * @param[out] niip next 
 * @param[out] niipcxt next 
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_ipv4da_next(int unit,
                int iprefixbits,
                int iip,
                int iipcxt,
                int *niprefixbits,
                int *niip,
                int *niipcxt);

/* Batch commit for ipv4da */
/**
 * ipv4da batch commit.
 *
 * @param[in]  unit chip unit number
 * @param[in]  runlength number of elements to commit (-1 means commit all)
 * @retval     SOC_E_NOT_FOUND no more entries
 */
extern int soc_sbx_g2p3_ipv4da_commit(int unit, int runlength);

/*
 * Entry accessors for ipv4dal0
 */

/**
 * Initialize ipv4dal0 entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ipv4dal0_t_init(
    soc_sbx_g2p3_ipv4dal0_t *e);

/**
 * Pack ipv4dal0 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ipv4dal0_pack(int unit,
    soc_sbx_g2p3_ipv4dal0_t *e, uint8 *b, int bsz);

/**
 * Unpack ipv4dal0 entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ipv4dal0_unpack(int unit,
                soc_sbx_g2p3_ipv4dal0_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ipv4dal0_index_check(int unit,
                int *vindex,
                int iaddr);

extern int soc_sbx_g2p3_ipv4dal0_entry_check(int unit,
                soc_sbx_g2p3_ipv4dal0_t *e);

/**
 * ipv4dal0 table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of ipv4dal0 elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  iaddr the most significant bits of the IP VRF concatenated
 * with the IP DA
 */
extern int soc_sbx_g2p3_ipv4dal0_entry_table_size_get(int unit,
                int *tsize,
                int iaddr);

/**
 * Synchronously set ipv4dal0 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iaddr the most significant bits of the IP VRF concatenated
 * with the IP DA
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv4dal0_set(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv4dal0_t *e);

/**
 *  Get ipv4dal0 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iaddr the most significant bits of the IP VRF concatenated
 * with the IP DA
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ipv4dal0_get(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv4dal0_t *e);

/*
 * Entry accessors for ipv4daodd
 */

/**
 * Initialize ipv4daodd entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ipv4daodd_t_init(
    soc_sbx_g2p3_ipv4daodd_t *e);

/**
 * Pack ipv4daodd entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ipv4daodd_pack(int unit,
    soc_sbx_g2p3_ipv4daodd_t *e, uint8 *b, int bsz);

/**
 * Unpack ipv4daodd entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ipv4daodd_unpack(int unit,
                soc_sbx_g2p3_ipv4daodd_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ipv4daodd_index_check(int unit,
                int *vindex,
                int iaddr);

extern int soc_sbx_g2p3_ipv4daodd_entry_check(int unit,
                soc_sbx_g2p3_ipv4daodd_t *e);

/**
 * ipv4daodd table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of ipv4daodd elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  iaddr the base address of the next layer table plus the next
 * most significant bits of the IP VRF concatenated with the
 * IP DA, or plus 0 if no singleton miss or plus 1 if
 * singleton match
 */
extern int soc_sbx_g2p3_ipv4daodd_entry_table_size_get(int unit,
                int *tsize,
                int iaddr);

/**
 * Synchronously set ipv4daodd entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iaddr the base address of the next layer table plus the next
 * most significant bits of the IP VRF concatenated with the
 * IP DA, or plus 0 if no singleton miss or plus 1 if
 * singleton match
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv4daodd_set(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv4daodd_t *e);

/**
 *  Get ipv4daodd entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iaddr the base address of the next layer table plus the next
 * most significant bits of the IP VRF concatenated with the
 * IP DA, or plus 0 if no singleton miss or plus 1 if
 * singleton match
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ipv4daodd_get(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv4daodd_t *e);

/*
 * Entry accessors for ipv4daeven
 */

/**
 * Initialize ipv4daeven entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ipv4daeven_t_init(
    soc_sbx_g2p3_ipv4daeven_t *e);

/**
 * Pack ipv4daeven entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ipv4daeven_pack(int unit,
    soc_sbx_g2p3_ipv4daeven_t *e, uint8 *b, int bsz);

/**
 * Unpack ipv4daeven entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ipv4daeven_unpack(int unit,
                soc_sbx_g2p3_ipv4daeven_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ipv4daeven_index_check(int unit,
                int *vindex,
                int iaddr);

extern int soc_sbx_g2p3_ipv4daeven_entry_check(int unit,
                soc_sbx_g2p3_ipv4daeven_t *e);

/**
 * ipv4daeven table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of ipv4daeven elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  iaddr the base address of the next layer table plus the next
 * most significant bits of the IP VRF concatenated with the
 * IP DA, or plus 0 if no singleton miss or plus 1 if
 * singleton match
 */
extern int soc_sbx_g2p3_ipv4daeven_entry_table_size_get(int unit,
                int *tsize,
                int iaddr);

/**
 * Synchronously set ipv4daeven entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iaddr the base address of the next layer table plus the next
 * most significant bits of the IP VRF concatenated with the
 * IP DA, or plus 0 if no singleton miss or plus 1 if
 * singleton match
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv4daeven_set(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv4daeven_t *e);

/**
 *  Get ipv4daeven entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iaddr the base address of the next layer table plus the next
 * most significant bits of the IP VRF concatenated with the
 * IP DA, or plus 0 if no singleton miss or plus 1 if
 * singleton match
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ipv4daeven_get(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv4daeven_t *e);

/*
 * Entry accessors for ipv4dapayload
 */

/**
 * Initialize ipv4dapayload entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_ipv4dapayload_t_init(
    soc_sbx_g2p3_ipv4dapayload_t *e);

/**
 * Pack ipv4dapayload entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_ipv4dapayload_pack(int unit,
    soc_sbx_g2p3_ipv4dapayload_t *e, uint8 *b, int bsz);

/**
 * Unpack ipv4dapayload entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_ipv4dapayload_unpack(int unit,
                soc_sbx_g2p3_ipv4dapayload_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_ipv4dapayload_index_check(int unit,
                int *vindex,
                int iaddr);

extern int soc_sbx_g2p3_ipv4dapayload_entry_check(int unit,
                soc_sbx_g2p3_ipv4dapayload_t *e);

/**
 * ipv4dapayload table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of ipv4dapayload elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  iaddr index into IPv4 DA payload table
 */
extern int soc_sbx_g2p3_ipv4dapayload_entry_table_size_get(int unit,
                int *tsize,
                int iaddr);

/**
 * Synchronously set ipv4dapayload entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iaddr index into IPv4 DA payload table
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_ipv4dapayload_set(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv4dapayload_t *e);

/**
 *  Get ipv4dapayload entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iaddr index into IPv4 DA payload table
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_ipv4dapayload_get(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv4dapayload_t *e);

/*
 * Entry accessors for P2FTI
 */

/**
 * Initialize P2FTI entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_p2fti_t_init(
    soc_sbx_g2p3_p2fti_t *e);

/**
 * Pack P2FTI entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_p2fti_pack(int unit,
    soc_sbx_g2p3_p2fti_t *e, uint8 *b, int bsz);

/**
 * Unpack P2FTI entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_p2fti_unpack(int unit,
                soc_sbx_g2p3_p2fti_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2p3_p2fti_index_check(int unit,
                int *vindex,
                int iport,
                int idmac);

extern int soc_sbx_g2p3_p2fti_entry_check(int unit,
                soc_sbx_g2p3_p2fti_t *e);

/**
 * P2FTI table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of P2FTI elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  iport Two sets of entries based on egress port number.
 * @param[in]  idmac If Dmac=IEEE (1).
 *                    If Dmac=Local Station (0).
 */
extern int soc_sbx_g2p3_p2fti_entry_table_size_get(int unit,
                int *tsize,
                int iport,
                int idmac);

/**
 * Synchronously set P2FTI entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iport Two sets of entries based on egress port number.
 * @param[in]  idmac If Dmac=IEEE (1).
 *                    If Dmac=Local Station (0).
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2p3_p2fti_set(int unit,
                int iport,
                int idmac,
                soc_sbx_g2p3_p2fti_t *e);

/**
 *  Get P2FTI entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iport Two sets of entries based on egress port number.
 * @param[in]  idmac If Dmac=IEEE (1).
 *                    If Dmac=Local Station (0).
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2p3_p2fti_get(int unit,
                int iport,
                int idmac,
                soc_sbx_g2p3_p2fti_t *e);

/*
 * Entry accessors for policer
 */

/**
 * Initialize policer entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_policer_t_init(
    soc_sbx_g2p3_policer_t *e);

/**
 * Get policer entry size.
 *
 * Use this function for storage management of the
 * policer table, because its entries have variable size
 *
 * @param[in]  unit chip unit number
 * @return     entry size, in words
 */
extern int soc_sbx_g2p3_policer_size(int unit);

/**
 * Pack policer entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_policer_pack(int unit,
    soc_sbx_g2p3_policer_t *e, uint8 *b, int bsz);

/**
 * Unpack policer entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_policer_unpack(int unit,
                soc_sbx_g2p3_policer_t *e, uint8 *b, int bsz);

/*
 * Entry accessors for timer
 */

/**
 * Initialize timer entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_timer_t_init(
    soc_sbx_g2p3_timer_t *e);

/**
 * Get timer entry size.
 *
 * Use this function for storage management of the
 * timer table, because its entries have variable size
 *
 * @param[in]  unit chip unit number
 * @return     entry size, in words
 */
extern int soc_sbx_g2p3_timer_size(int unit);

/**
 * Pack timer entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_timer_pack(int unit,
    soc_sbx_g2p3_timer_t *e, uint8 *b, int bsz);

/**
 * Unpack timer entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_timer_unpack(int unit,
                soc_sbx_g2p3_timer_t *e, uint8 *b, int bsz);

/*
 * Entry accessors for sequence
 */

/**
 * Initialize sequence entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2p3_sequence_t_init(
    soc_sbx_g2p3_sequence_t *e);

/**
 * Get sequence entry size.
 *
 * Use this function for storage management of the
 * sequence table, because its entries have variable size
 *
 * @param[in]  unit chip unit number
 * @return     entry size, in words
 */
extern int soc_sbx_g2p3_sequence_size(int unit);

/**
 * Pack sequence entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2p3_sequence_pack(int unit,
    soc_sbx_g2p3_sequence_t *e, uint8 *b, int bsz);

/**
 * Unpack sequence entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2p3_sequence_unpack(int unit,
                soc_sbx_g2p3_sequence_t *e, uint8 *b, int bsz);

/**
 * Get counter bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank counter bank number
 * @param[out] p counter bank parameters
 */
extern int soc_sbx_g2p3_counter_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_counter_bank_params_t *p);

/**
 * Get pdctr counter parameters.
 *
 * Ingress Port Drop Counters.
 * This counter is used to support the 802.1 MIB per-port
 * discard counter.  The 802.1 MIB requires only a
 * frames discarded count, but this counter includes both
 * bytes and packets.
 *
 * @param[in]  unit chip unit number
 * @param[out] p counter parameters
 */
extern int soc_sbx_g2p3_pdctr_counter_params_get(int unit,
                soc_sbx_g2p3_counter_params_t *p);

/**
 * Set the size of the counter set for pdctr
 *
 * Ingress Port Drop Counters.
 * This counter is used to support the 802.1 MIB per-port
 * discard counter.  The 802.1 MIB requires only a
 * frames discarded count, but this counter includes both
 * bytes and packets.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size number of counters in the counter set
 */
extern int soc_sbx_g2p3_pdctr_counter_size_set(int unit, int size);

/**
 * Get pdctr counter value.
 *
 * Ingress Port Drop Counters.
 * This counter is used to support the 802.1 MIB per-port
 * discard counter.  The 802.1 MIB requires only a
 * frames discarded count, but this counter includes both
 * bytes and packets.
 *
 * @param[in]  unit chip unit number
 * @param[in]  clear clear counter on read
 * @param[in]  cnum counter number (within pdctr)
 * @param[out] v counter value
 */
extern int soc_sbx_g2p3_pdctr_get(int unit,
                int clear, int cnum,
                soc_sbx_g2p3_counter_value_t *v);

/**
 * Get rtctr counter parameters.
 *
 * Rule Table Counters.
 * There is one counter for every RCE entry including
 * each batch and additional, hitless update entries.
 * When the RCE management software updates the RCE,
 * the hardware will begin updating new <tt>rtctrs</tt>
 * and the software will collect the counts for
 * the previously active entries and add them to
 * the running per-rule totals.  Therefore
 * the <tt>rtctrs</tt> only contain counts since the most
 * recent update to the associated batch.
 * <br><br>Coherent, per-rule counters
 * are retrieved through the <tt>ifpctr / efpctr </tt> group.
 *
 * @param[in]  unit chip unit number
 * @param[out] p counter parameters
 */
extern int soc_sbx_g2p3_rtctr_counter_params_get(int unit,
                soc_sbx_g2p3_counter_params_t *p);

/**
 * Set the size of the counter set for rtctr
 *
 * Rule Table Counters.
 * There is one counter for every RCE entry including
 * each batch and additional, hitless update entries.
 * When the RCE management software updates the RCE,
 * the hardware will begin updating new <tt>rtctrs</tt>
 * and the software will collect the counts for
 * the previously active entries and add them to
 * the running per-rule totals.  Therefore
 * the <tt>rtctrs</tt> only contain counts since the most
 * recent update to the associated batch.
 * <br><br>Coherent, per-rule counters
 * are retrieved through the <tt>ifpctr / efpctr </tt> group.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size number of counters in the counter set
 */
extern int soc_sbx_g2p3_rtctr_counter_size_set(int unit, int size);

/**
 * Get rtctr counter value.
 *
 * Rule Table Counters.
 * There is one counter for every RCE entry including
 * each batch and additional, hitless update entries.
 * When the RCE management software updates the RCE,
 * the hardware will begin updating new <tt>rtctrs</tt>
 * and the software will collect the counts for
 * the previously active entries and add them to
 * the running per-rule totals.  Therefore
 * the <tt>rtctrs</tt> only contain counts since the most
 * recent update to the associated batch.
 * <br><br>Coherent, per-rule counters
 * are retrieved through the <tt>ifpctr / efpctr </tt> group.
 *
 * @param[in]  unit chip unit number
 * @param[in]  clear clear counter on read
 * @param[in]  cnum counter number (within rtctr)
 * @param[out] v counter value
 */
extern int soc_sbx_g2p3_rtctr_get(int unit,
                int clear, int cnum,
                soc_sbx_g2p3_counter_value_t *v);

/**
 * Get irtctr counter parameters.
 *
 * Ingress Rule Table Counters.
 * There is one counter for every IFP RCE entry including
 * each batch and additional, hitless update entries.
 * When the RCE management software updates the RCE,
 * the hardware will begin updating new <tt>irtctrs</tt>
 * and the software will collect the counts for
 * the previously active entries and add them to
 * the running per-rule totals.  Therefore
 * the <tt>irtctrs</tt> only contain counts since the most
 * recent IFP update to the associated batch.
 * <br><br>Coherent, per-rule EFP counters
 * are retrieved through the <tt>ifpctr</tt> group.
 *
 * @param[in]  unit chip unit number
 * @param[out] p counter parameters
 */
extern int soc_sbx_g2p3_irtctr_counter_params_get(int unit,
                soc_sbx_g2p3_counter_params_t *p);

/**
 * Set the size of the counter set for irtctr
 *
 * Ingress Rule Table Counters.
 * There is one counter for every IFP RCE entry including
 * each batch and additional, hitless update entries.
 * When the RCE management software updates the RCE,
 * the hardware will begin updating new <tt>irtctrs</tt>
 * and the software will collect the counts for
 * the previously active entries and add them to
 * the running per-rule totals.  Therefore
 * the <tt>irtctrs</tt> only contain counts since the most
 * recent IFP update to the associated batch.
 * <br><br>Coherent, per-rule EFP counters
 * are retrieved through the <tt>ifpctr</tt> group.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size number of counters in the counter set
 */
extern int soc_sbx_g2p3_irtctr_counter_size_set(int unit, int size);

/**
 * Get irtctr counter value.
 *
 * Ingress Rule Table Counters.
 * There is one counter for every IFP RCE entry including
 * each batch and additional, hitless update entries.
 * When the RCE management software updates the RCE,
 * the hardware will begin updating new <tt>irtctrs</tt>
 * and the software will collect the counts for
 * the previously active entries and add them to
 * the running per-rule totals.  Therefore
 * the <tt>irtctrs</tt> only contain counts since the most
 * recent IFP update to the associated batch.
 * <br><br>Coherent, per-rule EFP counters
 * are retrieved through the <tt>ifpctr</tt> group.
 *
 * @param[in]  unit chip unit number
 * @param[in]  clear clear counter on read
 * @param[in]  cnum counter number (within irtctr)
 * @param[out] v counter value
 */
extern int soc_sbx_g2p3_irtctr_get(int unit,
                int clear, int cnum,
                soc_sbx_g2p3_counter_value_t *v);

/**
 * Get ifpctr counter parameters.
 *
 * Ingress Field Processor Counters.
 * These counters provide a coherent, front-end view to the SDK
 * for the IFP counters.  This abstracts away the details behind
 * how rules are batched and how hitless update is performed
 * in the <tt>irtctr</tt> area.  The <tt>ifpctrs</tt> contain
 * the accumulated counts for rules in the IFP database 
 * across all IFP updates.
 * <br><br>The <tt>ifpctrs</tt> are maintained in host
 * memory and there are no directly corresponding counters
 * in device memory.
 *
 * @param[in]  unit chip unit number
 * @param[out] p counter parameters
 */
extern int soc_sbx_g2p3_ifpctr_counter_params_get(int unit,
                soc_sbx_g2p3_counter_params_t *p);

/**
 * Set the size of the counter set for ifpctr
 *
 * Ingress Field Processor Counters.
 * These counters provide a coherent, front-end view to the SDK
 * for the IFP counters.  This abstracts away the details behind
 * how rules are batched and how hitless update is performed
 * in the <tt>irtctr</tt> area.  The <tt>ifpctrs</tt> contain
 * the accumulated counts for rules in the IFP database 
 * across all IFP updates.
 * <br><br>The <tt>ifpctrs</tt> are maintained in host
 * memory and there are no directly corresponding counters
 * in device memory.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size number of counters in the counter set
 */
extern int soc_sbx_g2p3_ifpctr_counter_size_set(int unit, int size);

/**
 * Get ifpctr counter value.
 *
 * Ingress Field Processor Counters.
 * These counters provide a coherent, front-end view to the SDK
 * for the IFP counters.  This abstracts away the details behind
 * how rules are batched and how hitless update is performed
 * in the <tt>irtctr</tt> area.  The <tt>ifpctrs</tt> contain
 * the accumulated counts for rules in the IFP database 
 * across all IFP updates.
 * <br><br>The <tt>ifpctrs</tt> are maintained in host
 * memory and there are no directly corresponding counters
 * in device memory.
 *
 * @param[in]  unit chip unit number
 * @param[in]  clear clear counter on read
 * @param[in]  cnum counter number (within ifpctr)
 * @param[out] v counter value
 */
extern int soc_sbx_g2p3_ifpctr_get(int unit,
                int clear, int cnum,
                soc_sbx_g2p3_counter_value_t *v);
extern int soc_sbx_g2p3_ifpctr_get_ext(int unit,
                int clear, int cnum,
                soc_sbx_g2p3_counter_value_t *v);

/**
 * Get ifp_v6ctr counter parameters.
 *
 * Ingress V6 Field Processor Counters.
 * These counters provide a coherent, front-end view to the SDK
 * for the IFP_V6 counters.  This abstracts away the details behind
 * how rules are batched and how hitless update is performed
 * in the <tt>irtctr</tt> area.  The <tt>ifp_v6ctrs</tt> contain
 * the accumulated counts for rules in the IFP_V6 database 
 * across all IFP_V6 updates.
 * <br><br>The <tt>ifp_v6ctrs</tt> are maintained in host
 * memory and there are no directly corresponding counters
 * in device memory.
 *
 * @param[in]  unit chip unit number
 * @param[out] p counter parameters
 */
extern int soc_sbx_g2p3_ifp_v6ctr_counter_params_get(int unit,
                soc_sbx_g2p3_counter_params_t *p);

/**
 * Set the size of the counter set for ifp_v6ctr
 *
 * Ingress V6 Field Processor Counters.
 * These counters provide a coherent, front-end view to the SDK
 * for the IFP_V6 counters.  This abstracts away the details behind
 * how rules are batched and how hitless update is performed
 * in the <tt>irtctr</tt> area.  The <tt>ifp_v6ctrs</tt> contain
 * the accumulated counts for rules in the IFP_V6 database 
 * across all IFP_V6 updates.
 * <br><br>The <tt>ifp_v6ctrs</tt> are maintained in host
 * memory and there are no directly corresponding counters
 * in device memory.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size number of counters in the counter set
 */
extern int soc_sbx_g2p3_ifp_v6ctr_counter_size_set(int unit, int size);

/**
 * Get ifp_v6ctr counter value.
 *
 * Ingress V6 Field Processor Counters.
 * These counters provide a coherent, front-end view to the SDK
 * for the IFP_V6 counters.  This abstracts away the details behind
 * how rules are batched and how hitless update is performed
 * in the <tt>irtctr</tt> area.  The <tt>ifp_v6ctrs</tt> contain
 * the accumulated counts for rules in the IFP_V6 database 
 * across all IFP_V6 updates.
 * <br><br>The <tt>ifp_v6ctrs</tt> are maintained in host
 * memory and there are no directly corresponding counters
 * in device memory.
 *
 * @param[in]  unit chip unit number
 * @param[in]  clear clear counter on read
 * @param[in]  cnum counter number (within ifp_v6ctr)
 * @param[out] v counter value
 */
extern int soc_sbx_g2p3_ifp_v6ctr_get(int unit,
                int clear, int cnum,
                soc_sbx_g2p3_counter_value_t *v);
extern int soc_sbx_g2p3_ifp_v6ctr_get_ext(int unit,
                int clear, int cnum,
                soc_sbx_g2p3_counter_value_t *v);

/**
 * Get ertctr counter parameters.
 *
 * Egress Rule Table Counters.
 * There are twice as many counters in the <tt>ertctr</tt>set
 * as the maximum number of EFP entries.  This allows
 * for hitless update of the EFP database.
 * When the RCE management software updates the RCE,
 * the hardware will begin updating new <tt>ertctrs</tt>
 * and the software will collect the counts for
 * the previously active entries and add them to
 * the running per-rule totals.  Therefore
 * the <tt>ertctrs</tt> only contain counts since the most
 * recent EFP update.
 * <br><br>Coherent, per-rule EFP counters
 * are retrieved through the <tt>efpctr</tt> group.
 *
 * @param[in]  unit chip unit number
 * @param[out] p counter parameters
 */
extern int soc_sbx_g2p3_ertctr_counter_params_get(int unit,
                soc_sbx_g2p3_counter_params_t *p);

/**
 * Set the size of the counter set for ertctr
 *
 * Egress Rule Table Counters.
 * There are twice as many counters in the <tt>ertctr</tt>set
 * as the maximum number of EFP entries.  This allows
 * for hitless update of the EFP database.
 * When the RCE management software updates the RCE,
 * the hardware will begin updating new <tt>ertctrs</tt>
 * and the software will collect the counts for
 * the previously active entries and add them to
 * the running per-rule totals.  Therefore
 * the <tt>ertctrs</tt> only contain counts since the most
 * recent EFP update.
 * <br><br>Coherent, per-rule EFP counters
 * are retrieved through the <tt>efpctr</tt> group.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size number of counters in the counter set
 */
extern int soc_sbx_g2p3_ertctr_counter_size_set(int unit, int size);

/**
 * Get ertctr counter value.
 *
 * Egress Rule Table Counters.
 * There are twice as many counters in the <tt>ertctr</tt>set
 * as the maximum number of EFP entries.  This allows
 * for hitless update of the EFP database.
 * When the RCE management software updates the RCE,
 * the hardware will begin updating new <tt>ertctrs</tt>
 * and the software will collect the counts for
 * the previously active entries and add them to
 * the running per-rule totals.  Therefore
 * the <tt>ertctrs</tt> only contain counts since the most
 * recent EFP update.
 * <br><br>Coherent, per-rule EFP counters
 * are retrieved through the <tt>efpctr</tt> group.
 *
 * @param[in]  unit chip unit number
 * @param[in]  clear clear counter on read
 * @param[in]  cnum counter number (within ertctr)
 * @param[out] v counter value
 */
extern int soc_sbx_g2p3_ertctr_get(int unit,
                int clear, int cnum,
                soc_sbx_g2p3_counter_value_t *v);

/**
 * Get efpctr counter parameters.
 *
 * Egress Field Processor Counters.
 * These counters provide a coherent, front-end view to the SDK
 * for the EFP counters.  This abstracts away the details behind
 * how hitless update is performed
 * in the <tt>ertctr</tt> area.  The <tt>efpctrs</tt> contain
 * the accumulated counts for rules in the EFP database 
 * across all EFP updates.
 * <br><br>The <tt>efpctrs</tt> are maintained in host
 * memory and there are no directly corresponding counters
 * in device memory.
 *
 * @param[in]  unit chip unit number
 * @param[out] p counter parameters
 */
extern int soc_sbx_g2p3_efpctr_counter_params_get(int unit,
                soc_sbx_g2p3_counter_params_t *p);

/**
 * Set the size of the counter set for efpctr
 *
 * Egress Field Processor Counters.
 * These counters provide a coherent, front-end view to the SDK
 * for the EFP counters.  This abstracts away the details behind
 * how hitless update is performed
 * in the <tt>ertctr</tt> area.  The <tt>efpctrs</tt> contain
 * the accumulated counts for rules in the EFP database 
 * across all EFP updates.
 * <br><br>The <tt>efpctrs</tt> are maintained in host
 * memory and there are no directly corresponding counters
 * in device memory.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size number of counters in the counter set
 */
extern int soc_sbx_g2p3_efpctr_counter_size_set(int unit, int size);

/**
 * Get efpctr counter value.
 *
 * Egress Field Processor Counters.
 * These counters provide a coherent, front-end view to the SDK
 * for the EFP counters.  This abstracts away the details behind
 * how hitless update is performed
 * in the <tt>ertctr</tt> area.  The <tt>efpctrs</tt> contain
 * the accumulated counts for rules in the EFP database 
 * across all EFP updates.
 * <br><br>The <tt>efpctrs</tt> are maintained in host
 * memory and there are no directly corresponding counters
 * in device memory.
 *
 * @param[in]  unit chip unit number
 * @param[in]  clear clear counter on read
 * @param[in]  cnum counter number (within efpctr)
 * @param[out] v counter value
 */
extern int soc_sbx_g2p3_efpctr_get(int unit,
                int clear, int cnum,
                soc_sbx_g2p3_counter_value_t *v);
extern int soc_sbx_g2p3_efpctr_get_ext(int unit,
                int clear, int cnum,
                soc_sbx_g2p3_counter_value_t *v);

/**
 * Get efp_v6ctr counter parameters.
 *
 * Egress V6 Field Processor Counters.
 * These counters provide a coherent, front-end view to the SDK
 * for the EFP_V6 counters.  This abstracts away the details behind
 * how hitless update is performed
 * in the <tt>ertctr</tt> area.  The <tt>efp_v6ctrs</tt> contain
 * the accumulated counts for rules in the EFP_V6 database 
 * across all EFP_V6 updates.
 * <br><br>The <tt>efp_v6ctrs</tt> are maintained in host
 * memory and there are no directly corresponding counters
 * in device memory.
 *
 * @param[in]  unit chip unit number
 * @param[out] p counter parameters
 */
extern int soc_sbx_g2p3_efp_v6ctr_counter_params_get(int unit,
                soc_sbx_g2p3_counter_params_t *p);

/**
 * Set the size of the counter set for efp_v6ctr
 *
 * Egress V6 Field Processor Counters.
 * These counters provide a coherent, front-end view to the SDK
 * for the EFP_V6 counters.  This abstracts away the details behind
 * how hitless update is performed
 * in the <tt>ertctr</tt> area.  The <tt>efp_v6ctrs</tt> contain
 * the accumulated counts for rules in the EFP_V6 database 
 * across all EFP_V6 updates.
 * <br><br>The <tt>efp_v6ctrs</tt> are maintained in host
 * memory and there are no directly corresponding counters
 * in device memory.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size number of counters in the counter set
 */
extern int soc_sbx_g2p3_efp_v6ctr_counter_size_set(int unit, int size);

/**
 * Get efp_v6ctr counter value.
 *
 * Egress V6 Field Processor Counters.
 * These counters provide a coherent, front-end view to the SDK
 * for the EFP_V6 counters.  This abstracts away the details behind
 * how hitless update is performed
 * in the <tt>ertctr</tt> area.  The <tt>efp_v6ctrs</tt> contain
 * the accumulated counts for rules in the EFP_V6 database 
 * across all EFP_V6 updates.
 * <br><br>The <tt>efp_v6ctrs</tt> are maintained in host
 * memory and there are no directly corresponding counters
 * in device memory.
 *
 * @param[in]  unit chip unit number
 * @param[in]  clear clear counter on read
 * @param[in]  cnum counter number (within efp_v6ctr)
 * @param[out] v counter value
 */
extern int soc_sbx_g2p3_efp_v6ctr_get(int unit,
                int clear, int cnum,
                soc_sbx_g2p3_counter_value_t *v);
extern int soc_sbx_g2p3_efp_v6ctr_get_ext(int unit,
                int clear, int cnum,
                soc_sbx_g2p3_counter_value_t *v);

/**
 * Get excctr counter parameters.
 *
 * Exception Counters.
 * The exception counters are organized by port and exception
 * identifier.  Port is the major index, so an exception
 * counter number for port p, exception e is
 * <tt>p * MAX_EXCEPTION + e</tt>, where <tt>MAX_EXCEPTION</tt>
 * is 128
 *
 * @param[in]  unit chip unit number
 * @param[out] p counter parameters
 */
extern int soc_sbx_g2p3_excctr_counter_params_get(int unit,
                soc_sbx_g2p3_counter_params_t *p);

/**
 * Set the size of the counter set for excctr
 *
 * Exception Counters.
 * The exception counters are organized by port and exception
 * identifier.  Port is the major index, so an exception
 * counter number for port p, exception e is
 * <tt>p * MAX_EXCEPTION + e</tt>, where <tt>MAX_EXCEPTION</tt>
 * is 128
 *
 * @param[in]  unit chip unit number
 * @param[in]  size number of counters in the counter set
 */
extern int soc_sbx_g2p3_excctr_counter_size_set(int unit, int size);

/**
 * Get excctr counter value.
 *
 * Exception Counters.
 * The exception counters are organized by port and exception
 * identifier.  Port is the major index, so an exception
 * counter number for port p, exception e is
 * <tt>p * MAX_EXCEPTION + e</tt>, where <tt>MAX_EXCEPTION</tt>
 * is 128
 *
 * @param[in]  unit chip unit number
 * @param[in]  clear clear counter on read
 * @param[in]  cnum counter number (within excctr)
 * @param[out] v counter value
 */
extern int soc_sbx_g2p3_excctr_get(int unit,
                int clear, int cnum,
                soc_sbx_g2p3_counter_value_t *v);

/**
 * Get ingctr counter parameters.
 *
 * Ingress Application Counters.
 * Ingress counting is performed in a various different
 * ways, depending on the counting type configured
 * in the <tt>lp</tt> table:
 * <ul>
 *   <li><i>no counting:</i> if <tt>lp.counter=0</tt>,
 *       counter 0, assuming to be a 'black-hole' counter
 *       will be updated, effectively not counting the
 *       packet in any meaningful way.</li>
 *   <li><i>untyped counting:</i> if <tt>lp.counter != 0</tt>
 *       and no other counting-related flags are set,
 *       the base counter will be incremented.  This allows
 *       logical ports to be counted at any desired granularity.
 *       For example, if a unique counter is assigned to each
 *       logical port, counting will be by logical port.  If
 *       unique counters are only assigned per physical port
 *       (with all <tt>lp</tt> table entries for the same
 *       physical port containing the same base counter),
 *       counting will be by physical port.</li>
 *   <li><i>typed counting:</i> if <tt>lp.counter != 0</tt>
 *       and <tt>lp.typedcount=1</tt>, one of 4 different
 *       counters will be incremented, based on the traffic
 *       type of the packet: <i>unknown unicast</i>,
 *       <i>known unicast</i>, <i>unknown multicast</i>,
 *       or <i>broadcast</i></li>
 *   <li><i>MEF counting:</i> if <tt>lp.counter != 0</tt>
 *       and <tt>lp.mef=1</tt>, one of 6 different counters
 *       will be incremented, based on whether the flood
 *       suppression policer was exceeded, and the final
 *       discard eligibility (color) from the application
 *       policer: <i>unknown unicast flood drop</i>,
 *       <i>unknown multicast flood drop</i>, <i>broadcast
 *       flood drop</i>, <i>green</i>, <i>yellow</i> or
 *       <i>red</i>.  Note that even though only 6 different
 *       counters can be incremented, 1 additional counter
 *       must be allocated, effectively wasting the <i>known
 *       unicast</i>
 *       traffic type counter location.  This design
 *       improves microcode efficiency.</li>
 *   <li><i>MEF CoS counting:</i> if <tt>lp.counter != 0,</tt>
 *       <tt>lp.mef=1</tt> and <tt>lp.mefcos=1</tt>, one of
 *       <tt>3 + 3 * max CoS</tt> different counters
 *       will be incremented, based on whether the flood
 *       suppression policer was exceeded, the CoS of the
 *       packet, and the final
 *       discard eligibility (color) from the application
 *       policer: <i>unknown unicast flood drop</i>,
 *       <i>unknown multicast flood drop</i>, <i>broadcast
 *       flood drop</i>, <i>CoS x green</i>,
 *       <i>CoS x yellow</i> or
 *       <i>CoS x red</i>.  Note that even though only
 *       <tt>3 + 3 * max CoS</tt> counters can be
 *       incremented, 1 additional counter must be
 *       allocated, effectively wasting the <i>known unicast</i>
 *       traffic type counter location.  This design
 *       improves microcode efficiency.</li>
 * </ul>
 * The counter offsets for typed, MEF and MEF CoS are in the 
 * <tt>PTYPE_*</tt> constants.
 *
 * @param[in]  unit chip unit number
 * @param[out] p counter parameters
 */
extern int soc_sbx_g2p3_ingctr_counter_params_get(int unit,
                soc_sbx_g2p3_counter_params_t *p);

/**
 * Set the size of the counter set for ingctr
 *
 * Ingress Application Counters.
 * Ingress counting is performed in a various different
 * ways, depending on the counting type configured
 * in the <tt>lp</tt> table:
 * <ul>
 *   <li><i>no counting:</i> if <tt>lp.counter=0</tt>,
 *       counter 0, assuming to be a 'black-hole' counter
 *       will be updated, effectively not counting the
 *       packet in any meaningful way.</li>
 *   <li><i>untyped counting:</i> if <tt>lp.counter != 0</tt>
 *       and no other counting-related flags are set,
 *       the base counter will be incremented.  This allows
 *       logical ports to be counted at any desired granularity.
 *       For example, if a unique counter is assigned to each
 *       logical port, counting will be by logical port.  If
 *       unique counters are only assigned per physical port
 *       (with all <tt>lp</tt> table entries for the same
 *       physical port containing the same base counter),
 *       counting will be by physical port.</li>
 *   <li><i>typed counting:</i> if <tt>lp.counter != 0</tt>
 *       and <tt>lp.typedcount=1</tt>, one of 4 different
 *       counters will be incremented, based on the traffic
 *       type of the packet: <i>unknown unicast</i>,
 *       <i>known unicast</i>, <i>unknown multicast</i>,
 *       or <i>broadcast</i></li>
 *   <li><i>MEF counting:</i> if <tt>lp.counter != 0</tt>
 *       and <tt>lp.mef=1</tt>, one of 6 different counters
 *       will be incremented, based on whether the flood
 *       suppression policer was exceeded, and the final
 *       discard eligibility (color) from the application
 *       policer: <i>unknown unicast flood drop</i>,
 *       <i>unknown multicast flood drop</i>, <i>broadcast
 *       flood drop</i>, <i>green</i>, <i>yellow</i> or
 *       <i>red</i>.  Note that even though only 6 different
 *       counters can be incremented, 1 additional counter
 *       must be allocated, effectively wasting the <i>known
 *       unicast</i>
 *       traffic type counter location.  This design
 *       improves microcode efficiency.</li>
 *   <li><i>MEF CoS counting:</i> if <tt>lp.counter != 0,</tt>
 *       <tt>lp.mef=1</tt> and <tt>lp.mefcos=1</tt>, one of
 *       <tt>3 + 3 * max CoS</tt> different counters
 *       will be incremented, based on whether the flood
 *       suppression policer was exceeded, the CoS of the
 *       packet, and the final
 *       discard eligibility (color) from the application
 *       policer: <i>unknown unicast flood drop</i>,
 *       <i>unknown multicast flood drop</i>, <i>broadcast
 *       flood drop</i>, <i>CoS x green</i>,
 *       <i>CoS x yellow</i> or
 *       <i>CoS x red</i>.  Note that even though only
 *       <tt>3 + 3 * max CoS</tt> counters can be
 *       incremented, 1 additional counter must be
 *       allocated, effectively wasting the <i>known unicast</i>
 *       traffic type counter location.  This design
 *       improves microcode efficiency.</li>
 * </ul>
 * The counter offsets for typed, MEF and MEF CoS are in the 
 * <tt>PTYPE_*</tt> constants.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size number of counters in the counter set
 */
extern int soc_sbx_g2p3_ingctr_counter_size_set(int unit, int size);

/**
 * Get ingctr counter value.
 *
 * Ingress Application Counters.
 * Ingress counting is performed in a various different
 * ways, depending on the counting type configured
 * in the <tt>lp</tt> table:
 * <ul>
 *   <li><i>no counting:</i> if <tt>lp.counter=0</tt>,
 *       counter 0, assuming to be a 'black-hole' counter
 *       will be updated, effectively not counting the
 *       packet in any meaningful way.</li>
 *   <li><i>untyped counting:</i> if <tt>lp.counter != 0</tt>
 *       and no other counting-related flags are set,
 *       the base counter will be incremented.  This allows
 *       logical ports to be counted at any desired granularity.
 *       For example, if a unique counter is assigned to each
 *       logical port, counting will be by logical port.  If
 *       unique counters are only assigned per physical port
 *       (with all <tt>lp</tt> table entries for the same
 *       physical port containing the same base counter),
 *       counting will be by physical port.</li>
 *   <li><i>typed counting:</i> if <tt>lp.counter != 0</tt>
 *       and <tt>lp.typedcount=1</tt>, one of 4 different
 *       counters will be incremented, based on the traffic
 *       type of the packet: <i>unknown unicast</i>,
 *       <i>known unicast</i>, <i>unknown multicast</i>,
 *       or <i>broadcast</i></li>
 *   <li><i>MEF counting:</i> if <tt>lp.counter != 0</tt>
 *       and <tt>lp.mef=1</tt>, one of 6 different counters
 *       will be incremented, based on whether the flood
 *       suppression policer was exceeded, and the final
 *       discard eligibility (color) from the application
 *       policer: <i>unknown unicast flood drop</i>,
 *       <i>unknown multicast flood drop</i>, <i>broadcast
 *       flood drop</i>, <i>green</i>, <i>yellow</i> or
 *       <i>red</i>.  Note that even though only 6 different
 *       counters can be incremented, 1 additional counter
 *       must be allocated, effectively wasting the <i>known
 *       unicast</i>
 *       traffic type counter location.  This design
 *       improves microcode efficiency.</li>
 *   <li><i>MEF CoS counting:</i> if <tt>lp.counter != 0,</tt>
 *       <tt>lp.mef=1</tt> and <tt>lp.mefcos=1</tt>, one of
 *       <tt>3 + 3 * max CoS</tt> different counters
 *       will be incremented, based on whether the flood
 *       suppression policer was exceeded, the CoS of the
 *       packet, and the final
 *       discard eligibility (color) from the application
 *       policer: <i>unknown unicast flood drop</i>,
 *       <i>unknown multicast flood drop</i>, <i>broadcast
 *       flood drop</i>, <i>CoS x green</i>,
 *       <i>CoS x yellow</i> or
 *       <i>CoS x red</i>.  Note that even though only
 *       <tt>3 + 3 * max CoS</tt> counters can be
 *       incremented, 1 additional counter must be
 *       allocated, effectively wasting the <i>known unicast</i>
 *       traffic type counter location.  This design
 *       improves microcode efficiency.</li>
 * </ul>
 * The counter offsets for typed, MEF and MEF CoS are in the 
 * <tt>PTYPE_*</tt> constants.
 *
 * @param[in]  unit chip unit number
 * @param[in]  clear clear counter on read
 * @param[in]  cnum counter number (within ingctr)
 * @param[out] v counter value
 */
extern int soc_sbx_g2p3_ingctr_get(int unit,
                int clear, int cnum,
                soc_sbx_g2p3_counter_value_t *v);

/**
 * Get egrctr counter parameters.
 *
 * Egress Application Counters.
 * Egress counting is performed at the granularity of
 * egress port, VLAN for the traditional bridging
 * forwarding model, and at the granularity of out
 * header index (typically corresponding to a tunnel
 * or a routed next-hop.
 *
 * @param[in]  unit chip unit number
 * @param[out] p counter parameters
 */
extern int soc_sbx_g2p3_egrctr_counter_params_get(int unit,
                soc_sbx_g2p3_counter_params_t *p);

/**
 * Set the size of the counter set for egrctr
 *
 * Egress Application Counters.
 * Egress counting is performed at the granularity of
 * egress port, VLAN for the traditional bridging
 * forwarding model, and at the granularity of out
 * header index (typically corresponding to a tunnel
 * or a routed next-hop.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size number of counters in the counter set
 */
extern int soc_sbx_g2p3_egrctr_counter_size_set(int unit, int size);

/**
 * Get egrctr counter value.
 *
 * Egress Application Counters.
 * Egress counting is performed at the granularity of
 * egress port, VLAN for the traditional bridging
 * forwarding model, and at the granularity of out
 * header index (typically corresponding to a tunnel
 * or a routed next-hop.
 *
 * @param[in]  unit chip unit number
 * @param[in]  clear clear counter on read
 * @param[in]  cnum counter number (within egrctr)
 * @param[out] v counter value
 */
extern int soc_sbx_g2p3_egrctr_get(int unit,
                int clear, int cnum,
                soc_sbx_g2p3_counter_value_t *v);

/**
 * Get policer bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank policer bank number
 * @param[out] p policer bank parameters
 */
extern int soc_sbx_g2p3_policer_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_policer_bank_params_t *p);

/**
 * Get xtpol policer parameters.
 *
 * Exception Policers.
 * These policers are used for all exception policing.
 *
 * @param[in]  unit chip unit number
 * @param[out] p policer parameters
 */
extern int soc_sbx_g2p3_xtpol_policer_params_get(int unit,
                soc_sbx_g2p3_policer_params_t *p);

/**
 * Set the size of the policer set for xtpol
 *
 * Exception Policers.
 * These policers are used for all exception policing.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size number of policers in the policer set
 */
extern int soc_sbx_g2p3_xtpol_policer_size_set(int unit, int size);

/**
 * Set xtpol (policer) parameters.
 *
 * Exception Policers.
 * These policers are used for all exception policing.
 *
 * @param[in]  unit chip unit number
 * @param[in]  policer policer number (within xtpol)
 * @param[in]  p policer parameters
 */
extern int soc_sbx_g2p3_xtpol_set(int unit,
                  int policer, soc_sbx_g2p3_policer_t *p);

/**
 * Get xtpol (policer) parameters.
 *
 * Exception Policers.
 * These policers are used for all exception policing.
 *
 * @param[in]  unit chip unit number
 * @param[in]  policer policer number (within xtpol)
 * @param[out] p policer parameters
 */
extern int soc_sbx_g2p3_xtpol_get(int unit,
                  int policer, soc_sbx_g2p3_policer_t *p);

/**
 * Delete one xtpol (policer).
 *
 * Exception Policers.
 * These policers are used for all exception policing.
 *
 * @param[in]  unit chip unit number
 * @param[in]  policer policer number (within xtpol)
 */
extern int soc_sbx_g2p3_xtpol_delete(int unit, int policer);

/**
 * Get ingegrpol policer parameters.
 *
 * Application Policers.
 * These policers are used for all forwarding policing.
 *
 * @param[in]  unit chip unit number
 * @param[out] p policer parameters
 */
extern int soc_sbx_g2p3_ingegrpol_policer_params_get(int unit,
                soc_sbx_g2p3_policer_params_t *p);

/**
 * Set the size of the policer set for ingegrpol
 *
 * Application Policers.
 * These policers are used for all forwarding policing.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size number of policers in the policer set
 */
extern int soc_sbx_g2p3_ingegrpol_policer_size_set(int unit, int size);

/**
 * Set ingegrpol (policer) parameters.
 *
 * Application Policers.
 * These policers are used for all forwarding policing.
 *
 * @param[in]  unit chip unit number
 * @param[in]  policer policer number (within ingegrpol)
 * @param[in]  p policer parameters
 */
extern int soc_sbx_g2p3_ingegrpol_set(int unit,
                  int policer, soc_sbx_g2p3_policer_t *p);

/**
 * Get ingegrpol (policer) parameters.
 *
 * Application Policers.
 * These policers are used for all forwarding policing.
 *
 * @param[in]  unit chip unit number
 * @param[in]  policer policer number (within ingegrpol)
 * @param[out] p policer parameters
 */
extern int soc_sbx_g2p3_ingegrpol_get(int unit,
                  int policer, soc_sbx_g2p3_policer_t *p);

/**
 * Delete one ingegrpol (policer).
 *
 * Application Policers.
 * These policers are used for all forwarding policing.
 *
 * @param[in]  unit chip unit number
 * @param[in]  policer policer number (within ingegrpol)
 */
extern int soc_sbx_g2p3_ingegrpol_delete(int unit, int policer);

/**
 * Get oamtimer policer parameters.
 *
 * OAM continuity check message watch-dog timers.
 *
 * @param[in]  unit chip unit number
 * @param[out] p policer parameters
 */
extern int soc_sbx_g2p3_oamtimer_policer_params_get(int unit,
                soc_sbx_g2p3_policer_params_t *p);

/**
 * Set the size of the policer set for oamtimer
 *
 * OAM continuity check message watch-dog timers.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size number of policers in the policer set
 */
extern int soc_sbx_g2p3_oamtimer_policer_size_set(int unit, int size);

/**
 * Set oamtimer (timer) parameters.
 *
 * OAM continuity check message watch-dog timers.
 *
 * @param[in]  unit chip unit number
 * @param[in]  policer policer number (within oamtimer)
 * @param[in]  p policer parameters
 */
extern int soc_sbx_g2p3_oamtimer_set(int unit,
                  int policer, soc_sbx_g2p3_timer_t *p);

/**
 * Get oamtimer (timer) parameters.
 *
 * OAM continuity check message watch-dog timers.
 *
 * @param[in]  unit chip unit number
 * @param[in]  policer policer number (within oamtimer)
 * @param[out] p policer parameters
 */
extern int soc_sbx_g2p3_oamtimer_get(int unit,
                  int policer, soc_sbx_g2p3_timer_t *p);

/**
 * Delete one oamtimer (timer).
 *
 * OAM continuity check message watch-dog timers.
 *
 * @param[in]  unit chip unit number
 * @param[in]  policer policer number (within oamtimer)
 */
extern int soc_sbx_g2p3_oamtimer_delete(int unit, int policer);

/**
 * Get oamseq policer parameters.
 *
 * OAM continuity check message sequence number generator.
 *
 * @param[in]  unit chip unit number
 * @param[out] p policer parameters
 */
extern int soc_sbx_g2p3_oamseq_policer_params_get(int unit,
                soc_sbx_g2p3_policer_params_t *p);

/**
 * Set the size of the policer set for oamseq
 *
 * OAM continuity check message sequence number generator.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size number of policers in the policer set
 */
extern int soc_sbx_g2p3_oamseq_policer_size_set(int unit, int size);

/**
 * Set oamseq (sequence) parameters.
 *
 * OAM continuity check message sequence number generator.
 *
 * @param[in]  unit chip unit number
 * @param[in]  policer policer number (within oamseq)
 * @param[in]  p policer parameters
 */
extern int soc_sbx_g2p3_oamseq_set(int unit,
                  int policer, soc_sbx_g2p3_sequence_t *p);

/**
 * Get oamseq (sequence) parameters.
 *
 * OAM continuity check message sequence number generator.
 *
 * @param[in]  unit chip unit number
 * @param[in]  policer policer number (within oamseq)
 * @param[out] p policer parameters
 */
extern int soc_sbx_g2p3_oamseq_get(int unit,
                  int policer, soc_sbx_g2p3_sequence_t *p);

/**
 * Delete one oamseq (sequence).
 *
 * OAM continuity check message sequence number generator.
 *
 * @param[in]  unit chip unit number
 * @param[in]  policer policer number (within oamseq)
 */
extern int soc_sbx_g2p3_oamseq_delete(int unit, int policer);

/**
 * Print p2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_p2e_print(int unit, 
    soc_sbx_g2p3_p2e_t *e);

/**
 * Print ep2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ep2e_print(int unit, 
    soc_sbx_g2p3_ep2e_t *e);

/**
 * Print p2e20 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_p2e20_print(int unit, 
    soc_sbx_g2p3_p2e20_t *e);

/**
 * Print ep2e20 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ep2e20_print(int unit, 
    soc_sbx_g2p3_ep2e20_t *e);

/**
 * Print p2e25 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_p2e25_print(int unit, 
    soc_sbx_g2p3_p2e25_t *e);

/**
 * Print ep2e25 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ep2e25_print(int unit, 
    soc_sbx_g2p3_ep2e25_t *e);

/**
 * Print tpid entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_tpid_print(int unit, 
    soc_sbx_g2p3_tpid_t *e);

/**
 * Print oam_rx entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_oam_rx_print(int unit, 
    soc_sbx_g2p3_oam_rx_t *e);

/**
 * Print oam_tx entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_oam_tx_print(int unit, 
    soc_sbx_g2p3_oam_tx_t *e);

/**
 * Print lsmac entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_lsmac_print(int unit, 
    soc_sbx_g2p3_lsmac_t *e);

/**
 * Print l2cpmac entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_l2cpmac_print(int unit, 
    soc_sbx_g2p3_l2cpmac_t *e);

/**
 * Print oamupmac entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_oamupmac_print(int unit, 
    soc_sbx_g2p3_oamupmac_t *e);

/**
 * Print qos entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_qos_print(int unit, 
    soc_sbx_g2p3_qos_t *e);

/**
 * Print dscp_qos entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_dscp_qos_print(int unit, 
    soc_sbx_g2p3_dscp_qos_t *e);

/**
 * Print irt entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_irt_print(int unit, 
    soc_sbx_g2p3_irt_t *e);

/**
 * Print irt_wrap entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_irt_wrap_print(int unit, 
    soc_sbx_g2p3_irt_wrap_t *e);

/**
 * Print rt_mt entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_rt_mt_print(int unit, 
    soc_sbx_g2p3_rt_mt_t *e);

/**
 * Print rt_rr0 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_rt_rr0_print(int unit, 
    soc_sbx_g2p3_rt_rr0_t *e);

/**
 * Print rt_rr1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_rt_rr1_print(int unit, 
    soc_sbx_g2p3_rt_rr1_t *e);

/**
 * Print lag entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_lag_print(int unit, 
    soc_sbx_g2p3_lag_t *e);

/**
 * Print rr entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_rr_print(int unit, 
    soc_sbx_g2p3_rr_t *e);

/**
 * Print xt entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_xt_print(int unit, 
    soc_sbx_g2p3_xt_t *e);

/**
 * Print mirror entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_mirror_print(int unit, 
    soc_sbx_g2p3_mirror_t *e);

/**
 * Print emirror entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_emirror_print(int unit, 
    soc_sbx_g2p3_emirror_t *e);

/**
 * Print emirror20 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_emirror20_print(int unit, 
    soc_sbx_g2p3_emirror20_t *e);

/**
 * Print emirror25 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_emirror25_print(int unit, 
    soc_sbx_g2p3_emirror25_t *e);

/**
 * Print emll1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_emll1_print(int unit, 
    soc_sbx_g2p3_emll1_t *e);

/**
 * Print mac entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_mac_print(int unit, 
    soc_sbx_g2p3_mac_t *e);

/**
 * Print macl1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_macl1_print(int unit, 
    soc_sbx_g2p3_macl1_t *e);

/**
 * Print macl2 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_macl2_print(int unit, 
    soc_sbx_g2p3_macl2_t *e);

/**
 * Print ipv6dhost entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ipv6dhost_print(int unit, 
    soc_sbx_g2p3_ipv6dhost_t *e);

/**
 * Print ipv6dhostl1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ipv6dhostl1_print(int unit, 
    soc_sbx_g2p3_ipv6dhostl1_t *e);

/**
 * Print ipv6dhostl2 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ipv6dhostl2_print(int unit, 
    soc_sbx_g2p3_ipv6dhostl2_t *e);

/**
 * Print mst entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_mst_print(int unit, 
    soc_sbx_g2p3_mst_t *e);

/**
 * Print pv2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_pv2e_print(int unit, 
    soc_sbx_g2p3_pv2e_t *e);

/**
 * Print p2appdata entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_p2appdata_print(int unit, 
    soc_sbx_g2p3_p2appdata_t *e);

/**
 * Print pv2appdata entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_pv2appdata_print(int unit, 
    soc_sbx_g2p3_pv2appdata_t *e);

/**
 * Print ipv6shost entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ipv6shost_print(int unit, 
    soc_sbx_g2p3_ipv6shost_t *e);

/**
 * Print ipv6shostl1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ipv6shostl1_print(int unit, 
    soc_sbx_g2p3_ipv6shostl1_t *e);

/**
 * Print ipv6shostl2 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ipv6shostl2_print(int unit, 
    soc_sbx_g2p3_ipv6shostl2_t *e);

/**
 * Print pvv2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_pvv2e_print(int unit, 
    soc_sbx_g2p3_pvv2e_t *e);

/**
 * Print pvv2epack entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_pvv2epack_print(int unit, 
    soc_sbx_g2p3_pvv2epack_t *e);

/**
 * Print isid2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_isid2e_print(int unit, 
    soc_sbx_g2p3_isid2e_t *e);

/**
 * Print oampvd2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_oampvd2e_print(int unit, 
    soc_sbx_g2p3_oampvd2e_t *e);

/**
 * Print oammaidmep2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_oammaidmep2e_print(int unit, 
    soc_sbx_g2p3_oammaidmep2e_t *e);

/**
 * Print cuckoo entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_cuckoo_print(int unit, 
    soc_sbx_g2p3_cuckoo_t *e);

/**
 * Print left entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_left_print(int unit, 
    soc_sbx_g2p3_left_t *e);

/**
 * Print right entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_right_print(int unit, 
    soc_sbx_g2p3_right_t *e);

/**
 * Print outerlabelcuckoo entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_outerlabelcuckoo_print(int unit, 
    soc_sbx_g2p3_outerlabelcuckoo_t *e);

/**
 * Print outerlabelleft entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_outerlabelleft_print(int unit, 
    soc_sbx_g2p3_outerlabelleft_t *e);

/**
 * Print outerlabelright entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_outerlabelright_print(int unit, 
    soc_sbx_g2p3_outerlabelright_t *e);

/**
 * Print innerlabelcuckoo entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_innerlabelcuckoo_print(int unit, 
    soc_sbx_g2p3_innerlabelcuckoo_t *e);

/**
 * Print innerlabelleft entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_innerlabelleft_print(int unit, 
    soc_sbx_g2p3_innerlabelleft_t *e);

/**
 * Print innerlabelright entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_innerlabelright_print(int unit, 
    soc_sbx_g2p3_innerlabelright_t *e);

/**
 * Print label2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_label2e_print(int unit, 
    soc_sbx_g2p3_label2e_t *e);

/**
 * Print tagged_mpls entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_tagged_mpls_print(int unit, 
    soc_sbx_g2p3_tagged_mpls_t *e);

/**
 * Print v2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_v2e_print(int unit, 
    soc_sbx_g2p3_v2e_t *e);

/**
 * Print v2e1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_v2e1_print(int unit, 
    soc_sbx_g2p3_v2e1_t *e);

/**
 * Print lp entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_lp_print(int unit, 
    soc_sbx_g2p3_lp_t *e);

/**
 * Print l2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_l2e_print(int unit, 
    soc_sbx_g2p3_l2e_t *e);

/**
 * Print l2cp entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_l2cp_print(int unit, 
    soc_sbx_g2p3_l2cp_t *e);

/**
 * Print l2cpslow entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_l2cpslow_print(int unit, 
    soc_sbx_g2p3_l2cpslow_t *e);

/**
 * Print l2cpnop entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_l2cpnop_print(int unit, 
    soc_sbx_g2p3_l2cpnop_t *e);

/**
 * Print ft entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ft_print(int unit, 
    soc_sbx_g2p3_ft_t *e);

/**
 * Print OamTimerCalendar entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_oamtimercalendar_print(int unit, 
    soc_sbx_g2p3_oamtimercalendar_t *e);

/**
 * Print OamPortMdLevel2Etc entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_oamportmdlevel2etc_print(int unit, 
    soc_sbx_g2p3_oamportmdlevel2etc_t *e);

/**
 * Print v4uc_str_sel entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_v4uc_str_sel_print(int unit, 
    soc_sbx_g2p3_v4uc_str_sel_t *e);

/**
 * Print cmac entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_cmac_print(int unit, 
    soc_sbx_g2p3_cmac_t *e);

/**
 * Print bmac entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_bmac_print(int unit, 
    soc_sbx_g2p3_bmac_t *e);

/**
 * Print ipv6mcsg entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ipv6mcsg_print(int unit, 
    soc_sbx_g2p3_ipv6mcsg_t *e);

/**
 * Print ipv6mcsgl1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ipv6mcsgl1_print(int unit, 
    soc_sbx_g2p3_ipv6mcsgl1_t *e);

/**
 * Print ipv6mcsgl2 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ipv6mcsgl2_print(int unit, 
    soc_sbx_g2p3_ipv6mcsgl2_t *e);

/**
 * Print ipv6mcg entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ipv6mcg_print(int unit, 
    soc_sbx_g2p3_ipv6mcg_t *e);

/**
 * Print ipv6mcgl1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ipv6mcgl1_print(int unit, 
    soc_sbx_g2p3_ipv6mcgl1_t *e);

/**
 * Print ipv6mcgl2 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ipv6mcgl2_print(int unit, 
    soc_sbx_g2p3_ipv6mcgl2_t *e);

/**
 * Print ipv4mcg entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ipv4mcg_print(int unit, 
    soc_sbx_g2p3_ipv4mcg_t *e);

/**
 * Print ipv4mcgl1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ipv4mcgl1_print(int unit, 
    soc_sbx_g2p3_ipv4mcgl1_t *e);

/**
 * Print ipv4mcgl2 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ipv4mcgl2_print(int unit, 
    soc_sbx_g2p3_ipv4mcgl2_t *e);

/**
 * Print ipv4mcsg entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ipv4mcsg_print(int unit, 
    soc_sbx_g2p3_ipv4mcsg_t *e);

/**
 * Print ipv4mcsgl1 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ipv4mcsgl1_print(int unit, 
    soc_sbx_g2p3_ipv4mcsgl1_t *e);

/**
 * Print ipv4mcsgl2 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ipv4mcsgl2_print(int unit, 
    soc_sbx_g2p3_ipv4mcsgl2_t *e);

/**
 * Print lpmnode entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_lpmnode_print(int unit, 
    soc_sbx_g2p3_lpmnode_t *e);

/**
 * Print ipv4sa entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ipv4sa_print(int unit, 
    soc_sbx_g2p3_ipv4sa_t *e);

/**
 * Print ipv4sal0 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ipv4sal0_print(int unit, 
    soc_sbx_g2p3_ipv4sal0_t *e);

/**
 * Print ipv4saodd entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ipv4saodd_print(int unit, 
    soc_sbx_g2p3_ipv4saodd_t *e);

/**
 * Print ipv4saeven entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ipv4saeven_print(int unit, 
    soc_sbx_g2p3_ipv4saeven_t *e);

/**
 * Print ipv4sapayload entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ipv4sapayload_print(int unit, 
    soc_sbx_g2p3_ipv4sapayload_t *e);

/**
 * Print ifp entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ifp_print(int unit, 
    soc_sbx_g2p3_ifp_t *e);

/**
 * Print ifp_v6 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ifp_v6_print(int unit, 
    soc_sbx_g2p3_ifp_v6_t *e);

/**
 * Print evp2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_evp2e_print(int unit, 
    soc_sbx_g2p3_evp2e_t *e);

/**
 * Print oi2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_oi2e_print(int unit, 
    soc_sbx_g2p3_oi2e_t *e);

/**
 * Print eteencap entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_eteencap_print(int unit, 
    soc_sbx_g2p3_eteencap_t *e);

/**
 * Print etel2 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_etel2_print(int unit, 
    soc_sbx_g2p3_etel2_t *e);

/**
 * Print oamEp entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_oamep_print(int unit, 
    soc_sbx_g2p3_oamep_t *e);

/**
 * Print remark entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_remark_print(int unit, 
    soc_sbx_g2p3_remark_t *e);

/**
 * Print epv2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_epv2e_print(int unit, 
    soc_sbx_g2p3_epv2e_t *e);

/**
 * Print esmac entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_esmac_print(int unit, 
    soc_sbx_g2p3_esmac_t *e);

/**
 * Print ert entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ert_print(int unit, 
    soc_sbx_g2p3_ert_t *e);

/**
 * Print ert_wrap entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ert_wrap_print(int unit, 
    soc_sbx_g2p3_ert_wrap_t *e);

/**
 * Print v4mc_str_sel entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_v4mc_str_sel_print(int unit, 
    soc_sbx_g2p3_v4mc_str_sel_t *e);

/**
 * Print efp entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_efp_print(int unit, 
    soc_sbx_g2p3_efp_t *e);

/**
 * Print efp_v6 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_efp_v6_print(int unit, 
    soc_sbx_g2p3_efp_v6_t *e);

/**
 * Print oamMultiplier entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_oammultiplier_print(int unit, 
    soc_sbx_g2p3_oammultiplier_t *e);

/**
 * Print oamEpRemap entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_oamepremap_print(int unit, 
    soc_sbx_g2p3_oamepremap_t *e);

/**
 * Print ipv6da entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ipv6da_print(int unit, 
    soc_sbx_g2p3_ipv6da_t *e);

/**
 * Print ipv6dal0 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ipv6dal0_print(int unit, 
    soc_sbx_g2p3_ipv6dal0_t *e);

/**
 * Print ipv6daodd entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ipv6daodd_print(int unit, 
    soc_sbx_g2p3_ipv6daodd_t *e);

/**
 * Print ipv6daeven entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ipv6daeven_print(int unit, 
    soc_sbx_g2p3_ipv6daeven_t *e);

/**
 * Print ipv6dapayload entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ipv6dapayload_print(int unit, 
    soc_sbx_g2p3_ipv6dapayload_t *e);

/**
 * Print ipv6sa entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ipv6sa_print(int unit, 
    soc_sbx_g2p3_ipv6sa_t *e);

/**
 * Print ipv6sal0 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ipv6sal0_print(int unit, 
    soc_sbx_g2p3_ipv6sal0_t *e);

/**
 * Print ipv6saodd entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ipv6saodd_print(int unit, 
    soc_sbx_g2p3_ipv6saodd_t *e);

/**
 * Print ipv6saeven entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ipv6saeven_print(int unit, 
    soc_sbx_g2p3_ipv6saeven_t *e);

/**
 * Print ipv6sapayload entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ipv6sapayload_print(int unit, 
    soc_sbx_g2p3_ipv6sapayload_t *e);

/**
 * Print ipv4da entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ipv4da_print(int unit, 
    soc_sbx_g2p3_ipv4da_t *e);

/**
 * Print ipv4dal0 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ipv4dal0_print(int unit, 
    soc_sbx_g2p3_ipv4dal0_t *e);

/**
 * Print ipv4daodd entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ipv4daodd_print(int unit, 
    soc_sbx_g2p3_ipv4daodd_t *e);

/**
 * Print ipv4daeven entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ipv4daeven_print(int unit, 
    soc_sbx_g2p3_ipv4daeven_t *e);

/**
 * Print ipv4dapayload entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_ipv4dapayload_print(int unit, 
    soc_sbx_g2p3_ipv4dapayload_t *e);

/**
 * Print P2FTI entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_p2fti_print(int unit, 
    soc_sbx_g2p3_p2fti_t *e);

/**
 * Print policer entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_policer_print(int unit, 
    soc_sbx_g2p3_policer_t *e);

/**
 * Print timer entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_timer_print(int unit, 
    soc_sbx_g2p3_timer_t *e);

/**
 * Print sequence entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2p3_sequence_print(int unit, 
    soc_sbx_g2p3_sequence_t *e);

/*
 * Diag shell print & set drivers
 */

/**
 * Diagnostic shell print.
 *
 * This function drives printing the state of microcode objects
 * (constants, globals, entries, memories and the memory map) based
 * on the supplied command line arguments.
 *
 * @param[in]  unit chip unit number
 * @param[in]  argc number of argument strings
 * @param[in]  argv pointer to array of argument strings
 */
extern int soc_sbx_g2p3_shell_print(int unit, int argc, char **argv);

/**
 * Diagnostic shell set.
 *
 * This function drives setting the state of microcode objects
 * (globals, entries, and memories) based
 * on the supplied command line arguments.
 *
 * @param[in]  unit chip unit number
 * @param[in]  argc number of argument strings
 * @param[in]  argv pointer to array of argument strings
 */
extern int soc_sbx_g2p3_shell_set(int unit, int argc, char **argv);

/**
 * Diagnostic shell delete.
 *
 * This function drives deleting microcode entries that support a 
 * delete operation based on the supplied command line arguments.
 *
 * @param[in]  unit chip unit number
 * @param[in]  argc number of argument strings
 * @param[in]  argv pointer to array of argument strings
 */
extern int soc_sbx_g2p3_shell_delete(int unit, int argc, char **argv);

/*
 * Diag shell usage messages
 */

/** Diagnostic shell set operation usage message */
extern char soc_sbx_g2p3_set_usage[];
/** Diagnostic shell print operation usage message */
extern char soc_sbx_g2p3_get_usage[];
/** Diagnostic shell delete operation usage message */
extern char soc_sbx_g2p3_delete_usage[];
#endif
#endif
#endif 
