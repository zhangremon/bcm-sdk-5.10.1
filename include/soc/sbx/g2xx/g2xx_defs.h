/*
 * $Id: g2xx_defs.h 1.7.106.2 Broadcom SDK $
 *
 *
 *
 * $Copyright: Copyright 2011 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 * 
 *
 * g2xx_defs.h: XXX Custom Microcode microcode accessor functions
 */

/**
 * @file g2xx_defs.h
 * XXX Custom Microcode microcode accessor functions.
 *
 * This file provides the public interface to the XXX Custom Microcode
 * microcode.  Only explicitly documented elements (types  & functions)
 * are supported, external interfaces.  Other elements are exported only
 * for debugging convenience.
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 */
#ifndef _G2XX_DEFS_H
#define _G2XX_DEFS_H
#ifdef BCM_SBX_SUPPORT
#include <sal/types.h>
#include <soc/sbx/fe2k_common/sbFe2000DmaMgr.h>
#include <sal/core/sync.h>

/*
 * Memory element enumeration
 * Not public: exported for debugging convenience only
 */
typedef enum soc_sbx_g2xx_memory_id_s {
    SOC_SBX_G2XX_MM0_NAR0_ID,
    SOC_SBX_G2XX_MM0_NAR1_ID,
    SOC_SBX_G2XX_MM0_WIDE_ID,
    SOC_SBX_G2XX_MM0_INT0_ID,
    SOC_SBX_G2XX_MM0_INT1_ID,
    SOC_SBX_G2XX_MM1_NAR0_ID,
    SOC_SBX_G2XX_MM1_NAR1_ID,
    SOC_SBX_G2XX_MM1_WIDE_ID,
    SOC_SBX_G2XX_MM1_INT0_ID,
    SOC_SBX_G2XX_MM1_INT1_ID,
    SOC_SBX_G2XX_RC0_RR_ID,
    SOC_SBX_G2XX_RC1_RR_ID,
    SOC_SBX_G2XX_RXPORTDATA_ID,
    SOC_SBX_G2XX_INITIALQSTATE20_ID,
    SOC_SBX_G2XX_INITIALQSTATE25_ID,
    SOC_SBX_G2XX_MEMORY_MAX_ID
} soc_sbx_g2xx_memory_id_t;

/*
 * Shared constant enumeration
 * Not public: exported for debugging convenience only
 */
typedef enum soc_sbx_g2xx_constant_id_s {
    SOC_SBX_G2XX_MIN_FREE_EXCEPTION_ID,
    SOC_SBX_G2XX_EXC_COPY_TO_HOST_ID,
    SOC_SBX_G2XX_MAX_FREE_EXCEPTION_ID,
    SOC_SBX_G2XX_HTYPE_ERH_ID,
    SOC_SBX_G2XX_HTYPE_ETYPE_ID,
    SOC_SBX_G2XX_HTYPE_ETH_ID,
    SOC_SBX_G2XX_HTYPE_IETH_ID,
    SOC_SBX_G2XX_HTYPE_VTAG_ID,
    SOC_SBX_G2XX_HTYPE_IPV4_ID,
    SOC_SBX_G2XX_HTYPE_ELEN_ID,
    SOC_SBX_G2XX_HTYPE_UNKN_ID,
    SOC_SBX_G2XX_LSMAC_TABLE_SIZE_ID,
    SOC_SBX_G2XX_CONSTANT_MAX_ID
} soc_sbx_g2xx_constant_id_t;

/*
 * Global value enumeration
 * Not public: exported for debugging convenience only
 */
typedef enum soc_sbx_g2xx_global_id_s {
    SOC_SBX_G2XX_TPID0_ID,
    SOC_SBX_G2XX_TPID1_ID,
    SOC_SBX_G2XX_TPID2_ID,
    SOC_SBX_G2XX_NODE_ID,
    SOC_SBX_G2XX_GLOBAL_MAX_ID
} soc_sbx_g2xx_global_id_t;

/*
 * Table enumeration
 * Not public: exported for debugging convenience only
 */
typedef enum soc_sbx_g2xx_table_id_s {
    SOC_SBX_G2XX_PORTDATA20_TABLE_ID,
    SOC_SBX_G2XX_PORTDATA25_TABLE_ID,
    SOC_SBX_G2XX_XT_TABLE_ID,
    SOC_SBX_G2XX_TABLE_MAX_ID
} soc_sbx_g2xx_table_id_t;

/*
 * Entry enumeration
 * Not public: exported for debugging convenience only
 */
typedef enum soc_sbx_g2xx_entry_id_s {
    SOC_SBX_G2XX_P2E_ID,
    SOC_SBX_G2XX_EP2E_ID,
    SOC_SBX_G2XX_P2E20_ID,
    SOC_SBX_G2XX_EP2E20_ID,
    SOC_SBX_G2XX_P2E25_ID,
    SOC_SBX_G2XX_EP2E25_ID,
    SOC_SBX_G2XX_TPID_ID,
    SOC_SBX_G2XX_LSMAC_ID,
    SOC_SBX_G2XX_XT_ID,
    SOC_SBX_G2XX_POLICER_ID,
    SOC_SBX_G2XX_TIMER_ID,
    SOC_SBX_G2XX_SEQUENCE_ID,
    SOC_SBX_G2XX_ENTRY_MAX_ID
} soc_sbx_g2xx_entry_id_t;

/*
 * Counter enumeration
 * Not public: exported for debugging convenience only
 */
typedef enum soc_sbx_g2xx_counter_id_s {
    SOC_SBX_G2XX_COUNTER_MAX_ID
} soc_sbx_g2xx_counter_id_t;

/*
 * Policer enumeration
 * Not public: exported for debugging convenience only
 */
typedef enum soc_sbx_g2xx_policer_id_s {
    SOC_SBX_G2XX_POLICER_MAX_ID
} soc_sbx_g2xx_policer_id_t;

#define SOC_SBX_G2XX_TABLE_BANKS_MAX 10
#define SOC_SBX_G2XX_COMPLEX_BANKS_MAX 24
#define SOC_SBX_G2XX_COUNTER_BANKS_MAX 32
#define SOC_SBX_G2XX_POLICER_BANKS_MAX 9

/**
 * Pack function for quasi-internal complex table implementation code.
 */
typedef int (*soc_sbx_g2xx_complex_pack_f_t)
   (int unit, void *e, void *b, int bsz);

/*
 * Constant description type
 * Not public: exported for debugging convenience only
 */
typedef struct soc_sbx_g2xx_constant_desc_s {
    char *name;
} soc_sbx_g2xx_constant_desc_t;

/*
 * Global value description type
 * Not public: exported for debugging convenience only
 */
typedef struct soc_sbx_g2xx_global_desc_s {
    char *name;
    int   range;
    int   value;
} soc_sbx_g2xx_global_desc_t;

/*
 * Table bank description type
 * Not public: exported for debugging convenience only
 */
typedef struct soc_sbx_g2xx_table_bank_s {
    int memory;
    int mbank;
    int size;
    int width;
    int base;
} soc_sbx_g2xx_table_bank_t;

/*
 * Table type.
 */
typedef enum soc_sbx_g2xx_table_type_s {
    SOC_SBX_G2XX_ARRAY_TABLE_TYPE  = 0,
    SOC_SBX_G2XX_LPM_TABLE_TYPE    = 1,
    SOC_SBX_G2XX_EML_TABLE_TYPE    = 2,
    SOC_SBX_G2XX_EM32_TABLE_TYPE   = 3
} soc_sbx_g2xx_table_type_t;

/*
 * Table description type
 * Not public: exported for debugging convenience only
 */
typedef struct soc_sbx_g2xx_table_desc_s {
    char *name;
    int nextaligned;
    int type;
    int nbanks;
    soc_sbx_g2xx_table_bank_t banks[SOC_SBX_G2XX_TABLE_BANKS_MAX];
    /* Complex-only state */
    int b0size;
    void *cstate;
} soc_sbx_g2xx_table_desc_t;

/*
 * Integer format type
 * Not public: exported for debugging convenience only
 */
typedef enum soc_sbx_g2xx_integer_format_s {
    SOC_SBX_G2XX_NATIVE_INTEGER_FORMAT = 0,
    SOC_SBX_G2XX_LE_INTEGER_FORMAT     = 1,
    SOC_SBX_G2XX_BE_INTEGER_FORMAT     = 2
} soc_sbx_g2xx_integer_format_t;

/*
 * Index description type
 * Not public: exported for debugging convenience only
 */
typedef struct soc_sbx_g2xx_index_desc_s {
    char *name;
    int   pos;
    int   range;
    int   orange;
    int   width;
    int   format;
} soc_sbx_g2xx_index_desc_t;

/*
 * Field description type
 * Not public: exported for debugging convenience only
 */
typedef struct soc_sbx_g2xx_field_desc_s {
    char *name;
    int   pos;
    int   range;
    int   width;
} soc_sbx_g2xx_field_desc_t;

/*
 * Entry bank description type
 * Not public: exported for debugging convenience only
 */
typedef struct soc_sbx_g2xx_entry_bank_s {
    int tablebank;
    int width;
    int stridebits;
} soc_sbx_g2xx_entry_bank_t;

/*
 * Entry type
 */
typedef enum soc_sbx_g2xx_entry_type_s {
    SOC_SBX_G2XX_ARRAY_ENTRY_TYPE = 0,
    SOC_SBX_G2XX_ARRAYHOOK_ENTRY_TYPE = 1,
    SOC_SBX_G2XX_EXT_ENTRY_TYPE = 2,
    SOC_SBX_G2XX_LPM_ENTRY_TYPE = 3,
    SOC_SBX_G2XX_EML_ENTRY_TYPE = 4,
    SOC_SBX_G2XX_EM32_ENTRY_TYPE = 5
} soc_sbx_g2xx_entry_type_t;

/*
 * Entry description type
 * Not public: exported for debugging convenience only
 */
typedef struct soc_sbx_g2xx_entry_desc_s {
    char *name;
    int type;
    soc_sbx_g2xx_table_id_t table;
    int esize;
    int epsize;
    soc_sbx_g2xx_complex_pack_f_t pack;
    int nindexes;
    soc_sbx_g2xx_index_desc_t *indexes;
    int indexeswidth;
    int nfields;
    soc_sbx_g2xx_field_desc_t *fields;
    int totalwidth;
    int nbanks;
    soc_sbx_g2xx_entry_bank_t banks[SOC_SBX_G2XX_TABLE_BANKS_MAX];
} soc_sbx_g2xx_entry_desc_t;

/*
 * Counter bank description type
 * Not public: exported for debugging convenience only
 */
typedef struct soc_sbx_g2xx_counter_bank_desc_s {
    int memory;
    int mbank;
    int base;
    int size;
} soc_sbx_g2xx_counter_bank_desc_t;

/*
 * Counter description type
 * Not public: exported for debugging convenience only
 */
typedef struct soc_sbx_g2xx_counter_desc_s {
    char *name;
    int bank;
    int base;
    int size;
} soc_sbx_g2xx_counter_desc_t;

/**
 * Policer bank type.
 */
typedef enum soc_sbx_g2xx_policer_bank_type_s {
    SOC_SBX_G2XX_POLICER_POLICER_BANK_TYPE  = 0,   /**< regular policer */
    SOC_SBX_G2XX_TIMER_POLICER_BANK_TYPE    = 1,   /**< OAM timer */
    SOC_SBX_G2XX_SEQUENCE_POLICER_BANK_TYPE = 2    /**< sequence number generator */
} soc_sbx_g2xx_policer_bank_type_t;

/*
 * Policer bank description type
 * Not public: exported for debugging convenience only
 */
typedef struct soc_sbx_g2xx_policer_bank_desc_s {
    int type;
    int memory;
    int mbank;
    int base;
    int size;
    int kbps;
} soc_sbx_g2xx_policer_bank_desc_t;

/*
 * Policer description type
 * Not public: exported for debugging convenience only
 */
typedef struct soc_sbx_g2xx_policer_desc_s {
    char *name;
    int bank;
    int base;
    int size;
} soc_sbx_g2xx_policer_desc_t;

/*
 * Memory bank type
 * Not public: exported for debugging convenience only
 */
typedef enum soc_sbx_g2xx_bank_type_s {
    SOC_SBX_G2XX_TABLE_BANK_TYPE,
    SOC_SBX_G2XX_COUNTER_BANK_TYPE,
    SOC_SBX_G2XX_POLICER_BANK_TYPE
} soc_sbx_g2xx_bank_type_t;

/*
 * Memory bank description type
 * Not public: exported for debugging convenience only
 */
typedef struct soc_sbx_g2xx_memory_bank_desc_s {
    soc_sbx_g2xx_bank_type_t type;
    int number;
    int bank;
    int nextaligned;
} soc_sbx_g2xx_memory_bank_desc_t;

/*
 * Memory description type
 * Not public: exported for debugging convenience only
 */
typedef struct soc_sbx_g2xx_memory_desc_s {
    char *name;
    int width;
    int size;
    int dma;
    int descending;
    int reg;
    int alignedlist;
    soc_sbx_g2xx_memory_bank_desc_t *banks;
    int nbanks;
} soc_sbx_g2xx_memory_desc_t;

/*
 * Table management state structure
 * Not public: exported for debugging convenience only
 */
typedef struct soc_sbx_g2xx_table_manager_s {
    int behost;
    soc_sbx_g2xx_memory_desc_t *memories;
    soc_sbx_g2xx_constant_desc_t *constants;
    soc_sbx_g2xx_global_desc_t *globals;
    int alignedlist;
    soc_sbx_g2xx_table_desc_t *tables;
    soc_sbx_g2xx_index_desc_t *indexes;
    soc_sbx_g2xx_entry_desc_t *entries;
    soc_sbx_g2xx_counter_bank_desc_t counterbanks[32];
    soc_sbx_g2xx_counter_desc_t *counters;
    soc_sbx_g2xx_policer_bank_desc_t policerbanks[9];
    soc_sbx_g2xx_policer_desc_t *policers;
    int policerbase;
    soc_sbx_g2xx_memory_bank_desc_t *memorybanks;
    int bufsize;
    uint8 *entrydmabuf;
    sal_paddr_t entrydmabufhba;
    sbFe2000DmaOp_t entrydmaop;
    sal_mutex_t dmabufmutex;
} soc_sbx_g2xx_table_manager_t;

/* ***
 * *** Types for public functions
 * ***/

/*
 * Big field types
 */

/** 6 byte type (typedef needed to keep ASE from dying) */
typedef uint8 soc_sbx_g2xx_6_byte_t[6];
/** 8 byte type (typedef needed to keep ASE from dying) */
typedef uint8 soc_sbx_g2xx_8_byte_t[8];

/**
 * Memory parameter structure.
 */
typedef struct soc_sbx_g2xx_memory_params_s {
    int size;   /**< size of memory, in words (-1 means unknown) */
    int width;  /**< width of memory word, in bits */
} soc_sbx_g2xx_memory_params_t;

/**
 * Table bank parameters.
 * 
 * Tables are composed of one or more banks, each of which is a contiguous
 * section of a memory.
 */
typedef struct soc_sbx_g2xx_table_bank_params_s {
    int base;   /**< base address, in memory words */
    int size;   /**< size, in memory words */
    int memory; /**< memory index (also CPU DMA memory port number) */
} soc_sbx_g2xx_table_bank_params_t;
/**
 * Counter bank parameters.
 *
 * Each counter bank resides in a contiguous section of a particular
 * memory, and is distinctly configured into the CM block.  A counter
 * bank may contain one or more counter blocks.
 */
typedef struct soc_sbx_g2xx_counter_bank_params_s {
    int memory; /**< memory index (also CPU DMA memory port number) */
    int base;   /**< base address, in memory words */
    int size;   /**< size, in memory words */
} soc_sbx_g2xx_counter_bank_params_t;

/**
 * Counter block parameters.
 *
 * Each counter block (or simply 'counter') is contained in a counter bank.
 * Each counter is a distinct functional group of counters
 * in the microcode forwarding application.
 */
typedef struct soc_sbx_g2xx_counter_params_s {
    int bank;   /**< bank number for the containing counter bank */
    int size;   /**< size, in counters */
    int base;   /**< base, address offset within the counter bank */
} soc_sbx_g2xx_counter_params_t;

/**
 * Counter value.
 *
 * The value of a single counter (pair) in bytes and packets
 */
typedef struct soc_sbx_g2xx_counter_value_s {
    COMPILER_UINT64 bytes;    /**< bytes */
    COMPILER_UINT64 packets;  /**< packets */
} soc_sbx_g2xx_counter_value_t;

/**
 * Policer bank parameters.
 *
 * Each policer bank resides in a contiguous section of the memory
 * attached to the PMU, and has distinct PMU parameters, including
 * functional type (policer, timer, or sequence generator), etc..  A policer
 * bank may contain one or more policer blocks.
 */
typedef struct soc_sbx_g2xx_policer_bank_params_s {
    int type;   /**< policer bank type (policer, timer or sequence generator */ 
    int memory; /**< memory index (also CPU DMA memory port number) */
    int base;   /**< base address, in memory words */
    int size;   /**< size, in memory words */
    int kbps;   /**< base rate, in kilobits/second */
} soc_sbx_g2xx_policer_bank_params_t;

/**
 * Policer block parameters.
 *
 * Each policer block (or simply 'policer') is contained in a policer bank.
 * Each policer is a distinct functional group of policers in the microcode
 * forwarding application.
 */
typedef struct soc_sbx_g2xx_policer_params_s {
    int bank;   /**< policer bank index */
    int size;   /**< size, in policers */
    int base;   /**< base, word address in memory (NB, not offset in bank!) */
} soc_sbx_g2xx_policer_params_t;

    /**
     * Ingress Port Table.
     * This table contains ingress per-port configuration data.
     * The contents of this table are contained in the PPE
     * per-port data and PPE variable memories.
     * 
     * <br><br>The PPE per-port and variable memories are
     * organized by source queue.  SWS source
     * queues may be assigned to ports in somewhat
     * arbitrary ways as necessary to ensure full
     * throughput for a given front panel port
     * configuation, so among other things, the
     * <tt>p2e</tt> and <tt>ep2e</tt> contain the ordinal
     * port number associated with a particular SWS queue.
     * <br><br>Although the data is internally organized by SWS
     * queue, the interface to the <tt>p2e</tt> table is by port.
     * The set and get implementation automatically perform
     * translation from forwarding port number to SWS queue to
     * access the appropriate per-port state.
     */
typedef struct soc_sbx_g2xx_p2e_s {
    /**
     * Microcode port number (for LRP use).  This field is
     * read-only.
     */
    uint32 port;
    /** default (native) VID for untagged packets */
    uint32 nativevid;
    /** default CFI for untagged packets */
    uint32 defcfi;
    /** default Ethernet priority for untagged packets */
    uint32 defpri;
    /**
     * strip VLAN tags unless overriden by
     * pv[v]2e.keeporstrip.  This flag is typically set for
     * both customer and provider ports for 802.1 provider bridging
     * forwarding (where a customer tag is transported from a
     * customer port, through a provider network).  This flag is
     * cleared for other cases, such as traditional 802.1
     * bridging, and VLAN cross-connect (e.g. TR-101-style
     * 2 tag service identification).
     */
    uint32 defstrip;
    /**
     * always strip the outer VLAN tag.
     * This flag is set only for provider bridging provider
     * ports.  pstrip=1 ensures the STAG is always stripped and
     * the CTAG is forwarded transparently.
     */
    uint32 pstrip;
    /**
     * PBB mode information.
     * This flag is set only for provider backbone bridging 
     * ports.  mim=0 means PBB is not enabled on this port.
     * The non-zero values are (tdb).
     */
    uint32 mim;
    /** HIDE */
    soc_sbx_g2xx_8_byte_t mask;
    /**
     * parse at most one CTPID tag on a packet.  Must not be set
     * concurrently with p2e.provider.  If both p2e.customer and
     * p2e.provider
     * are 0, all VLAN tags will be processed completely
     * transparently (i.e. ignored), similarly to a non
     * VLAN-capable switch.  This transparent mode is typically
     * not used for normal system operation, but is
     * useful for testing purpose.
     */
    uint32 customer;
    /**
     * parse at most once STPID tag, possibly with a CTPID tag
     * beneath it, on a packet.  The STPID (either STPID0 or
     * STPID1) is selected based on p2e.stpid1.  p2e.provider
     * not be set concurrently with p2e.customer.  If both
     * p2e.customer and p2e.provider
     * are 0, all VLAN tags will be processed completely
     * transparently (i.e. ignored), similarly to a non
     * VLAN-capable switch.  This transparent mode is typically
     * not used for normal system operation, but is
     * useful for testing purpose.
     */
    uint32 provider;
    /**
     * enable 802.3 link OAM loopback mode.
     * When oamloop=1, all ingress packets are sent to the
     * exception stream with a PPE trap code indicating the port
     * is in link loopback mode.  The ingress exception
     * stream microcode will loop back all packets except
     * L2CP slow protocol packets which will be sent to
     * the CPU as exceptions.  When oamloop=1, egress L2CP slow
     * protocol packets are forwarded normally, and all other
     * packets are sent to the egress exception stream with
     * a PPE trap code indicating the port is in link loopback
     * mode.  The egress exception microcode will drop all
     * link loopback packets.
     */
    uint32 oamloop;
    /** use STPID1 for provider-mode tag parsing. */
    uint32 stpid1;
    /**
     * enable an additional STPID for provider-mode tag parsing.
     * If p2e.twintpid=1, a provider tag can either be preceded
     * by the configured STPID (0 or 1, depending on p2e.stpid1), 
     * or by a third STPID value (STPID2).  This allows a single
     * port to concurrently support two different STPID
     * conventions for interworking scenarios.
     */
    uint32 twintpid;
    /** enable PBB fast-path fowarding on a port */
    uint32 pbb;
    /** enable IP multicast fast-path fowarding on a port */
    uint32 ipv4mc;
    /** HIDE */
    uint32 state;
    /**
     * Microcode port number (for PPE parsing use).  This field is
     * read-only.  It is used for behavior such as matching
     * per-port local station addresses.
     */
    uint32 pport;
    /** HIDE */
    uint32 htype;
} soc_sbx_g2xx_p2e_t;

    /**
     * Egress Port Table.
     * This egress table contains per-port configuration data.
     * The contents of this table are contained in the PPE
     * per-port data and PPE variable memories.
     * 
     * <br><br>The PPE per-port and variable memories are
     * organized by source queue.  SWS source
     * queues may be assigned to ports in somewhat
     * arbitrary ways as necessary to ensure full
     * throughput for a given front panel port
     * configuation, so among other things, the
     * <tt>p2e</tt> and <tt>ep2e</tt> contain the ordinal
     * port number associated with a particular SWS queue.
     * <br><br>Although the data is internally organized by SWS
     * queue, the interface to the <tt>p2e</tt> table is by port.
     * The set and get implementation automatically perform
     * translation from forwarding port number to SWS queue to
     * access the appropriate per-port state.
     */
typedef struct soc_sbx_g2xx_ep2e_s {
    /**
     * PBB mode information.
     * This flag is set only for provider backbone bridging 
     * ports.  mim=0 means PBB is not enabled on this port.
     * The non-zero values are (tdb).
     */
    uint32 mim;
    /**
     * egress port id.  This value is used to perform
     * split-horizon packet dropping in cases where the ETE
     * does not contain an ETE-specific PID value.
     */
    uint32 pid;
    /** use STPID0 for STAGs. */
    uint32 stpid0;
    /** use STPID1 for STAGs. */
    uint32 stpid1;
    /**
     * enable provider bridging customer port egress CTAG
     * processing.  This bit should be set on provider bridging
     * customer ports (but not on ports operating in any other role
     * such as `traditional' 802.1 bridging ports, provider
     * bridging provider ports, transparent mux/demux ports, or
     * TR-101-style crossconnect ports).  When ep2e.customer=1, 
     * the tag of a tagged packet arriving at egress is used to
     * determine STP state, tag stripping and classification.
     * Untagged packets will use a native VID and default PCP
     * from the ETE.
     * When ep2e.customer=0, any tags on the packet are ignored
     * by egress processing, and the PCP is always computed from
     * the remark table lookup.
     */
    uint32 customer;
    /**
     * do not strip the ERH.  This flag can be used when
     * the FE is connected to a third party device (e.g. an FPGA)
     * that requires information from the ERH, such as the packet
     * length
     */
    uint32 keeperh;
    /**
     * Microcode port number (for LRP use).  This field is
     * read-only.
     */
    uint32 port;
    /**
     * egress mirror index; unlike ingress mirroring, egress
     * mirroring selects one of 16 FE hardware mirrors; on the
     * BCM88020, to direct an egress mirrored flow some place
     * other than a port on the local FE, an unused port
     * must be put into loopback mode, and the ingress
     * packet processing configured to direct all looped
     * packets to the mirror port or tunnel; the BCM88025
     * supports arbitrary forwarding of hardware mirrored
     * traffic so using port loopback is not necessary
     */
    uint32 mirroridx;
    /** HIDE */
    soc_sbx_g2xx_8_byte_t mask;
    /**
     * enable 802.3 link OAM loopback mode.
     * When oamloop=1, all ingress packets are sent to the
     * exception stream with a PPE trap code indicating the port
     * is in link loopback mode.  The ingress exception
     * stream microcode will loop back all packets except
     * L2CP slow protocol packets which will be sent to
     * the CPU as exceptions.  When oamloop=1, egress L2CP slow
     * protocol packets are forwarded normally, and all other
     * packets are sent to the egress exception stream with
     * a PPE trap code indicating the port is in link loopback
     * mode.  The egress exception microcode will drop all
     * link loopback packets.
     */
    uint32 oamloop;
    /** enable PBB fast-path fowarding on a port */
    uint32 pbb;
    /** HIDE */
    uint32 state;
    /** HIDE */
    uint32 htype;
} soc_sbx_g2xx_ep2e_t;

    /** p2e20 entry contents. */
typedef struct soc_sbx_g2xx_p2e20_s {
    /**
     * Microcode port number (for LRP use).  This field is
     * read-only.
     */
    uint32 port;
    /** default (native) VID for untagged packets */
    uint32 nativevid;
    /** default CFI for untagged packets */
    uint32 defcfi;
    /** default Ethernet priority for untagged packets */
    uint32 defpri;
    /**
     * strip VLAN tags unless overriden by
     * pv[v]2e.keeporstrip.  This flag is typically set for
     * both customer and provider ports for 802.1 provider bridging
     * forwarding (where a customer tag is transported from a
     * customer port, through a provider network).  This flag is
     * cleared for other cases, such as traditional 802.1
     * bridging, and VLAN cross-connect (e.g. TR-101-style
     * 2 tag service identification).
     */
    uint32 defstrip;
    /**
     * always strip the outer VLAN tag.
     * This flag is set only for provider bridging provider
     * ports.  pstrip=1 ensures the STAG is always stripped and
     * the CTAG is forwarded transparently.
     */
    uint32 pstrip;
    /**
     * PBB mode information.
     * This flag is set only for provider backbone bridging 
     * ports.  mim=0 means PBB is not enabled on this port.
     * The non-zero values are (tdb).
     */
    uint32 mim;
    /** HIDE */
    soc_sbx_g2xx_8_byte_t mask;
    /**
     * parse at most one CTPID tag on a packet.  Must not be set
     * concurrently with p2e.provider.  If both p2e.customer and
     * p2e.provider
     * are 0, all VLAN tags will be processed completely
     * transparently (i.e. ignored), similarly to a non
     * VLAN-capable switch.  This transparent mode is typically
     * not used for normal system operation, but is
     * useful for testing purpose.
     */
    uint32 customer;
    /**
     * parse at most once STPID tag, possibly with a CTPID tag
     * beneath it, on a packet.  The STPID (either STPID0 or
     * STPID1) is selected based on p2e.stpid1.  p2e.provider
     * not be set concurrently with p2e.customer.  If both
     * p2e.customer and p2e.provider
     * are 0, all VLAN tags will be processed completely
     * transparently (i.e. ignored), similarly to a non
     * VLAN-capable switch.  This transparent mode is typically
     * not used for normal system operation, but is
     * useful for testing purpose.
     */
    uint32 provider;
    /**
     * enable 802.3 link OAM loopback mode.
     * When oamloop=1, all ingress packets are sent to the
     * exception stream with a PPE trap code indicating the port
     * is in link loopback mode.  The ingress exception
     * stream microcode will loop back all packets except
     * L2CP slow protocol packets which will be sent to
     * the CPU as exceptions.  When oamloop=1, egress L2CP slow
     * protocol packets are forwarded normally, and all other
     * packets are sent to the egress exception stream with
     * a PPE trap code indicating the port is in link loopback
     * mode.  The egress exception microcode will drop all
     * link loopback packets.
     */
    uint32 oamloop;
    /** use STPID1 for provider-mode tag parsing. */
    uint32 stpid1;
    /**
     * enable an additional STPID for provider-mode tag parsing.
     * If p2e.twintpid=1, a provider tag can either be preceded
     * by the configured STPID (0 or 1, depending on p2e.stpid1), 
     * or by a third STPID value (STPID2).  This allows a single
     * port to concurrently support two different STPID
     * conventions for interworking scenarios.
     */
    uint32 twintpid;
    /** enable PBB fast-path fowarding on a port */
    uint32 pbb;
    /** enable IP multicast fast-path fowarding on a port */
    uint32 ipv4mc;
    /** HIDE */
    uint32 state;
    /**
     * Microcode port number (for PPE parsing use).  This field is
     * read-only.  It is used for behavior such as matching
     * per-port local station addresses.
     */
    uint32 pport;
    /** HIDE */
    uint32 htype;
} soc_sbx_g2xx_p2e20_t;

    /** ep2e20 entry contents. */
typedef struct soc_sbx_g2xx_ep2e20_s {
    /**
     * PBB mode information.
     * This flag is set only for provider backbone bridging 
     * ports.  mim=0 means PBB is not enabled on this port.
     * The non-zero values are (tdb).
     */
    uint32 mim;
    /**
     * egress port id.  This value is used to perform
     * split-horizon packet dropping in cases where the ETE
     * does not contain an ETE-specific PID value.
     */
    uint32 pid;
    /** use STPID0 for STAGs. */
    uint32 stpid0;
    /** use STPID1 for STAGs. */
    uint32 stpid1;
    /**
     * enable provider bridging customer port egress CTAG
     * processing.  This bit should be set on provider bridging
     * customer ports (but not on ports operating in any other role
     * such as `traditional' 802.1 bridging ports, provider
     * bridging provider ports, transparent mux/demux ports, or
     * TR-101-style crossconnect ports).  When ep2e.customer=1, 
     * the tag of a tagged packet arriving at egress is used to
     * determine STP state, tag stripping and classification.
     * Untagged packets will use a native VID and default PCP
     * from the ETE.
     * When ep2e.customer=0, any tags on the packet are ignored
     * by egress processing, and the PCP is always computed from
     * the remark table lookup.
     */
    uint32 customer;
    /**
     * do not strip the ERH.  This flag can be used when
     * the FE is connected to a third party device (e.g. an FPGA)
     * that requires information from the ERH, such as the packet
     * length
     */
    uint32 keeperh;
    /**
     * Microcode port number (for LRP use).  This field is
     * read-only.
     */
    uint32 port;
    /**
     * egress mirror index; unlike ingress mirroring, egress
     * mirroring selects one of 16 FE hardware mirrors; on the
     * BCM88020, to direct an egress mirrored flow some place
     * other than a port on the local FE, an unused port
     * must be put into loopback mode, and the ingress
     * packet processing configured to direct all looped
     * packets to the mirror port or tunnel; the BCM88025
     * supports arbitrary forwarding of hardware mirrored
     * traffic so using port loopback is not necessary
     */
    uint32 mirroridx;
    /** HIDE */
    soc_sbx_g2xx_8_byte_t mask;
    /**
     * enable 802.3 link OAM loopback mode.
     * When oamloop=1, all ingress packets are sent to the
     * exception stream with a PPE trap code indicating the port
     * is in link loopback mode.  The ingress exception
     * stream microcode will loop back all packets except
     * L2CP slow protocol packets which will be sent to
     * the CPU as exceptions.  When oamloop=1, egress L2CP slow
     * protocol packets are forwarded normally, and all other
     * packets are sent to the egress exception stream with
     * a PPE trap code indicating the port is in link loopback
     * mode.  The egress exception microcode will drop all
     * link loopback packets.
     */
    uint32 oamloop;
    /** enable PBB fast-path fowarding on a port */
    uint32 pbb;
    /** HIDE */
    uint32 state;
    /** HIDE */
    uint32 htype;
} soc_sbx_g2xx_ep2e20_t;

    /** p2e25 entry contents. */
typedef struct soc_sbx_g2xx_p2e25_s {
    /**
     * Microcode port number (for LRP use).  This field is
     * read-only.
     */
    uint32 port;
    /** default (native) VID for untagged packets */
    uint32 nativevid;
    /** default CFI for untagged packets */
    uint32 defcfi;
    /** default Ethernet priority for untagged packets */
    uint32 defpri;
    /**
     * strip VLAN tags unless overriden by
     * pv[v]2e.keeporstrip.  This flag is typically set for
     * both customer and provider ports for 802.1 provider bridging
     * forwarding (where a customer tag is transported from a
     * customer port, through a provider network).  This flag is
     * cleared for other cases, such as traditional 802.1
     * bridging, and VLAN cross-connect (e.g. TR-101-style
     * 2 tag service identification).
     */
    uint32 defstrip;
    /**
     * always strip the outer VLAN tag.
     * This flag is set only for provider bridging provider
     * ports.  pstrip=1 ensures the STAG is always stripped and
     * the CTAG is forwarded transparently.
     */
    uint32 pstrip;
    /**
     * PBB mode information.
     * This flag is set only for provider backbone bridging 
     * ports.  mim=0 means PBB is not enabled on this port.
     * The non-zero values are (tdb).
     */
    uint32 mim;
    /** HIDE */
    soc_sbx_g2xx_8_byte_t mask;
    /**
     * parse at most one CTPID tag on a packet.  Must not be set
     * concurrently with p2e.provider.  If both p2e.customer and
     * p2e.provider
     * are 0, all VLAN tags will be processed completely
     * transparently (i.e. ignored), similarly to a non
     * VLAN-capable switch.  This transparent mode is typically
     * not used for normal system operation, but is
     * useful for testing purpose.
     */
    uint32 customer;
    /**
     * parse at most once STPID tag, possibly with a CTPID tag
     * beneath it, on a packet.  The STPID (either STPID0 or
     * STPID1) is selected based on p2e.stpid1.  p2e.provider
     * not be set concurrently with p2e.customer.  If both
     * p2e.customer and p2e.provider
     * are 0, all VLAN tags will be processed completely
     * transparently (i.e. ignored), similarly to a non
     * VLAN-capable switch.  This transparent mode is typically
     * not used for normal system operation, but is
     * useful for testing purpose.
     */
    uint32 provider;
    /**
     * enable 802.3 link OAM loopback mode.
     * When oamloop=1, all ingress packets are sent to the
     * exception stream with a PPE trap code indicating the port
     * is in link loopback mode.  The ingress exception
     * stream microcode will loop back all packets except
     * L2CP slow protocol packets which will be sent to
     * the CPU as exceptions.  When oamloop=1, egress L2CP slow
     * protocol packets are forwarded normally, and all other
     * packets are sent to the egress exception stream with
     * a PPE trap code indicating the port is in link loopback
     * mode.  The egress exception microcode will drop all
     * link loopback packets.
     */
    uint32 oamloop;
    /** use STPID1 for provider-mode tag parsing. */
    uint32 stpid1;
    /**
     * enable an additional STPID for provider-mode tag parsing.
     * If p2e.twintpid=1, a provider tag can either be preceded
     * by the configured STPID (0 or 1, depending on p2e.stpid1), 
     * or by a third STPID value (STPID2).  This allows a single
     * port to concurrently support two different STPID
     * conventions for interworking scenarios.
     */
    uint32 twintpid;
    /** enable PBB fast-path fowarding on a port */
    uint32 pbb;
    /** enable IP multicast fast-path fowarding on a port */
    uint32 ipv4mc;
    /** HIDE */
    uint32 state;
    /**
     * Microcode port number (for PPE parsing use).  This field is
     * read-only.  It is used for behavior such as matching
     * per-port local station addresses.
     */
    uint32 pport;
    /** HIDE */
    uint32 htype;
} soc_sbx_g2xx_p2e25_t;

    /** ep2e25 entry contents. */
typedef struct soc_sbx_g2xx_ep2e25_s {
    /**
     * PBB mode information.
     * This flag is set only for provider backbone bridging 
     * ports.  mim=0 means PBB is not enabled on this port.
     * The non-zero values are (tdb).
     */
    uint32 mim;
    /**
     * egress port id.  This value is used to perform
     * split-horizon packet dropping in cases where the ETE
     * does not contain an ETE-specific PID value.
     */
    uint32 pid;
    /** use STPID0 for STAGs. */
    uint32 stpid0;
    /** use STPID1 for STAGs. */
    uint32 stpid1;
    /**
     * enable provider bridging customer port egress CTAG
     * processing.  This bit should be set on provider bridging
     * customer ports (but not on ports operating in any other role
     * such as `traditional' 802.1 bridging ports, provider
     * bridging provider ports, transparent mux/demux ports, or
     * TR-101-style crossconnect ports).  When ep2e.customer=1, 
     * the tag of a tagged packet arriving at egress is used to
     * determine STP state, tag stripping and classification.
     * Untagged packets will use a native VID and default PCP
     * from the ETE.
     * When ep2e.customer=0, any tags on the packet are ignored
     * by egress processing, and the PCP is always computed from
     * the remark table lookup.
     */
    uint32 customer;
    /**
     * do not strip the ERH.  This flag can be used when
     * the FE is connected to a third party device (e.g. an FPGA)
     * that requires information from the ERH, such as the packet
     * length
     */
    uint32 keeperh;
    /**
     * Microcode port number (for LRP use).  This field is
     * read-only.
     */
    uint32 port;
    /**
     * egress mirror index; unlike ingress mirroring, egress
     * mirroring selects one of 16 FE hardware mirrors; on the
     * BCM88020, to direct an egress mirrored flow some place
     * other than a port on the local FE, an unused port
     * must be put into loopback mode, and the ingress
     * packet processing configured to direct all looped
     * packets to the mirror port or tunnel; the BCM88025
     * supports arbitrary forwarding of hardware mirrored
     * traffic so using port loopback is not necessary
     */
    uint32 mirroridx;
    /** HIDE */
    soc_sbx_g2xx_8_byte_t mask;
    /**
     * enable 802.3 link OAM loopback mode.
     * When oamloop=1, all ingress packets are sent to the
     * exception stream with a PPE trap code indicating the port
     * is in link loopback mode.  The ingress exception
     * stream microcode will loop back all packets except
     * L2CP slow protocol packets which will be sent to
     * the CPU as exceptions.  When oamloop=1, egress L2CP slow
     * protocol packets are forwarded normally, and all other
     * packets are sent to the egress exception stream with
     * a PPE trap code indicating the port is in link loopback
     * mode.  The egress exception microcode will drop all
     * link loopback packets.
     */
    uint32 oamloop;
    /** enable PBB fast-path fowarding on a port */
    uint32 pbb;
    /** HIDE */
    uint32 state;
    /** HIDE */
    uint32 htype;
} soc_sbx_g2xx_ep2e25_t;

    /**
     * Ingress TPID Table.
     * This table controls the TPIDs used for ingress
     * packet parsing.  There is 1 TPID for customer tags, and
     * 2 TPIDs for provider tags.  The SVID TPID is selected
     * per-port for ports in provider mode by the
     * <tt>p2e.stpid1</tt> bit.  In addition, provider-mode ports
     * can be configured to allow 2 different SVID TPIDs to
     * indicate the presence of a provider tag with the
     * <tt>p2e.twintpid</tt> bit.
     * <br><br>At present, there is no mechanism
     * to set the `twin' SVID TPID (it defaults to 0x8100), but
     * ultimately it will be set through this table.
     */
typedef struct soc_sbx_g2xx_tpid_s {
    /** TPID Ethertype value (e.g. 0x8100) */
    uint32 tpid;
} soc_sbx_g2xx_tpid_t;

    /**
     * Ingress Local Station MAC Address Table.
     * This table contains local station MAC addresses
     * that will cause the ingress PPE processing to select
     * routed
     * forwarding functions (IP, IPMC and MPLS).
     * <br><br>Local station addresses can either be global,
     * matching on any port, or port-specific, matching on a
     * single port.  If a local station should match on a set of
     * ports, it must be added to this table once for each port.
     * <br><br>Setting an entry with a MAC address of
     * <tt>0:0:0:0:0:0</tt> will delete the entry.
     */
typedef struct soc_sbx_g2xx_lsmac_s {
    /** port number to match, if useport=1 */
    uint32 port;
    /** local station MAC is port-specific */
    uint32 useport;
    /** local station MAC address */
    soc_sbx_g2xx_6_byte_t mac;
} soc_sbx_g2xx_lsmac_t;

    /**
     * Exception Table.
     * This table is shared between ingress and egress
     * processing and controls forwarding of exception packets.
     * <br><br>Exceptions fall in several different ranges:
     * <ul>
     *   <li>Exception 0 is reserved.</li>
     *   <li>Exceptions <tt>0x1-0xf</tt> are used by microcode for
     *       replication
     *       exceptions.  Replication exceptions are exceptions that
     *       can occur in addition to nominal packet forwarding.
     *       A packet can cause multiple replication exceptions,
     *       which will cause one exception packet per replication
     *       exception, in addition to the nominal packet
     *       forwarding.  Replication exceptions are not generated
     *       if nominal processing ends with an
     *       exception, <i>except</i> a learning exception may be
     *       generated if <tt>xt.learn=1.</tt></li>
     *   <li>Exceptions <tt>0x10-0x53</tt> are generated by packet
     *       checkers
     *       in the PPE hardware.  For example, SMAC=0, SMAC=DMAC,
     *       IP checksum failure, etc.  PPE checker exceptions
     *       can be individually enabled or disabled by modifying
     *       the appropriate PPE configuration registers (using
     *       the SDK bcm_switch_control_set() API.</li>
     *   <li>Exceptions <tt>0x53-MIN_FREE_EXCEPTION-1</tt> are
     *       generated by microcode.  Unlike replication exceptions,
     *       these exceptions affect the nominal packet
     *       forwarding.</li>
     *   <li>Exceptions <tt>MIN_FREE_EXCEPTION-MAX_FREE_EXCEPTION
     *       </tt> are available for the SDK to assign to
     *       any other exceptions that can be classified using
     *       nominal forwarding mechanisms.  For example, 
     *       exceptions for different types of processor-bound
     *       traffic (BGP versus OSPF versus L2CP), packet dropping
     *       causes (drop particular destination MAC entries, or
     *       control protocol traffic, or DOS traffic), and
     *       consistency checks (invalid forwarding table
     *       entries).</li>
     * </ul>
     * <br><br>The exception table is the only mechanism for
     * sending packets to the CPU.  While it is possible to
     * configure a regular forwarding table entry to a CPU queue
     * in the system, this will not result in the ERH being
     * formatted properly for the SDK to correctly interpret
     * the packet.  The SDK assumes the source port and module
     * information and exception identifier are in the ERH, which
     * will only happen if the packet is forwarded as an exception.
     * The SDK allocates a generic to-CPU exception for the
     * purposes sending general (not otherwise exceptional) traffic
     * to the CPU.
     */
typedef struct soc_sbx_g2xx_xt_s {
    /** forward the exception; forward=0 means drop */
    uint32 forward;
    /**
     * drop precedence for policer and fabric; 0: green,
     * 1: yellow, 2: red
     */
    uint32 dp;
    /** fabric queue identifier for forwarding */
    uint32 qid;
    /**
     * truncate packets to 64 bytes (actually, truncation length
     * is configured in the PED with registers); typically used for
     * learning exceptions, or other exceptions where only the
     * header of the packet is necessary.  This will reduce load
     * on the CPU PCI interface
     */
    uint32 trunc;
    /**
     * generate a learning exception even if the nominal processing
     * ends in an exception; typically used for STP drop and other
     * L2CP exception cases
     */
    uint32 learn;
    /**
     * debit the policer by 64 bytes for every packet;
     * allows policing as a function of packet rate instead of
     * packet size
     */
    uint32 ppspolice;
    /** policer to debit; policer=0 means no policer */
    uint32 policer;
} soc_sbx_g2xx_xt_t;

    /** UTG-defined generic policer entry. */
typedef struct soc_sbx_g2xx_policer_s {
    /** cbsbytes */
    uint32 cbsbytes;
    /** cirkbps */
    uint32 cirkbps;
    /** ebsbytes */
    uint32 ebsbytes;
    /** eirkbps */
    uint32 eirkbps;
    /** mode */
    uint32 mode;
    /** lenshift */
    uint32 lenshift;
    /** colorblind */
    uint32 colorblind;
    /** dropred */
    uint32 dropred;
    /** coupling */
    uint32 coupling;
    /** nodebit */
    uint32 nodebit;
} soc_sbx_g2xx_policer_t;

    /** UTG-defined generic timer entry. */
typedef struct soc_sbx_g2xx_timer_s {
    /** ms */
    uint32 ms;
    /** started */
    uint32 started;
    /** ucodereset */
    uint32 ucodereset;
    /** interrupt */
    uint32 interrupt;
} soc_sbx_g2xx_timer_t;

    /** UTG-defined generic sequence generator entry. */
typedef struct soc_sbx_g2xx_sequence_s {
    /** seqnum */
    uint32 seqnum;
} soc_sbx_g2xx_sequence_t;

/* Find a memory bank member by address */
int soc_sbx_g2xx_memory_bank_find(
                soc_sbx_g2xx_table_manager_t *tm,
                soc_sbx_g2xx_memory_desc_t *md,
                int addr, char **name, int *offset, int *iscnt);

/* Generic policer set (internal use only) */
extern int soc_sbx_g2xx_generic_policer_set(int unit,
                int pid, int policer,
                soc_sbx_g2xx_policer_t *p);

/* Generic policer get (internal use only) */
extern int soc_sbx_g2xx_generic_policer_get(int unit,
                int pid, int policer,
                soc_sbx_g2xx_policer_t *p);

/* Generic policer delete (internal use only) */
extern int soc_sbx_g2xx_generic_policer_delete(int unit, int pid, int policer);

/* Generic timer set (internal use only) */
extern int soc_sbx_g2xx_generic_timer_set(int unit,
                int pid, int timer,
                soc_sbx_g2xx_timer_t *p);

/* Generic timer get (internal use only) */
extern int soc_sbx_g2xx_generic_timer_get(int unit,
                int pid, int timer,
                soc_sbx_g2xx_timer_t *p);

/* Generic timer delete (internal use only) */
extern int soc_sbx_g2xx_generic_timer_delete(int unit, int pid, int timer);

/* Generic sequence set (internal use only) */
extern int soc_sbx_g2xx_generic_sequence_set(int unit,
                int pid, int sequence,
                soc_sbx_g2xx_sequence_t *p);

/* Generic sequence get (internal use only) */
extern int soc_sbx_g2xx_generic_sequence_get(int unit,
                int pid, int sequence,
                soc_sbx_g2xx_sequence_t *p);

/* Generic sequence delete (internal use only) */
extern int soc_sbx_g2xx_generic_sequence_delete(int unit, int pid, int sequence);

/**
 * Microcode accessor uninitialization function.
 *
 * @param[in]  unit chip unit number
 */
extern int soc_sbx_g2xx_uninit(int unit);

/**
 * Microcode accessor initialization function.
 *
 * @param[in]  unit chip unit number
 */
extern int soc_sbx_g2xx_init(int unit);

/**
 * Restore microcode push-down parameters
 *
 * Call this function after reloading microcode to restore globals and
 * table placement information that may have been updated during operation.
 *
 * @param[in]  unit chip unit number
 */
extern int soc_sbx_g2xx_reload(int unit);

/**
 * Recover microcode state from hardware.
 *
 * Call this function after warm booting microcode to restore internal state.
 * Underlying microcode access object must be recovered prior to calling.
 *
 * @param[in]  unit chip unit number
 */
extern int soc_sbx_g2xx_recover(int unit);

/**
 * Get memory parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  mid memory index (also CPU DMA memory port number)
 * @param[out] mp memory parameters
 */
extern int soc_sbx_g2xx_memory_params_get(int unit, int mid,
                soc_sbx_g2xx_memory_params_t *mp);

/**
 * Set memory size.
 *
 * Currently, the memory size is not used for anything.
 *
 * @param[in]  unit chip unit number
 * @param[in]  mid memory index (also CPU DMA memory port number)
 * @param[in]  size memory size, in words
 */
extern int soc_sbx_g2xx_memory_size_set(int unit, int mid, int size)
;

/*
 * Shared constant accessors
 */

/**
 * Get constant MIN_FREE_EXCEPTION value.
 *
 * Minimum unused exception index.
 * Exceptions between this value and <tt>MAX_FREE_EXCEPTION</tt>
 * can be used arbitrarily by software.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2xx_min_free_exception_get(int unit, uint32 *vp);

/**
 * Get constant EXC_COPY_TO_HOST value.
 *
 * Host application requested this packet be sent up.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2xx_exc_copy_to_host_get(int unit, uint32 *vp);

/**
 * Get constant MAX_FREE_EXCEPTION value.
 *
 * Maximum unused exception index.
 * Exceptions between <tt>MAX_FREE_EXCEPTION</tt> and this
 * value and can be used arbitrarily by software.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2xx_max_free_exception_get(int unit, uint32 *vp);

/**
 * Get constant HTYPE_ERH value.
 *
 * PPE/PED ERH header code.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2xx_htype_erh_get(int unit, uint32 *vp);

/**
 * Get constant HTYPE_ETYPE value.
 *
 * PPE/PED Ingress Ethertype header code.
 * Only the ingress processing splits the Ethernet header
 * and Ethertype fields.  Egress processing does not use a
 * separate Ethertype header code.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2xx_htype_etype_get(int unit, uint32 *vp);

/**
 * Get constant HTYPE_ETH value.
 *
 * HIDE
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2xx_htype_eth_get(int unit, uint32 *vp);

/**
 * Get constant HTYPE_IETH value.
 *
 * PPE/PED Ingress Ethernet header code.
 * The PPE/PED ingress Ethernet header includes only DMAC and
 * SMAC fields.  Ethertypes are parsed separately, or included
 * in <tt>HTYPE_VTAG</tt> or <tt>HTYPE_MIM</tt> headers, 
 * and 802.1 length fields are included in <tt>HTYPE_LLC</tt>
 * and <tt>HTYPE_SNAP</tt> headers.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2xx_htype_ieth_get(int unit, uint32 *vp);

/**
 * Get constant HTYPE_VTAG value.
 *
 * PPE/PED VLAN tag header code.
 * A VLAN tag header for ingress processing includes the TPID
 * and the tag information.
 * <br><br>A VLAN tag header for egress
 * processing includes the tag information and the
 * <i>following</i> Ethertype.  In addition, the egress
 * processing will only parse at most one VLAN tag.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2xx_htype_vtag_get(int unit, uint32 *vp);

/**
 * Get constant HTYPE_IPV4 value.
 *
 * PPE/PED IPv4 header code.
 * An IPv4 header includes the IP header itself, and whatever
 * options are contained within the header.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2xx_htype_ipv4_get(int unit, uint32 *vp);

/**
 * Get constant HTYPE_ELEN value.
 *
 * PED Embedded Length header code.
 * The first byte of this header is the length of the
 * remainder of the header.  This header is used by
 * egress processing to add encapsulation data to 
 * packets.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2xx_htype_elen_get(int unit, uint32 *vp);

/**
 * Get constant HTYPE_UNKN value.
 *
 * PPE/PED Unknown header code.
 * All header parsing must end with an unknown header.  This
 * header includes all remaining, unparsed data from the
 * header record.  On ingress, the unknown header marks
 * the beginning of layer-4 (TCP, UDP, etc) fields, and this
 * marking is used for assembling the IFP classification key.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2xx_htype_unkn_get(int unit, uint32 *vp);

/**
 * Get constant LSMAC_TABLE_SIZE value.
 *
 * Maximum ingress PPE local station entries.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2xx_lsmac_table_size_get(int unit, uint32 *vp);

/*
 * Global value accessors
 */

/**
 * Set global tpid0 value.
 *
 * Egress encapsulation TPID1 value (typically for CTAG)
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2xx_tpid0_set(int unit, uint32 v);

/**
 * Get global tpid0 value.
 *
 * Egress encapsulation TPID1 value (typically for CTAG)
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2xx_tpid0_get(int unit, uint32 *vp);

/**
 * Set global tpid1 value.
 *
 * Egress encapsulation TPID1 value (typically for 
 * 802.1ad SVID)
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2xx_tpid1_set(int unit, uint32 v);

/**
 * Get global tpid1 value.
 *
 * Egress encapsulation TPID1 value (typically for 
 * 802.1ad SVID)
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2xx_tpid1_get(int unit, uint32 *vp);

/**
 * Set global tpid2 value.
 *
 * Egress encapsulation TPID2 value (typically for 
 * a proprietary SVID, e.g. 0x9100 or 0x8100)
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2xx_tpid2_set(int unit, uint32 v);

/**
 * Get global tpid2 value.
 *
 * Egress encapsulation TPID2 value (typically for 
 * a proprietary SVID, e.g. 0x9100 or 0x8100)
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2xx_tpid2_get(int unit, uint32 *vp);

/**
 * Set global node value.
 *
 * SDK module identifier for an FE.
 *
 * @param[in]  unit chip unit number
 * @param[in]  v value
 */
extern int soc_sbx_g2xx_node_set(int unit, uint32 v);

/**
 * Get global node value.
 *
 * SDK module identifier for an FE.
 *
 * @param[in]  unit chip unit number
 * @param[out] vp returns value
 */
extern int soc_sbx_g2xx_node_get(int unit, uint32 *vp);

/*
 * Table state accessors
 */

/* Table state accessors for portdata20 */

/**
 * Get portdata20 table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2xx_portdata20_bank_params_get(int unit, int bank,
                soc_sbx_g2xx_table_bank_params_t *p);

/**
 * Get portdata20 table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2xx_portdata20_table_size_get(int unit);

/**
 * Set portdata20 table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2xx_portdata20_table_size_set(int unit, int size);

/* Table state accessors for portdata25 */

/**
 * Get portdata25 table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2xx_portdata25_bank_params_get(int unit, int bank,
                soc_sbx_g2xx_table_bank_params_t *p);

/**
 * Get portdata25 table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2xx_portdata25_table_size_get(int unit);

/**
 * Set portdata25 table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2xx_portdata25_table_size_set(int unit, int size);

/* Table state accessors for xt */

/**
 * Get xt table bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank bank number
 * @param[out] p returns table bank parameters
 */
extern int soc_sbx_g2xx_xt_bank_params_get(int unit, int bank,
                soc_sbx_g2xx_table_bank_params_t *p);

/**
 * Get xt table size.
 *
 * @param[in]  unit chip unit number
 * @return     table size, in bank address units
 */
extern int soc_sbx_g2xx_xt_table_size_get(int unit);

/**
 * Set xt table size.
 *
 * @param[in]  unit chip unit number
 * @param[in]  size table size, in bank address units
 */
extern int soc_sbx_g2xx_xt_table_size_set(int unit, int size);

/*
 * Entry accessors
 */

/*
 * Entry accessors for p2e
 */

/**
 * Initialize p2e entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2xx_p2e_t_init(
    soc_sbx_g2xx_p2e_t *e);

/**
 * Get p2e entry size.
 *
 * Use this function for storage management of the
 * p2e table, because its entries have variable size
 *
 * @param[in]  unit chip unit number
 * @return     entry size, in words
 */
extern int soc_sbx_g2xx_p2e_size(int unit);

/**
 * Pack p2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2xx_p2e_pack(int unit,
    soc_sbx_g2xx_p2e_t *e, uint8 *b, int bsz);

/**
 * Unpack p2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2xx_p2e_unpack(int unit,
                soc_sbx_g2xx_p2e_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2xx_p2e_index_check(int unit,
                int *vindex,
                int iport);

extern int soc_sbx_g2xx_p2e_entry_check(int unit,
                soc_sbx_g2xx_p2e_t *e);

/**
 * Synchronously set p2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iport microcode port number
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2xx_p2e_set(int unit,
                int iport,
                soc_sbx_g2xx_p2e_t *e);

extern int soc_sbx_g2xx_p2e_set_ext(int unit,
                int iport,
                soc_sbx_g2xx_p2e_t *e);

/**
 *  Get p2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iport microcode port number
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2xx_p2e_get(int unit,
                int iport,
                soc_sbx_g2xx_p2e_t *e);

extern int soc_sbx_g2xx_p2e_get_ext(int unit,
                int iport,
                soc_sbx_g2xx_p2e_t *e);

/*
 * Entry accessors for ep2e
 */

/**
 * Initialize ep2e entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2xx_ep2e_t_init(
    soc_sbx_g2xx_ep2e_t *e);

/**
 * Get ep2e entry size.
 *
 * Use this function for storage management of the
 * ep2e table, because its entries have variable size
 *
 * @param[in]  unit chip unit number
 * @return     entry size, in words
 */
extern int soc_sbx_g2xx_ep2e_size(int unit);

/**
 * Pack ep2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2xx_ep2e_pack(int unit,
    soc_sbx_g2xx_ep2e_t *e, uint8 *b, int bsz);

/**
 * Unpack ep2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2xx_ep2e_unpack(int unit,
                soc_sbx_g2xx_ep2e_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2xx_ep2e_index_check(int unit,
                int *vindex,
                int iport);

extern int soc_sbx_g2xx_ep2e_entry_check(int unit,
                soc_sbx_g2xx_ep2e_t *e);

/**
 * Synchronously set ep2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iport microcode port number
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2xx_ep2e_set(int unit,
                int iport,
                soc_sbx_g2xx_ep2e_t *e);

extern int soc_sbx_g2xx_ep2e_set_ext(int unit,
                int iport,
                soc_sbx_g2xx_ep2e_t *e);

/**
 *  Get ep2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iport microcode port number
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2xx_ep2e_get(int unit,
                int iport,
                soc_sbx_g2xx_ep2e_t *e);

extern int soc_sbx_g2xx_ep2e_get_ext(int unit,
                int iport,
                soc_sbx_g2xx_ep2e_t *e);

/*
 * Entry accessors for p2e20
 */

/**
 * Initialize p2e20 entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2xx_p2e20_t_init(
    soc_sbx_g2xx_p2e20_t *e);

/**
 * Pack p2e20 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2xx_p2e20_pack(int unit,
    soc_sbx_g2xx_p2e20_t *e, uint8 *b, int bsz);

/**
 * Unpack p2e20 entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2xx_p2e20_unpack(int unit,
                soc_sbx_g2xx_p2e20_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2xx_p2e20_index_check(int unit,
                int *vindex,
                int iport);

extern int soc_sbx_g2xx_p2e20_entry_check(int unit,
                soc_sbx_g2xx_p2e20_t *e);

/**
 * p2e20 table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of p2e20 elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  iport 
 */
extern int soc_sbx_g2xx_p2e20_entry_table_size_get(int unit,
                int *tsize,
                int iport);

/**
 * Synchronously set p2e20 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iport 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2xx_p2e20_set(int unit,
                int iport,
                soc_sbx_g2xx_p2e20_t *e);


extern int soc_sbx_g2xx_p2e20_set_hook(int unit,
                int *sset, int *key,
                int iport,
                soc_sbx_g2xx_p2e20_t *e);

/**
 *  Get p2e20 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iport 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2xx_p2e20_get(int unit,
                int iport,
                soc_sbx_g2xx_p2e20_t *e);


extern int soc_sbx_g2xx_p2e20_get_hook(int unit,
                int *sset, int *key,
                int iport);

/*
 * Entry accessors for ep2e20
 */

/**
 * Initialize ep2e20 entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2xx_ep2e20_t_init(
    soc_sbx_g2xx_ep2e20_t *e);

/**
 * Pack ep2e20 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2xx_ep2e20_pack(int unit,
    soc_sbx_g2xx_ep2e20_t *e, uint8 *b, int bsz);

/**
 * Unpack ep2e20 entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2xx_ep2e20_unpack(int unit,
                soc_sbx_g2xx_ep2e20_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2xx_ep2e20_index_check(int unit,
                int *vindex,
                int iport);

extern int soc_sbx_g2xx_ep2e20_entry_check(int unit,
                soc_sbx_g2xx_ep2e20_t *e);

/**
 * ep2e20 table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of ep2e20 elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  iport 
 */
extern int soc_sbx_g2xx_ep2e20_entry_table_size_get(int unit,
                int *tsize,
                int iport);

/**
 * Synchronously set ep2e20 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iport 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2xx_ep2e20_set(int unit,
                int iport,
                soc_sbx_g2xx_ep2e20_t *e);


extern int soc_sbx_g2xx_ep2e20_set_hook(int unit,
                int *sset, int *key,
                int iport,
                soc_sbx_g2xx_ep2e20_t *e);

/**
 *  Get ep2e20 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iport 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2xx_ep2e20_get(int unit,
                int iport,
                soc_sbx_g2xx_ep2e20_t *e);


extern int soc_sbx_g2xx_ep2e20_get_hook(int unit,
                int *sset, int *key,
                int iport);

/*
 * Entry accessors for p2e25
 */

/**
 * Initialize p2e25 entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2xx_p2e25_t_init(
    soc_sbx_g2xx_p2e25_t *e);

/**
 * Pack p2e25 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2xx_p2e25_pack(int unit,
    soc_sbx_g2xx_p2e25_t *e, uint8 *b, int bsz);

/**
 * Unpack p2e25 entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2xx_p2e25_unpack(int unit,
                soc_sbx_g2xx_p2e25_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2xx_p2e25_index_check(int unit,
                int *vindex,
                int iport);

extern int soc_sbx_g2xx_p2e25_entry_check(int unit,
                soc_sbx_g2xx_p2e25_t *e);

/**
 * p2e25 table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of p2e25 elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  iport 
 */
extern int soc_sbx_g2xx_p2e25_entry_table_size_get(int unit,
                int *tsize,
                int iport);

/**
 * Synchronously set p2e25 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iport 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2xx_p2e25_set(int unit,
                int iport,
                soc_sbx_g2xx_p2e25_t *e);


extern int soc_sbx_g2xx_p2e25_set_hook(int unit,
                int *sset, int *key,
                int iport,
                soc_sbx_g2xx_p2e25_t *e);

/**
 *  Get p2e25 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iport 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2xx_p2e25_get(int unit,
                int iport,
                soc_sbx_g2xx_p2e25_t *e);


extern int soc_sbx_g2xx_p2e25_get_hook(int unit,
                int *sset, int *key,
                int iport);

/*
 * Entry accessors for ep2e25
 */

/**
 * Initialize ep2e25 entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2xx_ep2e25_t_init(
    soc_sbx_g2xx_ep2e25_t *e);

/**
 * Pack ep2e25 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2xx_ep2e25_pack(int unit,
    soc_sbx_g2xx_ep2e25_t *e, uint8 *b, int bsz);

/**
 * Unpack ep2e25 entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2xx_ep2e25_unpack(int unit,
                soc_sbx_g2xx_ep2e25_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2xx_ep2e25_index_check(int unit,
                int *vindex,
                int iport);

extern int soc_sbx_g2xx_ep2e25_entry_check(int unit,
                soc_sbx_g2xx_ep2e25_t *e);

/**
 * ep2e25 table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of ep2e25 elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  iport 
 */
extern int soc_sbx_g2xx_ep2e25_entry_table_size_get(int unit,
                int *tsize,
                int iport);

/**
 * Synchronously set ep2e25 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iport 
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2xx_ep2e25_set(int unit,
                int iport,
                soc_sbx_g2xx_ep2e25_t *e);


extern int soc_sbx_g2xx_ep2e25_set_hook(int unit,
                int *sset, int *key,
                int iport,
                soc_sbx_g2xx_ep2e25_t *e);

/**
 *  Get ep2e25 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  iport 
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2xx_ep2e25_get(int unit,
                int iport,
                soc_sbx_g2xx_ep2e25_t *e);


extern int soc_sbx_g2xx_ep2e25_get_hook(int unit,
                int *sset, int *key,
                int iport);

/*
 * Entry accessors for tpid
 */

/**
 * Initialize tpid entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2xx_tpid_t_init(
    soc_sbx_g2xx_tpid_t *e);

/**
 * Get tpid entry size.
 *
 * Use this function for storage management of the
 * tpid table, because its entries have variable size
 *
 * @param[in]  unit chip unit number
 * @return     entry size, in words
 */
extern int soc_sbx_g2xx_tpid_size(int unit);

/**
 * Pack tpid entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2xx_tpid_pack(int unit,
    soc_sbx_g2xx_tpid_t *e, uint8 *b, int bsz);

/**
 * Unpack tpid entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2xx_tpid_unpack(int unit,
                soc_sbx_g2xx_tpid_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2xx_tpid_index_check(int unit,
                int *vindex,
                int itpidi);

extern int soc_sbx_g2xx_tpid_entry_check(int unit,
                soc_sbx_g2xx_tpid_t *e);

/**
 * Synchronously set tpid entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  itpidi TPID number;  0: CTPID, 1: STPID0, 2: STPID1
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2xx_tpid_set(int unit,
                int itpidi,
                soc_sbx_g2xx_tpid_t *e);

extern int soc_sbx_g2xx_tpid_set_ext(int unit,
                int itpidi,
                soc_sbx_g2xx_tpid_t *e);

/**
 *  Get tpid entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  itpidi TPID number;  0: CTPID, 1: STPID0, 2: STPID1
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2xx_tpid_get(int unit,
                int itpidi,
                soc_sbx_g2xx_tpid_t *e);

extern int soc_sbx_g2xx_tpid_get_ext(int unit,
                int itpidi,
                soc_sbx_g2xx_tpid_t *e);

/*
 * Entry accessors for lsmac
 */

/**
 * Initialize lsmac entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2xx_lsmac_t_init(
    soc_sbx_g2xx_lsmac_t *e);

/**
 * Get lsmac entry size.
 *
 * Use this function for storage management of the
 * lsmac table, because its entries have variable size
 *
 * @param[in]  unit chip unit number
 * @return     entry size, in words
 */
extern int soc_sbx_g2xx_lsmac_size(int unit);

/**
 * Pack lsmac entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2xx_lsmac_pack(int unit,
    soc_sbx_g2xx_lsmac_t *e, uint8 *b, int bsz);

/**
 * Unpack lsmac entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2xx_lsmac_unpack(int unit,
                soc_sbx_g2xx_lsmac_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2xx_lsmac_index_check(int unit,
                int *vindex,
                int ilsi);

extern int soc_sbx_g2xx_lsmac_entry_check(int unit,
                soc_sbx_g2xx_lsmac_t *e);

/**
 * Synchronously set lsmac entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ilsi local station MAC table entry number
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2xx_lsmac_set(int unit,
                int ilsi,
                soc_sbx_g2xx_lsmac_t *e);

extern int soc_sbx_g2xx_lsmac_set_ext(int unit,
                int ilsi,
                soc_sbx_g2xx_lsmac_t *e);

/**
 *  Get lsmac entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ilsi local station MAC table entry number
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2xx_lsmac_get(int unit,
                int ilsi,
                soc_sbx_g2xx_lsmac_t *e);

extern int soc_sbx_g2xx_lsmac_get_ext(int unit,
                int ilsi,
                soc_sbx_g2xx_lsmac_t *e);

/*
 * Entry accessors for xt
 */

/**
 * Initialize xt entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2xx_xt_t_init(
    soc_sbx_g2xx_xt_t *e);

/**
 * Pack xt entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2xx_xt_pack(int unit,
    soc_sbx_g2xx_xt_t *e, uint8 *b, int bsz);

/**
 * Unpack xt entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2xx_xt_unpack(int unit,
                soc_sbx_g2xx_xt_t *e, uint8 *b, int bsz);

extern int soc_sbx_g2xx_xt_index_check(int unit,
                int *vindex,
                int ixi);

extern int soc_sbx_g2xx_xt_entry_check(int unit,
                soc_sbx_g2xx_xt_t *e);

/**
 * xt table size get
 *
 * This function computes the size the  table must be
 * to contain the indicated number of xt elements.
 *
 * @param[in]  unit chip unit number
 * @param[out] tsize table size (bank address units; pass to table size set)
 * @param[in]  ixi exception index
 */
extern int soc_sbx_g2xx_xt_entry_table_size_get(int unit,
                int *tsize,
                int ixi);

/**
 * Synchronously set xt entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ixi exception index
 * @param[in]  e entry parameters
 */
extern int soc_sbx_g2xx_xt_set(int unit,
                int ixi,
                soc_sbx_g2xx_xt_t *e);

/**
 *  Get xt entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  ixi exception index
 * @param[out] e entry parameters
 */
extern int soc_sbx_g2xx_xt_get(int unit,
                int ixi,
                soc_sbx_g2xx_xt_t *e);

/*
 * Entry accessors for policer
 */

/**
 * Initialize policer entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2xx_policer_t_init(
    soc_sbx_g2xx_policer_t *e);

/**
 * Get policer entry size.
 *
 * Use this function for storage management of the
 * policer table, because its entries have variable size
 *
 * @param[in]  unit chip unit number
 * @return     entry size, in words
 */
extern int soc_sbx_g2xx_policer_size(int unit);

/**
 * Pack policer entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2xx_policer_pack(int unit,
    soc_sbx_g2xx_policer_t *e, uint8 *b, int bsz);

/**
 * Unpack policer entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2xx_policer_unpack(int unit,
                soc_sbx_g2xx_policer_t *e, uint8 *b, int bsz);

/*
 * Entry accessors for timer
 */

/**
 * Initialize timer entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2xx_timer_t_init(
    soc_sbx_g2xx_timer_t *e);

/**
 * Get timer entry size.
 *
 * Use this function for storage management of the
 * timer table, because its entries have variable size
 *
 * @param[in]  unit chip unit number
 * @return     entry size, in words
 */
extern int soc_sbx_g2xx_timer_size(int unit);

/**
 * Pack timer entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2xx_timer_pack(int unit,
    soc_sbx_g2xx_timer_t *e, uint8 *b, int bsz);

/**
 * Unpack timer entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2xx_timer_unpack(int unit,
                soc_sbx_g2xx_timer_t *e, uint8 *b, int bsz);

/*
 * Entry accessors for sequence
 */

/**
 * Initialize sequence entry parameters.
 *
 * @param[out] e entry parameter object
 */
extern void soc_sbx_g2xx_sequence_t_init(
    soc_sbx_g2xx_sequence_t *e);

/**
 * Get sequence entry size.
 *
 * Use this function for storage management of the
 * sequence table, because its entries have variable size
 *
 * @param[in]  unit chip unit number
 * @return     entry size, in words
 */
extern int soc_sbx_g2xx_sequence_size(int unit);

/**
 * Pack sequence entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 * @param[out] b packed byte array
 * @param[in]  bsz size of byte array
 */
extern int soc_sbx_g2xx_sequence_pack(int unit,
    soc_sbx_g2xx_sequence_t *e, uint8 *b, int bsz);

/**
 * Unpack sequence entry.
 *
 * @param[in]  unit chip unit number
 * @param[out] e entry parameters
 * @param[in]  b packed byte array
 * @param[in]  bsz size of packed byte array
 */
extern int soc_sbx_g2xx_sequence_unpack(int unit,
                soc_sbx_g2xx_sequence_t *e, uint8 *b, int bsz);

/**
 * Get counter bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank counter bank number
 * @param[out] p counter bank parameters
 */
extern int soc_sbx_g2xx_counter_bank_params_get(int unit, int bank,
                soc_sbx_g2xx_counter_bank_params_t *p);

/**
 * Get policer bank parameters.
 *
 * @param[in]  unit chip unit number
 * @param[in]  bank policer bank number
 * @param[out] p policer bank parameters
 */
extern int soc_sbx_g2xx_policer_bank_params_get(int unit, int bank,
                soc_sbx_g2xx_policer_bank_params_t *p);

/**
 * Print p2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2xx_p2e_print(int unit, 
    soc_sbx_g2xx_p2e_t *e);

/**
 * Print ep2e entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2xx_ep2e_print(int unit, 
    soc_sbx_g2xx_ep2e_t *e);

/**
 * Print p2e20 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2xx_p2e20_print(int unit, 
    soc_sbx_g2xx_p2e20_t *e);

/**
 * Print ep2e20 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2xx_ep2e20_print(int unit, 
    soc_sbx_g2xx_ep2e20_t *e);

/**
 * Print p2e25 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2xx_p2e25_print(int unit, 
    soc_sbx_g2xx_p2e25_t *e);

/**
 * Print ep2e25 entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2xx_ep2e25_print(int unit, 
    soc_sbx_g2xx_ep2e25_t *e);

/**
 * Print tpid entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2xx_tpid_print(int unit, 
    soc_sbx_g2xx_tpid_t *e);

/**
 * Print lsmac entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2xx_lsmac_print(int unit, 
    soc_sbx_g2xx_lsmac_t *e);

/**
 * Print xt entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2xx_xt_print(int unit, 
    soc_sbx_g2xx_xt_t *e);

/**
 * Print policer entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2xx_policer_print(int unit, 
    soc_sbx_g2xx_policer_t *e);

/**
 * Print timer entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2xx_timer_print(int unit, 
    soc_sbx_g2xx_timer_t *e);

/**
 * Print sequence entry.
 *
 * @param[in]  unit chip unit number
 * @param[in]  e entry parameters
 */
extern void soc_sbx_g2xx_sequence_print(int unit, 
    soc_sbx_g2xx_sequence_t *e);

/*
 * Diag shell print & set drivers
 */

/**
 * Diagnostic shell print.
 *
 * This function drives printing the state of microcode objects
 * (constants, globals, entries, memories and the memory map) based
 * on the supplied command line arguments.
 *
 * @param[in]  unit chip unit number
 * @param[in]  argc number of argument strings
 * @param[in]  argv pointer to array of argument strings
 */
extern int soc_sbx_g2xx_shell_print(int unit, int argc, char **argv);

/**
 * Diagnostic shell set.
 *
 * This function drives setting the state of microcode objects
 * (globals, entries, and memories) based
 * on the supplied command line arguments.
 *
 * @param[in]  unit chip unit number
 * @param[in]  argc number of argument strings
 * @param[in]  argv pointer to array of argument strings
 */
extern int soc_sbx_g2xx_shell_set(int unit, int argc, char **argv);

/**
 * Diagnostic shell delete.
 *
 * This function drives deleting microcode entries that support a 
 * delete operation based on the supplied command line arguments.
 *
 * @param[in]  unit chip unit number
 * @param[in]  argc number of argument strings
 * @param[in]  argv pointer to array of argument strings
 */
extern int soc_sbx_g2xx_shell_delete(int unit, int argc, char **argv);

/*
 * Diag shell usage messages
 */

/** Diagnostic shell set operation usage message */
extern char soc_sbx_g2xx_set_usage[];
/** Diagnostic shell print operation usage message */
extern char soc_sbx_g2xx_get_usage[];
/** Diagnostic shell delete operation usage message */
extern char soc_sbx_g2xx_delete_usage[];
#endif
#endif
