/*
 * $Id: c2_g2p3_mplstp_defs.c 1.107.6.3 Broadcom SDK $
 *
 *
 * $Copyright: Copyright 2011 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 * 
 *
 * g2p3_defs.c: Guadalupe2k V1.3 microcode accessor functions
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 */
#ifdef BCM_SBX_MPLSTP_SUPPORT
#include <soc/sbx/g2p3/g2p3_int.h>
#include <soc/sbx/sbx_drv.h>
#include <sal/core/libc.h>
#include <sal/appl/sal.h>
#include <soc/sbx/fe2k/sbFe2000Util.h>
#define UTG_MALLOC(x) sal_alloc((x), "utg");

/* Static symbol name for initialization */
char soc_sbx_g2p3_sym[128];

/* Only for debugging */
char *soc_sbx_g2p3_errsym;

/* Parse an integer */
int soc_sbx_g2p3_read(char *a, int range, uint32 *vp);
int soc_sbx_g2p3_read(char *a, int range, uint32 *vp)
{
    uint32 v;

    if (a[0] < '0' || '9' < a[0]) {
        return SOC_E_PARAM;
    }
    v = sal_ctoi(a, 0);
    if (0 < range && ((uint32) range) <= v) {
        return SOC_E_PARAM;
    }
    *vp = v;
    return SOC_E_NONE;
}

/* Read an arbitrarily large value from shell command arguments */
int soc_sbx_g2p3_big_value_read(uint8 *v,
                int width, int noarg0, int argc, char **argv);
int soc_sbx_g2p3_big_value_read(uint8 *v,
                int width, int noarg0, int argc, char **argv)
{
    int i, rv, vwidth, n = 0;
    int bytes = (width + 7) / 8;
    char *s, *s0;
    uint8 c;
    uint8 b[6];
    uint32 v0, v1;

    sal_memset(v, 0, bytes);
    if (noarg0) {
        s = *argv;
    } else {
        for(s = *argv; *s && *s != '='; s++);
        if (!*s) {
            if (argc < 2) {
                soc_cm_print("no value given for %s\n", *argv);
                return -1;
            }
            argv++;
            argc--;
            s = *argv;
            n++;
        } else if (*s == '=') {
            s++;
        }
    }
      
    for(s0 = s; *s0 && *s0 != '.' && *s0 != '-' && *s0 != ':'; s0++);

    if (*s0 == '.') {
        v1 = 0;
        vwidth = 0;
        c = (uint8) *s++;
        for (i = 0; i < 4; i++) {
            if (!('0' <= c && c <= '9')) {
                soc_cm_print("illegal octet in IP address %s\n", *argv);
                return -1;
            }
            v0 = 0;
            for (; '0' <= c && c <= '9'; c = (uint8) *s++) {
                v0 = v0 * 10 + (c - '0');
                if (v0 > 255) {
                    soc_cm_print("octet too large in IP address %s\n", *argv);
                    return -1;
                }
            }
            v1 = (v1 << 8) + v0;
            if (c && (i == 3 || c != '.')) {
                soc_cm_print("illegal number %s\n", *argv);
                return -1;
            }
            if (c) c = (uint8) *s++;
            if (vwidth) {
                vwidth += 8;
            } else {
                for (; ((uint32) (1 << vwidth)) <= v0; vwidth++);
            }
            if (vwidth > width) {
                soc_cm_print("number is too large %s\n", *argv);
                return -1;
            }
        }

        for (i = 0; v1 && i < bytes; i++) {
            v[i] = v1;
            v1 >>= 8;
        }
        return n + 1;
    } else if (*s0 == '-' || *s0 == ':') {
        vwidth = 0;
        c = (uint8) *s++;
        for (i = 0; i < 6; i++) {
            if (!(('0' <= c && c <= '9')
                  || ('A' <= c && c <= 'F')
                  || ('a' <= c && c <= 'f'))) {
                soc_cm_print("illegal octet in MAC address %s\n", *argv);
                return -1;
            }
            v0 = 0;
            for (;('0' <= c && c <= '9')
                 || ('A' <= c && c <= 'F')
                 || ('a' <= c && c <= 'f');
                 c = (uint8) *s++) {
                if ('0' <= c && c <= '9') {
                  c -= '0';
                } else if ('A' <= c && c <= 'F') {
                  c -= 'A' - 10;
                } else if ('a' <= c && c <= 'f') {
                  c -= 'a' - 10;
                }
                v0 = v0 * 16 + c;
                if (v0 > 255) {
                    soc_cm_print("octet too large in MAC address %s\n", *argv);
                    return -1;
                }
            }
            if (c && (i == 5 || (c != ':' && c != '-'))) {
                soc_cm_print("illegal number %s\n", *argv);
                return -1;
            }
            if (c) c = (uint8) *s++;
            if (vwidth) {
                vwidth += 8;
            } else {
                for (; ((uint32) (1 << vwidth)) <= v0; vwidth++);
            }
            if (vwidth > width) {
                soc_cm_print("number is too large %s\n", *argv);
                return -1;
            }
            b[i] = v0;
        }
        for (i = 0; i < bytes; i++) {
            v[i] = b[i];
        }
        return n + 1;
    }

    rv = soc_sbx_g2p3_read(s, -1, &v0);
    if (rv) {
        if (noarg0) {
            return 0;
        }
        soc_cm_print("illegal number %s\n", *argv);
        return -1;
    }

    for (vwidth = 0;
         ((uint32) (1 << vwidth)) <= v0 && vwidth < 32;
         vwidth++);
    if (vwidth > width) {
        soc_cm_print("number is too large %s\n", *argv);
        return -1;
    }
    if (vwidth > 8) {
        for (i = 0; v0; i++) {
            v[i] = v0;
            v0 >>= 8;
        }
        return n + 1;
    }

    for (i = 0; i < bytes; i++) {
        rv = soc_sbx_g2p3_read(s, 256, &v0);
        if (rv) {
            break;
        }
        if (v0) {
            for (vwidth = 0; ((uint32) (1 << vwidth)) <= v0; vwidth++);
            vwidth += i * 8;
        }
        if (vwidth > width) {
            soc_cm_print("number is too large %s\n", *argv);
            return -1;
        }
        v[i] = v0;
        n++;
        argv++;
        argc--;
        if (!argc) {
            break;
        }
        s = *argv;
    }
    return n;
}

/* Read a 32 bit value from shell command arguments */
int soc_sbx_g2p3_value_read(uint32 *v,
                int range, int noarg0, int argc, char **argv);
int soc_sbx_g2p3_value_read(uint32 *v,
                int range, int noarg0, int argc, char **argv)
{
    uint8 b[4];
    uint32 v0;
    int rv;

    rv = soc_sbx_g2p3_big_value_read(b, 32, noarg0, argc, argv);
    if (rv > 0) {
        v0 = b[0] | (b[1] << 8) | (b[2] << 16) | (b[3] << 24);
        if (0 < range && ((uint32) range) <= v0) {
            soc_cm_print("value 0x%x too large in %s\n", v0, *argv);
            return -1;
        }
        *v = v0;
    }
    return rv;
}

/* Print an integer */
int soc_sbx_g2p3_print(int range, uint32 v);
int soc_sbx_g2p3_print(int range, uint32 v)
{
    int d = 8;

    if (0 < range) {
      for (d = 0; d < 8; d++) {
        if (range <= (1 << (d * 4))) break;
      }
    }
    soc_cm_print("0x%0*x", d, v);
    return 2 + d;
}

/* Get a constant value */
int soc_sbx_g2p3_constant_get(int unit, char *sym, uint32 *vp);
int soc_sbx_g2p3_constant_get(int unit, char *sym, uint32 *vp)
{
    int s;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
  
    s = sbFe2000GetNamedConstant(fe->regSet, fe->ucode, sym, vp);
    if (s != 0) {
      return SOC_E_NOT_FOUND;
    }
    return SOC_E_NONE;
}

/* Set a global value into the running microcode */
int soc_sbx_g2p3_global_set(int unit, char *sym, uint32 v);
int soc_sbx_g2p3_global_set(int unit, char *sym, uint32 v)
{
    int s;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
  
    s = sbFe2000SetNamedConstant(fe->regSet, fe->ucode, sym, v);
    if (s != 0) {
      return SOC_E_NOT_FOUND;
    }
    return SOC_E_NONE;
}

/* Get a global value */
int soc_sbx_g2p3_global_get(int unit, char *sym, uint32 *vp);
int soc_sbx_g2p3_global_get(int unit, char *sym, uint32 *vp)
{
    int s;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
  
    s = sbFe2000GetNamedConstant(fe->regSet, fe->ucode, sym, vp);
    if (s != 0) {
      return SOC_E_NOT_FOUND;
    }
    return SOC_E_NONE;
}

/* Insert a bit string into a buffer */
void soc_sbx_g2p3_insert(uint8 *b,
                int bbe, int pos, int width,
                uint8 *b0, int b0be, int swab);
void soc_sbx_g2p3_insert(uint8 *b,
                int bbe, int pos, int width,
                uint8 *b0, int b0be, int swab)
{
    int c, m, binc, b0inc, off;
        
    if (bbe) {
        b -= pos / 8;
        binc = -1;
    } else {
        b += pos / 8;
        binc = 1;
    }
    if (b0be) {
        b0inc = -1;
    } else {
        b0inc = 1;
    }
    if (swab) {
        off = ((width + 7) / 8) - 1;
        if (b0be) off = -off;
        b0 += off;
        b0inc = -b0inc;
    }
    pos %= 8;

    for (c = *b0; 8 < width; c = *(b0 += b0inc), b += binc, width -= 8) {
        *b = (*b & (0xff >> (8 - pos))) | (c << pos);
        if (pos != 0)
            *(b + binc) = (*(b + binc) & (0xff << pos)) | (c >> (8 - pos));
    }

    m = ((0xff >> (8 - pos)) | (0xff << (pos + width)));
    *b = (*b & m) | ((c << pos) & ~m);
    width -= 8 - pos;
    if (width > 0)
        *(b + binc) = (*(b + binc) & (0xff << width)) 
            | ((c >> (8 - pos)) & (0xff >> (8 - width)));
}

/* OR a bit string into a buffer */
void soc_sbx_g2p3_insert_or(uint8 *b,
                int bbe, int pos, int width,
                uint8 *b0, int b0be, int swab);
void soc_sbx_g2p3_insert_or(uint8 *b,
                int bbe, int pos, int width,
                uint8 *b0, int b0be, int swab)
{
    int c, m, binc, b0inc, off;
        
    if (bbe) {
        b -= pos / 8;
        binc = -1;
    } else {
        b += pos / 8;
        binc = 1;
    }
    if (b0be) {
        b0inc = -1;
    } else {
        b0inc = 1;
    }
    if (swab) {
        off = ((width + 7) / 8) - 1;
        if (b0be) off = -off;
        b0 += off;
        b0inc = -b0inc;
    }
    pos %= 8;

    for (c = *b0; 8 < width; c = *(b0 += b0inc), b += binc , width -= 8) {
        *b |= (c << pos);
        if (pos) *(b + binc) |= (c >> (8 - pos));
    }

    m = ((0xff >> (8 - pos)) | (0xff << (pos + width)));
    *b |= (c << pos) & ~m;
    width -= 8 - pos;
    if (width > 0) *(b + binc) |= (c >> (8 - pos)) & (0xff >> (8 - width));
}

/*
 * Extract a bit string into a buffer 
 *
 * b (source) and b0 (destination) can overlap as long as b >= b0 and
 * swab == 0.  This behavior is exploited by the entry_read_write function
 */
void soc_sbx_g2p3_extract(uint8 *b,
                int bbe, int pos, int width,
                uint8 *b0, int b0be, int swab);
void soc_sbx_g2p3_extract(uint8 *b,
                int bbe, int pos, int width,
                uint8 *b0, int b0be, int swab)
{
    int c, binc, b0inc, off;
        
    if (bbe) {
        b -= pos / 8;
        binc = -1;
    } else {
        b += pos / 8;
        binc = 1;
    }
    if (b0be) {
        b0inc = -1;
    } else {
        b0inc = 1;
    }
    if (swab) {
        off = ((width + 7) / 8) - 1;
        if (b0be) off = -off;
        b0 += off;
        b0inc = -b0inc;
    }
    pos %= 8;

    for (;;b0 += b0inc, b += binc, width -= 8) {
        c = (((*b >> pos) & 0xff)
             | (pos != 0 && width > (8 - pos) ? *(b + binc) << (8 - pos) : 0));
        if (width <= 8) break;
        *b0 = c;
    }

    *b0 = c & ~(0xff << width);
}

/* Read or write an entry */
int soc_sbx_g2p3_entry_read_write(int unit, int read, int idx,
                 soc_sbx_g2p3_entry_desc_t *ed);
int soc_sbx_g2p3_entry_read_write(int unit, int read, int idx,
                 soc_sbx_g2p3_entry_desc_t *ed)
{
    int i, s, width, bytes, pos, offset, rmw, opcode;
    int mwidth = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_entry_bank_t *eb = NULL;
    soc_sbx_g2p3_table_bank_t *tb;
    soc_sbx_g2p3_memory_desc_t *md;
    uint8 buf[4] = {0, 0, 0, 0};

    bytes = 0;
    i = 0;
    rmw = 0;
    opcode = read ? SB_FE2000_DMA_OPCODE_READ : SB_FE2000_DMA_OPCODE_WRITE;
    while (i < ed->nbanks) {
        eb = &ed->banks[i];
        width = eb->width;
        tb = &td->banks[eb->tablebank];
        md = &tm->memories[tb->memory];
        mwidth = md->width;

        if (eb->width < mwidth) {
            if (ed->nbanks > 1) {
                return SOC_E_INTERNAL;
            }
            if (opcode == SB_FE2000_DMA_OPCODE_WRITE) {
                buf[0] = tm->entrydmabuf[0];
                buf[1] = tm->entrydmabuf[1];
                buf[2] = tm->entrydmabuf[2];
                buf[3] = tm->entrydmabuf[3];
                opcode = SB_FE2000_DMA_OPCODE_READ;
                rmw = 1;
            } else if (rmw) {
                pos = eb->width * (idx % (mwidth / eb->width));
                soc_sbx_g2p3_insert(tm->entrydmabuf,
                       0, pos, eb->width, buf, 0, 0);
                opcode = SB_FE2000_DMA_OPCODE_WRITE;
                rmw = 0;
            }
            width = mwidth;
        }
      
        tm->entrydmaop.opcode = opcode;
        tm->entrydmaop.words = (uint32) ((width + 31) / 32);
        tm->entrydmaop.hostAddress = 
            (uint32 *) (tm->entrydmabuf + bytes);
        offset = (uint32) 
            (tb->base + ((idx * eb->stridebits) / mwidth));
        if (md->dma) {
          tm->entrydmaop.hostBusAddress = tm->entrydmabufhba + bytes;
          tm->entrydmaop.feAddress = (uint32)
            SB_FE2000_DMA_MAKE_ADDRESS(tb->memory, offset);
          s = sbFe2000DmaRequest(fe->pDmaMgr, INT_TO_PTR(unit),
                                 &tm->entrydmaop);
          if (s) {
              return SOC_E_FAIL;
          }
        } else {
            if (opcode == SB_FE2000_DMA_OPCODE_WRITE) {
                s = sbFe2000UtilWriteIndir(fe->regSet, 1, md->descending,
                                           md->reg, offset,
                                           tm->entrydmaop.words,
                                           tm->entrydmaop.hostAddress);
            } else {
                s = sbFe2000UtilReadIndir(fe->regSet, 1, md->descending,
                                          md->reg, offset,
                                          tm->entrydmaop.words,
                                          tm->entrydmaop.hostAddress);
            }
            if (s) {
                return SOC_E_TIMEOUT;
            }
        }
        if (!rmw) {
            bytes += width / 8;
            i++;
        }
    }

    if (eb->width < mwidth && read) {
        pos = eb->width * (idx % (mwidth / eb->width));
        soc_sbx_g2p3_extract(tm->entrydmabuf,
               0, pos, eb->width, tm->entrydmabuf, 0, 0);
    }
    return SOC_E_NONE;
}

int soc_sbx_g2p3_entry_generic_fast_word_set(int unit,
                soc_sbx_g2p3_field_desc_t *fd,
                soc_sbx_g2p3_entry_desc_t *ed,
                int startvindex,
                int endvindex,
                int *sets,
                uint32 *vs);
int soc_sbx_g2p3_entry_generic_fast_word_set(int unit,
                soc_sbx_g2p3_field_desc_t *fd,
                soc_sbx_g2p3_entry_desc_t *ed,
                int startvindex,
                int endvindex,
                int *sets,
                uint32 *vs)
{
    int s, i, posbase, shift, wordoff, words, offset, addrshift, mwidth,
        v, v0, entries, wordsperentry;
    uint32 mask, *wp;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb;
    soc_sbx_g2p3_entry_bank_t *eb = NULL;
    soc_sbx_g2p3_memory_desc_t *md;

    posbase = 0;
    for (i = 0; i < ed->nbanks; i++) {
        eb = &ed->banks[i];
        if (fd->pos < posbase + eb->width) {
            break;
        }
        posbase += eb->width;
    }
    tb = &td->banks[eb->tablebank];
    md = &tm->memories[tb->memory];
    shift = (fd->pos - posbase) % 32;
    wordoff = (fd->pos - posbase) / 32;
    mwidth = md->width;

    addrshift = md->width > 32 ? 1 : 0;
    wordsperentry = (eb->width + 31) / 32;
    mask = fd->width == 32 ? 0xffffffff : (uint32) ((1 << fd->width) - 1);
    mask = ~(mask << shift);
    if (tm->behost) {
        mask = _shr_swap32(mask);
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    tm->entrydmaop.hostAddress = (uint32 *) tm->entrydmabuf;
    tm->entrydmaop.hostBusAddress = tm->entrydmabufhba;
    offset = (uint32)
        (tb->base + ((startvindex * eb->stridebits) / mwidth));
    tm->entrydmaop.feAddress = (uint32)
        SB_FE2000_DMA_MAKE_ADDRESS(tb->memory, offset);
    words = (endvindex - startvindex + 1) * wordsperentry;

    while (words) {
        tm->entrydmaop.opcode = SB_FE2000_DMA_OPCODE_READ;
        tm->entrydmaop.words = (uint32)
            (words > tm->bufsize ? tm->bufsize : words);
        s = sbFe2000DmaRequest(fe->pDmaMgr, INT_TO_PTR(unit),
                               &tm->entrydmaop);
        if (s) {
            sal_mutex_give(tm->dmabufmutex);
            return SOC_E_FAIL;
        }
        entries = tm->entrydmaop.words / wordsperentry;
        wp = (((uint32 *) tm->entrydmabuf) + wordoff);
        while (entries) {
            v = *wp;
            if (!sets || *sets++) {
                v0 = *vs << shift;
                if (tm->behost) {
                    v0 = _shr_swap32(v0);
                }
                v = ((v & mask) | v0);
                *wp = v;
            }
            wp += wordsperentry;
            vs++;
            entries--;
        }
        tm->entrydmaop.opcode = SB_FE2000_DMA_OPCODE_WRITE;
        s = sbFe2000DmaRequest(fe->pDmaMgr, INT_TO_PTR(unit),
                               &tm->entrydmaop);
        if (s) {
            sal_mutex_give(tm->dmabufmutex);
            return SOC_E_FAIL;
        }
        
        tm->entrydmaop.feAddress += tm->entrydmaop.words >> addrshift;
        words -= tm->entrydmaop.words;
    }

    sal_mutex_give(tm->dmabufmutex);
    return SOC_E_NONE;
}

int soc_sbx_g2p3_entry_generic_fast_small_set(int unit,
                soc_sbx_g2p3_field_desc_t *fd,
                soc_sbx_g2p3_entry_desc_t *ed,
                int startvindex,
                int endvindex,
                int *sets,
                uint32 *vs);
int soc_sbx_g2p3_entry_generic_fast_small_set(int unit,
                soc_sbx_g2p3_field_desc_t *fd,
                soc_sbx_g2p3_entry_desc_t *ed,
                int startvindex,
                int endvindex,
                int *sets,
                uint32 *vs)
{
    int i, s, mwidth, entriesperword, offset, fieldshift, entryshift, shift;
    int dmawords, startfringe, endfringe, burstwords, windex;
    int maxword;
    uint32 fieldmask, mask, word;
    uint32 *wp, *lastvs;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    soc_sbx_g2p3_memory_desc_t *md = &tm->memories[tb->memory];

    mwidth = md->width;
    entriesperword = 32 / eb->stridebits;

    windex = ((startvindex * eb->stridebits) / 32) % (mwidth / 32);
    dmawords = 
        ((endvindex * eb->stridebits / mwidth)
         - (startvindex * eb->stridebits / mwidth)
         + 1) * (mwidth / 32);
    offset = (uint32)
        (tb->base + (startvindex * eb->stridebits / mwidth));
    tm->entrydmaop.hostAddress = (uint32 *) tm->entrydmabuf;
    tm->entrydmaop.hostBusAddress = tm->entrydmabufhba;
    tm->entrydmaop.feAddress = (uint32)
        SB_FE2000_DMA_MAKE_ADDRESS(tb->memory, offset);
    wp = ((uint32 *) tm->entrydmabuf);

    fieldmask = (uint32) ((1 << fd->width) - 1);
    fieldshift = fd->pos % 32;
    entryshift = eb->stridebits;

    startfringe = startvindex % entriesperword;
    endfringe = 0;
    lastvs = &vs[endvindex - startvindex + 1];

    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    while (vs != lastvs) {
        burstwords = dmawords;
        if (burstwords > tm->bufsize) {
            burstwords = tm->bufsize;
        }
        tm->entrydmaop.opcode = SB_FE2000_DMA_OPCODE_READ;
        tm->entrydmaop.words = burstwords;
        s = sbFe2000DmaRequest(fe->pDmaMgr, INT_TO_PTR(unit),
                               &tm->entrydmaop);
        if (s) {
            sal_mutex_give(tm->dmabufmutex);
            return SOC_E_FAIL;
        }

        if (startfringe) {
            mask = 0;
            word = 0;
            shift = fieldshift + entryshift * startfringe;
            while (startfringe < entriesperword && vs != lastvs) {
                if (!sets || *sets++) {
                    word |= *vs << shift;
                    mask |= fieldmask << shift;
                }
                vs++;
                shift += entryshift;
                startfringe++;
            }
            mask = ~mask;
            if (tm->behost) {
                mask = _shr_swap32(mask);
                word = _shr_swap32(word);
            }
            wp[windex] = (wp[windex] & mask) | word;
            windex++;
            startfringe = 0;
        }

        maxword = burstwords;
        if (burstwords == dmawords) {
            endfringe = (endvindex + 1) % entriesperword;
            if (endfringe) {
                maxword--;
            }
        }

        for (; windex < maxword; windex++) {
            word = 0;
            mask = 0;
            shift = fieldshift;
            for (i = 0; i < entriesperword; i++) {
                if (!sets || *sets++) {
                    word |= *vs << shift;
                    mask |= fieldmask << shift;
                }
                vs++;
                shift += entryshift;
            }
            mask = ~mask;
            if (tm->behost) {
                word = _shr_swap32(word);
                mask = _shr_swap32(mask);
            }
            wp[windex] = (wp[windex] & mask) | word;
        }

        if (endfringe) {
            mask = 0;
            word = 0;
            shift = fieldshift;
            while (vs != lastvs) {
                if (!sets || *sets++) {
                    mask |= fieldmask << shift;
                    word |= (*vs << shift);
                }
                vs++;
                shift += entryshift;
            }
            mask = ~mask;
            if (tm->behost) {
                mask = _shr_swap32(mask);
                word = _shr_swap32(word);
            }
            wp[windex] = (wp[windex] & mask) | word;
        }

        tm->entrydmaop.opcode = SB_FE2000_DMA_OPCODE_WRITE;
        s = sbFe2000DmaRequest(fe->pDmaMgr, INT_TO_PTR(unit),
                               &tm->entrydmaop);
        if (s) {
            sal_mutex_give(tm->dmabufmutex);
            return SOC_E_FAIL;
        }
        tm->entrydmaop.feAddress +=
            burstwords >> (mwidth > 32 ? 1 : 0);
        dmawords -= burstwords;
        windex = 0;
    }
    
    sal_mutex_give(tm->dmabufmutex);

    return SOC_E_NONE;
}

int soc_sbx_g2p3_entry_generic_fast_set(int unit,
                soc_sbx_g2p3_field_desc_t *fd,
                soc_sbx_g2p3_entry_desc_t *ed,
                int startvindex,
                int endvindex,
                int *sets,
                uint32 *vs);
int soc_sbx_g2p3_entry_generic_fast_set(int unit,
                soc_sbx_g2p3_field_desc_t *fd,
                soc_sbx_g2p3_entry_desc_t *ed,
                int startvindex,
                int endvindex,
                int *sets,
                uint32 *vs)
{
    int s;

    if (endvindex < startvindex) {
        return SOC_E_PARAM;
    }

    if (ed->banks[0].width < 32) {
        s = soc_sbx_g2p3_entry_generic_fast_small_set(unit,
                       fd, ed, startvindex, endvindex, sets, vs);
    } else {
        s = soc_sbx_g2p3_entry_generic_fast_word_set(unit,
                       fd, ed, startvindex, endvindex, sets, vs);
    }

    return s;
}

int soc_sbx_g2p3_entry_generic_fast_word_get(int unit,
                soc_sbx_g2p3_field_desc_t *fd,
                soc_sbx_g2p3_entry_desc_t *ed,
                int startvindex,
                int endvindex,
                uint32 *vs);
int soc_sbx_g2p3_entry_generic_fast_word_get(int unit,
                soc_sbx_g2p3_field_desc_t *fd,
                soc_sbx_g2p3_entry_desc_t *ed,
                int startvindex,
                int endvindex,
                uint32 *vs)
{
    int s, i, posbase, shift, wordoff, words, offset, addrshift, mwidth,
        v, entries, wordsperentry;
    uint32 mask, *wp;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb;
    soc_sbx_g2p3_entry_bank_t *eb = NULL;
    soc_sbx_g2p3_memory_desc_t *md;

    if (vs == NULL) {
        return SOC_E_PARAM;
    }

    posbase = 0;
    for (i = 0; i < ed->nbanks; i++) {
        eb = &ed->banks[i];
        if (fd->pos < posbase + eb->width) {
            break;
        }
        posbase += eb->width;
    }
    tb = &td->banks[eb->tablebank];
    md = &tm->memories[tb->memory];
    shift = (fd->pos - posbase) % 32;
    wordoff = (fd->pos - posbase) / 32;
    mwidth = md->width;

    addrshift = md->width > 32 ? 1 : 0;
    wordsperentry = (eb->width + 31) / 32;
    mask = fd->width == 32 ? 0xffffffff : (uint32) ((1 << fd->width) - 1);

    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    tm->entrydmaop.hostAddress = (uint32 *) tm->entrydmabuf;
    tm->entrydmaop.hostBusAddress = tm->entrydmabufhba;
    offset = (uint32)
        (tb->base + ((startvindex * eb->stridebits) / mwidth));
    tm->entrydmaop.feAddress = (uint32)
        SB_FE2000_DMA_MAKE_ADDRESS(tb->memory, offset);
    words = (endvindex - startvindex + 1) * wordsperentry;

    while (words) {
        tm->entrydmaop.opcode = SB_FE2000_DMA_OPCODE_READ;
        tm->entrydmaop.words = (uint32)
            (words > tm->bufsize ? tm->bufsize : words);
        s = sbFe2000DmaRequest(fe->pDmaMgr, INT_TO_PTR(unit),
                               &tm->entrydmaop);
        if (s) {
            sal_mutex_give(tm->dmabufmutex);
            return SOC_E_FAIL;
        }

        entries = tm->entrydmaop.words / wordsperentry;
        wp = (((uint32 *) tm->entrydmabuf) + wordoff);

        while (entries) {
            v = *wp;
            if (tm->behost) {
                v = _shr_swap32(v);
            }
            *vs = (v >> shift) & mask;
            wp += wordsperentry;
            vs++;
            entries--;
        }
        
        tm->entrydmaop.feAddress += tm->entrydmaop.words >> addrshift;
        words -= tm->entrydmaop.words;
    }

    sal_mutex_give(tm->dmabufmutex);
    return SOC_E_NONE;
}

int soc_sbx_g2p3_entry_generic_fast_small_get(int unit,
                soc_sbx_g2p3_field_desc_t *fd,
                soc_sbx_g2p3_entry_desc_t *ed,
                int startvindex,
                int endvindex,
                uint32 *vs);
int soc_sbx_g2p3_entry_generic_fast_small_get(int unit,
                soc_sbx_g2p3_field_desc_t *fd,
                soc_sbx_g2p3_entry_desc_t *ed,
                int startvindex,
                int endvindex,
                uint32 *vs)
{
    int i, s, mwidth, entriesperword, offset, fieldshift, entryshift, shift;
    int dmawords, startfringe, endfringe, burstwords, windex;
    int maxword;
    uint32 fieldmask, word;
    uint32 *wp, *lastvs;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    soc_sbx_g2p3_memory_desc_t *md = &tm->memories[tb->memory];

    if (vs == NULL) {
        return SOC_E_PARAM;
    }

    mwidth = md->width;
    entriesperword = 32 / eb->stridebits;

    windex = ((startvindex * eb->stridebits) / 32) % (mwidth / 32);
    dmawords = 
        ((endvindex * eb->stridebits / mwidth)
         - (startvindex * eb->stridebits / mwidth)
         + 1) * (mwidth / 32);
    offset = (uint32)
        (tb->base + (startvindex * eb->stridebits / mwidth));
    tm->entrydmaop.hostAddress = (uint32 *) tm->entrydmabuf;
    tm->entrydmaop.hostBusAddress = tm->entrydmabufhba;
    tm->entrydmaop.feAddress = (uint32)
        SB_FE2000_DMA_MAKE_ADDRESS(tb->memory, offset);
    wp = ((uint32 *) tm->entrydmabuf);

    fieldmask = (uint32) ((1 << fd->width) - 1);
    fieldshift = fd->pos % 32;
    entryshift = eb->stridebits;

    startfringe = startvindex % entriesperword;
    endfringe = 0;
    lastvs = &vs[endvindex - startvindex + 1];

    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    while (vs != lastvs) {
        burstwords = dmawords;
        if (burstwords > tm->bufsize) {
            burstwords = tm->bufsize;
        }
        tm->entrydmaop.opcode = SB_FE2000_DMA_OPCODE_READ;
        tm->entrydmaop.words = burstwords;
        s = sbFe2000DmaRequest(fe->pDmaMgr, INT_TO_PTR(unit),
                               &tm->entrydmaop);
        if (s) {
            sal_mutex_give(tm->dmabufmutex);
            return SOC_E_FAIL;
        }

        if (startfringe) {
            word = wp[windex];
            windex++;
            if (tm->behost) {
                word = _shr_swap32(word);
            }
            shift = fieldshift + entryshift * startfringe;
            while (startfringe < entriesperword && vs != lastvs) {
                *vs = (word >> shift) & fieldmask;
                vs++;
                shift += entryshift;
                startfringe++;
            }
            startfringe = 0;
        }

        maxword = burstwords;
        if (burstwords == dmawords) {
            endfringe = (endvindex + 1) % entriesperword;
            if (endfringe) {
                maxword--;
            }
        }

        for (; windex < maxword; windex++) {

            word = wp[windex];
            if (tm->behost) {
                word = _shr_swap32(word);
            }
            shift = fieldshift;
            for (i = 0; i < entriesperword; i++) {
                *vs = (word >> shift) & fieldmask;
                vs++;
                shift += entryshift;
            }
        }

        if (endfringe) {
            word = wp[windex];
            if (tm->behost) {
                word = _shr_swap32(word);
            }
            shift = fieldshift;
            while (vs != lastvs) {
                *vs = (word >> shift) & fieldmask;
                vs++;
                shift += entryshift;
            }
        }
    }
    
    sal_mutex_give(tm->dmabufmutex);

    return SOC_E_NONE;
}

int soc_sbx_g2p3_entry_generic_fast_get(int unit,
                soc_sbx_g2p3_field_desc_t *fd,
                soc_sbx_g2p3_entry_desc_t *ed,
                int startvindex,
                int endvindex,
                uint32 *vs);
int soc_sbx_g2p3_entry_generic_fast_get(int unit,
                soc_sbx_g2p3_field_desc_t *fd,
                soc_sbx_g2p3_entry_desc_t *ed,
                int startvindex,
                int endvindex,
                uint32 *vs)
{
    int s;

    if (endvindex < startvindex) {
        return SOC_E_PARAM;
    }

    if (ed->banks[0].width < 32) {
        s = soc_sbx_g2p3_entry_generic_fast_small_get(unit,
                       fd, ed, startvindex, endvindex, vs);
    } else {
        s = soc_sbx_g2p3_entry_generic_fast_word_get(unit,
                       fd, ed, startvindex, endvindex, vs);
    }

    return s;
}

/* Format a microcode package symbol (for get or set) */
void soc_sbx_g2p3_ucode_symbol_format(
                char *sym, int symlen,
                char *s0, char *s1, int d, char *s2, char *s3);
void soc_sbx_g2p3_ucode_symbol_format(
                char *sym, int symlen,
                char *s0, char *s1, int d, char *s2, char *s3)
{
    char *s;
    char c;

    if (d >= 0) {
        sal_snprintf(sym, symlen, "%s%s%s%d%s%s%s%s",
                     s0, *s0 ? "_" : s0,
                     s1, 
                     d,
                     *s2 ? "_" : s2, s2, 
                     *s3 ? "_" : s3, s3);
    } else {
        sal_snprintf(sym, symlen, "%s%s%s%s%s%s%s",
                     s0, *s0 ? "_" : s0,
                     s1, 
                     *s2 ? "_" : s2, s2, 
                     *s3 ? "_" : s3, s3);
    }

    for (s = sym; (c = *s); s++) {
        if ('a' <= c && c <= 'z') {
            *s = c - ('a' - 'A');
        }
    }
}

/* Get a symbol from the microcode package */
int soc_sbx_g2p3_ucode_get(int unit,
                char *sym, int symlen, int *v,
                char *s0, char *s1, int d, char *s2, char *s3);
int soc_sbx_g2p3_ucode_get(int unit,
                char *sym, int symlen, int *v,
                char *s0, char *s1, int d, char *s2, char *s3)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;

    soc_sbx_g2p3_ucode_symbol_format(sym, symlen, s0, s1, d, s2, s3);

    if (sbFe2000GetNamedConstant(fe->regSet, fe->ucode, sym, (uint32 *) v)) {
        return SOC_E_NOT_FOUND;
    }
    return SOC_E_NONE;
}

/* Set a symbol from the microcode package */
int soc_sbx_g2p3_ucode_set(int unit,
                char *sym, int symlen, int v,
                char *s0, char *s1, int d, char *s2, char *s3);
int soc_sbx_g2p3_ucode_set(int unit,
                char *sym, int symlen, int v,
                char *s0, char *s1, int d, char *s2, char *s3)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;

    soc_sbx_g2p3_ucode_symbol_format(sym, symlen, s0, s1, d, s2, s3);

    if (sbFe2000SetNamedConstant(fe->regSet, fe->ucode, sym, v)) {
        return SOC_E_NOT_FOUND;
    }
    return SOC_E_NONE;
}
/* Find an entry index from a name */
int soc_sbx_g2p3_index_find(
                soc_sbx_g2p3_entry_desc_t *ed, char *a);
int soc_sbx_g2p3_index_find(
                soc_sbx_g2p3_entry_desc_t *ed, char *a)
{
    int i, l;

    for (i = 0; i < ed->nindexes; i++) {
        if (!sal_strcasecmp(a, ed->indexes[i].name)) {
          return i;
        }
        l = sal_strlen(ed->indexes[i].name);
        if (!sal_strncasecmp(a, ed->indexes[i].name, l)
            && a[l] == '=') {
          return i;
      }
    }
    return -1;
}

/* Read a sequence of index arguments */
int soc_sbx_g2p3_indexes_read(void **idxs,
                soc_sbx_g2p3_entry_desc_t *ed, int argc, char **argv);
int soc_sbx_g2p3_indexes_read(void **idxs,
                soc_sbx_g2p3_entry_desc_t *ed, int argc, char **argv)
{
    int rv, i, noarg0, bytes, n = 0;
    
    for (i = 0; i < ed->nindexes; i++) {
        bytes = (ed->indexes[i].width + 7) / 8;
        if (bytes < 4) { bytes = 4; }
        sal_memset(idxs[i], 0, bytes);
    }

    while (argc) {
        i = soc_sbx_g2p3_index_find(ed, *argv);
        noarg0 = i < 0;
        if (noarg0) {
            i = 0;
            if (n != 0 || ed->nindexes != 1) {
                break;
            }
        }

        if (ed->indexes[i].width > 32) {
            rv = soc_sbx_g2p3_big_value_read(idxs[i],
                           ed->indexes[i].width, noarg0, argc, argv);
        } else {
            rv = soc_sbx_g2p3_value_read(idxs[i],
                          ed->indexes[i].range, noarg0, argc, argv);
        }
        if (rv < 0) {
            return -1;
        }
        if (rv == 0) {
            break;
        }
        n += rv;
        argc -= rv;
        argv += rv;
    }
    return n;
}

/* Print a sequence of indexes */
void soc_sbx_g2p3_indexes_print(void **indexpointers,
                soc_sbx_g2p3_entry_desc_t *ed);
void soc_sbx_g2p3_indexes_print(void **indexpointers,
                soc_sbx_g2p3_entry_desc_t *ed)
{
    int i, j;
    int bytes;

    soc_cm_print("%s[", ed->name);
    for (i = 0; i < ed->nindexes; i++) {
        soc_cm_print("%s=", ed->indexes[i].name);
        bytes = (ed->indexes[i].width + 7) / 8;
        if (bytes > 4) {
            for (j = 0; j < bytes; j++) {
                soc_cm_print("0x%02x%s",
                        ((uint8 *) indexpointers[i])[j],
                        j < bytes - 1 ? " " : "");
            }
        } else {
            soc_sbx_g2p3_print(ed->indexes[i].range,
                   *((uint32 *) indexpointers[i]));
        }
        if (i + 1 < ed->nindexes) {
            soc_cm_print(" ");
        }
    }
    soc_cm_print("]:\n");
}

/* Parse range arguments with optional flags */
int soc_sbx_g2p3_range_parse(int argc, char **argv,
                int *lower, int *upper,
                int *f0, char *f0name,
                int *f1, char *f1name,
                int *f2, char *f2name);
int soc_sbx_g2p3_range_parse(int argc, char **argv,
                int *lower, int *upper,
                int *f0, char *f0name,
                int *f1, char *f1name,
                int *f2, char *f2name)
{
    int max, rv;
    int num = 0;
    char *s;

    max = *upper + 1;
    while (argc) {
        s = argv[0];
        if (f0name && !sal_strcasecmp(s, f0name)) {
            *f0 = 1;
        } else if (f0name
                   && (s[0] == 'n' || s[0] == 'N')
                   && (s[1] == 'o' || s[1] == 'O')
                   && !sal_strcasecmp(&s[2], f0name)) {
            *f0 = 0;
        } else if (f1name && !sal_strcasecmp(s, f1name)) {
            *f1 = 1;
        } else if (f1name
                   && (s[0] == 'n' || s[0] == 'N')
                   && (s[1] == 'o' || s[1] == 'O')
                   && !sal_strcasecmp(&s[2], f1name)) {
            *f1 = 0;
        } else if (f2name && !sal_strcasecmp(s, f2name)) {
            *f2 = 1;
        } else if (f2name
                   && (s[0] == 'n' || s[0] == 'N')
                   && (s[1] == 'o' || s[1] == 'O')
                   && !sal_strcasecmp(&s[2], f2name)) {
            *f2 = 0;
        } else {
            rv = soc_sbx_g2p3_read(s, max, (uint32 *) lower);
            if (rv == SOC_E_NONE) {
                for(s = *argv; *s && *s != '-'; s++);
                if (*s) {
                    s++;
                    rv = soc_sbx_g2p3_read(s, max, (uint32 *) upper);
                    if (rv) {
                        soc_cm_print("illegal upper bound in range %s\n", s);
                        return SOC_E_FAIL;
                    }
                } else if (argc > 1) {
                    rv = soc_sbx_g2p3_read(argv[1], max, (uint32 *) &num);
                    if (rv == SOC_E_NONE) {
                        *upper = *lower + num - 1;
                        if (*upper >= max) {
                            soc_cm_print("%s overflows the legal range\n",
                                    argv[1]);
                            return SOC_E_NONE;
                        }
                        argv++;
                        argc--;
                    } else {
                        *upper = *lower;
                    }
                } else {
                    *upper = *lower;
                }
            } else {
                soc_cm_print("unexpected argument: %s\n", s);
                return SOC_E_PARAM;
            }
        }
        argv++;
        argc--;
    }
    return SOC_E_NONE;
}
/* Find an entry field from a name */
int soc_sbx_g2p3_field_find(
                soc_sbx_g2p3_entry_desc_t *ed, char *a);
int soc_sbx_g2p3_field_find(
                soc_sbx_g2p3_entry_desc_t *ed, char *a)
{
    int i, l;

    for (i = 0; i < ed->nfields; i++) {
        if (!sal_strcasecmp(a, ed->fields[i].name)) {
          return i;
        }
        l = sal_strlen(ed->fields[i].name);
        if (!sal_strncasecmp(a, ed->fields[i].name, l)
            && a[l] == '=') {
          return i;
      }
      
    }
    return -1;
}

/* Update the base of a table bank */
int soc_sbx_g2p3_table_bank_base_set(int unit,
                int tid, int bank, int base);
int soc_sbx_g2p3_table_bank_base_set(int unit,
                int tid, int bank, int base)
{
    int s;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[tid];
    char *e = "";

    td->banks[bank].base = base;
     
    s = soc_sbx_g2p3_ucode_set(unit, soc_sbx_g2p3_sym, 128,
                base, e, td->name, bank == 0 ? -1 : bank, e, "BASE");
    return s;
}

/* Update the base of a counter bank */
int soc_sbx_g2p3_counter_bank_base_set(int unit,
                int bank, int base);
int soc_sbx_g2p3_counter_bank_base_set(int unit,
                int bank, int base)
{
    int s;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_counter_bank_desc_t *cb = &tm->counterbanks[bank];
    char *e = "";

    cb->base = base;
    s = soc_sbx_g2p3_ucode_set(unit, soc_sbx_g2p3_sym, 128,
                base, e, "COUNTER_BANK", bank, e, "BASE");
    return s;
}

/* Update the base of a policer bank */
int soc_sbx_g2p3_policer_bank_base_set(int unit,
                int bank, int base);
int soc_sbx_g2p3_policer_bank_base_set(int unit,
                int bank, int base)
{
    int s, i;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_policer_bank_desc_t *pb = &tm->policerbanks[bank];
    char *e = "";

    for (i = 0; i < SOC_SBX_G2P3_POLICER_MAX_ID; i++) {
        if (tm->policers[i].bank == bank) {
            s = soc_sbx_g2p3_ucode_set(unit,
                        soc_sbx_g2p3_sym, 128,
                        base + tm->policers[i].base,
                        e, tm->policers[i].name, -1, e,
                        "BASE");
            if (s) {
                return s;
            }
        }
    }

    pb->base = base;
    s = soc_sbx_g2p3_ucode_set(unit, soc_sbx_g2p3_sym, 128,
                base, e, "POLICER_BANK", bank, e, "BASE");

    return s;
}

/* Sets a memory bank base */
int soc_sbx_g2p3_memory_bank_base_set(int unit,
                soc_sbx_g2p3_memory_bank_desc_t *mb, int base);
int soc_sbx_g2p3_memory_bank_base_set(int unit,
                soc_sbx_g2p3_memory_bank_desc_t *mb, int base)
{
    int s = SOC_E_INTERNAL;

    switch (mb->type) {
    case SOC_SBX_G2P3_TABLE_BANK_TYPE:
        s = soc_sbx_g2p3_table_bank_base_set(unit,
                      mb->number, mb->bank, base);
        break;
    case SOC_SBX_G2P3_COUNTER_BANK_TYPE:
        s = soc_sbx_g2p3_counter_bank_base_set(unit,
                      mb->number, base);
        break;
    case SOC_SBX_G2P3_POLICER_BANK_TYPE:
        s = soc_sbx_g2p3_policer_bank_base_set(unit,
                      mb->number, base);
        break;
    }

    return s;
}

/* Get the base & size of a bank in a memory */
void soc_sbx_g2p3_memory_bank_params_get(int *base, int *size,
                soc_sbx_g2p3_memory_bank_desc_t *mb,
                soc_sbx_g2p3_table_manager_t *tm);  
void soc_sbx_g2p3_memory_bank_params_get(int *base, int *size,
                soc_sbx_g2p3_memory_bank_desc_t *mb,
                soc_sbx_g2p3_table_manager_t *tm)
{
    soc_sbx_g2p3_table_bank_t *tb;

    switch (mb->type) {
    case SOC_SBX_G2P3_TABLE_BANK_TYPE:
        tb = &tm->tables[mb->number].banks[mb->bank];
        *base = tb->base;
        *size = tb->size * tb->width / tm->memories[tb->memory].width;
        break;
    case SOC_SBX_G2P3_COUNTER_BANK_TYPE:
        *base = tm->counterbanks[mb->number].base;
        *size = tm->counterbanks[mb->number].size;
        break;
    case SOC_SBX_G2P3_POLICER_BANK_TYPE:
        *base = tm->policerbanks[mb->number].base;
        *size = tm->policerbanks[mb->number].size;
        break;
    }
}

/* Pack all memory banks based on current sizes */
int soc_sbx_g2p3_memory_banks_pack(int unit);
int soc_sbx_g2p3_memory_banks_pack(int unit)
{
    int s = SOC_E_NONE;
    int i, j, base, size;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_memory_desc_t *md;
    soc_sbx_g2p3_memory_bank_desc_t *mb;

    for (i = 0; !s && i < SOC_SBX_G2P3_MEMORY_MAX_ID; i++) {
        md = &tm->memories[i];
        for (j = 0; !s && j < md->nbanks; j++) {
            mb = &md->banks[j];
            if (j) {
                soc_sbx_g2p3_memory_bank_params_get(&base, &size,
                          &md->banks[j - 1], tm);
            } else {
                base = 0;
                size = 0;
            }
            base = base + size;
            s = soc_sbx_g2p3_memory_bank_base_set(unit, mb, base);
        }
    }

    return s;
}

/* Slide the base of all banks from a starting bank in a memory */
int soc_sbx_g2p3_bank_slide(int unit,
                soc_sbx_g2p3_memory_desc_t *md,
                int mbank, int offset);
int soc_sbx_g2p3_bank_slide(int unit,
                soc_sbx_g2p3_memory_desc_t *md,
                int mbank, int offset)
{
    int s = SOC_E_NONE;
    int i, base, size;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_memory_bank_desc_t *mb;

    for (i = mbank; !s && i < md->nbanks; i++) {
        mb = &md->banks[i];
        soc_sbx_g2p3_memory_bank_params_get(&base, &size, mb, tm);
        s = soc_sbx_g2p3_memory_bank_base_set(unit, mb, base + offset);
    }

    return SOC_E_NONE;
}

/* Realign aligned table banks */
int soc_sbx_g2p3_tables_realign(int unit);
int soc_sbx_g2p3_tables_realign(int unit)
{
    int s, tid, first, i, maxbase, mbank, base, size, offset;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td;
    soc_sbx_g2p3_table_bank_t *tb;
    soc_sbx_g2p3_memory_desc_t *md;

    for (tid = tm->alignedlist; tid != -1; tid = td->nextaligned) {
        td = &tm->tables[tid];
        if (td->banks[0].size == 0) continue;
        maxbase = 0;
        first = (td->type == SOC_SBX_G2P3_LPM_TABLE_TYPE
                 || td->type == SOC_SBX_G2P3_EML_TABLE_TYPE);
        for (i = first; i < td->nbanks; i++) {
            tb = &td->banks[i];
            mbank = tb->mbank;
            md = &tm->memories[tb->memory];
            if (mbank > 0) {
                soc_sbx_g2p3_memory_bank_params_get(&base, &size,
                          &md->banks[mbank - 1], tm);
                if (maxbase < base + size) {
                    maxbase = base + size;
                }
            }
        }
        for (i = first; i < td->nbanks; i++) {
            tb = &td->banks[i];
            offset = maxbase - tb->base;
            md = &tm->memories[tb->memory];
            s = soc_sbx_g2p3_bank_slide(unit, md, tb->mbank, offset);
            if (s) {
                return s;
            }
        }
    }

    return SOC_E_NONE;
}

/* Set an entry index range from a table size */
void soc_sbx_g2p3_entry_index_ranges_set(int unit,
                soc_sbx_g2p3_entry_id_t eid);
void soc_sbx_g2p3_entry_index_ranges_set(int unit,
                soc_sbx_g2p3_entry_id_t eid)
{
    int i, j, isize, max;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed = &tm->entries[eid];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    
    i = ed->nindexes - 1;
    if (ed->table != SOC_SBX_G2P3_TABLE_MAX_ID
        && ed->type != SOC_SBX_G2P3_EXT_ENTRY_TYPE
        && ed->type != SOC_SBX_G2P3_LPM_ENTRY_TYPE
        && ed->type != SOC_SBX_G2P3_EML_ENTRY_TYPE
        && ed->type != SOC_SBX_G2P3_EM32_ENTRY_TYPE) {

        isize = (tb->size * tb->width / eb->stridebits) - 1;
        for (; 0 <= i; i--) {
            max = isize >> ed->indexes[i].pos;
            if (max) {
                ed->indexes[i].range = max + 1;
                if (i == ed->nindexes - 1) {
                    for (j = 1; 1 << j < max; j++);
                    ed->indexes[i].width = j;
                    ed->indexeswidth =
                        ed->indexes[i].pos + ed->indexes[i].width;
                }
                i--;
                break;
            } else {
                ed->indexes[i].range = 1;
            }
        }
    }
    for (; 0 <= i; i--) {
        ed->indexes[i].range = ed->indexes[i].orange;
    }
}

/* Set the size of a table */
int soc_sbx_g2p3_generic_table_size_set(int unit,
                soc_sbx_g2p3_table_id_t tid, int size, int pack);
int soc_sbx_g2p3_generic_table_size_set(int unit,
                soc_sbx_g2p3_table_id_t tid, int size, int pack)
{
    int s, i, size0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[tid];
    soc_sbx_g2p3_table_bank_t *tb;
    soc_sbx_g2p3_entry_desc_t *ed;
    char *e = "";

    if (td->type == SOC_SBX_G2P3_EM32_TABLE_TYPE) {
        if (size) {
            if (size < td->b0size) {
                return SOC_E_PARAM;
            }
            size = td->b0size;
        }
    }

    for (i = 0; i < td->nbanks; i++) {
        tb = &td->banks[i];
        size0 = (size && !i && td->b0size) ? td->b0size : size;
        tb->size = size0;
        s = soc_sbx_g2p3_ucode_set(unit,
                    soc_sbx_g2p3_sym, 128,
                    size0, e, td->name, i == 0 ? -1 : i, e,
                    "SIZE");
        if (s) {
            return s;
        }
    }

    if (pack) {
        s = soc_sbx_g2p3_memory_banks_pack(unit);
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_tables_realign(unit);
        if (s) {
            return s;
        }
    }

    for (i = 0; i < SOC_SBX_G2P3_ENTRY_MAX_ID; i++) {
        ed = &tm->entries[i];
        if (ed->table == tid) {
            soc_sbx_g2p3_entry_index_ranges_set(unit, i);
        }
    }

    return SOC_E_NONE;
}

/* Set the size of a counter */
int soc_sbx_g2p3_generic_counter_size_set(int unit,
                int cid, int size, int pack);
int soc_sbx_g2p3_generic_counter_size_set(int unit,
                int cid, int size, int pack)
{
    int s, i, offset;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_counter_desc_t *cd = &tm->counters[cid];
    int bank = cd->bank;
    int base = cd->base;
    soc_sbx_g2p3_counter_bank_desc_t *cb = &tm->counterbanks[bank];
    char *e = "";

    offset = size - cd->size;
    cb->size += offset;
    cd->size = size;
    s = soc_sbx_g2p3_ucode_set(unit,
                soc_sbx_g2p3_sym, 128,
                cd->size, e, cd->name, -1, e, "SIZE");
    if (s) {
        return s;
    }

    for (i = 0; i < SOC_SBX_G2P3_COUNTER_MAX_ID; i++) {
        cd = &tm->counters[i];
        if (cd->bank == bank && base < cd->base) {
            cd->base += offset;
            s = soc_sbx_g2p3_ucode_set(unit, soc_sbx_g2p3_sym, 128,
                        cd->base, e, cd->name, -1, e, "BASE");
            if (s) {
                return s;
            }
        }
    }

    if (pack) {
        s = soc_sbx_g2p3_memory_banks_pack(unit);
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_tables_realign(unit);
        if (s) {
            return s;
        }
    }

    return SOC_E_NONE;
}

/* Set the size of a policer */
int soc_sbx_g2p3_generic_policer_size_set(int unit,
                int pid, int size, int pack);
int soc_sbx_g2p3_generic_policer_size_set(int unit,
                int pid, int size, int pack)
{
    int s, i, offset;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_policer_desc_t *pd = &tm->policers[pid];
    int base = pd->base;
    int bank = pd->bank;
    soc_sbx_g2p3_policer_bank_desc_t *pb = &tm->policerbanks[bank];
    char *e = "";

    offset = size - pd->size;
    pb->size += offset;
    pd->size = size;
    s = soc_sbx_g2p3_ucode_set(unit,
                soc_sbx_g2p3_sym, 128,
                pd->size, e, pd->name, -1, e, "SIZE");
    if (s) {
        return s;
    }

    for (i = 0; i < SOC_SBX_G2P3_POLICER_MAX_ID; i++) {
        pd = &tm->policers[i];
        if (pd->bank == bank && base < pd->base) {
            pd->base += offset;
            s = soc_sbx_g2p3_ucode_set(unit,
                        soc_sbx_g2p3_sym, 128,
                        pb->base + pd->base, e, pd->name, -1, e,
                        "BASE");
            if (s) {
                return s;
            }
        }
    }

    if (pack) {
        s = soc_sbx_g2p3_memory_banks_pack(unit);
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_tables_realign(unit);
        if (s) {
            return s;
        }
    }

    return SOC_E_NONE;
}

void soc_sbx_g2p3_memory_bank_sort(int size,
                soc_sbx_g2p3_memory_bank_desc_t *mb,
                soc_sbx_g2p3_table_manager_t *tm);
void soc_sbx_g2p3_memory_bank_sort(int size,
                soc_sbx_g2p3_memory_bank_desc_t *mb,
                soc_sbx_g2p3_table_manager_t *tm)
{
    int i, j;
    int basea, sizea, baseb, sizeb;
    int t;

    for (i = 0; i < size; i++) {
        soc_sbx_g2p3_memory_bank_params_get(&basea, &sizea, &mb[i], tm);
        for (j = i + 1; j < size; j++) {
            soc_sbx_g2p3_memory_bank_params_get(&baseb, &sizeb, &mb[j], tm);
            if (baseb < basea) {
                t = mb[i].type;
                mb[i].type = mb[j].type;
                mb[j].type = t;
                t = mb[i].number;
                mb[i].number = mb[j].number;
                mb[j].number = t;
                t = mb[i].bank;
                mb[i].bank = mb[j].bank;
                mb[j].bank = t;
                basea = baseb;
                sizea = sizeb;
            }
        }
    }
}

void soc_sbx_g2p3_memory_banks_init(soc_sbx_g2p3_table_manager_t *tm);
void soc_sbx_g2p3_memory_banks_init(soc_sbx_g2p3_table_manager_t *tm)
{
    int i, j, k;
    int p = 0;
    soc_sbx_g2p3_memory_desc_t *md;
    soc_sbx_g2p3_memory_bank_desc_t *mb;

    for (i = 0; i < SOC_SBX_G2P3_MEMORY_MAX_ID; i++) {
        md = &tm->memories[i];
        md->banks = &tm->memorybanks[p];
        md->nbanks = 0;
        for (j = 0; j < SOC_SBX_G2P3_TABLE_MAX_ID; j++) {
            for (k = 0; k < tm->tables[j].nbanks; k++) {
                if (tm->tables[j].banks[k].memory == i) {
                    tm->memorybanks[p].type =
                        SOC_SBX_G2P3_TABLE_BANK_TYPE;
                    tm->memorybanks[p].number = j;
                    tm->memorybanks[p].bank = k;
                    p++;
                    md->nbanks++;
                }
            }
        }
        for (j = 0; j < SOC_SBX_G2P3_COUNTER_BANKS_MAX; j++) {
            if (tm->counterbanks[j].base >= 0
                && tm->counterbanks[j].memory == i) {
                tm->memorybanks[p].type =
                    SOC_SBX_G2P3_COUNTER_BANK_TYPE;
                tm->memorybanks[p].number = j;
                tm->memorybanks[p].bank = 0;
                p++;
                md->nbanks++;
            }
        }
        for (j = 0; j < SOC_SBX_G2P3_POLICER_BANKS_MAX; j++) {
            if (tm->policerbanks[j].base >= 0
                && tm->policerbanks[j].memory == i) {
                tm->memorybanks[p].type =
                    SOC_SBX_G2P3_POLICER_BANK_TYPE;
                tm->memorybanks[p].number = j;
                tm->memorybanks[p].bank = 0;
                p++;
                md->nbanks++;
            }
        }
    }

    for (i = 0; i < SOC_SBX_G2P3_MEMORY_MAX_ID; i++) {
        md = &tm->memories[i];
        soc_sbx_g2p3_memory_bank_sort(md->nbanks, md->banks, tm);
        for (j = md->nbanks - 1; 0 <= j; j--) {
            mb = &md->banks[j];
            switch (mb->type) {
            case SOC_SBX_G2P3_TABLE_BANK_TYPE:
                tm->tables[mb->number].banks[mb->bank].mbank = j;
                if (tm->tables[mb->number].nextaligned) {
                    mb->nextaligned = md->alignedlist;
                    md->alignedlist = j;
                }
                break;
            case SOC_SBX_G2P3_COUNTER_BANK_TYPE:
                tm->counterbanks[mb->number].mbank = j;
                break;
            case SOC_SBX_G2P3_POLICER_BANK_TYPE:
                tm->policerbanks[mb->number].mbank = j;
                break;
            }
        }
    }
}

/* Find a memory bank member by address */
int soc_sbx_g2p3_memory_bank_find(
                soc_sbx_g2p3_table_manager_t *tm,
                soc_sbx_g2p3_memory_desc_t *md,
                int addr, char **name, int *offset, int *iscnt)
{
    int i, base, size, offset0;
    soc_sbx_g2p3_memory_bank_desc_t *mb = NULL;
    soc_sbx_g2p3_counter_desc_t *cd = NULL;
    soc_sbx_g2p3_policer_desc_t *pd = NULL;

    for (i = 0; i < md->nbanks; i++) {
        mb = &md->banks[i];
        soc_sbx_g2p3_memory_bank_params_get(&base, &size, mb, tm);
        if (addr < base) {
            *name = NULL;
            *iscnt = 0;
            return SOC_E_NONE;
        }
        if (base <= addr && addr < base + size) {
            break;
        }
    }
    if (i == md->nbanks) {
        *name = NULL;
        *iscnt = 0;
        return SOC_E_NONE;
    }

    offset0 = addr - base;
    switch (mb->type) {
    case SOC_SBX_G2P3_TABLE_BANK_TYPE:
        *iscnt = 0;
        *name = tm->tables[mb->number].name;
        break;
    case SOC_SBX_G2P3_COUNTER_BANK_TYPE:
        *iscnt = 1;
        for (i = 0; i < SOC_SBX_G2P3_COUNTER_MAX_ID; i++) {
            cd = &tm->counters[i];
            if (cd->bank == mb->number
                && cd->base <= offset0
                && offset0 < cd->base + cd->size) {
                *name = cd->name;
                offset0 -= cd->base;
                break;
            }
        }
        if (i == SOC_SBX_G2P3_COUNTER_MAX_ID) {
            soc_cm_print("couldn't find counter info for address 0x%x\n", addr);
            return SOC_E_INTERNAL;
        }
        break;
    case SOC_SBX_G2P3_POLICER_BANK_TYPE:
        *iscnt = 0;
        for (i = 0; i < SOC_SBX_G2P3_POLICER_MAX_ID; i++) {
            pd = &tm->policers[i];
            if (pd->bank == mb->number
                && pd->base <= offset0
                && offset0 < pd->base + pd->size) {
                *name = pd->name;
                offset0 -= pd->base;
                break;
            }
        }
        if (i == SOC_SBX_G2P3_POLICER_MAX_ID) { 
            soc_cm_print("couldn't find policer info for address 0x%x\n", addr);
            return SOC_E_INTERNAL;
        }
        break;
    }
    *offset = offset0;

    return SOC_E_NONE;
}

void soc_sbx_g2p3_tables_aligned_topo_sort_walk(int unit, int tid);
void soc_sbx_g2p3_tables_aligned_topo_sort_walk(int unit, int tid)
{
    int i, first, ctid;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[tid];
    soc_sbx_g2p3_table_bank_t *tb;
    soc_sbx_g2p3_memory_desc_t *md;
    soc_sbx_g2p3_memory_bank_desc_t *mb;

    if (td->nextaligned == -2) {
        first = (td->type == SOC_SBX_G2P3_LPM_TABLE_TYPE
                 || td->type == SOC_SBX_G2P3_EML_TABLE_TYPE);
        for (i = first; i < td->nbanks; i++) {
            tb = &td->banks[i];
            md = &tm->memories[tb->memory];
            mb = &md->banks[tb->mbank];
            if (mb->nextaligned != -1) {
                ctid = md->banks[mb->nextaligned].number;
                soc_sbx_g2p3_tables_aligned_topo_sort_walk(unit, ctid);
            }
        }
        td->nextaligned = tm->alignedlist;
        tm->alignedlist = tid;
    }
}

void soc_sbx_g2p3_tables_aligned_topo_sort(int unit);
void soc_sbx_g2p3_tables_aligned_topo_sort(int unit)
{
    int i;

    for (i = 0; i < SOC_SBX_G2P3_TABLE_MAX_ID; i++) {
        soc_sbx_g2p3_tables_aligned_topo_sort_walk(unit, i);
    }
}
/*
 * Compute the bank 0 size for a complex table
 */
extern int soc_sbx_g2p3_complex_b0size_set(int unit, soc_sbx_g2p3_table_desc_t *td);
int soc_sbx_g2p3_complex_b0size_set(int unit, soc_sbx_g2p3_table_desc_t *td)
{
    char *e = "";
    int i, cbs, type, b, width;
    int s = SOC_E_NONE;


    switch (td->type) {
    case SOC_SBX_G2P3_LPM_TABLE_TYPE:
    case SOC_SBX_G2P3_EML_TABLE_TYPE:
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &width,
                    e,
                    td->name,
                    0,
                    e,
                    "CBANK_WIDTH");
        td->b0size = 1 << width;
        break;
    case SOC_SBX_G2P3_EM32_TABLE_TYPE:
        width = 0;
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &cbs,
                    e,
                    td->name,
                    -1,
                    e,
                    "CBANKS");
        for (i = 0; !s && i < cbs; i++) {
            s = soc_sbx_g2p3_ucode_get(unit,
                        soc_sbx_g2p3_sym,
                        128,
                        &type,
                        e,
                        td->name,
                        i,
                        e,
                        "CBANK_TYPE");
            if (!s && type == SOC_SBX_G2P3_KEY_COMPLEX_BANK_TYPE) {
                s = soc_sbx_g2p3_ucode_get(unit,
                            soc_sbx_g2p3_sym,
                            128,
                            &b,
                            e,
                            td->name,
                            i,
                            e,
                            "CBANK_WIDTH");
                width += b;
            }
        }
        td->b0size = 2 * (1 << (32 - width));
        break;
    }

    return s;
}

/* Generic policer set implementation */
int soc_sbx_g2p3_generic_policer_set(int unit,
                int pid, int policer,
                soc_sbx_g2p3_policer_t *p)
{
    soc_sbx_g2p3_state_t *fe =
       (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_policer_desc_t *pd =
        &tm->policers[pid];
    soc_sbx_g2p3_policer_bank_desc_t *pb =
        &tm->policerbanks[pd->bank];
    sbZfFe2000PmPolicerConfig_t pc;
    uint32 n;
    sbStatus_t s;

    if (policer >= pd->size) {
        return SOC_E_PARAM;
    }
    if (p->mode != SB_FE_2000_PM_PMODE_RFC_2697
        && p->mode != SB_FE_2000_PM_PMODE_RFC_2698
        && p->mode != SB_FE_2000_PM_PMODE_RFC_4115
        && p->mode != SB_FE_2000_PM_PMODE_RFC_MEF) {
        return SOC_E_PARAM;
    }
    if (p->lenshift > 7) {
        return SOC_E_PARAM;
    }

    sbZfFe2000PmPolicerConfig_InitInstance(&pc);
    pc.uRfcMode = p->mode;
    pc.uLenShift = p->lenshift;
    pc.uRate = sbFe2000PmConvertRate(tm->policerbanks[pd->bank].kbps);
    pc.uCBS = p->cbsbytes;
    pc.uCIR = p->cirkbps;
    pc.uEBS = p->ebsbytes;
    pc.uEIR = p->eirkbps;
    pc.bBlindMode = !!p->colorblind;
    pc.bDropOnRed = !!p->dropred;
    pc.bCoupling = !!p->coupling;
    pc.bCBSNoDecrement = !!p->nodebit;
    pc.bEBSNoDecrement = !!p->nodebit;

    n = (uint32) (policer + pb->base + pd->base - tm->policerbase);
    s = sbFe2000PmPolicerDelete(fe->pm, n);
    s = sbFe2000PmPolicerCreate(fe->pm, n, &pc, &n);

    return soc_sbx_translate_status(s);
}

/* Generic policer get implementation */
int soc_sbx_g2p3_generic_policer_get(int unit,
                int pid, int policer,
                soc_sbx_g2p3_policer_t *p)
{
    soc_sbx_g2p3_state_t *fe =
       (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_policer_desc_t *pd =
        &tm->policers[pid];
    soc_sbx_g2p3_policer_bank_desc_t *pb = &tm->policerbanks[pd->bank];
    sbZfFe2000PmPolicerConfig_t pc;
    uint32 n;
    sbStatus_t s;

    if (policer >= pd->size) {
        return SOC_E_PARAM;
    }

    n = (uint32) (policer + pb->base + pd->base - tm->policerbase);
    s = sbFe2000PmPolicerRead(fe->pm, n, &pc);

    if (!s) {
        p->mode = pc.uRfcMode;
        p->lenshift = pc.uLenShift;
        p->cbsbytes = pc.uCBS;
        p->cirkbps = pc.uCIR;
        p->ebsbytes = pc.uEBS;
        p->eirkbps = pc.uEIR;
        p->colorblind = !!pc.bBlindMode;
        p->dropred = !!pc.bDropOnRed;
        p->coupling = !!pc.bCoupling;
        p->nodebit = !!pc.bCBSNoDecrement;
    }
        
    return soc_sbx_translate_status(s);
}

/* Generic policer delete implementation */
int soc_sbx_g2p3_generic_policer_delete(int unit, int pid, int policer)
{
    soc_sbx_g2p3_state_t *fe =
       (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_policer_desc_t *pd =
        &tm->policers[pid];
    soc_sbx_g2p3_policer_bank_desc_t *pb = &tm->policerbanks[pd->bank];
    uint32 n;
    sbStatus_t s;

    if (policer >= pd->size) {
        return SOC_E_PARAM;
    }

    n = (uint32) (policer + pb->base + pd->base - tm->policerbase);
    s = sbFe2000PmPolicerDelete(fe->pm, n);
    return soc_sbx_translate_status(s);
}

/* Generic timer set implementation */
int soc_sbx_g2p3_generic_timer_set(int unit,
                int pid, int timer,
                soc_sbx_g2p3_timer_t *p)
{
    soc_sbx_g2p3_state_t *fe =
       (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_policer_desc_t *pd =
        &tm->policers[pid];
    soc_sbx_g2p3_policer_bank_desc_t *pb =
        &tm->policerbanks[pd->bank];
    sbZfFe2000PmOamTimerConfig_t tc;
    uint32 n;
    sbStatus_t s;

    if (timer >= pd->size) {
        return SOC_E_PARAM;
    }
    if (p->ms > 10 * 60 * 1000) {
        return SOC_E_PARAM;
    }

    sbZfFe2000PmOamTimerConfig_InitInstance(&tc);
    tc.uRate = sbFe2000PmConvertRate(tm->policerbanks[pd->bank].kbps);
    tc.uDeadline = p->ms;
    tc.bStarted = !!p->started;
    tc.bStrict = 0;
    tc.bReset = !!p->ucodereset;
    tc.bInterrupt = !!p->interrupt;

    n = (uint32) (timer + pb->base + pd->base - tm->policerbase);
    s = sbFe2000PmOamTimerDelete(fe->pm, n);
    s = sbFe2000PmOamTimerCreate(fe->pm, n, &tc, &n);

    return soc_sbx_translate_status(s);
}

/* Generic timer get implementation */
int soc_sbx_g2p3_generic_timer_get(int unit,
                int pid, int timer,
                soc_sbx_g2p3_timer_t *p)
{
    soc_sbx_g2p3_state_t *fe =
       (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_policer_desc_t *pd =
        &tm->policers[pid];
    soc_sbx_g2p3_policer_bank_desc_t *pb = &tm->policerbanks[pd->bank];
    sbZfFe2000PmOamTimerConfig_t tc;
    uint32 n;
    sbStatus_t s;

    if (timer >= pd->size) {
        return SOC_E_PARAM;
    }

    n = (uint32) (timer + pb->base + pd->base - tm->policerbase);
    s = sbFe2000PmOamTimerRead(fe->pm, n, &tc);

    if (!s) {
        p->ms = tc.uDeadline;
        p->started = !!tc.bStarted;
        p->ucodereset = !!tc.bReset;
        p->interrupt = !!tc.bInterrupt;
    }
        
    return soc_sbx_translate_status(s);
}

/* Generic timer delete implementation */
int soc_sbx_g2p3_generic_timer_delete(int unit, int pid, int timer)
{
    soc_sbx_g2p3_state_t *fe =
       (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_policer_desc_t *pd =
        &tm->policers[pid];
    soc_sbx_g2p3_policer_bank_desc_t *pb = &tm->policerbanks[pd->bank];
    uint32 n;
    sbStatus_t s;

    if (timer >= pd->size) {
        return SOC_E_PARAM;
    }

    n = (uint32) (timer + pb->base + pd->base - tm->policerbase);
    s = sbFe2000PmOamTimerDelete(fe->pm, n);
    return soc_sbx_translate_status(s);
}

/* Generic sequence set implementation */
int soc_sbx_g2p3_generic_sequence_set(int unit,
                int pid, int sequence,
                soc_sbx_g2p3_sequence_t *p)
{
    soc_sbx_g2p3_state_t *fe =
       (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_policer_desc_t *pd =
        &tm->policers[pid];
    soc_sbx_g2p3_policer_bank_desc_t *pb =
        &tm->policerbanks[pd->bank];
    uint32 n;
    sbStatus_t s;

    if (sequence >= pd->size) {
        return SOC_E_PARAM;
    }

    p = p;
    n = (uint32) (sequence + pb->base + pd->base - tm->policerbase);
    s = sbFe2000PmOamSeqGenDelete(fe->pm, n);
    s = sbFe2000PmOamSeqGenCreate(fe->pm, n, &n);

    return soc_sbx_translate_status(s);
}

/* Generic sequence get implementation */
int soc_sbx_g2p3_generic_sequence_get(int unit,
                int pid, int sequence,
                soc_sbx_g2p3_sequence_t *p)
{
    soc_sbx_g2p3_state_t *fe =
       (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_policer_desc_t *pd =
        &tm->policers[pid];

    if (sequence >= pd->size) {
        return SOC_E_PARAM;
    }

    p->seqnum = 0;
        
    return SOC_E_NONE;
}

/* Generic sequence delete implementation */
int soc_sbx_g2p3_generic_sequence_delete(int unit, int pid, int sequence)
{
    soc_sbx_g2p3_state_t *fe =
       (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_policer_desc_t *pd =
        &tm->policers[pid];
    soc_sbx_g2p3_policer_bank_desc_t *pb = &tm->policerbanks[pd->bank];
    uint32 n;
    sbStatus_t s;

    if (sequence >= pd->size) {
        return SOC_E_PARAM;
    }

    n = (uint32) (sequence + pb->base + pd->base - tm->policerbase);
    s = sbFe2000PmOamSeqGenDelete(fe->pm, n);
    return soc_sbx_translate_status(s);
}

/* Uninitialization function implementation */
int soc_sbx_g2p3_uninit(int unit)
{
    int i, s0;
    int s = SOC_E_NONE;

    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm;

    if (!fe->tableinfo) return s;
    tm = fe->tableinfo;
    if (tm->entrydmabuf) soc_cm_sfree(unit, tm->entrydmabuf);
    if (tm->dmabufmutex) sal_mutex_destroy(tm->dmabufmutex);
    if (tm->memorybanks) sal_free(tm->memorybanks);
    if (tm->memories)    sal_free(tm->memories);
    if (tm->policers)    sal_free(tm->policers);
    if (tm->counters)    sal_free(tm->counters);
    if (tm->entries) {
        for (i = 0; i < SOC_SBX_G2P3_ENTRY_MAX_ID; i++) {
            if (tm->entries[i].fields) {
                sal_free(tm->entries[i].fields);
            }
            if (tm->entries[i].indexes) {
                sal_free(tm->entries[i].indexes);
            }
        }
        sal_free(tm->entries);
    }
    if (tm->tables) {
        for (i = 0; i < SOC_SBX_G2P3_TABLE_MAX_ID; i++) {
            if (tm->tables[i].type == SOC_SBX_G2P3_LPM_TABLE_TYPE) {
                if (tm->tables[i].cstate) {
                    s0 = soc_sbx_g2p3_lpm_uninit_ext(unit,
                                   tm->tables[i].cstate);
                    if (!s) s = s0;
                    tm->tables[i].cstate = NULL;
                }
            }
            if (tm->tables[i].type == SOC_SBX_G2P3_EML_TABLE_TYPE) {
                if (tm->tables[i].cstate) {
                    s0 = soc_sbx_g2p3_eml_uninit_ext(unit,
                                   tm->tables[i].cstate);
                    if (!s) s = s0;
                    tm->tables[i].cstate = NULL;
                }
            }
            if (tm->tables[i].type == SOC_SBX_G2P3_EM32_TABLE_TYPE) {
                if (tm->tables[i].cstate) {
                    s0 = soc_sbx_g2p3_em32_uninit_ext(unit,
                                   tm->tables[i].cstate);
                    if (!s) s = s0;
                    tm->tables[i].cstate = NULL;
                }
            }
        }
        sal_free(tm->tables);
    }
    if (tm->globals)     sal_free(tm->globals);
    if (tm->constants)   sal_free(tm->constants);
    sal_free(tm);
    fe->tableinfo = NULL;

    return s;
}

/*
 * Microcode definitions subsystem initializer implementation
 */
int soc_sbx_g2p3_init(int unit)
{
    char *e = "";
    int i, j, pbset, s;
    uint32 v;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm;

    soc_sbx_g2p3_errsym = soc_sbx_g2p3_sym;

    if (fe->tableinfo) {
        return soc_sbx_g2p3_reload(unit);
    }

    tm = UTG_MALLOC(sizeof(soc_sbx_g2p3_table_manager_t));
    if (!tm) {
      return SOC_E_MEMORY;
    }
    sal_memset(tm, 0, sizeof(soc_sbx_g2p3_table_manager_t));
    fe->tableinfo = tm;
    fe->regSet = (sbhandle)unit;

    v = 0x1;
    tm->behost = !*((uint8 *) &v);

    /*
     * Per-constant state initialization
     */
    tm->constants = UTG_MALLOC(sizeof(soc_sbx_g2p3_constant_desc_t)
                           * SOC_SBX_G2P3_CONSTANT_MAX_ID);
    if (!tm->constants) {
      soc_sbx_g2p3_uninit(unit);
      return SOC_E_MEMORY;
    }
    tm->constants[SOC_SBX_G2P3_MAX_PORTS_ID].name =
        "max_ports";
    tm->constants[SOC_SBX_G2P3_IPV4_VRF_BITS_ID].name =
        "ipv4_vrf_bits";
    tm->constants[SOC_SBX_G2P3_EXC_IP_CHECKSUM_IDX_ID].name =
        "EXC_IP_CHECKSUM_IDX";
    tm->constants[SOC_SBX_G2P3_EXC_STP_BLOCKED_IDX_ID].name =
        "EXC_STP_BLOCKED_IDX";
    tm->constants[SOC_SBX_G2P3_EXC_SMAC_DROP_IDX_ID].name =
        "EXC_SMAC_DROP_IDX";
    tm->constants[SOC_SBX_G2P3_EXC_SMAC_UNKNOWN_IDX_ID].name =
        "EXC_SMAC_UNKNOWN_IDX";
    tm->constants[SOC_SBX_G2P3_EXC_MAC_HAIRPIN_IDX_ID].name =
        "EXC_MAC_HAIRPIN_IDX";
    tm->constants[SOC_SBX_G2P3_EXC_DMAC_DROP_IDX_ID].name =
        "EXC_DMAC_DROP_IDX";
    tm->constants[SOC_SBX_G2P3_EXC_TTL_EXPIRED_IDX_ID].name =
        "EXC_TTL_EXPIRED_IDX";
    tm->constants[SOC_SBX_G2P3_EXC_EGR_STP_BLOCKED_IDX_ID].name =
        "EXC_EGR_STP_BLOCKED_IDX";
    tm->constants[SOC_SBX_G2P3_EXC_SPLIT_IDX_ID].name =
        "EXC_SPLIT_IDX";
    tm->constants[SOC_SBX_G2P3_EXC_MTU_IDX_ID].name =
        "EXC_MTU_IDX";
    tm->constants[SOC_SBX_G2P3_EXC_OAM_MISMATCH_ID].name =
        "EXC_OAM_MISMATCH";
    tm->constants[SOC_SBX_G2P3_EXC_OAM_LEARN_ID].name =
        "EXC_OAM_LEARN";
    tm->constants[SOC_SBX_G2P3_EXC_OAM_NO_ENDPOINT_ID].name =
        "EXC_OAM_NO_ENDPOINT";
    tm->constants[SOC_SBX_G2P3_EXC_OAM_TYPE_ID].name =
        "EXC_OAM_TYPE";
    tm->constants[SOC_SBX_G2P3_EXC_OAM_RDI_ID].name =
        "EXC_OAM_RDI";
    tm->constants[SOC_SBX_G2P3_EXC_VLAN_DROP_IDX_ID].name =
        "EXC_VLAN_DROP_IDX";
    tm->constants[SOC_SBX_G2P3_EXC_V4MC_RPF_CHECK_IDX_ID].name =
        "EXC_V4MC_RPF_CHECK_IDX";
    tm->constants[SOC_SBX_G2P3_EXC_URPF_DROP_IDX_ID].name =
        "EXC_URPF_DROP_IDX";
    tm->constants[SOC_SBX_G2P3_EXC_IP_SA_DROP_IDX_ID].name =
        "EXC_IP_SA_DROP_IDX";
    tm->constants[SOC_SBX_G2P3_EXC_MIM_BAD_FORMAT_IDX_ID].name =
        "EXC_MIM_BAD_FORMAT_IDX";
    tm->constants[SOC_SBX_G2P3_EXC_ISID2E_MISS_IDX_ID].name =
        "EXC_ISID2E_MISS_IDX";
    tm->constants[SOC_SBX_G2P3_EXC_OAM_THRESHOLD_EXCEEDED_ID].name =
        "EXC_OAM_THRESHOLD_EXCEEDED";
    tm->constants[SOC_SBX_G2P3_EXC_OAM_COPY_TO_HOST_ID].name =
        "EXC_OAM_COPY_TO_HOST";
    tm->constants[SOC_SBX_G2P3_EXC_OAM_PARAM_CHANGE_ID].name =
        "EXC_OAM_PARAM_CHANGE";
    tm->constants[SOC_SBX_G2P3_EXC_BAD_OUTER_LABEL_IDX_ID].name =
        "EXC_BAD_OUTER_LABEL_IDX";
    tm->constants[SOC_SBX_G2P3_EXC_BAD_INNER_LABEL_IDX_ID].name =
        "EXC_BAD_INNER_LABEL_IDX";
    tm->constants[SOC_SBX_G2P3_EXC_LSP_PING_IDX_ID].name =
        "EXC_LSP_PING_IDX";
    tm->constants[SOC_SBX_G2P3_EXC_TOO_MANY_LABELS_IDX_ID].name =
        "EXC_TOO_MANY_LABELS_IDX";
    tm->constants[SOC_SBX_G2P3_EXC_EGR_DROP_TAGGED_IDX_ID].name =
        "EXC_EGR_DROP_TAGGED_IDX";
    tm->constants[SOC_SBX_G2P3_EXC_EGR_DROP_UNTAGGED_IDX_ID].name =
        "EXC_EGR_DROP_UNTAGGED_IDX";
    tm->constants[SOC_SBX_G2P3_EXC_EGR_OAM_LINK_IDX_ID].name =
        "EXC_EGR_OAM_LINK_IDX";
    tm->constants[SOC_SBX_G2P3_EXC_OAM_EP_INVALID_IDX_ID].name =
        "EXC_OAM_EP_INVALID_IDX";
    tm->constants[SOC_SBX_G2P3_EXC_DCN_IDX_ID].name =
        "EXC_DCN_IDX";
    tm->constants[SOC_SBX_G2P3_EXC_MPLS_FILTER_IDX_ID].name =
        "EXC_MPLS_FILTER_IDX";
    tm->constants[SOC_SBX_G2P3_EXC_MIN_FREE_EXCEPTION_ID].name =
        "EXC_MIN_FREE_EXCEPTION";
    tm->constants[SOC_SBX_G2P3_MAX_FREE_EXCEPTION_ID].name =
        "MAX_FREE_EXCEPTION";
    tm->constants[SOC_SBX_G2P3_EXC_SMAC_LEARN_IDX_ID].name =
        "EXC_SMAC_LEARN_IDX";
    tm->constants[SOC_SBX_G2P3_EXC_PIM_IDX_ID].name =
        "EXC_PIM_IDX";
    tm->constants[SOC_SBX_G2P3_EXC_IGMP_IDX_ID].name =
        "EXC_IGMP_IDX";
    tm->constants[SOC_SBX_G2P3_EXC_RT_COPY_IDX_ID].name =
        "EXC_RT_COPY_IDX";
    tm->constants[SOC_SBX_G2P3_EXC_L2CP_COPY_IDX_ID].name =
        "EXC_L2CP_COPY_IDX";
    tm->constants[SOC_SBX_G2P3_EXC_DMAC_COPY_IDX_ID].name =
        "EXC_DMAC_COPY_IDX";
    tm->constants[SOC_SBX_G2P3_EXC_IPREDIRECT_IDX_ID].name =
        "EXC_IPREDIRECT_IDX";
    tm->constants[SOC_SBX_G2P3_EXC_BMAC_LEARN_IDX_ID].name =
        "EXC_BMAC_LEARN_IDX";
    tm->constants[SOC_SBX_G2P3_EXC_COPY_MAX_IDX_ID].name =
        "EXC_COPY_MAX_IDX";
    tm->constants[SOC_SBX_G2P3_HTYPE_ERH_ID].name =
        "HTYPE_ERH";
    tm->constants[SOC_SBX_G2P3_HTYPE_ETYPE_ID].name =
        "HTYPE_ETYPE";
    tm->constants[SOC_SBX_G2P3_HTYPE_ETH_ID].name =
        "HTYPE_ETH";
    tm->constants[SOC_SBX_G2P3_HTYPE_IETH_ID].name =
        "HTYPE_IETH";
    tm->constants[SOC_SBX_G2P3_HTYPE_LLC_ID].name =
        "HTYPE_LLC";
    tm->constants[SOC_SBX_G2P3_HTYPE_SNAP_ID].name =
        "HTYPE_SNAP";
    tm->constants[SOC_SBX_G2P3_HTYPE_VTAG_ID].name =
        "HTYPE_VTAG";
    tm->constants[SOC_SBX_G2P3_HTYPE_DVTAG_ID].name =
        "HTYPE_DVTAG";
    tm->constants[SOC_SBX_G2P3_HTYPE_MPLS_ID].name =
        "HTYPE_MPLS";
    tm->constants[SOC_SBX_G2P3_HTYPE_IPV4_ID].name =
        "HTYPE_IPV4";
    tm->constants[SOC_SBX_G2P3_HTYPE_IPV6_ID].name =
        "HTYPE_IPV6";
    tm->constants[SOC_SBX_G2P3_HTYPE_ACH_ID].name =
        "HTYPE_ACH";
    tm->constants[SOC_SBX_G2P3_HTYPE_MIM_ID].name =
        "HTYPE_MIM";
    tm->constants[SOC_SBX_G2P3_HTYPE_ELEN_ID].name =
        "HTYPE_ELEN";
    tm->constants[SOC_SBX_G2P3_HTYPE_UNKN_ID].name =
        "HTYPE_UNKN";
    tm->constants[SOC_SBX_G2P3_TRAP_OAMLABELPRESENT_ID].name =
        "TRAP_OAMLABELPRESENT";
    tm->constants[SOC_SBX_G2P3_TRAP_LINKLOOPBACK_ID].name =
        "TRAP_LINKLOOPBACK";
    tm->constants[SOC_SBX_G2P3_LSMAC_TABLE_SIZE_ID].name =
        "LSMAC_TABLE_SIZE";
    tm->constants[SOC_SBX_G2P3_L2CPMAC_TABLE_SIZE_ID].name =
        "L2CPMAC_TABLE_SIZE";
    tm->constants[SOC_SBX_G2P3_OAMUPMAC_TABLE_SIZE_ID].name =
        "OAMUPMAC_TABLE_SIZE";
    tm->constants[SOC_SBX_G2P3_OAMEPREMAP_C2_TABLE_SIZE_ID].name =
        "OAMEPREMAP_C2_TABLE_SIZE";
    tm->constants[SOC_SBX_G2P3_OAMMULTIPLIER_C2_TABLE_SIZE_ID].name =
        "OAMMULTIPLIER_C2_TABLE_SIZE";
    tm->constants[SOC_SBX_G2P3_EGRCTR_CA_COUNTER_SIZE_ID].name =
        "EGRCTR_CA_COUNTER_SIZE";
    tm->constants[SOC_SBX_G2P3_MAC_CA_TABLE_SIZE_ID].name =
        "MAC_CA_TABLE_SIZE";
    tm->constants[SOC_SBX_G2P3_PTYPE_UNKNOWN_UNICAST_ID].name =
        "PTYPE_UNKNOWN_UNICAST";
    tm->constants[SOC_SBX_G2P3_PTYPE_KNOWN_UNICAST_ID].name =
        "PTYPE_KNOWN_UNICAST";
    tm->constants[SOC_SBX_G2P3_PTYPE_MULTICAST_ID].name =
        "PTYPE_MULTICAST";
    tm->constants[SOC_SBX_G2P3_PTYPE_BROADCAST_ID].name =
        "PTYPE_BROADCAST";
    tm->constants[SOC_SBX_G2P3_PTYPE_LAST_ID].name =
        "PTYPE_LAST";
    tm->constants[SOC_SBX_G2P3_CUCKOO_TYPE_PVV_ID].name =
        "CUCKOO_TYPE_PVV";
    tm->constants[SOC_SBX_G2P3_CUCKOO_TYPE_ISID_ID].name =
        "CUCKOO_TYPE_ISID";
    tm->constants[SOC_SBX_G2P3_CUCKOO_TYPE_PVD_ID].name =
        "CUCKOO_TYPE_PVD";
    tm->constants[SOC_SBX_G2P3_CUCKOO_TYPE_MAIDMEP_ID].name =
        "CUCKOO_TYPE_MAIDMEP";
    tm->constants[SOC_SBX_G2P3_CUCKOO_TYPE_SHIFT_ID].name =
        "CUCKOO_TYPE_SHIFT";
    tm->constants[SOC_SBX_G2P3_OAM_EP_SUBTYPE_CCM_ID].name =
        "OAM_EP_SUBTYPE_CCM";
    tm->constants[SOC_SBX_G2P3_OAM_EP_SUBTYPE_LM_ID].name =
        "OAM_EP_SUBTYPE_LM";
    tm->constants[SOC_SBX_G2P3_OAM_EP_SUBTYPE_DM_ID].name =
        "OAM_EP_SUBTYPE_DM";
    tm->constants[SOC_SBX_G2P3_OAM_EP_SUBTYPE_SHIFT_ID].name =
        "OAM_EP_SUBTYPE_SHIFT";
    tm->constants[SOC_SBX_G2P3_OAM_TYPE_INVALID_ID].name =
        "OAM_TYPE_INVALID";
    tm->constants[SOC_SBX_G2P3_OAM_TYPE_ENET_ID].name =
        "OAM_TYPE_ENET";
    tm->constants[SOC_SBX_G2P3_OAM_TYPE_MPLS_PWE_ID].name =
        "OAM_TYPE_MPLS_PWE";
    tm->constants[SOC_SBX_G2P3_OAM_TYPE_MPLS_LSP_ID].name =
        "OAM_TYPE_MPLS_LSP";
    tm->constants[SOC_SBX_G2P3_OAM_FUNCTION_UNUSED_ID].name =
        "OAM_FUNCTION_UNUSED";
    tm->constants[SOC_SBX_G2P3_OAM_FUNCTION_BFD_ID].name =
        "OAM_FUNCTION_BFD";
    tm->constants[SOC_SBX_G2P3_OAM_FUNCTION_LM_ID].name =
        "OAM_FUNCTION_LM";
    tm->constants[SOC_SBX_G2P3_OAM_FUNCTION_DM_ID].name =
        "OAM_FUNCTION_DM";
    tm->constants[SOC_SBX_G2P3_OAM_FUNCTION_CCM_FIRST_ID].name =
        "OAM_FUNCTION_CCM_FIRST";
    tm->constants[SOC_SBX_G2P3_OAM_FUNCTION_CCM_SECOND_ID].name =
        "OAM_FUNCTION_CCM_SECOND";
    tm->constants[SOC_SBX_G2P3_OAM_FUNCTION_CCM_PEER_ID].name =
        "OAM_FUNCTION_CCM_PEER";
    tm->constants[SOC_SBX_G2P3_OAM_FUNCTION_PSC_ID].name =
        "OAM_FUNCTION_PSC";
    tm->constants[SOC_SBX_G2P3_OAM_FUNCTION_PM_ID].name =
        "OAM_FUNCTION_PM";
    tm->constants[SOC_SBX_G2P3_OAM_FUNCTION_CCM_LOCAL_ID].name =
        "OAM_FUNCTION_CCM_LOCAL";
    tm->constants[SOC_SBX_G2P3_OAM_NUM_ENDPOINTS_ID].name =
        "OAM_NUM_ENDPOINTS";
    tm->constants[SOC_SBX_G2P3_OAM_MAX_CALENDAR_ID].name =
        "OAM_MAX_CALENDAR";
    tm->constants[SOC_SBX_G2P3_OAM_BUBBLE_TIMEOUT_ID].name =
        "OAM_BUBBLE_TIMEOUT";
    tm->constants[SOC_SBX_G2P3_OAM_LIST_MGR_SIZE_ID].name =
        "OAM_LIST_MGR_SIZE";
    tm->constants[SOC_SBX_G2P3_OAM_LIST_MGR_SIZE_CA_ID].name =
        "OAM_LIST_MGR_SIZE_CA";
    tm->constants[SOC_SBX_G2P3_OAM_BUBBLE_TIMER_ADDR_ID].name =
        "OAM_BUBBLE_TIMER_ADDR";
    tm->constants[SOC_SBX_G2P3_OAM_LIST_MGR_ADDR_ID].name =
        "OAM_LIST_MGR_ADDR";
    tm->constants[SOC_SBX_G2P3_OAM_INTERVAL1_ID].name =
        "OAM_INTERVAL1";
    tm->constants[SOC_SBX_G2P3_OAM_INTERVAL2_ID].name =
        "OAM_INTERVAL2";
    tm->constants[SOC_SBX_G2P3_OAM_INTERVAL3_ID].name =
        "OAM_INTERVAL3";
    tm->constants[SOC_SBX_G2P3_OAM_INTERVAL4_ID].name =
        "OAM_INTERVAL4";
    tm->constants[SOC_SBX_G2P3_OAM_INTERVAL5_ID].name =
        "OAM_INTERVAL5";
    tm->constants[SOC_SBX_G2P3_OAM_INTERVAL6_ID].name =
        "OAM_INTERVAL6";
    tm->constants[SOC_SBX_G2P3_OAM_INTERVAL7_ID].name =
        "OAM_INTERVAL7";
    tm->constants[SOC_SBX_G2P3_OAM_REMOTE_EP_BASE_ID].name =
        "OAM_REMOTE_EP_BASE";
    tm->constants[SOC_SBX_G2P3_MAX_QOS_PROFILE_INDEX_ID].name =
        "MAX_QOS_PROFILE_INDEX";
    tm->constants[SOC_SBX_G2P3_MAX_QOS_MAP_TABLE_ID].name =
        "MAX_QOS_MAP_TABLE";
    tm->constants[SOC_SBX_G2P3_MAX_QOS_REMARK_TABLE_ID].name =
        "MAX_QOS_REMARK_TABLE";
    tm->constants[SOC_SBX_G2P3_MAX_L2CP_TYPES_ID].name =
        "MAX_L2CP_TYPES";
    tm->constants[SOC_SBX_G2P3_MAX_L2CP_SUBTYPES_ID].name =
        "MAX_L2CP_SUBTYPES";
    tm->constants[SOC_SBX_G2P3_URPF_DEFAULT_PID_ID].name =
        "URPF_DEFAULT_PID";
    tm->constants[SOC_SBX_G2P3_STPSTATE_FORWARD_ID].name =
        "stpstate_forward";
    tm->constants[SOC_SBX_G2P3_STPSTATE_BLOCK_ID].name =
        "stpstate_block";
    tm->constants[SOC_SBX_G2P3_STPSTATE_LEARN_ID].name =
        "stpstate_learn";
    tm->constants[SOC_SBX_G2P3_MPLSTP_LOOPBACK_OAM_ID].name =
        "mplstp_loopback_oam";
    tm->constants[SOC_SBX_G2P3_MPLSTP_LOOPBACK_FULL_ID].name =
        "mplstp_loopback_full";
    tm->constants[SOC_SBX_G2P3_MPLSTP_LOOPBACK_NONE_ID].name =
        "mplstp_loopback_none";
    tm->constants[SOC_SBX_G2P3_LABEL_LSR_ID].name =
        "label_lsr";
    tm->constants[SOC_SBX_G2P3_LABEL_ETH_PWE3_ID].name =
        "label_eth_pwe3";
    tm->constants[SOC_SBX_G2P3_LABEL_LER_ID].name =
        "label_ler";
    tm->constants[SOC_SBX_G2P3_LABEL_CES_PWE3_ID].name =
        "label_ces_pwe3";

    /*
     * Global value initialization
     */
    tm->globals = UTG_MALLOC(sizeof(soc_sbx_g2p3_memory_desc_t)
                         * SOC_SBX_G2P3_GLOBAL_MAX_ID);
    if (!tm->globals) {
        soc_sbx_g2p3_uninit(unit);
        return SOC_E_MEMORY;
    }
    tm->globals[SOC_SBX_G2P3_CONTEXTS_ID].name =
        "contexts";
    tm->globals[SOC_SBX_G2P3_TPID0_ID].name =
        "tpid0";
    tm->globals[SOC_SBX_G2P3_TPID1_ID].name =
        "tpid1";
    tm->globals[SOC_SBX_G2P3_TPID2_ID].name =
        "tpid2";
    tm->globals[SOC_SBX_G2P3_DEFITAG_ID].name =
        "defitag";
    tm->globals[SOC_SBX_G2P3_AGE_ID].name =
        "age";
    tm->globals[SOC_SBX_G2P3_LABELCUCKOO_ABSEED_ID].name =
        "labelcuckoo_abseed";
    tm->globals[SOC_SBX_G2P3_CUCKOO_ABSEED_ID].name =
        "cuckoo_abseed";
    tm->globals[SOC_SBX_G2P3_NODE_ID].name =
        "node";
    tm->globals[SOC_SBX_G2P3_VLAN_FT_BASE_ID].name =
        "vlan_ft_base";
    tm->globals[SOC_SBX_G2P3_VPWS_VLAN_ID].name =
        "vpws_vlan";
    tm->globals[SOC_SBX_G2P3_VPWS_FT_OFFSET_ID].name =
        "vpws_ft_offset";
    tm->globals[SOC_SBX_G2P3_EEX_MIRROR0_ID].name =
        "eex_mirror0";
    tm->globals[SOC_SBX_G2P3_EEX_MIRROR1_ID].name =
        "eex_mirror1";
    tm->globals[SOC_SBX_G2P3_MAX_PIDS_ID].name =
        "max_pids";
    tm->globals[SOC_SBX_G2P3_MC_FT_OFFSET_ID].name =
        "mc_ft_offset";
    tm->globals[SOC_SBX_G2P3_OAM_DROP_BIT_ID].name =
        "oam_drop_bit";
    tm->globals[SOC_SBX_G2P3_OAM_ENET_CONTINUE_BYTE_ID].name =
        "oam_enet_continue_byte";
    tm->globals[SOC_SBX_G2P3_OAM_MPLS_CONTINUE_BYTE_ID].name =
        "oam_mpls_continue_byte";
    tm->globals[SOC_SBX_G2P3_OAM_ENET_FRAME_LEN_ID].name =
        "oam_enet_frame_len";
    tm->globals[SOC_SBX_G2P3_OAM_MPLS_FRAME_LEN_ID].name =
        "oam_mpls_frame_len";
    tm->globals[SOC_SBX_G2P3_OAM_SOURCE_QUEUE_ID].name =
        "oam_source_queue";
    tm->globals[SOC_SBX_G2P3_OAM_DEST_QUEUE_ID].name =
        "oam_dest_queue";
    tm->globals[SOC_SBX_G2P3_OAM_SOURCE_BUFFER_ID].name =
        "oam_source_buffer";
    tm->globals[SOC_SBX_G2P3_OAM_BUBBLE_TIMER_OFFSET_ID].name =
        "oam_bubble_timer_offset";
    tm->globals[SOC_SBX_G2P3_OAM_SA_LM_ID].name =
        "oam_sa_lm";
    tm->globals[SOC_SBX_G2P3_OAM_SA_DM_ID].name =
        "oam_sa_dm";
    tm->globals[SOC_SBX_G2P3_OAM_MPLS_SA_LM_ID].name =
        "oam_mpls_sa_lm";
    tm->globals[SOC_SBX_G2P3_OAM_MPLS_SA_DM_ID].name =
        "oam_mpls_sa_dm";
    tm->globals[SOC_SBX_G2P3_OAM_PWE_IP_SA_ID].name =
        "oam_pwe_ip_sa";
    tm->globals[SOC_SBX_G2P3_OAM_PWE_UDP_DEST_PORT_ID].name =
        "oam_pwe_udp_dest_port";
    tm->globals[SOC_SBX_G2P3_OAM_MIRROR_INDEX_ID].name =
        "oam_mirror_index";
    tm->globals[SOC_SBX_G2P3_OAM_LOOPBACK_QID_ID].name =
        "oam_loopback_qid";
    tm->globals[SOC_SBX_G2P3_OAM_SA_4LO_ID].name =
        "oam_sa_4lo";
    tm->globals[SOC_SBX_G2P3_OAM_SA_2HI_ID].name =
        "oam_sa_2hi";
    tm->globals[SOC_SBX_G2P3_OAM_SA_4LO_AUX_ID].name =
        "oam_sa_4lo_aux";
    tm->globals[SOC_SBX_G2P3_OAM_SA_2HI_AUX_ID].name =
        "oam_sa_2hi_aux";
    tm->globals[SOC_SBX_G2P3_OAM_BFD_STATE_TABLE_ID].name =
        "oam_bfd_state_table";
    tm->globals[SOC_SBX_G2P3_OAM_BFD_RDI_DIAG_CODE_ID].name =
        "oam_bfd_rdi_diag_code";
    tm->globals[SOC_SBX_G2P3_OAM_TX_PACKETS_PER_BUBBLE_ID].name =
        "oam_tx_packets_per_bubble";
    tm->globals[SOC_SBX_G2P3_OAM_TX_PACKETS_PER_BUBBLE_CA_ID].name =
        "oam_tx_packets_per_bubble_ca";
    tm->globals[SOC_SBX_G2P3_OAM_PSC_RX_FILTER_ID].name =
        "oam_psc_rx_filter";
    tm->globals[SOC_SBX_G2P3_OAM_LOCAL_FE_QID_ID].name =
        "oam_local_fe_qid";
    tm->globals[SOC_SBX_G2P3_BLACKHOLE_VLAN_ID].name =
        "blackhole_vlan";
    tm->globals[SOC_SBX_G2P3_IGMP_PROXY_MODE_ID].name =
        "igmp_proxy_mode";
    tm->globals[SOC_SBX_G2P3_STATIC_LAG_ID].name =
        "static_lag";
    tm->globals[SOC_SBX_G2P3_IPV4_CHECKSUM_MODE_ID].name =
        "ipv4_checksum_mode";
    tm->globals[SOC_SBX_G2P3_EXIT_FILTER_ON_BTAG_ID].name =
        "exit_filter_on_btag";
    tm->globals[SOC_SBX_G2P3_SWITCH_METER_ADJUST_ID].name =
        "switch_meter_adjust";
    tm->globals[SOC_SBX_G2P3_RC1_RULE_STARTIDX_ID].name =
        "rc1_rule_startidx";
    tm->globals[SOC_SBX_G2P3_IPV6_ACL_ENABLE_ID].name =
        "ipv6_acl_enable";
    tm->globals[SOC_SBX_G2P3_OI2EOFF_ID].name =
        "oi2eoff";
    tm->globals[SOC_SBX_G2P3_ETE0PLUS1_ID].name =
        "ete0plus1";
    tm->globals[SOC_SBX_G2P3_ETE1PLUS1_ID].name =
        "ete1plus1";

    for (i = 0; i < SOC_SBX_G2P3_GLOBAL_MAX_ID; i++) {
        s = soc_sbx_g2p3_ucode_get(unit,
                  soc_sbx_g2p3_sym,
                  128,
                  &tm->globals[i].range,
                  "GLOBAL",
                  tm->globals[i].name,
                  -1,
                  e,
                  "RANGE");
        if (s) {
            soc_sbx_g2p3_uninit(unit);
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                  soc_sbx_g2p3_sym,
                  128,
                  &tm->globals[i].value,
                  "GLOBAL",
                  tm->globals[i].name,
                  -1,
                  e,
                  e);
        if (s) {
            soc_sbx_g2p3_uninit(unit);
            return s;
        }
    }

    /*
     * Per-table state initialization
     */
    tm->tables = UTG_MALLOC(sizeof(soc_sbx_g2p3_table_desc_t)
                         * SOC_SBX_G2P3_TABLE_MAX_ID);
    if (!tm->tables) {
        soc_sbx_g2p3_uninit(unit);
        return SOC_E_MEMORY;
    }
    sal_memset(tm->tables, 0, sizeof(soc_sbx_g2p3_table_desc_t)
           * SOC_SBX_G2P3_TABLE_MAX_ID);

    tm->alignedlist = -1;
    tm->tables[SOC_SBX_G2P3_PORTDATA20_TABLE_ID].name =
        "portdata20";
    tm->tables[SOC_SBX_G2P3_PORTDATA25_TABLE_ID].name =
        "portdata25";
    tm->tables[SOC_SBX_G2P3_QOS_TABLE_ID].name =
        "qos";
    tm->tables[SOC_SBX_G2P3_DSCP_QOS_TABLE_ID].name =
        "dscp_qos";
    tm->tables[SOC_SBX_G2P3_IRT_TABLE_ID].name =
        "irt";
    tm->tables[SOC_SBX_G2P3_RT_MT_TABLE_ID].name =
        "rt_mt";
    tm->tables[SOC_SBX_G2P3_RT_RR0_TABLE_ID].name =
        "rt_rr0";
    tm->tables[SOC_SBX_G2P3_RT_RR1_TABLE_ID].name =
        "rt_rr1";
    tm->tables[SOC_SBX_G2P3_LAG_TABLE_ID].name =
        "lag";
    tm->tables[SOC_SBX_G2P3_RR_TABLE_ID].name =
        "rr";
    tm->tables[SOC_SBX_G2P3_XT_TABLE_ID].name =
        "xt";
    tm->tables[SOC_SBX_G2P3_MIRROR_TABLE_ID].name =
        "mirror";
    tm->tables[SOC_SBX_G2P3_EMIRROR20_TABLE_ID].name =
        "emirror20";
    tm->tables[SOC_SBX_G2P3_EMIRROR25_TABLE_ID].name =
        "emirror25";
    tm->tables[SOC_SBX_G2P3_MAC_TABLE_ID].name =
        "mac";
    tm->tables[SOC_SBX_G2P3_IPV6DHOST_TABLE_ID].name =
        "ipv6dhost";
    tm->tables[SOC_SBX_G2P3_MST_TABLE_ID].name =
        "mst";
    tm->tables[SOC_SBX_G2P3_PV2E_TABLE_ID].name =
        "pv2e";
    tm->tables[SOC_SBX_G2P3_P2APPDATA_TABLE_ID].name =
        "p2appdata";
    tm->tables[SOC_SBX_G2P3_PV2APPDATA_TABLE_ID].name =
        "pv2appdata";
    tm->tables[SOC_SBX_G2P3_IPV6SHOST_TABLE_ID].name =
        "ipv6shost";
    tm->tables[SOC_SBX_G2P3_CUCKOO_TABLE_ID].name =
        "cuckoo";
    tm->tables[SOC_SBX_G2P3_OUTERLABELCUCKOO_TABLE_ID].name =
        "outerlabelcuckoo";
    tm->tables[SOC_SBX_G2P3_INNERLABELCUCKOO_TABLE_ID].name =
        "innerlabelcuckoo";
    tm->tables[SOC_SBX_G2P3_V2E_TABLE_ID].name =
        "v2e";
    tm->tables[SOC_SBX_G2P3_V2E1_TABLE_ID].name =
        "v2e1";
    tm->tables[SOC_SBX_G2P3_LP_TABLE_ID].name =
        "lp";
    tm->tables[SOC_SBX_G2P3_L2E_TABLE_ID].name =
        "l2e";
    tm->tables[SOC_SBX_G2P3_L2CP_TABLE_ID].name =
        "l2cp";
    tm->tables[SOC_SBX_G2P3_L2CPSLOW_TABLE_ID].name =
        "l2cpslow";
    tm->tables[SOC_SBX_G2P3_L2CPNOP_TABLE_ID].name =
        "l2cpnop";
    tm->tables[SOC_SBX_G2P3_FT_TABLE_ID].name =
        "ft";
    tm->tables[SOC_SBX_G2P3_OAMTIMERCALENDAR_TABLE_ID].name =
        "OamTimerCalendar";
    tm->tables[SOC_SBX_G2P3_OAMPORTMDLEVEL2ETC_TABLE_ID].name =
        "OamPortMdLevel2Etc";
    tm->tables[SOC_SBX_G2P3_IPV6MCSG_TABLE_ID].name =
        "ipv6mcsg";
    tm->tables[SOC_SBX_G2P3_IPV6MCG_TABLE_ID].name =
        "ipv6mcg";
    tm->tables[SOC_SBX_G2P3_IPV4MCG_TABLE_ID].name =
        "ipv4mcg";
    tm->tables[SOC_SBX_G2P3_IPV4MCSG_TABLE_ID].name =
        "ipv4mcsg";
    tm->tables[SOC_SBX_G2P3_IPV4SA_TABLE_ID].name =
        "ipv4sa";
    tm->tables[SOC_SBX_G2P3_EVP2E_TABLE_ID].name =
        "evp2e";
    tm->tables[SOC_SBX_G2P3_OI2E_TABLE_ID].name =
        "oi2e";
    tm->tables[SOC_SBX_G2P3_ETE_TABLE_ID].name =
        "ete";
    tm->tables[SOC_SBX_G2P3_OAMEP_TABLE_ID].name =
        "oamEp";
    tm->tables[SOC_SBX_G2P3_REMARK_TABLE_ID].name =
        "remark";
    tm->tables[SOC_SBX_G2P3_EPV2E_TABLE_ID].name =
        "epv2e";
    tm->tables[SOC_SBX_G2P3_ESMAC_TABLE_ID].name =
        "esmac";
    tm->tables[SOC_SBX_G2P3_ERT_TABLE_ID].name =
        "ert";
    tm->tables[SOC_SBX_G2P3_OAMMULTIPLIER_TABLE_ID].name =
        "oamMultiplier";
    tm->tables[SOC_SBX_G2P3_OAMEPREMAP_TABLE_ID].name =
        "oamEpRemap";
    tm->tables[SOC_SBX_G2P3_IPV6DA_TABLE_ID].name =
        "ipv6da";
    tm->tables[SOC_SBX_G2P3_IPV6SA_TABLE_ID].name =
        "ipv6sa";
    tm->tables[SOC_SBX_G2P3_IPV4DA_TABLE_ID].name =
        "ipv4da";
    tm->tables[SOC_SBX_G2P3_P2FTI_TABLE_ID].name =
        "P2FTI";

    for (i = 0; i < SOC_SBX_G2P3_TABLE_MAX_ID; i++) {
        s = soc_sbx_g2p3_ucode_get(unit,
                  soc_sbx_g2p3_sym,
                  128,
                  &tm->tables[i].nbanks,
                  e,
                  tm->tables[i].name,
                  -1,
                  e,
                  "TABLE_BANKS");
        if (s) {
            soc_sbx_g2p3_uninit(unit);
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                  soc_sbx_g2p3_sym,
                  128,
                  &j,
                  e,
                  tm->tables[i].name,
                  -1,
                  e,
                  "TABLE_ALIGN");
        if (s) {
            soc_sbx_g2p3_uninit(unit);
            return s;
        }
        tm->tables[i].nextaligned = j ? -2 : 0;
        s = soc_sbx_g2p3_ucode_get(unit,
                  soc_sbx_g2p3_sym,
                  128,
                  &tm->tables[i].type,
                  e,
                  tm->tables[i].name,
                  -1,
                  e,
                  "TABLE_TYPE");
        if (s) {
            soc_sbx_g2p3_uninit(unit);
            return s;
        }
        for (j = 0; j < tm->tables[i].nbanks; j++) {
            s = soc_sbx_g2p3_ucode_get(unit,
                      soc_sbx_g2p3_sym,
                      128,
                      &tm->tables[i].banks[j].memory,
                      e,
                      tm->tables[i].name,
                      j == 0 ? -1 : j,
                      e,
                      "MEMORY");
            if (s) {
                soc_sbx_g2p3_uninit(unit);
                return s;
            }
            s = soc_sbx_g2p3_ucode_get(unit,
                      soc_sbx_g2p3_sym,
                      128,
                      &tm->tables[i].banks[j].base,
                      e,
                      tm->tables[i].name,
                      j == 0 ? -1 : j,
                      e,
                      "BASE");
            if (s) {
                soc_sbx_g2p3_uninit(unit);
                return s;
            }
            s = soc_sbx_g2p3_ucode_get(unit,
                      soc_sbx_g2p3_sym,
                      128,
                      &tm->tables[i].banks[j].size,
                      e,
                      tm->tables[i].name,
                      j == 0 ? -1 : j,
                      e,
                      "SIZE");
            if (s) {
                soc_sbx_g2p3_uninit(unit);
                return s;
            }
            s = soc_sbx_g2p3_ucode_get(unit,
                      soc_sbx_g2p3_sym,
                      128,
                      &tm->tables[i].banks[j].width,
                      e,
                      tm->tables[i].name,
                      j == 0 ? -1 : j,
                      e,
                      "TABLE_WIDTH");
            if (s) {
                soc_sbx_g2p3_uninit(unit);
                return s;
            }
        }
        s = soc_sbx_g2p3_complex_b0size_set(unit, &tm->tables[i]);
        if (s) {
            soc_sbx_g2p3_uninit(unit);
            return s;
        }
    }

    /*
     * Per-entry state initialization
     */
    tm->entries = UTG_MALLOC(sizeof(soc_sbx_g2p3_entry_desc_t)
                         * SOC_SBX_G2P3_ENTRY_MAX_ID);
    if (!tm->entries) {
        soc_sbx_g2p3_uninit(unit);
        return SOC_E_MEMORY;
    }

    /* Zero indexes & entries pointers */
    sal_memset(tm->entries, 0, sizeof(soc_sbx_g2p3_entry_desc_t)
           * SOC_SBX_G2P3_ENTRY_MAX_ID);

    tm->entries[SOC_SBX_G2P3_P2E_ID].name =
        "p2e";
    tm->entries[SOC_SBX_G2P3_P2E_ID].table =
        SOC_SBX_G2P3_TABLE_MAX_ID;
    tm->entries[SOC_SBX_G2P3_P2E_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_p2e_pack;
    tm->entries[SOC_SBX_G2P3_P2E_ID].esize =
        sizeof(soc_sbx_g2p3_p2e_t);
    tm->entries[SOC_SBX_G2P3_P2E_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_P2E_ID].nfields = 19;

    tm->entries[SOC_SBX_G2P3_EP2E_ID].name =
        "ep2e";
    tm->entries[SOC_SBX_G2P3_EP2E_ID].table =
        SOC_SBX_G2P3_TABLE_MAX_ID;
    tm->entries[SOC_SBX_G2P3_EP2E_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ep2e_pack;
    tm->entries[SOC_SBX_G2P3_EP2E_ID].esize =
        sizeof(soc_sbx_g2p3_ep2e_t);
    tm->entries[SOC_SBX_G2P3_EP2E_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_EP2E_ID].nfields = 13;

    tm->entries[SOC_SBX_G2P3_P2E20_ID].name =
        "p2e20";
    tm->entries[SOC_SBX_G2P3_P2E20_ID].table =
        SOC_SBX_G2P3_PORTDATA20_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_P2E20_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_p2e20_pack;
    tm->entries[SOC_SBX_G2P3_P2E20_ID].esize =
        sizeof(soc_sbx_g2p3_p2e20_t);
    tm->entries[SOC_SBX_G2P3_P2E20_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_P2E20_ID].nfields = 19;

    tm->entries[SOC_SBX_G2P3_EP2E20_ID].name =
        "ep2e20";
    tm->entries[SOC_SBX_G2P3_EP2E20_ID].table =
        SOC_SBX_G2P3_PORTDATA20_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_EP2E20_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ep2e20_pack;
    tm->entries[SOC_SBX_G2P3_EP2E20_ID].esize =
        sizeof(soc_sbx_g2p3_ep2e20_t);
    tm->entries[SOC_SBX_G2P3_EP2E20_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_EP2E20_ID].nfields = 13;

    tm->entries[SOC_SBX_G2P3_P2E25_ID].name =
        "p2e25";
    tm->entries[SOC_SBX_G2P3_P2E25_ID].table =
        SOC_SBX_G2P3_PORTDATA25_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_P2E25_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_p2e25_pack;
    tm->entries[SOC_SBX_G2P3_P2E25_ID].esize =
        sizeof(soc_sbx_g2p3_p2e25_t);
    tm->entries[SOC_SBX_G2P3_P2E25_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_P2E25_ID].nfields = 19;

    tm->entries[SOC_SBX_G2P3_EP2E25_ID].name =
        "ep2e25";
    tm->entries[SOC_SBX_G2P3_EP2E25_ID].table =
        SOC_SBX_G2P3_PORTDATA25_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_EP2E25_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ep2e25_pack;
    tm->entries[SOC_SBX_G2P3_EP2E25_ID].esize =
        sizeof(soc_sbx_g2p3_ep2e25_t);
    tm->entries[SOC_SBX_G2P3_EP2E25_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_EP2E25_ID].nfields = 13;

    tm->entries[SOC_SBX_G2P3_TPID_ID].name =
        "tpid";
    tm->entries[SOC_SBX_G2P3_TPID_ID].table =
        SOC_SBX_G2P3_TABLE_MAX_ID;
    tm->entries[SOC_SBX_G2P3_TPID_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_tpid_pack;
    tm->entries[SOC_SBX_G2P3_TPID_ID].esize =
        sizeof(soc_sbx_g2p3_tpid_t);
    tm->entries[SOC_SBX_G2P3_TPID_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_TPID_ID].nfields = 1;

    tm->entries[SOC_SBX_G2P3_OAM_RX_ID].name =
        "oam_rx";
    tm->entries[SOC_SBX_G2P3_OAM_RX_ID].table =
        SOC_SBX_G2P3_TABLE_MAX_ID;
    tm->entries[SOC_SBX_G2P3_OAM_RX_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_oam_rx_pack;
    tm->entries[SOC_SBX_G2P3_OAM_RX_ID].esize =
        sizeof(soc_sbx_g2p3_oam_rx_t);
    tm->entries[SOC_SBX_G2P3_OAM_RX_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_OAM_RX_ID].nfields = 1;

    tm->entries[SOC_SBX_G2P3_OAM_TX_ID].name =
        "oam_tx";
    tm->entries[SOC_SBX_G2P3_OAM_TX_ID].table =
        SOC_SBX_G2P3_TABLE_MAX_ID;
    tm->entries[SOC_SBX_G2P3_OAM_TX_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_oam_tx_pack;
    tm->entries[SOC_SBX_G2P3_OAM_TX_ID].esize =
        sizeof(soc_sbx_g2p3_oam_tx_t);
    tm->entries[SOC_SBX_G2P3_OAM_TX_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_OAM_TX_ID].nfields = 1;

    tm->entries[SOC_SBX_G2P3_LSMAC_ID].name =
        "lsmac";
    tm->entries[SOC_SBX_G2P3_LSMAC_ID].table =
        SOC_SBX_G2P3_TABLE_MAX_ID;
    tm->entries[SOC_SBX_G2P3_LSMAC_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_lsmac_pack;
    tm->entries[SOC_SBX_G2P3_LSMAC_ID].esize =
        sizeof(soc_sbx_g2p3_lsmac_t);
    tm->entries[SOC_SBX_G2P3_LSMAC_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_LSMAC_ID].nfields = 3;

    tm->entries[SOC_SBX_G2P3_L2CPMAC_ID].name =
        "l2cpmac";
    tm->entries[SOC_SBX_G2P3_L2CPMAC_ID].table =
        SOC_SBX_G2P3_TABLE_MAX_ID;
    tm->entries[SOC_SBX_G2P3_L2CPMAC_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_l2cpmac_pack;
    tm->entries[SOC_SBX_G2P3_L2CPMAC_ID].esize =
        sizeof(soc_sbx_g2p3_l2cpmac_t);
    tm->entries[SOC_SBX_G2P3_L2CPMAC_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_L2CPMAC_ID].nfields = 3;

    tm->entries[SOC_SBX_G2P3_OAMUPMAC_ID].name =
        "oamupmac";
    tm->entries[SOC_SBX_G2P3_OAMUPMAC_ID].table =
        SOC_SBX_G2P3_TABLE_MAX_ID;
    tm->entries[SOC_SBX_G2P3_OAMUPMAC_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_oamupmac_pack;
    tm->entries[SOC_SBX_G2P3_OAMUPMAC_ID].esize =
        sizeof(soc_sbx_g2p3_oamupmac_t);
    tm->entries[SOC_SBX_G2P3_OAMUPMAC_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_OAMUPMAC_ID].nfields = 2;

    tm->entries[SOC_SBX_G2P3_QOS_ID].name =
        "qos";
    tm->entries[SOC_SBX_G2P3_QOS_ID].table =
        SOC_SBX_G2P3_QOS_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_QOS_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_qos_pack;
    tm->entries[SOC_SBX_G2P3_QOS_ID].esize =
        sizeof(soc_sbx_g2p3_qos_t);
    tm->entries[SOC_SBX_G2P3_QOS_ID].nindexes = 3;
    tm->entries[SOC_SBX_G2P3_QOS_ID].nfields = 5;

    tm->entries[SOC_SBX_G2P3_DSCP_QOS_ID].name =
        "dscp_qos";
    tm->entries[SOC_SBX_G2P3_DSCP_QOS_ID].table =
        SOC_SBX_G2P3_DSCP_QOS_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_DSCP_QOS_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_dscp_qos_pack;
    tm->entries[SOC_SBX_G2P3_DSCP_QOS_ID].esize =
        sizeof(soc_sbx_g2p3_dscp_qos_t);
    tm->entries[SOC_SBX_G2P3_DSCP_QOS_ID].nindexes = 2;
    tm->entries[SOC_SBX_G2P3_DSCP_QOS_ID].nfields = 5;

    tm->entries[SOC_SBX_G2P3_IRT_ID].name =
        "irt";
    tm->entries[SOC_SBX_G2P3_IRT_ID].table =
        SOC_SBX_G2P3_IRT_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_IRT_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_irt_pack;
    tm->entries[SOC_SBX_G2P3_IRT_ID].esize =
        sizeof(soc_sbx_g2p3_irt_t);
    tm->entries[SOC_SBX_G2P3_IRT_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_IRT_ID].nfields = 15;

    tm->entries[SOC_SBX_G2P3_IRT_WRAP_ID].name =
        "irt_wrap";
    tm->entries[SOC_SBX_G2P3_IRT_WRAP_ID].table =
        SOC_SBX_G2P3_TABLE_MAX_ID;
    tm->entries[SOC_SBX_G2P3_IRT_WRAP_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_irt_wrap_pack;
    tm->entries[SOC_SBX_G2P3_IRT_WRAP_ID].esize =
        sizeof(soc_sbx_g2p3_irt_wrap_t);
    tm->entries[SOC_SBX_G2P3_IRT_WRAP_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_IRT_WRAP_ID].nfields = 15;

    tm->entries[SOC_SBX_G2P3_RT_MT_ID].name =
        "rt_mt";
    tm->entries[SOC_SBX_G2P3_RT_MT_ID].table =
        SOC_SBX_G2P3_RT_MT_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_RT_MT_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_rt_mt_pack;
    tm->entries[SOC_SBX_G2P3_RT_MT_ID].esize =
        sizeof(soc_sbx_g2p3_rt_mt_t);
    tm->entries[SOC_SBX_G2P3_RT_MT_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_RT_MT_ID].nfields = 1;

    tm->entries[SOC_SBX_G2P3_RT_RR0_ID].name =
        "rt_rr0";
    tm->entries[SOC_SBX_G2P3_RT_RR0_ID].table =
        SOC_SBX_G2P3_RT_RR0_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_RT_RR0_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_rt_rr0_pack;
    tm->entries[SOC_SBX_G2P3_RT_RR0_ID].esize =
        sizeof(soc_sbx_g2p3_rt_rr0_t);
    tm->entries[SOC_SBX_G2P3_RT_RR0_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_RT_RR0_ID].nfields = 18;

    tm->entries[SOC_SBX_G2P3_RT_ID].name =
        "rt";
    tm->entries[SOC_SBX_G2P3_RT_ID].table =
        SOC_SBX_G2P3_RT_RR0_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_RT_ID].pack =
        NULL;
    tm->entries[SOC_SBX_G2P3_RT_ID].esize =
        sizeof(soc_sbx_g2p3_rt_t);
    tm->entries[SOC_SBX_G2P3_RT_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_RT_ID].nfields = 0;

    tm->entries[SOC_SBX_G2P3_RT_RR1_ID].name =
        "rt_rr1";
    tm->entries[SOC_SBX_G2P3_RT_RR1_ID].table =
        SOC_SBX_G2P3_RT_RR1_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_RT_RR1_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_rt_rr1_pack;
    tm->entries[SOC_SBX_G2P3_RT_RR1_ID].esize =
        sizeof(soc_sbx_g2p3_rt_rr1_t);
    tm->entries[SOC_SBX_G2P3_RT_RR1_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_RT_RR1_ID].nfields = 18;

    tm->entries[SOC_SBX_G2P3_LAG_ID].name =
        "lag";
    tm->entries[SOC_SBX_G2P3_LAG_ID].table =
        SOC_SBX_G2P3_LAG_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_LAG_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_lag_pack;
    tm->entries[SOC_SBX_G2P3_LAG_ID].esize =
        sizeof(soc_sbx_g2p3_lag_t);
    tm->entries[SOC_SBX_G2P3_LAG_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_LAG_ID].nfields = 2;

    tm->entries[SOC_SBX_G2P3_RR_ID].name =
        "rr";
    tm->entries[SOC_SBX_G2P3_RR_ID].table =
        SOC_SBX_G2P3_RR_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_RR_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_rr_pack;
    tm->entries[SOC_SBX_G2P3_RR_ID].esize =
        sizeof(soc_sbx_g2p3_rr_t);
    tm->entries[SOC_SBX_G2P3_RR_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_RR_ID].nfields = 1;

    tm->entries[SOC_SBX_G2P3_XT_ID].name =
        "xt";
    tm->entries[SOC_SBX_G2P3_XT_ID].table =
        SOC_SBX_G2P3_XT_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_XT_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_xt_pack;
    tm->entries[SOC_SBX_G2P3_XT_ID].esize =
        sizeof(soc_sbx_g2p3_xt_t);
    tm->entries[SOC_SBX_G2P3_XT_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_XT_ID].nfields = 7;

    tm->entries[SOC_SBX_G2P3_MIRROR_ID].name =
        "mirror";
    tm->entries[SOC_SBX_G2P3_MIRROR_ID].table =
        SOC_SBX_G2P3_MIRROR_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_MIRROR_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_mirror_pack;
    tm->entries[SOC_SBX_G2P3_MIRROR_ID].esize =
        sizeof(soc_sbx_g2p3_mirror_t);
    tm->entries[SOC_SBX_G2P3_MIRROR_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_MIRROR_ID].nfields = 3;

    tm->entries[SOC_SBX_G2P3_EMIRROR_ID].name =
        "emirror";
    tm->entries[SOC_SBX_G2P3_EMIRROR_ID].table =
        SOC_SBX_G2P3_TABLE_MAX_ID;
    tm->entries[SOC_SBX_G2P3_EMIRROR_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_emirror_pack;
    tm->entries[SOC_SBX_G2P3_EMIRROR_ID].esize =
        sizeof(soc_sbx_g2p3_emirror_t);
    tm->entries[SOC_SBX_G2P3_EMIRROR_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_EMIRROR_ID].nfields = 4;

    tm->entries[SOC_SBX_G2P3_EMIRROR20_ID].name =
        "emirror20";
    tm->entries[SOC_SBX_G2P3_EMIRROR20_ID].table =
        SOC_SBX_G2P3_EMIRROR20_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_EMIRROR20_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_emirror20_pack;
    tm->entries[SOC_SBX_G2P3_EMIRROR20_ID].esize =
        sizeof(soc_sbx_g2p3_emirror20_t);
    tm->entries[SOC_SBX_G2P3_EMIRROR20_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_EMIRROR20_ID].nfields = 3;

    tm->entries[SOC_SBX_G2P3_EMIRROR25_ID].name =
        "emirror25";
    tm->entries[SOC_SBX_G2P3_EMIRROR25_ID].table =
        SOC_SBX_G2P3_EMIRROR25_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_EMIRROR25_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_emirror25_pack;
    tm->entries[SOC_SBX_G2P3_EMIRROR25_ID].esize =
        sizeof(soc_sbx_g2p3_emirror25_t);
    tm->entries[SOC_SBX_G2P3_EMIRROR25_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_EMIRROR25_ID].nfields = 9;

    tm->entries[SOC_SBX_G2P3_EMLL1_ID].name =
        "emll1";
    tm->entries[SOC_SBX_G2P3_EMLL1_ID].table =
        SOC_SBX_G2P3_TABLE_MAX_ID;
    tm->entries[SOC_SBX_G2P3_EMLL1_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_emll1_pack;
    tm->entries[SOC_SBX_G2P3_EMLL1_ID].esize =
        sizeof(soc_sbx_g2p3_emll1_t);
    tm->entries[SOC_SBX_G2P3_EMLL1_ID].nindexes = 0;
    tm->entries[SOC_SBX_G2P3_EMLL1_ID].nfields = 3;

    tm->entries[SOC_SBX_G2P3_MAC_ID].name =
        "mac";
    tm->entries[SOC_SBX_G2P3_MAC_ID].table =
        SOC_SBX_G2P3_MAC_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_MAC_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_mac_pack;
    tm->entries[SOC_SBX_G2P3_MAC_ID].esize =
        sizeof(soc_sbx_g2p3_mac_t);
    tm->entries[SOC_SBX_G2P3_MAC_ID].nindexes = 3;
    tm->entries[SOC_SBX_G2P3_MAC_ID].nfields = 10;

    tm->entries[SOC_SBX_G2P3_MACL1_ID].name =
        "macl1";
    tm->entries[SOC_SBX_G2P3_MACL1_ID].table =
        SOC_SBX_G2P3_MAC_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_MACL1_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_macl1_pack;
    tm->entries[SOC_SBX_G2P3_MACL1_ID].esize =
        sizeof(soc_sbx_g2p3_macl1_t);
    tm->entries[SOC_SBX_G2P3_MACL1_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_MACL1_ID].nfields = 3;

    tm->entries[SOC_SBX_G2P3_MACL2_ID].name =
        "macl2";
    tm->entries[SOC_SBX_G2P3_MACL2_ID].table =
        SOC_SBX_G2P3_MAC_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_MACL2_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_macl2_pack;
    tm->entries[SOC_SBX_G2P3_MACL2_ID].esize =
        sizeof(soc_sbx_g2p3_macl2_t);
    tm->entries[SOC_SBX_G2P3_MACL2_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_MACL2_ID].nfields = 14;

    tm->entries[SOC_SBX_G2P3_IPV6DHOST_ID].name =
        "ipv6dhost";
    tm->entries[SOC_SBX_G2P3_IPV6DHOST_ID].table =
        SOC_SBX_G2P3_IPV6DHOST_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_IPV6DHOST_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ipv6dhost_pack;
    tm->entries[SOC_SBX_G2P3_IPV6DHOST_ID].esize =
        sizeof(soc_sbx_g2p3_ipv6dhost_t);
    tm->entries[SOC_SBX_G2P3_IPV6DHOST_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_IPV6DHOST_ID].nfields = 3;

    tm->entries[SOC_SBX_G2P3_IPV6DHOSTL1_ID].name =
        "ipv6dhostl1";
    tm->entries[SOC_SBX_G2P3_IPV6DHOSTL1_ID].table =
        SOC_SBX_G2P3_IPV6DHOST_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_IPV6DHOSTL1_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ipv6dhostl1_pack;
    tm->entries[SOC_SBX_G2P3_IPV6DHOSTL1_ID].esize =
        sizeof(soc_sbx_g2p3_ipv6dhostl1_t);
    tm->entries[SOC_SBX_G2P3_IPV6DHOSTL1_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_IPV6DHOSTL1_ID].nfields = 3;

    tm->entries[SOC_SBX_G2P3_IPV6DHOSTL2_ID].name =
        "ipv6dhostl2";
    tm->entries[SOC_SBX_G2P3_IPV6DHOSTL2_ID].table =
        SOC_SBX_G2P3_IPV6DHOST_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_IPV6DHOSTL2_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ipv6dhostl2_pack;
    tm->entries[SOC_SBX_G2P3_IPV6DHOSTL2_ID].esize =
        sizeof(soc_sbx_g2p3_ipv6dhostl2_t);
    tm->entries[SOC_SBX_G2P3_IPV6DHOSTL2_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_IPV6DHOSTL2_ID].nfields = 4;

    tm->entries[SOC_SBX_G2P3_MST_ID].name =
        "mst";
    tm->entries[SOC_SBX_G2P3_MST_ID].table =
        SOC_SBX_G2P3_MST_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_MST_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_mst_pack;
    tm->entries[SOC_SBX_G2P3_MST_ID].esize =
        sizeof(soc_sbx_g2p3_mst_t);
    tm->entries[SOC_SBX_G2P3_MST_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_MST_ID].nfields = 10;

    tm->entries[SOC_SBX_G2P3_PV2E_ID].name =
        "pv2e";
    tm->entries[SOC_SBX_G2P3_PV2E_ID].table =
        SOC_SBX_G2P3_PV2E_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_PV2E_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_pv2e_pack;
    tm->entries[SOC_SBX_G2P3_PV2E_ID].esize =
        sizeof(soc_sbx_g2p3_pv2e_t);
    tm->entries[SOC_SBX_G2P3_PV2E_ID].nindexes = 2;
    tm->entries[SOC_SBX_G2P3_PV2E_ID].nfields = 5;

    tm->entries[SOC_SBX_G2P3_P2APPDATA_ID].name =
        "p2appdata";
    tm->entries[SOC_SBX_G2P3_P2APPDATA_ID].table =
        SOC_SBX_G2P3_P2APPDATA_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_P2APPDATA_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_p2appdata_pack;
    tm->entries[SOC_SBX_G2P3_P2APPDATA_ID].esize =
        sizeof(soc_sbx_g2p3_p2appdata_t);
    tm->entries[SOC_SBX_G2P3_P2APPDATA_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_P2APPDATA_ID].nfields = 2;

    tm->entries[SOC_SBX_G2P3_PV2APPDATA_ID].name =
        "pv2appdata";
    tm->entries[SOC_SBX_G2P3_PV2APPDATA_ID].table =
        SOC_SBX_G2P3_PV2APPDATA_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_PV2APPDATA_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_pv2appdata_pack;
    tm->entries[SOC_SBX_G2P3_PV2APPDATA_ID].esize =
        sizeof(soc_sbx_g2p3_pv2appdata_t);
    tm->entries[SOC_SBX_G2P3_PV2APPDATA_ID].nindexes = 2;
    tm->entries[SOC_SBX_G2P3_PV2APPDATA_ID].nfields = 1;

    tm->entries[SOC_SBX_G2P3_IPV6SHOST_ID].name =
        "ipv6shost";
    tm->entries[SOC_SBX_G2P3_IPV6SHOST_ID].table =
        SOC_SBX_G2P3_IPV6SHOST_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_IPV6SHOST_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ipv6shost_pack;
    tm->entries[SOC_SBX_G2P3_IPV6SHOST_ID].esize =
        sizeof(soc_sbx_g2p3_ipv6shost_t);
    tm->entries[SOC_SBX_G2P3_IPV6SHOST_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_IPV6SHOST_ID].nfields = 4;

    tm->entries[SOC_SBX_G2P3_IPV6SHOSTL1_ID].name =
        "ipv6shostl1";
    tm->entries[SOC_SBX_G2P3_IPV6SHOSTL1_ID].table =
        SOC_SBX_G2P3_IPV6SHOST_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_IPV6SHOSTL1_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ipv6shostl1_pack;
    tm->entries[SOC_SBX_G2P3_IPV6SHOSTL1_ID].esize =
        sizeof(soc_sbx_g2p3_ipv6shostl1_t);
    tm->entries[SOC_SBX_G2P3_IPV6SHOSTL1_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_IPV6SHOSTL1_ID].nfields = 3;

    tm->entries[SOC_SBX_G2P3_IPV6SHOSTL2_ID].name =
        "ipv6shostl2";
    tm->entries[SOC_SBX_G2P3_IPV6SHOSTL2_ID].table =
        SOC_SBX_G2P3_IPV6SHOST_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_IPV6SHOSTL2_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ipv6shostl2_pack;
    tm->entries[SOC_SBX_G2P3_IPV6SHOSTL2_ID].esize =
        sizeof(soc_sbx_g2p3_ipv6shostl2_t);
    tm->entries[SOC_SBX_G2P3_IPV6SHOSTL2_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_IPV6SHOSTL2_ID].nfields = 4;

    tm->entries[SOC_SBX_G2P3_PVV2E_ID].name =
        "pvv2e";
    tm->entries[SOC_SBX_G2P3_PVV2E_ID].table =
        SOC_SBX_G2P3_TABLE_MAX_ID;
    tm->entries[SOC_SBX_G2P3_PVV2E_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_pvv2e_pack;
    tm->entries[SOC_SBX_G2P3_PVV2E_ID].esize =
        sizeof(soc_sbx_g2p3_pvv2e_t);
    tm->entries[SOC_SBX_G2P3_PVV2E_ID].nindexes = 3;
    tm->entries[SOC_SBX_G2P3_PVV2E_ID].nfields = 8;

    tm->entries[SOC_SBX_G2P3_PVV2EPACK_ID].name =
        "pvv2epack";
    tm->entries[SOC_SBX_G2P3_PVV2EPACK_ID].table =
        SOC_SBX_G2P3_TABLE_MAX_ID;
    tm->entries[SOC_SBX_G2P3_PVV2EPACK_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_pvv2epack_pack;
    tm->entries[SOC_SBX_G2P3_PVV2EPACK_ID].esize =
        sizeof(soc_sbx_g2p3_pvv2epack_t);
    tm->entries[SOC_SBX_G2P3_PVV2EPACK_ID].nindexes = 3;
    tm->entries[SOC_SBX_G2P3_PVV2EPACK_ID].nfields = 8;

    tm->entries[SOC_SBX_G2P3_ISID2E_ID].name =
        "isid2e";
    tm->entries[SOC_SBX_G2P3_ISID2E_ID].table =
        SOC_SBX_G2P3_TABLE_MAX_ID;
    tm->entries[SOC_SBX_G2P3_ISID2E_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_isid2e_pack;
    tm->entries[SOC_SBX_G2P3_ISID2E_ID].esize =
        sizeof(soc_sbx_g2p3_isid2e_t);
    tm->entries[SOC_SBX_G2P3_ISID2E_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_ISID2E_ID].nfields = 3;

    tm->entries[SOC_SBX_G2P3_OAMPVD2E_ID].name =
        "oampvd2e";
    tm->entries[SOC_SBX_G2P3_OAMPVD2E_ID].table =
        SOC_SBX_G2P3_TABLE_MAX_ID;
    tm->entries[SOC_SBX_G2P3_OAMPVD2E_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_oampvd2e_pack;
    tm->entries[SOC_SBX_G2P3_OAMPVD2E_ID].esize =
        sizeof(soc_sbx_g2p3_oampvd2e_t);
    tm->entries[SOC_SBX_G2P3_OAMPVD2E_ID].nindexes = 4;
    tm->entries[SOC_SBX_G2P3_OAMPVD2E_ID].nfields = 4;

    tm->entries[SOC_SBX_G2P3_OAMMAIDMEP2E_ID].name =
        "oammaidmep2e";
    tm->entries[SOC_SBX_G2P3_OAMMAIDMEP2E_ID].table =
        SOC_SBX_G2P3_TABLE_MAX_ID;
    tm->entries[SOC_SBX_G2P3_OAMMAIDMEP2E_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_oammaidmep2e_pack;
    tm->entries[SOC_SBX_G2P3_OAMMAIDMEP2E_ID].esize =
        sizeof(soc_sbx_g2p3_oammaidmep2e_t);
    tm->entries[SOC_SBX_G2P3_OAMMAIDMEP2E_ID].nindexes = 2;
    tm->entries[SOC_SBX_G2P3_OAMMAIDMEP2E_ID].nfields = 2;

    tm->entries[SOC_SBX_G2P3_CUCKOO_ID].name =
        "cuckoo";
    tm->entries[SOC_SBX_G2P3_CUCKOO_ID].table =
        SOC_SBX_G2P3_CUCKOO_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_CUCKOO_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_cuckoo_pack;
    tm->entries[SOC_SBX_G2P3_CUCKOO_ID].esize =
        sizeof(soc_sbx_g2p3_cuckoo_t);
    tm->entries[SOC_SBX_G2P3_CUCKOO_ID].nindexes = 2;
    tm->entries[SOC_SBX_G2P3_CUCKOO_ID].nfields = 1;

    tm->entries[SOC_SBX_G2P3_LEFT_ID].name =
        "left";
    tm->entries[SOC_SBX_G2P3_LEFT_ID].table =
        SOC_SBX_G2P3_CUCKOO_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_LEFT_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_left_pack;
    tm->entries[SOC_SBX_G2P3_LEFT_ID].esize =
        sizeof(soc_sbx_g2p3_left_t);
    tm->entries[SOC_SBX_G2P3_LEFT_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_LEFT_ID].nfields = 2;

    tm->entries[SOC_SBX_G2P3_RIGHT_ID].name =
        "right";
    tm->entries[SOC_SBX_G2P3_RIGHT_ID].table =
        SOC_SBX_G2P3_CUCKOO_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_RIGHT_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_right_pack;
    tm->entries[SOC_SBX_G2P3_RIGHT_ID].esize =
        sizeof(soc_sbx_g2p3_right_t);
    tm->entries[SOC_SBX_G2P3_RIGHT_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_RIGHT_ID].nfields = 2;

    tm->entries[SOC_SBX_G2P3_OUTERLABELCUCKOO_ID].name =
        "outerlabelcuckoo";
    tm->entries[SOC_SBX_G2P3_OUTERLABELCUCKOO_ID].table =
        SOC_SBX_G2P3_OUTERLABELCUCKOO_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_OUTERLABELCUCKOO_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_outerlabelcuckoo_pack;
    tm->entries[SOC_SBX_G2P3_OUTERLABELCUCKOO_ID].esize =
        sizeof(soc_sbx_g2p3_outerlabelcuckoo_t);
    tm->entries[SOC_SBX_G2P3_OUTERLABELCUCKOO_ID].nindexes = 2;
    tm->entries[SOC_SBX_G2P3_OUTERLABELCUCKOO_ID].nfields = 1;

    tm->entries[SOC_SBX_G2P3_OUTERLABELLEFT_ID].name =
        "outerlabelleft";
    tm->entries[SOC_SBX_G2P3_OUTERLABELLEFT_ID].table =
        SOC_SBX_G2P3_OUTERLABELCUCKOO_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_OUTERLABELLEFT_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_outerlabelleft_pack;
    tm->entries[SOC_SBX_G2P3_OUTERLABELLEFT_ID].esize =
        sizeof(soc_sbx_g2p3_outerlabelleft_t);
    tm->entries[SOC_SBX_G2P3_OUTERLABELLEFT_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_OUTERLABELLEFT_ID].nfields = 2;

    tm->entries[SOC_SBX_G2P3_OUTERLABELRIGHT_ID].name =
        "outerlabelright";
    tm->entries[SOC_SBX_G2P3_OUTERLABELRIGHT_ID].table =
        SOC_SBX_G2P3_OUTERLABELCUCKOO_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_OUTERLABELRIGHT_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_outerlabelright_pack;
    tm->entries[SOC_SBX_G2P3_OUTERLABELRIGHT_ID].esize =
        sizeof(soc_sbx_g2p3_outerlabelright_t);
    tm->entries[SOC_SBX_G2P3_OUTERLABELRIGHT_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_OUTERLABELRIGHT_ID].nfields = 2;

    tm->entries[SOC_SBX_G2P3_INNERLABELCUCKOO_ID].name =
        "innerlabelcuckoo";
    tm->entries[SOC_SBX_G2P3_INNERLABELCUCKOO_ID].table =
        SOC_SBX_G2P3_INNERLABELCUCKOO_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_INNERLABELCUCKOO_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_innerlabelcuckoo_pack;
    tm->entries[SOC_SBX_G2P3_INNERLABELCUCKOO_ID].esize =
        sizeof(soc_sbx_g2p3_innerlabelcuckoo_t);
    tm->entries[SOC_SBX_G2P3_INNERLABELCUCKOO_ID].nindexes = 2;
    tm->entries[SOC_SBX_G2P3_INNERLABELCUCKOO_ID].nfields = 1;

    tm->entries[SOC_SBX_G2P3_INNERLABELLEFT_ID].name =
        "innerlabelleft";
    tm->entries[SOC_SBX_G2P3_INNERLABELLEFT_ID].table =
        SOC_SBX_G2P3_INNERLABELCUCKOO_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_INNERLABELLEFT_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_innerlabelleft_pack;
    tm->entries[SOC_SBX_G2P3_INNERLABELLEFT_ID].esize =
        sizeof(soc_sbx_g2p3_innerlabelleft_t);
    tm->entries[SOC_SBX_G2P3_INNERLABELLEFT_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_INNERLABELLEFT_ID].nfields = 2;

    tm->entries[SOC_SBX_G2P3_INNERLABELRIGHT_ID].name =
        "innerlabelright";
    tm->entries[SOC_SBX_G2P3_INNERLABELRIGHT_ID].table =
        SOC_SBX_G2P3_INNERLABELCUCKOO_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_INNERLABELRIGHT_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_innerlabelright_pack;
    tm->entries[SOC_SBX_G2P3_INNERLABELRIGHT_ID].esize =
        sizeof(soc_sbx_g2p3_innerlabelright_t);
    tm->entries[SOC_SBX_G2P3_INNERLABELRIGHT_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_INNERLABELRIGHT_ID].nfields = 2;

    tm->entries[SOC_SBX_G2P3_LABEL2E_ID].name =
        "label2e";
    tm->entries[SOC_SBX_G2P3_LABEL2E_ID].table =
        SOC_SBX_G2P3_TABLE_MAX_ID;
    tm->entries[SOC_SBX_G2P3_LABEL2E_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_label2e_pack;
    tm->entries[SOC_SBX_G2P3_LABEL2E_ID].esize =
        sizeof(soc_sbx_g2p3_label2e_t);
    tm->entries[SOC_SBX_G2P3_LABEL2E_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_LABEL2E_ID].nfields = 11;

    tm->entries[SOC_SBX_G2P3_TAGGED_MPLS_ID].name =
        "tagged_mpls";
    tm->entries[SOC_SBX_G2P3_TAGGED_MPLS_ID].table =
        SOC_SBX_G2P3_TABLE_MAX_ID;
    tm->entries[SOC_SBX_G2P3_TAGGED_MPLS_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_tagged_mpls_pack;
    tm->entries[SOC_SBX_G2P3_TAGGED_MPLS_ID].esize =
        sizeof(soc_sbx_g2p3_tagged_mpls_t);
    tm->entries[SOC_SBX_G2P3_TAGGED_MPLS_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_TAGGED_MPLS_ID].nfields = 1;

    tm->entries[SOC_SBX_G2P3_V2E_ID].name =
        "v2e";
    tm->entries[SOC_SBX_G2P3_V2E_ID].table =
        SOC_SBX_G2P3_V2E_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_V2E_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_v2e_pack;
    tm->entries[SOC_SBX_G2P3_V2E_ID].esize =
        sizeof(soc_sbx_g2p3_v2e_t);
    tm->entries[SOC_SBX_G2P3_V2E_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_V2E_ID].nfields = 11;

    tm->entries[SOC_SBX_G2P3_V2E1_ID].name =
        "v2e1";
    tm->entries[SOC_SBX_G2P3_V2E1_ID].table =
        SOC_SBX_G2P3_V2E1_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_V2E1_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_v2e1_pack;
    tm->entries[SOC_SBX_G2P3_V2E1_ID].esize =
        sizeof(soc_sbx_g2p3_v2e1_t);
    tm->entries[SOC_SBX_G2P3_V2E1_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_V2E1_ID].nfields = 4;

    tm->entries[SOC_SBX_G2P3_LP_ID].name =
        "lp";
    tm->entries[SOC_SBX_G2P3_LP_ID].table =
        SOC_SBX_G2P3_LP_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_LP_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_lp_pack;
    tm->entries[SOC_SBX_G2P3_LP_ID].esize =
        sizeof(soc_sbx_g2p3_lp_t);
    tm->entries[SOC_SBX_G2P3_LP_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_LP_ID].nfields = 20;

    tm->entries[SOC_SBX_G2P3_L2E_ID].name =
        "l2e";
    tm->entries[SOC_SBX_G2P3_L2E_ID].table =
        SOC_SBX_G2P3_L2E_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_L2E_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_l2e_pack;
    tm->entries[SOC_SBX_G2P3_L2E_ID].esize =
        sizeof(soc_sbx_g2p3_l2e_t);
    tm->entries[SOC_SBX_G2P3_L2E_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_L2E_ID].nfields = 7;

    tm->entries[SOC_SBX_G2P3_L2CP_ID].name =
        "l2cp";
    tm->entries[SOC_SBX_G2P3_L2CP_ID].table =
        SOC_SBX_G2P3_L2CP_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_L2CP_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_l2cp_pack;
    tm->entries[SOC_SBX_G2P3_L2CP_ID].esize =
        sizeof(soc_sbx_g2p3_l2cp_t);
    tm->entries[SOC_SBX_G2P3_L2CP_ID].nindexes = 2;
    tm->entries[SOC_SBX_G2P3_L2CP_ID].nfields = 4;

    tm->entries[SOC_SBX_G2P3_L2CPSLOW_ID].name =
        "l2cpslow";
    tm->entries[SOC_SBX_G2P3_L2CPSLOW_ID].table =
        SOC_SBX_G2P3_L2CPSLOW_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_L2CPSLOW_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_l2cpslow_pack;
    tm->entries[SOC_SBX_G2P3_L2CPSLOW_ID].esize =
        sizeof(soc_sbx_g2p3_l2cpslow_t);
    tm->entries[SOC_SBX_G2P3_L2CPSLOW_ID].nindexes = 2;
    tm->entries[SOC_SBX_G2P3_L2CPSLOW_ID].nfields = 4;

    tm->entries[SOC_SBX_G2P3_L2CPNOP_ID].name =
        "l2cpnop";
    tm->entries[SOC_SBX_G2P3_L2CPNOP_ID].table =
        SOC_SBX_G2P3_L2CPNOP_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_L2CPNOP_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_l2cpnop_pack;
    tm->entries[SOC_SBX_G2P3_L2CPNOP_ID].esize =
        sizeof(soc_sbx_g2p3_l2cpnop_t);
    tm->entries[SOC_SBX_G2P3_L2CPNOP_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_L2CPNOP_ID].nfields = 4;

    tm->entries[SOC_SBX_G2P3_FT_ID].name =
        "ft";
    tm->entries[SOC_SBX_G2P3_FT_ID].table =
        SOC_SBX_G2P3_FT_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_FT_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ft_pack;
    tm->entries[SOC_SBX_G2P3_FT_ID].esize =
        sizeof(soc_sbx_g2p3_ft_t);
    tm->entries[SOC_SBX_G2P3_FT_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_FT_ID].nfields = 16;

    tm->entries[SOC_SBX_G2P3_OAMTIMERCALENDAR_ID].name =
        "OamTimerCalendar";
    tm->entries[SOC_SBX_G2P3_OAMTIMERCALENDAR_ID].table =
        SOC_SBX_G2P3_OAMTIMERCALENDAR_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_OAMTIMERCALENDAR_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_oamtimercalendar_pack;
    tm->entries[SOC_SBX_G2P3_OAMTIMERCALENDAR_ID].esize =
        sizeof(soc_sbx_g2p3_oamtimercalendar_t);
    tm->entries[SOC_SBX_G2P3_OAMTIMERCALENDAR_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_OAMTIMERCALENDAR_ID].nfields = 3;

    tm->entries[SOC_SBX_G2P3_OAMPORTMDLEVEL2ETC_ID].name =
        "OamPortMdLevel2Etc";
    tm->entries[SOC_SBX_G2P3_OAMPORTMDLEVEL2ETC_ID].table =
        SOC_SBX_G2P3_OAMPORTMDLEVEL2ETC_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_OAMPORTMDLEVEL2ETC_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_oamportmdlevel2etc_pack;
    tm->entries[SOC_SBX_G2P3_OAMPORTMDLEVEL2ETC_ID].esize =
        sizeof(soc_sbx_g2p3_oamportmdlevel2etc_t);
    tm->entries[SOC_SBX_G2P3_OAMPORTMDLEVEL2ETC_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_OAMPORTMDLEVEL2ETC_ID].nfields = 3;

    tm->entries[SOC_SBX_G2P3_V4UC_STR_SEL_ID].name =
        "v4uc_str_sel";
    tm->entries[SOC_SBX_G2P3_V4UC_STR_SEL_ID].table =
        SOC_SBX_G2P3_TABLE_MAX_ID;
    tm->entries[SOC_SBX_G2P3_V4UC_STR_SEL_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_v4uc_str_sel_pack;
    tm->entries[SOC_SBX_G2P3_V4UC_STR_SEL_ID].esize =
        sizeof(soc_sbx_g2p3_v4uc_str_sel_t);
    tm->entries[SOC_SBX_G2P3_V4UC_STR_SEL_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_V4UC_STR_SEL_ID].nfields = 1;

    tm->entries[SOC_SBX_G2P3_CMAC_ID].name =
        "cmac";
    tm->entries[SOC_SBX_G2P3_CMAC_ID].table =
        SOC_SBX_G2P3_TABLE_MAX_ID;
    tm->entries[SOC_SBX_G2P3_CMAC_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_cmac_pack;
    tm->entries[SOC_SBX_G2P3_CMAC_ID].esize =
        sizeof(soc_sbx_g2p3_cmac_t);
    tm->entries[SOC_SBX_G2P3_CMAC_ID].nindexes = 2;
    tm->entries[SOC_SBX_G2P3_CMAC_ID].nfields = 7;

    tm->entries[SOC_SBX_G2P3_BMAC_ID].name =
        "bmac";
    tm->entries[SOC_SBX_G2P3_BMAC_ID].table =
        SOC_SBX_G2P3_TABLE_MAX_ID;
    tm->entries[SOC_SBX_G2P3_BMAC_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_bmac_pack;
    tm->entries[SOC_SBX_G2P3_BMAC_ID].esize =
        sizeof(soc_sbx_g2p3_bmac_t);
    tm->entries[SOC_SBX_G2P3_BMAC_ID].nindexes = 2;
    tm->entries[SOC_SBX_G2P3_BMAC_ID].nfields = 3;

    tm->entries[SOC_SBX_G2P3_IPV6MCSG_ID].name =
        "ipv6mcsg";
    tm->entries[SOC_SBX_G2P3_IPV6MCSG_ID].table =
        SOC_SBX_G2P3_IPV6MCSG_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_IPV6MCSG_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ipv6mcsg_pack;
    tm->entries[SOC_SBX_G2P3_IPV6MCSG_ID].esize =
        sizeof(soc_sbx_g2p3_ipv6mcsg_t);
    tm->entries[SOC_SBX_G2P3_IPV6MCSG_ID].nindexes = 3;
    tm->entries[SOC_SBX_G2P3_IPV6MCSG_ID].nfields = 3;

    tm->entries[SOC_SBX_G2P3_IPV6MCSGL1_ID].name =
        "ipv6mcsgl1";
    tm->entries[SOC_SBX_G2P3_IPV6MCSGL1_ID].table =
        SOC_SBX_G2P3_IPV6MCSG_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_IPV6MCSGL1_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ipv6mcsgl1_pack;
    tm->entries[SOC_SBX_G2P3_IPV6MCSGL1_ID].esize =
        sizeof(soc_sbx_g2p3_ipv6mcsgl1_t);
    tm->entries[SOC_SBX_G2P3_IPV6MCSGL1_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_IPV6MCSGL1_ID].nfields = 3;

    tm->entries[SOC_SBX_G2P3_IPV6MCSGL2_ID].name =
        "ipv6mcsgl2";
    tm->entries[SOC_SBX_G2P3_IPV6MCSGL2_ID].table =
        SOC_SBX_G2P3_IPV6MCSG_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_IPV6MCSGL2_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ipv6mcsgl2_pack;
    tm->entries[SOC_SBX_G2P3_IPV6MCSGL2_ID].esize =
        sizeof(soc_sbx_g2p3_ipv6mcsgl2_t);
    tm->entries[SOC_SBX_G2P3_IPV6MCSGL2_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_IPV6MCSGL2_ID].nfields = 6;

    tm->entries[SOC_SBX_G2P3_IPV6MCG_ID].name =
        "ipv6mcg";
    tm->entries[SOC_SBX_G2P3_IPV6MCG_ID].table =
        SOC_SBX_G2P3_IPV6MCG_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_IPV6MCG_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ipv6mcg_pack;
    tm->entries[SOC_SBX_G2P3_IPV6MCG_ID].esize =
        sizeof(soc_sbx_g2p3_ipv6mcg_t);
    tm->entries[SOC_SBX_G2P3_IPV6MCG_ID].nindexes = 2;
    tm->entries[SOC_SBX_G2P3_IPV6MCG_ID].nfields = 3;

    tm->entries[SOC_SBX_G2P3_IPV6MCGL1_ID].name =
        "ipv6mcgl1";
    tm->entries[SOC_SBX_G2P3_IPV6MCGL1_ID].table =
        SOC_SBX_G2P3_IPV6MCG_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_IPV6MCGL1_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ipv6mcgl1_pack;
    tm->entries[SOC_SBX_G2P3_IPV6MCGL1_ID].esize =
        sizeof(soc_sbx_g2p3_ipv6mcgl1_t);
    tm->entries[SOC_SBX_G2P3_IPV6MCGL1_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_IPV6MCGL1_ID].nfields = 3;

    tm->entries[SOC_SBX_G2P3_IPV6MCGL2_ID].name =
        "ipv6mcgl2";
    tm->entries[SOC_SBX_G2P3_IPV6MCGL2_ID].table =
        SOC_SBX_G2P3_IPV6MCG_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_IPV6MCGL2_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ipv6mcgl2_pack;
    tm->entries[SOC_SBX_G2P3_IPV6MCGL2_ID].esize =
        sizeof(soc_sbx_g2p3_ipv6mcgl2_t);
    tm->entries[SOC_SBX_G2P3_IPV6MCGL2_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_IPV6MCGL2_ID].nfields = 5;

    tm->entries[SOC_SBX_G2P3_IPV4MCG_ID].name =
        "ipv4mcg";
    tm->entries[SOC_SBX_G2P3_IPV4MCG_ID].table =
        SOC_SBX_G2P3_IPV4MCG_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_IPV4MCG_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ipv4mcg_pack;
    tm->entries[SOC_SBX_G2P3_IPV4MCG_ID].esize =
        sizeof(soc_sbx_g2p3_ipv4mcg_t);
    tm->entries[SOC_SBX_G2P3_IPV4MCG_ID].nindexes = 2;
    tm->entries[SOC_SBX_G2P3_IPV4MCG_ID].nfields = 3;

    tm->entries[SOC_SBX_G2P3_IPV4MCGL1_ID].name =
        "ipv4mcgl1";
    tm->entries[SOC_SBX_G2P3_IPV4MCGL1_ID].table =
        SOC_SBX_G2P3_IPV4MCG_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_IPV4MCGL1_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ipv4mcgl1_pack;
    tm->entries[SOC_SBX_G2P3_IPV4MCGL1_ID].esize =
        sizeof(soc_sbx_g2p3_ipv4mcgl1_t);
    tm->entries[SOC_SBX_G2P3_IPV4MCGL1_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_IPV4MCGL1_ID].nfields = 3;

    tm->entries[SOC_SBX_G2P3_IPV4MCGL2_ID].name =
        "ipv4mcgl2";
    tm->entries[SOC_SBX_G2P3_IPV4MCGL2_ID].table =
        SOC_SBX_G2P3_IPV4MCG_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_IPV4MCGL2_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ipv4mcgl2_pack;
    tm->entries[SOC_SBX_G2P3_IPV4MCGL2_ID].esize =
        sizeof(soc_sbx_g2p3_ipv4mcgl2_t);
    tm->entries[SOC_SBX_G2P3_IPV4MCGL2_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_IPV4MCGL2_ID].nfields = 5;

    tm->entries[SOC_SBX_G2P3_IPV4MCSG_ID].name =
        "ipv4mcsg";
    tm->entries[SOC_SBX_G2P3_IPV4MCSG_ID].table =
        SOC_SBX_G2P3_IPV4MCSG_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_IPV4MCSG_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ipv4mcsg_pack;
    tm->entries[SOC_SBX_G2P3_IPV4MCSG_ID].esize =
        sizeof(soc_sbx_g2p3_ipv4mcsg_t);
    tm->entries[SOC_SBX_G2P3_IPV4MCSG_ID].nindexes = 3;
    tm->entries[SOC_SBX_G2P3_IPV4MCSG_ID].nfields = 3;

    tm->entries[SOC_SBX_G2P3_IPV4MCSGL1_ID].name =
        "ipv4mcsgl1";
    tm->entries[SOC_SBX_G2P3_IPV4MCSGL1_ID].table =
        SOC_SBX_G2P3_IPV4MCSG_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_IPV4MCSGL1_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ipv4mcsgl1_pack;
    tm->entries[SOC_SBX_G2P3_IPV4MCSGL1_ID].esize =
        sizeof(soc_sbx_g2p3_ipv4mcsgl1_t);
    tm->entries[SOC_SBX_G2P3_IPV4MCSGL1_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_IPV4MCSGL1_ID].nfields = 3;

    tm->entries[SOC_SBX_G2P3_IPV4MCSGL2_ID].name =
        "ipv4mcsgl2";
    tm->entries[SOC_SBX_G2P3_IPV4MCSGL2_ID].table =
        SOC_SBX_G2P3_IPV4MCSG_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_IPV4MCSGL2_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ipv4mcsgl2_pack;
    tm->entries[SOC_SBX_G2P3_IPV4MCSGL2_ID].esize =
        sizeof(soc_sbx_g2p3_ipv4mcsgl2_t);
    tm->entries[SOC_SBX_G2P3_IPV4MCSGL2_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_IPV4MCSGL2_ID].nfields = 6;

    tm->entries[SOC_SBX_G2P3_LPMNODE_ID].name =
        "lpmnode";
    tm->entries[SOC_SBX_G2P3_LPMNODE_ID].table =
        SOC_SBX_G2P3_TABLE_MAX_ID;
    tm->entries[SOC_SBX_G2P3_LPMNODE_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_lpmnode_pack;
    tm->entries[SOC_SBX_G2P3_LPMNODE_ID].esize =
        sizeof(soc_sbx_g2p3_lpmnode_t);
    tm->entries[SOC_SBX_G2P3_LPMNODE_ID].nindexes = 0;
    tm->entries[SOC_SBX_G2P3_LPMNODE_ID].nfields = 4;

    tm->entries[SOC_SBX_G2P3_IPV4SA_ID].name =
        "ipv4sa";
    tm->entries[SOC_SBX_G2P3_IPV4SA_ID].table =
        SOC_SBX_G2P3_IPV4SA_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_IPV4SA_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ipv4sa_pack;
    tm->entries[SOC_SBX_G2P3_IPV4SA_ID].esize =
        sizeof(soc_sbx_g2p3_ipv4sa_t);
    tm->entries[SOC_SBX_G2P3_IPV4SA_ID].nindexes = 3;
    tm->entries[SOC_SBX_G2P3_IPV4SA_ID].nfields = 4;

    tm->entries[SOC_SBX_G2P3_IPV4SAL0_ID].name =
        "ipv4sal0";
    tm->entries[SOC_SBX_G2P3_IPV4SAL0_ID].table =
        SOC_SBX_G2P3_IPV4SA_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_IPV4SAL0_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ipv4sal0_pack;
    tm->entries[SOC_SBX_G2P3_IPV4SAL0_ID].esize =
        sizeof(soc_sbx_g2p3_ipv4sal0_t);
    tm->entries[SOC_SBX_G2P3_IPV4SAL0_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_IPV4SAL0_ID].nfields = 4;

    tm->entries[SOC_SBX_G2P3_IPV4SAODD_ID].name =
        "ipv4saodd";
    tm->entries[SOC_SBX_G2P3_IPV4SAODD_ID].table =
        SOC_SBX_G2P3_IPV4SA_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_IPV4SAODD_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ipv4saodd_pack;
    tm->entries[SOC_SBX_G2P3_IPV4SAODD_ID].esize =
        sizeof(soc_sbx_g2p3_ipv4saodd_t);
    tm->entries[SOC_SBX_G2P3_IPV4SAODD_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_IPV4SAODD_ID].nfields = 4;

    tm->entries[SOC_SBX_G2P3_IPV4SAEVEN_ID].name =
        "ipv4saeven";
    tm->entries[SOC_SBX_G2P3_IPV4SAEVEN_ID].table =
        SOC_SBX_G2P3_IPV4SA_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_IPV4SAEVEN_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ipv4saeven_pack;
    tm->entries[SOC_SBX_G2P3_IPV4SAEVEN_ID].esize =
        sizeof(soc_sbx_g2p3_ipv4saeven_t);
    tm->entries[SOC_SBX_G2P3_IPV4SAEVEN_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_IPV4SAEVEN_ID].nfields = 4;

    tm->entries[SOC_SBX_G2P3_IPV4SAPAYLOAD_ID].name =
        "ipv4sapayload";
    tm->entries[SOC_SBX_G2P3_IPV4SAPAYLOAD_ID].table =
        SOC_SBX_G2P3_IPV4SA_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_IPV4SAPAYLOAD_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ipv4sapayload_pack;
    tm->entries[SOC_SBX_G2P3_IPV4SAPAYLOAD_ID].esize =
        sizeof(soc_sbx_g2p3_ipv4sapayload_t);
    tm->entries[SOC_SBX_G2P3_IPV4SAPAYLOAD_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_IPV4SAPAYLOAD_ID].nfields = 4;

    tm->entries[SOC_SBX_G2P3_IFP_ID].name =
        "ifp";
    tm->entries[SOC_SBX_G2P3_IFP_ID].table =
        SOC_SBX_G2P3_TABLE_MAX_ID;
    tm->entries[SOC_SBX_G2P3_IFP_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ifp_pack;
    tm->entries[SOC_SBX_G2P3_IFP_ID].esize =
        sizeof(soc_sbx_g2p3_ifp_t);
    tm->entries[SOC_SBX_G2P3_IFP_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_IFP_ID].nfields = 68;

    tm->entries[SOC_SBX_G2P3_IFP_V6_ID].name =
        "ifp_v6";
    tm->entries[SOC_SBX_G2P3_IFP_V6_ID].table =
        SOC_SBX_G2P3_TABLE_MAX_ID;
    tm->entries[SOC_SBX_G2P3_IFP_V6_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ifp_v6_pack;
    tm->entries[SOC_SBX_G2P3_IFP_V6_ID].esize =
        sizeof(soc_sbx_g2p3_ifp_v6_t);
    tm->entries[SOC_SBX_G2P3_IFP_V6_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_IFP_V6_ID].nfields = 47;

    tm->entries[SOC_SBX_G2P3_EVP2E_ID].name =
        "evp2e";
    tm->entries[SOC_SBX_G2P3_EVP2E_ID].table =
        SOC_SBX_G2P3_EVP2E_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_EVP2E_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_evp2e_pack;
    tm->entries[SOC_SBX_G2P3_EVP2E_ID].esize =
        sizeof(soc_sbx_g2p3_evp2e_t);
    tm->entries[SOC_SBX_G2P3_EVP2E_ID].nindexes = 2;
    tm->entries[SOC_SBX_G2P3_EVP2E_ID].nfields = 5;

    tm->entries[SOC_SBX_G2P3_OI2E_ID].name =
        "oi2e";
    tm->entries[SOC_SBX_G2P3_OI2E_ID].table =
        SOC_SBX_G2P3_OI2E_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_OI2E_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_oi2e_pack;
    tm->entries[SOC_SBX_G2P3_OI2E_ID].esize =
        sizeof(soc_sbx_g2p3_oi2e_t);
    tm->entries[SOC_SBX_G2P3_OI2E_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_OI2E_ID].nfields = 5;

    tm->entries[SOC_SBX_G2P3_ETEENCAP_ID].name =
        "eteencap";
    tm->entries[SOC_SBX_G2P3_ETEENCAP_ID].table =
        SOC_SBX_G2P3_ETE_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_ETEENCAP_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_eteencap_pack;
    tm->entries[SOC_SBX_G2P3_ETEENCAP_ID].esize =
        sizeof(soc_sbx_g2p3_eteencap_t);
    tm->entries[SOC_SBX_G2P3_ETEENCAP_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_ETEENCAP_ID].nfields = 56;

    tm->entries[SOC_SBX_G2P3_ETEL2_ID].name =
        "etel2";
    tm->entries[SOC_SBX_G2P3_ETEL2_ID].table =
        SOC_SBX_G2P3_ETE_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_ETEL2_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_etel2_pack;
    tm->entries[SOC_SBX_G2P3_ETEL2_ID].esize =
        sizeof(soc_sbx_g2p3_etel2_t);
    tm->entries[SOC_SBX_G2P3_ETEL2_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_ETEL2_ID].nfields = 15;

    tm->entries[SOC_SBX_G2P3_OAMEP_ID].name =
        "oamEp";
    tm->entries[SOC_SBX_G2P3_OAMEP_ID].table =
        SOC_SBX_G2P3_OAMEP_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_OAMEP_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_oamep_pack;
    tm->entries[SOC_SBX_G2P3_OAMEP_ID].esize =
        sizeof(soc_sbx_g2p3_oamep_t);
    tm->entries[SOC_SBX_G2P3_OAMEP_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_OAMEP_ID].nfields = 88;

    tm->entries[SOC_SBX_G2P3_REMARK_ID].name =
        "remark";
    tm->entries[SOC_SBX_G2P3_REMARK_ID].table =
        SOC_SBX_G2P3_REMARK_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_REMARK_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_remark_pack;
    tm->entries[SOC_SBX_G2P3_REMARK_ID].esize =
        sizeof(soc_sbx_g2p3_remark_t);
    tm->entries[SOC_SBX_G2P3_REMARK_ID].nindexes = 4;
    tm->entries[SOC_SBX_G2P3_REMARK_ID].nfields = 4;

    tm->entries[SOC_SBX_G2P3_EPV2E_ID].name =
        "epv2e";
    tm->entries[SOC_SBX_G2P3_EPV2E_ID].table =
        SOC_SBX_G2P3_EPV2E_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_EPV2E_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_epv2e_pack;
    tm->entries[SOC_SBX_G2P3_EPV2E_ID].esize =
        sizeof(soc_sbx_g2p3_epv2e_t);
    tm->entries[SOC_SBX_G2P3_EPV2E_ID].nindexes = 2;
    tm->entries[SOC_SBX_G2P3_EPV2E_ID].nfields = 2;

    tm->entries[SOC_SBX_G2P3_ESMAC_ID].name =
        "esmac";
    tm->entries[SOC_SBX_G2P3_ESMAC_ID].table =
        SOC_SBX_G2P3_ESMAC_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_ESMAC_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_esmac_pack;
    tm->entries[SOC_SBX_G2P3_ESMAC_ID].esize =
        sizeof(soc_sbx_g2p3_esmac_t);
    tm->entries[SOC_SBX_G2P3_ESMAC_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_ESMAC_ID].nfields = 6;

    tm->entries[SOC_SBX_G2P3_ERT_ID].name =
        "ert";
    tm->entries[SOC_SBX_G2P3_ERT_ID].table =
        SOC_SBX_G2P3_ERT_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_ERT_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ert_pack;
    tm->entries[SOC_SBX_G2P3_ERT_ID].esize =
        sizeof(soc_sbx_g2p3_ert_t);
    tm->entries[SOC_SBX_G2P3_ERT_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_ERT_ID].nfields = 2;

    tm->entries[SOC_SBX_G2P3_ERT_WRAP_ID].name =
        "ert_wrap";
    tm->entries[SOC_SBX_G2P3_ERT_WRAP_ID].table =
        SOC_SBX_G2P3_TABLE_MAX_ID;
    tm->entries[SOC_SBX_G2P3_ERT_WRAP_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ert_wrap_pack;
    tm->entries[SOC_SBX_G2P3_ERT_WRAP_ID].esize =
        sizeof(soc_sbx_g2p3_ert_wrap_t);
    tm->entries[SOC_SBX_G2P3_ERT_WRAP_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_ERT_WRAP_ID].nfields = 2;

    tm->entries[SOC_SBX_G2P3_V4MC_STR_SEL_ID].name =
        "v4mc_str_sel";
    tm->entries[SOC_SBX_G2P3_V4MC_STR_SEL_ID].table =
        SOC_SBX_G2P3_TABLE_MAX_ID;
    tm->entries[SOC_SBX_G2P3_V4MC_STR_SEL_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_v4mc_str_sel_pack;
    tm->entries[SOC_SBX_G2P3_V4MC_STR_SEL_ID].esize =
        sizeof(soc_sbx_g2p3_v4mc_str_sel_t);
    tm->entries[SOC_SBX_G2P3_V4MC_STR_SEL_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_V4MC_STR_SEL_ID].nfields = 1;

    tm->entries[SOC_SBX_G2P3_EFP_ID].name =
        "efp";
    tm->entries[SOC_SBX_G2P3_EFP_ID].table =
        SOC_SBX_G2P3_TABLE_MAX_ID;
    tm->entries[SOC_SBX_G2P3_EFP_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_efp_pack;
    tm->entries[SOC_SBX_G2P3_EFP_ID].esize =
        sizeof(soc_sbx_g2p3_efp_t);
    tm->entries[SOC_SBX_G2P3_EFP_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_EFP_ID].nfields = 55;

    tm->entries[SOC_SBX_G2P3_EFP_V6_ID].name =
        "efp_v6";
    tm->entries[SOC_SBX_G2P3_EFP_V6_ID].table =
        SOC_SBX_G2P3_TABLE_MAX_ID;
    tm->entries[SOC_SBX_G2P3_EFP_V6_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_efp_v6_pack;
    tm->entries[SOC_SBX_G2P3_EFP_V6_ID].esize =
        sizeof(soc_sbx_g2p3_efp_v6_t);
    tm->entries[SOC_SBX_G2P3_EFP_V6_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_EFP_V6_ID].nfields = 34;

    tm->entries[SOC_SBX_G2P3_OAMMULTIPLIER_ID].name =
        "oamMultiplier";
    tm->entries[SOC_SBX_G2P3_OAMMULTIPLIER_ID].table =
        SOC_SBX_G2P3_OAMMULTIPLIER_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_OAMMULTIPLIER_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_oammultiplier_pack;
    tm->entries[SOC_SBX_G2P3_OAMMULTIPLIER_ID].esize =
        sizeof(soc_sbx_g2p3_oammultiplier_t);
    tm->entries[SOC_SBX_G2P3_OAMMULTIPLIER_ID].nindexes = 2;
    tm->entries[SOC_SBX_G2P3_OAMMULTIPLIER_ID].nfields = 1;

    tm->entries[SOC_SBX_G2P3_OAMEPREMAP_ID].name =
        "oamEpRemap";
    tm->entries[SOC_SBX_G2P3_OAMEPREMAP_ID].table =
        SOC_SBX_G2P3_OAMEPREMAP_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_OAMEPREMAP_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_oamepremap_pack;
    tm->entries[SOC_SBX_G2P3_OAMEPREMAP_ID].esize =
        sizeof(soc_sbx_g2p3_oamepremap_t);
    tm->entries[SOC_SBX_G2P3_OAMEPREMAP_ID].nindexes = 3;
    tm->entries[SOC_SBX_G2P3_OAMEPREMAP_ID].nfields = 1;

    tm->entries[SOC_SBX_G2P3_IPV6DA_ID].name =
        "ipv6da";
    tm->entries[SOC_SBX_G2P3_IPV6DA_ID].table =
        SOC_SBX_G2P3_IPV6DA_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_IPV6DA_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ipv6da_pack;
    tm->entries[SOC_SBX_G2P3_IPV6DA_ID].esize =
        sizeof(soc_sbx_g2p3_ipv6da_t);
    tm->entries[SOC_SBX_G2P3_IPV6DA_ID].nindexes = 2;
    tm->entries[SOC_SBX_G2P3_IPV6DA_ID].nfields = 3;

    tm->entries[SOC_SBX_G2P3_IPV6DAL0_ID].name =
        "ipv6dal0";
    tm->entries[SOC_SBX_G2P3_IPV6DAL0_ID].table =
        SOC_SBX_G2P3_IPV6DA_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_IPV6DAL0_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ipv6dal0_pack;
    tm->entries[SOC_SBX_G2P3_IPV6DAL0_ID].esize =
        sizeof(soc_sbx_g2p3_ipv6dal0_t);
    tm->entries[SOC_SBX_G2P3_IPV6DAL0_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_IPV6DAL0_ID].nfields = 4;

    tm->entries[SOC_SBX_G2P3_IPV6DAODD_ID].name =
        "ipv6daodd";
    tm->entries[SOC_SBX_G2P3_IPV6DAODD_ID].table =
        SOC_SBX_G2P3_IPV6DA_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_IPV6DAODD_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ipv6daodd_pack;
    tm->entries[SOC_SBX_G2P3_IPV6DAODD_ID].esize =
        sizeof(soc_sbx_g2p3_ipv6daodd_t);
    tm->entries[SOC_SBX_G2P3_IPV6DAODD_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_IPV6DAODD_ID].nfields = 4;

    tm->entries[SOC_SBX_G2P3_IPV6DAEVEN_ID].name =
        "ipv6daeven";
    tm->entries[SOC_SBX_G2P3_IPV6DAEVEN_ID].table =
        SOC_SBX_G2P3_IPV6DA_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_IPV6DAEVEN_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ipv6daeven_pack;
    tm->entries[SOC_SBX_G2P3_IPV6DAEVEN_ID].esize =
        sizeof(soc_sbx_g2p3_ipv6daeven_t);
    tm->entries[SOC_SBX_G2P3_IPV6DAEVEN_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_IPV6DAEVEN_ID].nfields = 4;

    tm->entries[SOC_SBX_G2P3_IPV6DAPAYLOAD_ID].name =
        "ipv6dapayload";
    tm->entries[SOC_SBX_G2P3_IPV6DAPAYLOAD_ID].table =
        SOC_SBX_G2P3_IPV6DA_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_IPV6DAPAYLOAD_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ipv6dapayload_pack;
    tm->entries[SOC_SBX_G2P3_IPV6DAPAYLOAD_ID].esize =
        sizeof(soc_sbx_g2p3_ipv6dapayload_t);
    tm->entries[SOC_SBX_G2P3_IPV6DAPAYLOAD_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_IPV6DAPAYLOAD_ID].nfields = 3;

    tm->entries[SOC_SBX_G2P3_IPV6SA_ID].name =
        "ipv6sa";
    tm->entries[SOC_SBX_G2P3_IPV6SA_ID].table =
        SOC_SBX_G2P3_IPV6SA_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_IPV6SA_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ipv6sa_pack;
    tm->entries[SOC_SBX_G2P3_IPV6SA_ID].esize =
        sizeof(soc_sbx_g2p3_ipv6sa_t);
    tm->entries[SOC_SBX_G2P3_IPV6SA_ID].nindexes = 2;
    tm->entries[SOC_SBX_G2P3_IPV6SA_ID].nfields = 4;

    tm->entries[SOC_SBX_G2P3_IPV6SAL0_ID].name =
        "ipv6sal0";
    tm->entries[SOC_SBX_G2P3_IPV6SAL0_ID].table =
        SOC_SBX_G2P3_IPV6SA_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_IPV6SAL0_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ipv6sal0_pack;
    tm->entries[SOC_SBX_G2P3_IPV6SAL0_ID].esize =
        sizeof(soc_sbx_g2p3_ipv6sal0_t);
    tm->entries[SOC_SBX_G2P3_IPV6SAL0_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_IPV6SAL0_ID].nfields = 4;

    tm->entries[SOC_SBX_G2P3_IPV6SAODD_ID].name =
        "ipv6saodd";
    tm->entries[SOC_SBX_G2P3_IPV6SAODD_ID].table =
        SOC_SBX_G2P3_IPV6SA_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_IPV6SAODD_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ipv6saodd_pack;
    tm->entries[SOC_SBX_G2P3_IPV6SAODD_ID].esize =
        sizeof(soc_sbx_g2p3_ipv6saodd_t);
    tm->entries[SOC_SBX_G2P3_IPV6SAODD_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_IPV6SAODD_ID].nfields = 4;

    tm->entries[SOC_SBX_G2P3_IPV6SAEVEN_ID].name =
        "ipv6saeven";
    tm->entries[SOC_SBX_G2P3_IPV6SAEVEN_ID].table =
        SOC_SBX_G2P3_IPV6SA_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_IPV6SAEVEN_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ipv6saeven_pack;
    tm->entries[SOC_SBX_G2P3_IPV6SAEVEN_ID].esize =
        sizeof(soc_sbx_g2p3_ipv6saeven_t);
    tm->entries[SOC_SBX_G2P3_IPV6SAEVEN_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_IPV6SAEVEN_ID].nfields = 4;

    tm->entries[SOC_SBX_G2P3_IPV6SAPAYLOAD_ID].name =
        "ipv6sapayload";
    tm->entries[SOC_SBX_G2P3_IPV6SAPAYLOAD_ID].table =
        SOC_SBX_G2P3_IPV6SA_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_IPV6SAPAYLOAD_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ipv6sapayload_pack;
    tm->entries[SOC_SBX_G2P3_IPV6SAPAYLOAD_ID].esize =
        sizeof(soc_sbx_g2p3_ipv6sapayload_t);
    tm->entries[SOC_SBX_G2P3_IPV6SAPAYLOAD_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_IPV6SAPAYLOAD_ID].nfields = 4;

    tm->entries[SOC_SBX_G2P3_IPV4DA_ID].name =
        "ipv4da";
    tm->entries[SOC_SBX_G2P3_IPV4DA_ID].table =
        SOC_SBX_G2P3_IPV4DA_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_IPV4DA_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ipv4da_pack;
    tm->entries[SOC_SBX_G2P3_IPV4DA_ID].esize =
        sizeof(soc_sbx_g2p3_ipv4da_t);
    tm->entries[SOC_SBX_G2P3_IPV4DA_ID].nindexes = 3;
    tm->entries[SOC_SBX_G2P3_IPV4DA_ID].nfields = 3;

    tm->entries[SOC_SBX_G2P3_IPV4DAL0_ID].name =
        "ipv4dal0";
    tm->entries[SOC_SBX_G2P3_IPV4DAL0_ID].table =
        SOC_SBX_G2P3_IPV4DA_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_IPV4DAL0_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ipv4dal0_pack;
    tm->entries[SOC_SBX_G2P3_IPV4DAL0_ID].esize =
        sizeof(soc_sbx_g2p3_ipv4dal0_t);
    tm->entries[SOC_SBX_G2P3_IPV4DAL0_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_IPV4DAL0_ID].nfields = 4;

    tm->entries[SOC_SBX_G2P3_IPV4DAODD_ID].name =
        "ipv4daodd";
    tm->entries[SOC_SBX_G2P3_IPV4DAODD_ID].table =
        SOC_SBX_G2P3_IPV4DA_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_IPV4DAODD_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ipv4daodd_pack;
    tm->entries[SOC_SBX_G2P3_IPV4DAODD_ID].esize =
        sizeof(soc_sbx_g2p3_ipv4daodd_t);
    tm->entries[SOC_SBX_G2P3_IPV4DAODD_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_IPV4DAODD_ID].nfields = 4;

    tm->entries[SOC_SBX_G2P3_IPV4DAEVEN_ID].name =
        "ipv4daeven";
    tm->entries[SOC_SBX_G2P3_IPV4DAEVEN_ID].table =
        SOC_SBX_G2P3_IPV4DA_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_IPV4DAEVEN_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ipv4daeven_pack;
    tm->entries[SOC_SBX_G2P3_IPV4DAEVEN_ID].esize =
        sizeof(soc_sbx_g2p3_ipv4daeven_t);
    tm->entries[SOC_SBX_G2P3_IPV4DAEVEN_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_IPV4DAEVEN_ID].nfields = 4;

    tm->entries[SOC_SBX_G2P3_IPV4DAPAYLOAD_ID].name =
        "ipv4dapayload";
    tm->entries[SOC_SBX_G2P3_IPV4DAPAYLOAD_ID].table =
        SOC_SBX_G2P3_IPV4DA_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_IPV4DAPAYLOAD_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_ipv4dapayload_pack;
    tm->entries[SOC_SBX_G2P3_IPV4DAPAYLOAD_ID].esize =
        sizeof(soc_sbx_g2p3_ipv4dapayload_t);
    tm->entries[SOC_SBX_G2P3_IPV4DAPAYLOAD_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2P3_IPV4DAPAYLOAD_ID].nfields = 3;

    tm->entries[SOC_SBX_G2P3_P2FTI_ID].name =
        "P2FTI";
    tm->entries[SOC_SBX_G2P3_P2FTI_ID].table =
        SOC_SBX_G2P3_P2FTI_TABLE_ID;
    tm->entries[SOC_SBX_G2P3_P2FTI_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_p2fti_pack;
    tm->entries[SOC_SBX_G2P3_P2FTI_ID].esize =
        sizeof(soc_sbx_g2p3_p2fti_t);
    tm->entries[SOC_SBX_G2P3_P2FTI_ID].nindexes = 2;
    tm->entries[SOC_SBX_G2P3_P2FTI_ID].nfields = 1;

    tm->entries[SOC_SBX_G2P3_POLICER_ID].name =
        "policer";
    tm->entries[SOC_SBX_G2P3_POLICER_ID].table =
        SOC_SBX_G2P3_TABLE_MAX_ID;
    tm->entries[SOC_SBX_G2P3_POLICER_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_policer_pack;
    tm->entries[SOC_SBX_G2P3_POLICER_ID].esize =
        sizeof(soc_sbx_g2p3_policer_t);
    tm->entries[SOC_SBX_G2P3_POLICER_ID].nindexes = 0;
    tm->entries[SOC_SBX_G2P3_POLICER_ID].nfields = 10;

    tm->entries[SOC_SBX_G2P3_TIMER_ID].name =
        "timer";
    tm->entries[SOC_SBX_G2P3_TIMER_ID].table =
        SOC_SBX_G2P3_TABLE_MAX_ID;
    tm->entries[SOC_SBX_G2P3_TIMER_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_timer_pack;
    tm->entries[SOC_SBX_G2P3_TIMER_ID].esize =
        sizeof(soc_sbx_g2p3_timer_t);
    tm->entries[SOC_SBX_G2P3_TIMER_ID].nindexes = 0;
    tm->entries[SOC_SBX_G2P3_TIMER_ID].nfields = 4;

    tm->entries[SOC_SBX_G2P3_SEQUENCE_ID].name =
        "sequence";
    tm->entries[SOC_SBX_G2P3_SEQUENCE_ID].table =
        SOC_SBX_G2P3_TABLE_MAX_ID;
    tm->entries[SOC_SBX_G2P3_SEQUENCE_ID].pack =
        (soc_sbx_g2p3_complex_pack_f_t) soc_sbx_g2p3_sequence_pack;
    tm->entries[SOC_SBX_G2P3_SEQUENCE_ID].esize =
        sizeof(soc_sbx_g2p3_sequence_t);
    tm->entries[SOC_SBX_G2P3_SEQUENCE_ID].nindexes = 0;
    tm->entries[SOC_SBX_G2P3_SEQUENCE_ID].nfields = 1;

    for (i = 0; i < SOC_SBX_G2P3_ENTRY_MAX_ID; i++) {
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &tm->entries[i].nbanks,
                    e,
                    tm->entries[i].name,
                    -1,
                    e,
                    "BANKS");
        if (s) {
            soc_sbx_g2p3_uninit(unit);
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &tm->entries[i].type,
                    e,
                    tm->entries[i].name,
                    -1,
                    e,
                    "TYPE");
        if (s) {
            soc_sbx_g2p3_uninit(unit);
            return s;
        }
        tm->entries[i].epsize = 0;
        for (j = 0; j < tm->entries[i].nbanks; j++) {
            s = soc_sbx_g2p3_ucode_get(unit,
                        soc_sbx_g2p3_sym,
                        128,
                        &tm->entries[i].banks[j].tablebank,
                        e,
                        tm->entries[i].name,
                        j == 0 ? -1 : j,
                        e,
                        "BANK");
            if (s) {
                soc_sbx_g2p3_uninit(unit);
                return s;
            }
            s = soc_sbx_g2p3_ucode_get(unit,
                        soc_sbx_g2p3_sym,
                        128,
                        &tm->entries[i].banks[j].width,
                        e,
                        tm->entries[i].name,
                        j == 0 ? -1 : j,
                        e,
                        "WIDTH");
            if (s) {
                soc_sbx_g2p3_uninit(unit);
                return s;
            }
            tm->entries[i].epsize += tm->entries[i].banks[j].width;
            s = soc_sbx_g2p3_ucode_get(unit,
                        soc_sbx_g2p3_sym,
                        128,
                        &tm->entries[i].banks[j].stridebits,
                        e,
                        tm->entries[i].name,
                        j == 0 ? -1 : j,
                        e,
                        "STRIDE");
            if (s) {
                soc_sbx_g2p3_uninit(unit);
                return s;
            }
            tm->entries[i].totalwidth +=
                tm->entries[i].banks[j].width;
        }

        /*
         * Per-index state initialization
         */
        if (tm->entries[i].nindexes) {
            tm->entries[i].indexes =
                UTG_MALLOC(sizeof(soc_sbx_g2p3_index_desc_t)
                       * tm->entries[i].nindexes);
            if (!tm->entries[i].indexes) {
                soc_sbx_g2p3_uninit(unit);
                return SOC_E_MEMORY;
            }
            sal_memset(tm->entries[i].indexes, 0, 
              (sizeof(soc_sbx_g2p3_index_desc_t) * tm->entries[i].nindexes));
        }

        switch (i) {
        case SOC_SBX_G2P3_P2E_ID:
            tm->entries[i].indexes[0].name = "port";
            break;
        case SOC_SBX_G2P3_EP2E_ID:
            tm->entries[i].indexes[0].name = "port";
            break;
        case SOC_SBX_G2P3_P2E20_ID:
            tm->entries[i].indexes[0].name = "port";
            break;
        case SOC_SBX_G2P3_EP2E20_ID:
            tm->entries[i].indexes[0].name = "port";
            break;
        case SOC_SBX_G2P3_P2E25_ID:
            tm->entries[i].indexes[0].name = "port";
            break;
        case SOC_SBX_G2P3_EP2E25_ID:
            tm->entries[i].indexes[0].name = "port";
            break;
        case SOC_SBX_G2P3_TPID_ID:
            tm->entries[i].indexes[0].name = "tpidi";
            break;
        case SOC_SBX_G2P3_OAM_RX_ID:
            tm->entries[i].indexes[0].name = "rule";
            break;
        case SOC_SBX_G2P3_OAM_TX_ID:
            tm->entries[i].indexes[0].name = "rule";
            break;
        case SOC_SBX_G2P3_LSMAC_ID:
            tm->entries[i].indexes[0].name = "lsi";
            break;
        case SOC_SBX_G2P3_L2CPMAC_ID:
            tm->entries[i].indexes[0].name = "lsi";
            break;
        case SOC_SBX_G2P3_OAMUPMAC_ID:
            tm->entries[i].indexes[0].name = "lsi";
            break;
        case SOC_SBX_G2P3_QOS_ID:
            tm->entries[i].indexes[0].name = "de";
            tm->entries[i].indexes[1].name = "pri";
            tm->entries[i].indexes[2].name = "prof";
            break;
        case SOC_SBX_G2P3_DSCP_QOS_ID:
            tm->entries[i].indexes[0].name = "dscp";
            tm->entries[i].indexes[1].name = "prof";
            break;
        case SOC_SBX_G2P3_IRT_ID:
            tm->entries[i].indexes[0].name = "rule";
            break;
        case SOC_SBX_G2P3_IRT_WRAP_ID:
            tm->entries[i].indexes[0].name = "rule";
            break;
        case SOC_SBX_G2P3_RT_MT_ID:
            tm->entries[i].indexes[0].name = "rule";
            break;
        case SOC_SBX_G2P3_RT_RR0_ID:
            tm->entries[i].indexes[0].name = "rule";
            break;
        case SOC_SBX_G2P3_RT_ID:
            tm->entries[i].indexes[0].name = "rule";
            break;
        case SOC_SBX_G2P3_RT_RR1_ID:
            tm->entries[i].indexes[0].name = "rule";
            break;
        case SOC_SBX_G2P3_LAG_ID:
            tm->entries[i].indexes[0].name = "lagi";
            break;
        case SOC_SBX_G2P3_RR_ID:
            tm->entries[i].indexes[0].name = "rri";
            break;
        case SOC_SBX_G2P3_XT_ID:
            tm->entries[i].indexes[0].name = "xi";
            break;
        case SOC_SBX_G2P3_MIRROR_ID:
            tm->entries[i].indexes[0].name = "mi";
            break;
        case SOC_SBX_G2P3_EMIRROR_ID:
            tm->entries[i].indexes[0].name = "mirror";
            break;
        case SOC_SBX_G2P3_EMIRROR20_ID:
            tm->entries[i].indexes[0].name = "mirror";
            break;
        case SOC_SBX_G2P3_EMIRROR25_ID:
            tm->entries[i].indexes[0].name = "mirror";
            break;
        case SOC_SBX_G2P3_EMLL1_ID:
            break;
        case SOC_SBX_G2P3_MAC_ID:
            tm->entries[i].indexes[0].name = "mac";
            tm->entries[i].indexes[1].name = "vlan";
            tm->entries[i].indexes[2].name = "bmac";
            break;
        case SOC_SBX_G2P3_MACL1_ID:
            tm->entries[i].indexes[0].name = "l1i";
            break;
        case SOC_SBX_G2P3_MACL2_ID:
            tm->entries[i].indexes[0].name = "maci";
            break;
        case SOC_SBX_G2P3_IPV6DHOST_ID:
            tm->entries[i].indexes[0].name = "ip";
            break;
        case SOC_SBX_G2P3_IPV6DHOSTL1_ID:
            tm->entries[i].indexes[0].name = "l1i";
            break;
        case SOC_SBX_G2P3_IPV6DHOSTL2_ID:
            tm->entries[i].indexes[0].name = "hosti";
            break;
        case SOC_SBX_G2P3_MST_ID:
            tm->entries[i].indexes[0].name = "msti";
            break;
        case SOC_SBX_G2P3_PV2E_ID:
            tm->entries[i].indexes[0].name = "vid";
            tm->entries[i].indexes[1].name = "port";
            break;
        case SOC_SBX_G2P3_P2APPDATA_ID:
            tm->entries[i].indexes[0].name = "port";
            break;
        case SOC_SBX_G2P3_PV2APPDATA_ID:
            tm->entries[i].indexes[0].name = "vid";
            tm->entries[i].indexes[1].name = "port";
            break;
        case SOC_SBX_G2P3_IPV6SHOST_ID:
            tm->entries[i].indexes[0].name = "ip";
            break;
        case SOC_SBX_G2P3_IPV6SHOSTL1_ID:
            tm->entries[i].indexes[0].name = "l1i";
            break;
        case SOC_SBX_G2P3_IPV6SHOSTL2_ID:
            tm->entries[i].indexes[0].name = "hosti";
            break;
        case SOC_SBX_G2P3_PVV2E_ID:
            tm->entries[i].indexes[0].name = "ivid";
            tm->entries[i].indexes[1].name = "ovid";
            tm->entries[i].indexes[2].name = "port";
            break;
        case SOC_SBX_G2P3_PVV2EPACK_ID:
            tm->entries[i].indexes[0].name = "ovid";
            tm->entries[i].indexes[1].name = "port";
            tm->entries[i].indexes[2].name = "ivid";
            break;
        case SOC_SBX_G2P3_ISID2E_ID:
            tm->entries[i].indexes[0].name = "isid";
            break;
        case SOC_SBX_G2P3_OAMPVD2E_ID:
            tm->entries[i].indexes[0].name = "port";
            tm->entries[i].indexes[1].name = "vid";
            tm->entries[i].indexes[2].name = "dir";
            tm->entries[i].indexes[3].name = "tag";
            break;
        case SOC_SBX_G2P3_OAMMAIDMEP2E_ID:
            tm->entries[i].indexes[0].name = "maid";
            tm->entries[i].indexes[1].name = "mepid";
            break;
        case SOC_SBX_G2P3_CUCKOO_ID:
            tm->entries[i].indexes[0].name = "key";
            tm->entries[i].indexes[1].name = "type";
            break;
        case SOC_SBX_G2P3_LEFT_ID:
            tm->entries[i].indexes[0].name = "li";
            break;
        case SOC_SBX_G2P3_RIGHT_ID:
            tm->entries[i].indexes[0].name = "ri";
            break;
        case SOC_SBX_G2P3_OUTERLABELCUCKOO_ID:
            tm->entries[i].indexes[0].name = "key";
            tm->entries[i].indexes[1].name = "type";
            break;
        case SOC_SBX_G2P3_OUTERLABELLEFT_ID:
            tm->entries[i].indexes[0].name = "li";
            break;
        case SOC_SBX_G2P3_OUTERLABELRIGHT_ID:
            tm->entries[i].indexes[0].name = "ri";
            break;
        case SOC_SBX_G2P3_INNERLABELCUCKOO_ID:
            tm->entries[i].indexes[0].name = "key";
            tm->entries[i].indexes[1].name = "type";
            break;
        case SOC_SBX_G2P3_INNERLABELLEFT_ID:
            tm->entries[i].indexes[0].name = "li";
            break;
        case SOC_SBX_G2P3_INNERLABELRIGHT_ID:
            tm->entries[i].indexes[0].name = "ri";
            break;
        case SOC_SBX_G2P3_LABEL2E_ID:
            tm->entries[i].indexes[0].name = "label";
            break;
        case SOC_SBX_G2P3_TAGGED_MPLS_ID:
            tm->entries[i].indexes[0].name = "rule";
            break;
        case SOC_SBX_G2P3_V2E_ID:
            tm->entries[i].indexes[0].name = "vlan";
            break;
        case SOC_SBX_G2P3_V2E1_ID:
            tm->entries[i].indexes[0].name = "vlan";
            break;
        case SOC_SBX_G2P3_LP_ID:
            tm->entries[i].indexes[0].name = "lpi";
            break;
        case SOC_SBX_G2P3_L2E_ID:
            tm->entries[i].indexes[0].name = "label";
            break;
        case SOC_SBX_G2P3_L2CP_ID:
            tm->entries[i].indexes[0].name = "lsb";
            tm->entries[i].indexes[1].name = "port";
            break;
        case SOC_SBX_G2P3_L2CPSLOW_ID:
            tm->entries[i].indexes[0].name = "subcode";
            tm->entries[i].indexes[1].name = "port";
            break;
        case SOC_SBX_G2P3_L2CPNOP_ID:
            tm->entries[i].indexes[0].name = "i";
            break;
        case SOC_SBX_G2P3_FT_ID:
            tm->entries[i].indexes[0].name = "fti";
            break;
        case SOC_SBX_G2P3_OAMTIMERCALENDAR_ID:
            tm->entries[i].indexes[0].name = "listMgrIndex";
            break;
        case SOC_SBX_G2P3_OAMPORTMDLEVEL2ETC_ID:
            tm->entries[i].indexes[0].name = "portMd";
            break;
        case SOC_SBX_G2P3_V4UC_STR_SEL_ID:
            tm->entries[i].indexes[0].name = "rule";
            break;
        case SOC_SBX_G2P3_CMAC_ID:
            tm->entries[i].indexes[0].name = "mac";
            tm->entries[i].indexes[1].name = "vlan";
            break;
        case SOC_SBX_G2P3_BMAC_ID:
            tm->entries[i].indexes[0].name = "mac";
            tm->entries[i].indexes[1].name = "vlan";
            break;
        case SOC_SBX_G2P3_IPV6MCSG_ID:
            tm->entries[i].indexes[0].name = "g";
            tm->entries[i].indexes[1].name = "s";
            tm->entries[i].indexes[2].name = "vlan";
            break;
        case SOC_SBX_G2P3_IPV6MCSGL1_ID:
            tm->entries[i].indexes[0].name = "l1i";
            break;
        case SOC_SBX_G2P3_IPV6MCSGL2_ID:
            tm->entries[i].indexes[0].name = "mcgi";
            break;
        case SOC_SBX_G2P3_IPV6MCG_ID:
            tm->entries[i].indexes[0].name = "g";
            tm->entries[i].indexes[1].name = "vlan";
            break;
        case SOC_SBX_G2P3_IPV6MCGL1_ID:
            tm->entries[i].indexes[0].name = "l1i";
            break;
        case SOC_SBX_G2P3_IPV6MCGL2_ID:
            tm->entries[i].indexes[0].name = "mcgi";
            break;
        case SOC_SBX_G2P3_IPV4MCG_ID:
            tm->entries[i].indexes[0].name = "g";
            tm->entries[i].indexes[1].name = "vlan";
            break;
        case SOC_SBX_G2P3_IPV4MCGL1_ID:
            tm->entries[i].indexes[0].name = "l1i";
            break;
        case SOC_SBX_G2P3_IPV4MCGL2_ID:
            tm->entries[i].indexes[0].name = "mcgi";
            break;
        case SOC_SBX_G2P3_IPV4MCSG_ID:
            tm->entries[i].indexes[0].name = "g";
            tm->entries[i].indexes[1].name = "s";
            tm->entries[i].indexes[2].name = "vlan";
            break;
        case SOC_SBX_G2P3_IPV4MCSGL1_ID:
            tm->entries[i].indexes[0].name = "l1i";
            break;
        case SOC_SBX_G2P3_IPV4MCSGL2_ID:
            tm->entries[i].indexes[0].name = "mcgi";
            break;
        case SOC_SBX_G2P3_LPMNODE_ID:
            break;
        case SOC_SBX_G2P3_IPV4SA_ID:
            tm->entries[i].indexes[0].name = "prefixbits";
            tm->entries[i].indexes[1].name = "ip";
            tm->entries[i].indexes[2].name = "ipcxt";
            break;
        case SOC_SBX_G2P3_IPV4SAL0_ID:
            tm->entries[i].indexes[0].name = "addr";
            break;
        case SOC_SBX_G2P3_IPV4SAODD_ID:
            tm->entries[i].indexes[0].name = "addr";
            break;
        case SOC_SBX_G2P3_IPV4SAEVEN_ID:
            tm->entries[i].indexes[0].name = "addr";
            break;
        case SOC_SBX_G2P3_IPV4SAPAYLOAD_ID:
            tm->entries[i].indexes[0].name = "addr";
            break;
        case SOC_SBX_G2P3_IFP_ID:
            tm->entries[i].indexes[0].name = "rule";
            break;
        case SOC_SBX_G2P3_IFP_V6_ID:
            tm->entries[i].indexes[0].name = "rule";
            break;
        case SOC_SBX_G2P3_EVP2E_ID:
            tm->entries[i].indexes[0].name = "vlan";
            tm->entries[i].indexes[1].name = "port";
            break;
        case SOC_SBX_G2P3_OI2E_ID:
            tm->entries[i].indexes[0].name = "oi";
            break;
        case SOC_SBX_G2P3_ETEENCAP_ID:
            tm->entries[i].indexes[0].name = "etei";
            break;
        case SOC_SBX_G2P3_ETEL2_ID:
            tm->entries[i].indexes[0].name = "etei";
            break;
        case SOC_SBX_G2P3_OAMEP_ID:
            tm->entries[i].indexes[0].name = "epIdx";
            break;
        case SOC_SBX_G2P3_REMARK_ID:
            tm->entries[i].indexes[0].name = "e";
            tm->entries[i].indexes[1].name = "dp";
            tm->entries[i].indexes[2].name = "cos";
            tm->entries[i].indexes[3].name = "prof";
            break;
        case SOC_SBX_G2P3_EPV2E_ID:
            tm->entries[i].indexes[0].name = "vid";
            tm->entries[i].indexes[1].name = "port";
            break;
        case SOC_SBX_G2P3_ESMAC_ID:
            tm->entries[i].indexes[0].name = "smaci";
            break;
        case SOC_SBX_G2P3_ERT_ID:
            tm->entries[i].indexes[0].name = "rule";
            break;
        case SOC_SBX_G2P3_ERT_WRAP_ID:
            tm->entries[i].indexes[0].name = "rule";
            break;
        case SOC_SBX_G2P3_V4MC_STR_SEL_ID:
            tm->entries[i].indexes[0].name = "rule";
            break;
        case SOC_SBX_G2P3_EFP_ID:
            tm->entries[i].indexes[0].name = "rule";
            break;
        case SOC_SBX_G2P3_EFP_V6_ID:
            tm->entries[i].indexes[0].name = "rule";
            break;
        case SOC_SBX_G2P3_OAMMULTIPLIER_ID:
            tm->entries[i].indexes[0].name = "lossCount";
            tm->entries[i].indexes[1].name = "threshold";
            break;
        case SOC_SBX_G2P3_OAMEPREMAP_ID:
            tm->entries[i].indexes[0].name = "endpoint";
            tm->entries[i].indexes[1].name = "mdLevel";
            tm->entries[i].indexes[2].name = "type";
            break;
        case SOC_SBX_G2P3_IPV6DA_ID:
            tm->entries[i].indexes[0].name = "prefixbits";
            tm->entries[i].indexes[1].name = "ip";
            break;
        case SOC_SBX_G2P3_IPV6DAL0_ID:
            tm->entries[i].indexes[0].name = "addr";
            break;
        case SOC_SBX_G2P3_IPV6DAODD_ID:
            tm->entries[i].indexes[0].name = "addr";
            break;
        case SOC_SBX_G2P3_IPV6DAEVEN_ID:
            tm->entries[i].indexes[0].name = "addr";
            break;
        case SOC_SBX_G2P3_IPV6DAPAYLOAD_ID:
            tm->entries[i].indexes[0].name = "addr";
            break;
        case SOC_SBX_G2P3_IPV6SA_ID:
            tm->entries[i].indexes[0].name = "prefixbits";
            tm->entries[i].indexes[1].name = "ip";
            break;
        case SOC_SBX_G2P3_IPV6SAL0_ID:
            tm->entries[i].indexes[0].name = "addr";
            break;
        case SOC_SBX_G2P3_IPV6SAODD_ID:
            tm->entries[i].indexes[0].name = "addr";
            break;
        case SOC_SBX_G2P3_IPV6SAEVEN_ID:
            tm->entries[i].indexes[0].name = "addr";
            break;
        case SOC_SBX_G2P3_IPV6SAPAYLOAD_ID:
            tm->entries[i].indexes[0].name = "addr";
            break;
        case SOC_SBX_G2P3_IPV4DA_ID:
            tm->entries[i].indexes[0].name = "prefixbits";
            tm->entries[i].indexes[1].name = "ip";
            tm->entries[i].indexes[2].name = "ipcxt";
            break;
        case SOC_SBX_G2P3_IPV4DAL0_ID:
            tm->entries[i].indexes[0].name = "addr";
            break;
        case SOC_SBX_G2P3_IPV4DAODD_ID:
            tm->entries[i].indexes[0].name = "addr";
            break;
        case SOC_SBX_G2P3_IPV4DAEVEN_ID:
            tm->entries[i].indexes[0].name = "addr";
            break;
        case SOC_SBX_G2P3_IPV4DAPAYLOAD_ID:
            tm->entries[i].indexes[0].name = "addr";
            break;
        case SOC_SBX_G2P3_P2FTI_ID:
            tm->entries[i].indexes[0].name = "port";
            tm->entries[i].indexes[1].name = "dmac";
            break;
        case SOC_SBX_G2P3_POLICER_ID:
            break;
        case SOC_SBX_G2P3_TIMER_ID:
            break;
        case SOC_SBX_G2P3_SEQUENCE_ID:
            break;
        }

        for (j = 0; j < tm->entries[i].nindexes; j++) {
            s = soc_sbx_g2p3_ucode_get(unit,
                        soc_sbx_g2p3_sym,
                        128,
                        &tm->entries[i].indexes[j].pos,
                        e,
                        tm->entries[i].name,
                        -1,
                        tm->entries[i].indexes[j].name,
                        "INDEX_POSITION");
            if (s) {
                soc_sbx_g2p3_uninit(unit);
                return s;
            }
            s = soc_sbx_g2p3_ucode_get(unit,
                        soc_sbx_g2p3_sym,
                        128,
                        &tm->entries[i].indexes[j].orange,
                        e,
                        tm->entries[i].name,
                        -1,
                        tm->entries[i].indexes[j].name,
                        "INDEX_RANGE");
            if (s) {
                soc_sbx_g2p3_uninit(unit);
                return s;
            }
            tm->entries[i].indexes[j].range
                = tm->entries[i].indexes[j].orange;
            s = soc_sbx_g2p3_ucode_get(unit,
                        soc_sbx_g2p3_sym,
                        128,
                        &tm->entries[i].indexes[j].width,
                        e,
                        tm->entries[i].name,
                        -1,
                        tm->entries[i].indexes[j].name,
                        "INDEX_WIDTH");
            if (s) {
                soc_sbx_g2p3_uninit(unit);
                return s;
            }
            s = soc_sbx_g2p3_ucode_get(unit,
                        soc_sbx_g2p3_sym,
                        128,
                        &tm->entries[i].indexes[j].format,
                        e,
                        tm->entries[i].name,
                        -1,
                        tm->entries[i].indexes[j].name,
                        "FORMAT");
            if (s) {
                soc_sbx_g2p3_uninit(unit);
                return s;
            }
        }

        if (tm->entries[i].nindexes) {
            tm->entries[i].indexeswidth =
                ((tm->entries[i].indexes[tm->entries[i].nindexes - 1].pos
                  + tm->entries[i].indexes[tm->entries[i].nindexes - 1].width
                  + 7) / 8) * 8;
        }

        soc_sbx_g2p3_entry_index_ranges_set(unit, i);


        /*
         * Per-field state initialization
         */
        if (tm->entries[i].nfields) {
            tm->entries[i].fields =
                UTG_MALLOC(sizeof(soc_sbx_g2p3_field_desc_t)
                       * tm->entries[i].nfields);
            if (!tm->entries[i].fields) {
                soc_sbx_g2p3_uninit(unit);
                return SOC_E_MEMORY;
            }
        }

        switch (i) {
        case SOC_SBX_G2P3_P2E_ID:
            tm->entries[i].fields[0].name = "port";
            tm->entries[i].fields[1].name = "nativevid";
            tm->entries[i].fields[2].name = "defcfi";
            tm->entries[i].fields[3].name = "defpri";
            tm->entries[i].fields[4].name = "defstrip";
            tm->entries[i].fields[5].name = "pstrip";
            tm->entries[i].fields[6].name = "mim";
            tm->entries[i].fields[7].name = "mplstp";
            tm->entries[i].fields[8].name = "mask";
            tm->entries[i].fields[9].name = "customer";
            tm->entries[i].fields[10].name = "provider";
            tm->entries[i].fields[11].name = "oamloop";
            tm->entries[i].fields[12].name = "stpid1";
            tm->entries[i].fields[13].name = "twintpid";
            tm->entries[i].fields[14].name = "pbb";
            tm->entries[i].fields[15].name = "ipv4mc";
            tm->entries[i].fields[16].name = "state";
            tm->entries[i].fields[17].name = "pport";
            tm->entries[i].fields[18].name = "htype";
            break;
        case SOC_SBX_G2P3_EP2E_ID:
            tm->entries[i].fields[0].name = "mim";
            tm->entries[i].fields[1].name = "pid";
            tm->entries[i].fields[2].name = "stpid0";
            tm->entries[i].fields[3].name = "stpid1";
            tm->entries[i].fields[4].name = "customer";
            tm->entries[i].fields[5].name = "keeperh";
            tm->entries[i].fields[6].name = "port";
            tm->entries[i].fields[7].name = "mirroridx";
            tm->entries[i].fields[8].name = "mask";
            tm->entries[i].fields[9].name = "oamloop";
            tm->entries[i].fields[10].name = "pbb";
            tm->entries[i].fields[11].name = "state";
            tm->entries[i].fields[12].name = "htype";
            break;
        case SOC_SBX_G2P3_P2E20_ID:
            tm->entries[i].fields[0].name = "port";
            tm->entries[i].fields[1].name = "nativevid";
            tm->entries[i].fields[2].name = "defcfi";
            tm->entries[i].fields[3].name = "defpri";
            tm->entries[i].fields[4].name = "defstrip";
            tm->entries[i].fields[5].name = "pstrip";
            tm->entries[i].fields[6].name = "mim";
            tm->entries[i].fields[7].name = "mplstp";
            tm->entries[i].fields[8].name = "mask";
            tm->entries[i].fields[9].name = "customer";
            tm->entries[i].fields[10].name = "provider";
            tm->entries[i].fields[11].name = "oamloop";
            tm->entries[i].fields[12].name = "stpid1";
            tm->entries[i].fields[13].name = "twintpid";
            tm->entries[i].fields[14].name = "pbb";
            tm->entries[i].fields[15].name = "ipv4mc";
            tm->entries[i].fields[16].name = "state";
            tm->entries[i].fields[17].name = "pport";
            tm->entries[i].fields[18].name = "htype";
            break;
        case SOC_SBX_G2P3_EP2E20_ID:
            tm->entries[i].fields[0].name = "mim";
            tm->entries[i].fields[1].name = "pid";
            tm->entries[i].fields[2].name = "stpid0";
            tm->entries[i].fields[3].name = "stpid1";
            tm->entries[i].fields[4].name = "customer";
            tm->entries[i].fields[5].name = "keeperh";
            tm->entries[i].fields[6].name = "port";
            tm->entries[i].fields[7].name = "mirroridx";
            tm->entries[i].fields[8].name = "mask";
            tm->entries[i].fields[9].name = "oamloop";
            tm->entries[i].fields[10].name = "pbb";
            tm->entries[i].fields[11].name = "state";
            tm->entries[i].fields[12].name = "htype";
            break;
        case SOC_SBX_G2P3_P2E25_ID:
            tm->entries[i].fields[0].name = "port";
            tm->entries[i].fields[1].name = "nativevid";
            tm->entries[i].fields[2].name = "defcfi";
            tm->entries[i].fields[3].name = "defpri";
            tm->entries[i].fields[4].name = "defstrip";
            tm->entries[i].fields[5].name = "pstrip";
            tm->entries[i].fields[6].name = "mim";
            tm->entries[i].fields[7].name = "mplstp";
            tm->entries[i].fields[8].name = "mask";
            tm->entries[i].fields[9].name = "customer";
            tm->entries[i].fields[10].name = "provider";
            tm->entries[i].fields[11].name = "oamloop";
            tm->entries[i].fields[12].name = "stpid1";
            tm->entries[i].fields[13].name = "twintpid";
            tm->entries[i].fields[14].name = "pbb";
            tm->entries[i].fields[15].name = "ipv4mc";
            tm->entries[i].fields[16].name = "state";
            tm->entries[i].fields[17].name = "pport";
            tm->entries[i].fields[18].name = "htype";
            break;
        case SOC_SBX_G2P3_EP2E25_ID:
            tm->entries[i].fields[0].name = "mim";
            tm->entries[i].fields[1].name = "pid";
            tm->entries[i].fields[2].name = "stpid0";
            tm->entries[i].fields[3].name = "stpid1";
            tm->entries[i].fields[4].name = "customer";
            tm->entries[i].fields[5].name = "keeperh";
            tm->entries[i].fields[6].name = "port";
            tm->entries[i].fields[7].name = "mirroridx";
            tm->entries[i].fields[8].name = "mask";
            tm->entries[i].fields[9].name = "oamloop";
            tm->entries[i].fields[10].name = "pbb";
            tm->entries[i].fields[11].name = "state";
            tm->entries[i].fields[12].name = "htype";
            break;
        case SOC_SBX_G2P3_TPID_ID:
            tm->entries[i].fields[0].name = "tpid";
            break;
        case SOC_SBX_G2P3_OAM_RX_ID:
            tm->entries[i].fields[0].name = "valid";
            break;
        case SOC_SBX_G2P3_OAM_TX_ID:
            tm->entries[i].fields[0].name = "valid";
            break;
        case SOC_SBX_G2P3_LSMAC_ID:
            tm->entries[i].fields[0].name = "port";
            tm->entries[i].fields[1].name = "useport";
            tm->entries[i].fields[2].name = "mac";
            break;
        case SOC_SBX_G2P3_L2CPMAC_ID:
            tm->entries[i].fields[0].name = "port";
            tm->entries[i].fields[1].name = "useport";
            tm->entries[i].fields[2].name = "mac";
            break;
        case SOC_SBX_G2P3_OAMUPMAC_ID:
            tm->entries[i].fields[0].name = "mac";
            tm->entries[i].fields[1].name = "mask";
            break;
        case SOC_SBX_G2P3_QOS_ID:
            tm->entries[i].fields[0].name = "e";
            tm->entries[i].fields[1].name = "dp";
            tm->entries[i].fields[2].name = "cos";
            tm->entries[i].fields[3].name = "fcos";
            tm->entries[i].fields[4].name = "mefcos";
            break;
        case SOC_SBX_G2P3_DSCP_QOS_ID:
            tm->entries[i].fields[0].name = "e";
            tm->entries[i].fields[1].name = "dp";
            tm->entries[i].fields[2].name = "cos";
            tm->entries[i].fields[3].name = "fcos";
            tm->entries[i].fields[4].name = "mefcos";
            break;
        case SOC_SBX_G2P3_IRT_ID:
            tm->entries[i].fields[0].name = "vlan";
            tm->entries[i].fields[1].name = "ftidx";
            tm->entries[i].fields[2].name = "mirror";
            tm->entries[i].fields[3].name = "usevlan";
            tm->entries[i].fields[4].name = "useftidx";
            tm->entries[i].fields[5].name = "copy";
            tm->entries[i].fields[6].name = "dp";
            tm->entries[i].fields[7].name = "cos";
            tm->entries[i].fields[8].name = "fcos";
            tm->entries[i].fields[9].name = "usedp";
            tm->entries[i].fields[10].name = "usecos";
            tm->entries[i].fields[11].name = "policer";
            tm->entries[i].fields[12].name = "typedpolice";
            tm->entries[i].fields[13].name = "mefcos";
            tm->entries[i].fields[14].name = "mef";
            break;
        case SOC_SBX_G2P3_IRT_WRAP_ID:
            tm->entries[i].fields[0].name = "vlan";
            tm->entries[i].fields[1].name = "ftidx";
            tm->entries[i].fields[2].name = "mirror";
            tm->entries[i].fields[3].name = "usevlan";
            tm->entries[i].fields[4].name = "useftidx";
            tm->entries[i].fields[5].name = "copy";
            tm->entries[i].fields[6].name = "dp";
            tm->entries[i].fields[7].name = "cos";
            tm->entries[i].fields[8].name = "fcos";
            tm->entries[i].fields[9].name = "usedp";
            tm->entries[i].fields[10].name = "usecos";
            tm->entries[i].fields[11].name = "policer";
            tm->entries[i].fields[12].name = "typedpolice";
            tm->entries[i].fields[13].name = "mefcos";
            tm->entries[i].fields[14].name = "mef";
            break;
        case SOC_SBX_G2P3_RT_MT_ID:
            tm->entries[i].fields[0].name = "policer";
            break;
        case SOC_SBX_G2P3_RT_RR0_ID:
            tm->entries[i].fields[0].name = "resv";
            tm->entries[i].fields[1].name = "usevlan";
            tm->entries[i].fields[2].name = "useftidx";
            tm->entries[i].fields[3].name = "vlan";
            tm->entries[i].fields[4].name = "ftidx";
            tm->entries[i].fields[5].name = "copy";
            tm->entries[i].fields[6].name = "dp";
            tm->entries[i].fields[7].name = "usedp";
            tm->entries[i].fields[8].name = "mirror";
            tm->entries[i].fields[9].name = "typedpolice";
            tm->entries[i].fields[10].name = "mefcos";
            tm->entries[i].fields[11].name = "mef";
            tm->entries[i].fields[12].name = "cos";
            tm->entries[i].fields[13].name = "fcos";
            tm->entries[i].fields[14].name = "usecos";
            tm->entries[i].fields[15].name = "emirror";
            tm->entries[i].fields[16].name = "drop";
            tm->entries[i].fields[17].name = "rtidx";
            break;
        case SOC_SBX_G2P3_RT_ID:
            break;
        case SOC_SBX_G2P3_RT_RR1_ID:
            tm->entries[i].fields[0].name = "resv";
            tm->entries[i].fields[1].name = "usevlan";
            tm->entries[i].fields[2].name = "useftidx";
            tm->entries[i].fields[3].name = "vlan";
            tm->entries[i].fields[4].name = "ftidx";
            tm->entries[i].fields[5].name = "copy";
            tm->entries[i].fields[6].name = "dp";
            tm->entries[i].fields[7].name = "usedp";
            tm->entries[i].fields[8].name = "mirror";
            tm->entries[i].fields[9].name = "typedpolice";
            tm->entries[i].fields[10].name = "mefcos";
            tm->entries[i].fields[11].name = "mef";
            tm->entries[i].fields[12].name = "cos";
            tm->entries[i].fields[13].name = "fcos";
            tm->entries[i].fields[14].name = "usecos";
            tm->entries[i].fields[15].name = "emirror";
            tm->entries[i].fields[16].name = "drop";
            tm->entries[i].fields[17].name = "rtidx";
            break;
        case SOC_SBX_G2P3_LAG_ID:
            tm->entries[i].fields[0].name = "qid";
            tm->entries[i].fields[1].name = "oi";
            break;
        case SOC_SBX_G2P3_RR_ID:
            tm->entries[i].fields[0].name = "backup";
            break;
        case SOC_SBX_G2P3_XT_ID:
            tm->entries[i].fields[0].name = "forward";
            tm->entries[i].fields[1].name = "dp";
            tm->entries[i].fields[2].name = "qid";
            tm->entries[i].fields[3].name = "trunc";
            tm->entries[i].fields[4].name = "learn";
            tm->entries[i].fields[5].name = "ppspolice";
            tm->entries[i].fields[6].name = "policer";
            break;
        case SOC_SBX_G2P3_MIRROR_ID:
            tm->entries[i].fields[0].name = "yellow";
            tm->entries[i].fields[1].name = "qid";
            tm->entries[i].fields[2].name = "oi";
            break;
        case SOC_SBX_G2P3_EMIRROR_ID:
            tm->entries[i].fields[0].name = "local";
            tm->entries[i].fields[1].name = "port";
            tm->entries[i].fields[2].name = "qid";
            tm->entries[i].fields[3].name = "oi";
            break;
        case SOC_SBX_G2P3_EMIRROR20_ID:
            tm->entries[i].fields[0].name = "queue";
            tm->entries[i].fields[1].name = "hdrpresent";
            tm->entries[i].fields[2].name = "dropsrcpkt";
            break;
        case SOC_SBX_G2P3_EMIRROR25_ID:
            tm->entries[i].fields[0].name = "queue";
            tm->entries[i].fields[1].name = "hdrpresent";
            tm->entries[i].fields[2].name = "dropsrcpkt";
            tm->entries[i].fields[3].name = "higighdr";
            tm->entries[i].fields[4].name = "overwritehdr";
            tm->entries[i].fields[5].name = "hdrdata0";
            tm->entries[i].fields[6].name = "hdrdata1";
            tm->entries[i].fields[7].name = "hdrdata2";
            tm->entries[i].fields[8].name = "hdrdata3";
            break;
        case SOC_SBX_G2P3_EMLL1_ID:
            tm->entries[i].fields[0].name = "usemap";
            tm->entries[i].fields[1].name = "pointer";
            tm->entries[i].fields[2].name = "salt";
            break;
        case SOC_SBX_G2P3_MAC_ID:
            tm->entries[i].fields[0].name = "age";
            tm->entries[i].fields[1].name = "pid";
            tm->entries[i].fields[2].name = "dcopy";
            tm->entries[i].fields[3].name = "dcopycos";
            tm->entries[i].fields[4].name = "ddrop";
            tm->entries[i].fields[5].name = "sdrop";
            tm->entries[i].fields[6].name = "dontage";
            tm->entries[i].fields[7].name = "bsdrop";
            tm->entries[i].fields[8].name = "bpid";
            tm->entries[i].fields[9].name = "btid";
            break;
        case SOC_SBX_G2P3_MACL1_ID:
            tm->entries[i].fields[0].name = "usemap";
            tm->entries[i].fields[1].name = "pointer";
            tm->entries[i].fields[2].name = "salt";
            break;
        case SOC_SBX_G2P3_MACL2_ID:
            tm->entries[i].fields[0].name = "mac";
            tm->entries[i].fields[1].name = "vlan";
            tm->entries[i].fields[2].name = "bmac";
            tm->entries[i].fields[3].name = "age";
            tm->entries[i].fields[4].name = "pid";
            tm->entries[i].fields[5].name = "dcopy";
            tm->entries[i].fields[6].name = "dcopycos";
            tm->entries[i].fields[7].name = "ddrop";
            tm->entries[i].fields[8].name = "sdrop";
            tm->entries[i].fields[9].name = "dontage";
            tm->entries[i].fields[10].name = "notage";
            tm->entries[i].fields[11].name = "bsdrop";
            tm->entries[i].fields[12].name = "bpid";
            tm->entries[i].fields[13].name = "btid";
            break;
        case SOC_SBX_G2P3_IPV6DHOST_ID:
            tm->entries[i].fields[0].name = "ftidx";
            tm->entries[i].fields[1].name = "ecmpmask";
            tm->entries[i].fields[2].name = "vid";
            break;
        case SOC_SBX_G2P3_IPV6DHOSTL1_ID:
            tm->entries[i].fields[0].name = "usemap";
            tm->entries[i].fields[1].name = "pointer";
            tm->entries[i].fields[2].name = "salt";
            break;
        case SOC_SBX_G2P3_IPV6DHOSTL2_ID:
            tm->entries[i].fields[0].name = "key";
            tm->entries[i].fields[1].name = "ftidx";
            tm->entries[i].fields[2].name = "ecmpmask";
            tm->entries[i].fields[3].name = "vid";
            break;
        case SOC_SBX_G2P3_MST_ID:
            tm->entries[i].fields[0].name = "learn";
            tm->entries[i].fields[1].name = "pim";
            tm->entries[i].fields[2].name = "igmp";
            tm->entries[i].fields[3].name = "rtcopy";
            tm->entries[i].fields[4].name = "l2cpcopy";
            tm->entries[i].fields[5].name = "dcopy";
            tm->entries[i].fields[6].name = "ipredirect";
            tm->entries[i].fields[7].name = "learn_bmac";
            tm->entries[i].fields[8].name = "mirroridx";
            tm->entries[i].fields[9].name = "vsi";
            break;
        case SOC_SBX_G2P3_PV2E_ID:
            tm->entries[i].fields[0].name = "lpi";
            tm->entries[i].fields[1].name = "vlan";
            tm->entries[i].fields[2].name = "stpstate";
            tm->entries[i].fields[3].name = "untagged_strip";
            tm->entries[i].fields[4].name = "vpws";
            break;
        case SOC_SBX_G2P3_P2APPDATA_ID:
            tm->entries[i].fields[0].name = "ifilteren";
            tm->entries[i].fields[1].name = "efilteren";
            break;
        case SOC_SBX_G2P3_PV2APPDATA_ID:
            tm->entries[i].fields[0].name = "member";
            break;
        case SOC_SBX_G2P3_IPV6SHOST_ID:
            tm->entries[i].fields[0].name = "poe";
            tm->entries[i].fields[1].name = "rpfmode";
            tm->entries[i].fields[2].name = "srcdrop";
            tm->entries[i].fields[3].name = "srccnt";
            break;
        case SOC_SBX_G2P3_IPV6SHOSTL1_ID:
            tm->entries[i].fields[0].name = "usemap";
            tm->entries[i].fields[1].name = "pointer";
            tm->entries[i].fields[2].name = "salt";
            break;
        case SOC_SBX_G2P3_IPV6SHOSTL2_ID:
            tm->entries[i].fields[0].name = "key";
            tm->entries[i].fields[1].name = "ftidx";
            tm->entries[i].fields[2].name = "ecmpmask";
            tm->entries[i].fields[3].name = "vid";
            break;
        case SOC_SBX_G2P3_PVV2E_ID:
            tm->entries[i].fields[0].name = "lpi";
            tm->entries[i].fields[1].name = "vlan";
            tm->entries[i].fields[2].name = "stpstate";
            tm->entries[i].fields[3].name = "untagged_strip";
            tm->entries[i].fields[4].name = "vpws";
            tm->entries[i].fields[5].name = "vid";
            tm->entries[i].fields[6].name = "replace";
            tm->entries[i].fields[7].name = "keeporstrip";
            break;
        case SOC_SBX_G2P3_PVV2EPACK_ID:
            tm->entries[i].fields[0].name = "lpi";
            tm->entries[i].fields[1].name = "vlan";
            tm->entries[i].fields[2].name = "stpstate";
            tm->entries[i].fields[3].name = "untagged_strip";
            tm->entries[i].fields[4].name = "vpws";
            tm->entries[i].fields[5].name = "vid";
            tm->entries[i].fields[6].name = "replace";
            tm->entries[i].fields[7].name = "keeporstrip";
            break;
        case SOC_SBX_G2P3_ISID2E_ID:
            tm->entries[i].fields[0].name = "lpi";
            tm->entries[i].fields[1].name = "vlan";
            tm->entries[i].fields[2].name = "stpstate";
            break;
        case SOC_SBX_G2P3_OAMPVD2E_ID:
            tm->entries[i].fields[0].name = "endpointPtr";
            tm->entries[i].fields[1].name = "ftIdx";
            tm->entries[i].fields[2].name = "mdLevelEp";
            tm->entries[i].fields[3].name = "mdLevelFwd";
            break;
        case SOC_SBX_G2P3_OAMMAIDMEP2E_ID:
            tm->entries[i].fields[0].name = "endpointPtr";
            tm->entries[i].fields[1].name = "epValid";
            break;
        case SOC_SBX_G2P3_CUCKOO_ID:
            tm->entries[i].fields[0].name = "pay";
            break;
        case SOC_SBX_G2P3_LEFT_ID:
            tm->entries[i].fields[0].name = "pay";
            tm->entries[i].fields[1].name = "key";
            break;
        case SOC_SBX_G2P3_RIGHT_ID:
            tm->entries[i].fields[0].name = "pay";
            tm->entries[i].fields[1].name = "key";
            break;
        case SOC_SBX_G2P3_OUTERLABELCUCKOO_ID:
            tm->entries[i].fields[0].name = "pay";
            break;
        case SOC_SBX_G2P3_OUTERLABELLEFT_ID:
            tm->entries[i].fields[0].name = "pay";
            tm->entries[i].fields[1].name = "key";
            break;
        case SOC_SBX_G2P3_OUTERLABELRIGHT_ID:
            tm->entries[i].fields[0].name = "pay";
            tm->entries[i].fields[1].name = "key";
            break;
        case SOC_SBX_G2P3_INNERLABELCUCKOO_ID:
            tm->entries[i].fields[0].name = "pay";
            break;
        case SOC_SBX_G2P3_INNERLABELLEFT_ID:
            tm->entries[i].fields[0].name = "pay";
            tm->entries[i].fields[1].name = "key";
            break;
        case SOC_SBX_G2P3_INNERLABELRIGHT_ID:
            tm->entries[i].fields[0].name = "pay";
            tm->entries[i].fields[1].name = "key";
            break;
        case SOC_SBX_G2P3_LABEL2E_ID:
            tm->entries[i].fields[0].name = "vlan";
            tm->entries[i].fields[1].name = "ftidx0";
            tm->entries[i].fields[2].name = "opcode";
            tm->entries[i].fields[3].name = "lpidx";
            tm->entries[i].fields[4].name = "cos";
            tm->entries[i].fields[5].name = "loopback";
            tm->entries[i].fields[6].name = "vpws";
            tm->entries[i].fields[7].name = "ftidx1";
            tm->entries[i].fields[8].name = "stpstate";
            tm->entries[i].fields[9].name = "elsp";
            tm->entries[i].fields[10].name = "pipe";
            break;
        case SOC_SBX_G2P3_TAGGED_MPLS_ID:
            tm->entries[i].fields[0].name = "valid";
            break;
        case SOC_SBX_G2P3_V2E_ID:
            tm->entries[i].fields[0].name = "pim";
            tm->entries[i].fields[1].name = "igmp";
            tm->entries[i].fields[2].name = "forceflood";
            tm->entries[i].fields[3].name = "dropunksmac";
            tm->entries[i].fields[4].name = "dontlearn";
            tm->entries[i].fields[5].name = "vrf";
            tm->entries[i].fields[6].name = "v6mcmode";
            tm->entries[i].fields[7].name = "v4mcmode";
            tm->entries[i].fields[8].name = "laghash";
            tm->entries[i].fields[9].name = "v4route";
            tm->entries[i].fields[10].name = "v6route";
            break;
        case SOC_SBX_G2P3_V2E1_ID:
            tm->entries[i].fields[0].name = "vrid0";
            tm->entries[i].fields[1].name = "vrid1";
            tm->entries[i].fields[2].name = "vrid2";
            tm->entries[i].fields[3].name = "vrid3";
            break;
        case SOC_SBX_G2P3_LP_ID:
            tm->entries[i].fields[0].name = "pid";
            tm->entries[i].fields[1].name = "qos";
            tm->entries[i].fields[2].name = "useexp";
            tm->entries[i].fields[3].name = "usedscp";
            tm->entries[i].fields[4].name = "updatefdp";
            tm->entries[i].fields[5].name = "mirror";
            tm->entries[i].fields[6].name = "updaterdp";
            tm->entries[i].fields[7].name = "policer";
            tm->entries[i].fields[8].name = "typedpolice";
            tm->entries[i].fields[9].name = "mefcos";
            tm->entries[i].fields[10].name = "mef";
            tm->entries[i].fields[11].name = "cocounter";
            tm->entries[i].fields[12].name = "priclass";
            tm->entries[i].fields[13].name = "allpri";
            tm->entries[i].fields[14].name = "xtpolreplace";
            tm->entries[i].fields[15].name = "counter";
            tm->entries[i].fields[16].name = "typedcount";
            tm->entries[i].fields[17].name = "color";
            tm->entries[i].fields[18].name = "usecolor";
            tm->entries[i].fields[19].name = "oamepi";
            break;
        case SOC_SBX_G2P3_L2E_ID:
            tm->entries[i].fields[0].name = "vlan";
            tm->entries[i].fields[1].name = "stpstate";
            tm->entries[i].fields[2].name = "elsp";
            tm->entries[i].fields[3].name = "pipe";
            tm->entries[i].fields[4].name = "ftidx";
            tm->entries[i].fields[5].name = "oamen";
            tm->entries[i].fields[6].name = "leren";
            break;
        case SOC_SBX_G2P3_L2CP_ID:
            tm->entries[i].fields[0].name = "ftidx";
            tm->entries[i].fields[1].name = "forward";
            tm->entries[i].fields[2].name = "passstp";
            tm->entries[i].fields[3].name = "copy";
            break;
        case SOC_SBX_G2P3_L2CPSLOW_ID:
            tm->entries[i].fields[0].name = "ftidx";
            tm->entries[i].fields[1].name = "forward";
            tm->entries[i].fields[2].name = "passstp";
            tm->entries[i].fields[3].name = "copy";
            break;
        case SOC_SBX_G2P3_L2CPNOP_ID:
            tm->entries[i].fields[0].name = "ftidx";
            tm->entries[i].fields[1].name = "forward";
            tm->entries[i].fields[2].name = "passstp";
            tm->entries[i].fields[3].name = "copy";
            break;
        case SOC_SBX_G2P3_FT_ID:
            tm->entries[i].fields[0].name = "rridx";
            tm->entries[i].fields[1].name = "excidx";
            tm->entries[i].fields[2].name = "lenadj";
            tm->entries[i].fields[3].name = "mc";
            tm->entries[i].fields[4].name = "t";
            tm->entries[i].fields[5].name = "hc";
            tm->entries[i].fields[6].name = "oi";
            tm->entries[i].fields[7].name = "qid";
            tm->entries[i].fields[8].name = "lagbase";
            tm->entries[i].fields[9].name = "lagsize";
            tm->entries[i].fields[10].name = "lag";
            tm->entries[i].fields[11].name = "oib";
            tm->entries[i].fields[12].name = "qidb";
            tm->entries[i].fields[13].name = "lagbaseb";
            tm->entries[i].fields[14].name = "lagsizeb";
            tm->entries[i].fields[15].name = "lagb";
            break;
        case SOC_SBX_G2P3_OAMTIMERCALENDAR_ID:
            tm->entries[i].fields[0].name = "endpointPtr";
            tm->entries[i].fields[1].name = "xmitPeriod";
            tm->entries[i].fields[2].name = "xmitCount";
            break;
        case SOC_SBX_G2P3_OAMPORTMDLEVEL2ETC_ID:
            tm->entries[i].fields[0].name = "valid";
            tm->entries[i].fields[1].name = "fwd";
            tm->entries[i].fields[2].name = "epIdx";
            break;
        case SOC_SBX_G2P3_V4UC_STR_SEL_ID:
            tm->entries[i].fields[0].name = "valid";
            break;
        case SOC_SBX_G2P3_CMAC_ID:
            tm->entries[i].fields[0].name = "age";
            tm->entries[i].fields[1].name = "pid";
            tm->entries[i].fields[2].name = "dcopy";
            tm->entries[i].fields[3].name = "dcopycos";
            tm->entries[i].fields[4].name = "ddrop";
            tm->entries[i].fields[5].name = "sdrop";
            tm->entries[i].fields[6].name = "dontage";
            break;
        case SOC_SBX_G2P3_BMAC_ID:
            tm->entries[i].fields[0].name = "bsdrop";
            tm->entries[i].fields[1].name = "bpid";
            tm->entries[i].fields[2].name = "btid";
            break;
        case SOC_SBX_G2P3_IPV6MCSG_ID:
            tm->entries[i].fields[0].name = "ftidx";
            tm->entries[i].fields[1].name = "rpfunion";
            tm->entries[i].fields[2].name = "proccopy";
            break;
        case SOC_SBX_G2P3_IPV6MCSGL1_ID:
            tm->entries[i].fields[0].name = "usemap";
            tm->entries[i].fields[1].name = "pointer";
            tm->entries[i].fields[2].name = "salt";
            break;
        case SOC_SBX_G2P3_IPV6MCSGL2_ID:
            tm->entries[i].fields[0].name = "g";
            tm->entries[i].fields[1].name = "s";
            tm->entries[i].fields[2].name = "vlan";
            tm->entries[i].fields[3].name = "proccopy";
            tm->entries[i].fields[4].name = "ftidx";
            tm->entries[i].fields[5].name = "rpfunion";
            break;
        case SOC_SBX_G2P3_IPV6MCG_ID:
            tm->entries[i].fields[0].name = "ftidx";
            tm->entries[i].fields[1].name = "rpfunion";
            tm->entries[i].fields[2].name = "proccopy";
            break;
        case SOC_SBX_G2P3_IPV6MCGL1_ID:
            tm->entries[i].fields[0].name = "usemap";
            tm->entries[i].fields[1].name = "pointer";
            tm->entries[i].fields[2].name = "salt";
            break;
        case SOC_SBX_G2P3_IPV6MCGL2_ID:
            tm->entries[i].fields[0].name = "g";
            tm->entries[i].fields[1].name = "ftidx";
            tm->entries[i].fields[2].name = "rpfunion";
            tm->entries[i].fields[3].name = "vlan";
            tm->entries[i].fields[4].name = "proccopy";
            break;
        case SOC_SBX_G2P3_IPV4MCG_ID:
            tm->entries[i].fields[0].name = "ftidx";
            tm->entries[i].fields[1].name = "rpfunion";
            tm->entries[i].fields[2].name = "proccopy";
            break;
        case SOC_SBX_G2P3_IPV4MCGL1_ID:
            tm->entries[i].fields[0].name = "usemap";
            tm->entries[i].fields[1].name = "pointer";
            tm->entries[i].fields[2].name = "salt";
            break;
        case SOC_SBX_G2P3_IPV4MCGL2_ID:
            tm->entries[i].fields[0].name = "g";
            tm->entries[i].fields[1].name = "ftidx";
            tm->entries[i].fields[2].name = "rpfunion";
            tm->entries[i].fields[3].name = "vlan";
            tm->entries[i].fields[4].name = "proccopy";
            break;
        case SOC_SBX_G2P3_IPV4MCSG_ID:
            tm->entries[i].fields[0].name = "ftidx";
            tm->entries[i].fields[1].name = "rpfunion";
            tm->entries[i].fields[2].name = "proccopy";
            break;
        case SOC_SBX_G2P3_IPV4MCSGL1_ID:
            tm->entries[i].fields[0].name = "usemap";
            tm->entries[i].fields[1].name = "pointer";
            tm->entries[i].fields[2].name = "salt";
            break;
        case SOC_SBX_G2P3_IPV4MCSGL2_ID:
            tm->entries[i].fields[0].name = "g";
            tm->entries[i].fields[1].name = "s";
            tm->entries[i].fields[2].name = "ftidx";
            tm->entries[i].fields[3].name = "rpfunion";
            tm->entries[i].fields[4].name = "vlan";
            tm->entries[i].fields[5].name = "proccopy";
            break;
        case SOC_SBX_G2P3_LPMNODE_ID:
            tm->entries[i].fields[0].name = "pattern";
            tm->entries[i].fields[1].name = "singleton";
            tm->entries[i].fields[2].name = "pointer";
            tm->entries[i].fields[3].name = "leaf";
            break;
        case SOC_SBX_G2P3_IPV4SA_ID:
            tm->entries[i].fields[0].name = "poe";
            tm->entries[i].fields[1].name = "rpfmode";
            tm->entries[i].fields[2].name = "srcdrop";
            tm->entries[i].fields[3].name = "srccnt";
            break;
        case SOC_SBX_G2P3_IPV4SAL0_ID:
            tm->entries[i].fields[0].name = "pattern";
            tm->entries[i].fields[1].name = "singleton";
            tm->entries[i].fields[2].name = "pointer";
            tm->entries[i].fields[3].name = "leaf";
            break;
        case SOC_SBX_G2P3_IPV4SAODD_ID:
            tm->entries[i].fields[0].name = "pattern";
            tm->entries[i].fields[1].name = "singleton";
            tm->entries[i].fields[2].name = "pointer";
            tm->entries[i].fields[3].name = "leaf";
            break;
        case SOC_SBX_G2P3_IPV4SAEVEN_ID:
            tm->entries[i].fields[0].name = "pattern";
            tm->entries[i].fields[1].name = "singleton";
            tm->entries[i].fields[2].name = "pointer";
            tm->entries[i].fields[3].name = "leaf";
            break;
        case SOC_SBX_G2P3_IPV4SAPAYLOAD_ID:
            tm->entries[i].fields[0].name = "poe";
            tm->entries[i].fields[1].name = "rpfmode";
            tm->entries[i].fields[2].name = "srcdrop";
            tm->entries[i].fields[3].name = "srccnt";
            break;
        case SOC_SBX_G2P3_IFP_ID:
            tm->entries[i].fields[0].name = "dbtype";
            tm->entries[i].fields[1].name = "usedbtype";
            tm->entries[i].fields[2].name = "port";
            tm->entries[i].fields[3].name = "useport";
            tm->entries[i].fields[4].name = "pbmpn";
            tm->entries[i].fields[5].name = "pri";
            tm->entries[i].fields[6].name = "usepri";
            tm->entries[i].fields[7].name = "fragment";
            tm->entries[i].fields[8].name = "usefragment";
            tm->entries[i].fields[9].name = "urg";
            tm->entries[i].fields[10].name = "useurg";
            tm->entries[i].fields[11].name = "ack";
            tm->entries[i].fields[12].name = "useack";
            tm->entries[i].fields[13].name = "psh";
            tm->entries[i].fields[14].name = "usepsh";
            tm->entries[i].fields[15].name = "rst";
            tm->entries[i].fields[16].name = "userst";
            tm->entries[i].fields[17].name = "syn";
            tm->entries[i].fields[18].name = "usesyn";
            tm->entries[i].fields[19].name = "fin";
            tm->entries[i].fields[20].name = "usefin";
            tm->entries[i].fields[21].name = "dscp";
            tm->entries[i].fields[22].name = "usedscp";
            tm->entries[i].fields[23].name = "ecn";
            tm->entries[i].fields[24].name = "useecn";
            tm->entries[i].fields[25].name = "proto";
            tm->entries[i].fields[26].name = "useproto";
            tm->entries[i].fields[27].name = "sporthi";
            tm->entries[i].fields[28].name = "sportlo";
            tm->entries[i].fields[29].name = "dporthi";
            tm->entries[i].fields[30].name = "dportlo";
            tm->entries[i].fields[31].name = "sa";
            tm->entries[i].fields[32].name = "sawidth";
            tm->entries[i].fields[33].name = "da";
            tm->entries[i].fields[34].name = "dawidth";
            tm->entries[i].fields[35].name = "etype";
            tm->entries[i].fields[36].name = "useetype";
            tm->entries[i].fields[37].name = "smac";
            tm->entries[i].fields[38].name = "smacwidth";
            tm->entries[i].fields[39].name = "dmac";
            tm->entries[i].fields[40].name = "dmacwidth";
            tm->entries[i].fields[41].name = "vid";
            tm->entries[i].fields[42].name = "usevid";
            tm->entries[i].fields[43].name = "ssaphi";
            tm->entries[i].fields[44].name = "ssaplo";
            tm->entries[i].fields[45].name = "usessap";
            tm->entries[i].fields[46].name = "dsaphi";
            tm->entries[i].fields[47].name = "dsaplo";
            tm->entries[i].fields[48].name = "usedsap";
            tm->entries[i].fields[49].name = "llcctrlhi";
            tm->entries[i].fields[50].name = "llcctrllo";
            tm->entries[i].fields[51].name = "usellcctrl";
            tm->entries[i].fields[52].name = "enable";
            tm->entries[i].fields[53].name = "vlan";
            tm->entries[i].fields[54].name = "ftidx";
            tm->entries[i].fields[55].name = "mirror";
            tm->entries[i].fields[56].name = "usevlan";
            tm->entries[i].fields[57].name = "useftidx";
            tm->entries[i].fields[58].name = "copy";
            tm->entries[i].fields[59].name = "dp";
            tm->entries[i].fields[60].name = "cos";
            tm->entries[i].fields[61].name = "fcos";
            tm->entries[i].fields[62].name = "usedp";
            tm->entries[i].fields[63].name = "usecos";
            tm->entries[i].fields[64].name = "policer";
            tm->entries[i].fields[65].name = "typedpolice";
            tm->entries[i].fields[66].name = "mefcos";
            tm->entries[i].fields[67].name = "mef";
            break;
        case SOC_SBX_G2P3_IFP_V6_ID:
            tm->entries[i].fields[0].name = "dbtype";
            tm->entries[i].fields[1].name = "usedbtype";
            tm->entries[i].fields[2].name = "port";
            tm->entries[i].fields[3].name = "useport";
            tm->entries[i].fields[4].name = "pbmpn";
            tm->entries[i].fields[5].name = "urg";
            tm->entries[i].fields[6].name = "useurg";
            tm->entries[i].fields[7].name = "ack";
            tm->entries[i].fields[8].name = "useack";
            tm->entries[i].fields[9].name = "psh";
            tm->entries[i].fields[10].name = "usepsh";
            tm->entries[i].fields[11].name = "rst";
            tm->entries[i].fields[12].name = "userst";
            tm->entries[i].fields[13].name = "syn";
            tm->entries[i].fields[14].name = "usesyn";
            tm->entries[i].fields[15].name = "fin";
            tm->entries[i].fields[16].name = "usefin";
            tm->entries[i].fields[17].name = "TC";
            tm->entries[i].fields[18].name = "useTC";
            tm->entries[i].fields[19].name = "nextheaderhi";
            tm->entries[i].fields[20].name = "nextheaderlo";
            tm->entries[i].fields[21].name = "sporthi";
            tm->entries[i].fields[22].name = "sportlo";
            tm->entries[i].fields[23].name = "dporthi";
            tm->entries[i].fields[24].name = "dportlo";
            tm->entries[i].fields[25].name = "sa";
            tm->entries[i].fields[26].name = "sawidth";
            tm->entries[i].fields[27].name = "da";
            tm->entries[i].fields[28].name = "dawidth";
            tm->entries[i].fields[29].name = "vid";
            tm->entries[i].fields[30].name = "usevid";
            tm->entries[i].fields[31].name = "enable";
            tm->entries[i].fields[32].name = "vlan";
            tm->entries[i].fields[33].name = "ftidx";
            tm->entries[i].fields[34].name = "mirror";
            tm->entries[i].fields[35].name = "usevlan";
            tm->entries[i].fields[36].name = "useftidx";
            tm->entries[i].fields[37].name = "copy";
            tm->entries[i].fields[38].name = "dp";
            tm->entries[i].fields[39].name = "cos";
            tm->entries[i].fields[40].name = "fcos";
            tm->entries[i].fields[41].name = "usedp";
            tm->entries[i].fields[42].name = "usecos";
            tm->entries[i].fields[43].name = "policer";
            tm->entries[i].fields[44].name = "typedpolice";
            tm->entries[i].fields[45].name = "mefcos";
            tm->entries[i].fields[46].name = "mef";
            break;
        case SOC_SBX_G2P3_EVP2E_ID:
            tm->entries[i].fields[0].name = "eteptr";
            tm->entries[i].fields[1].name = "counter";
            tm->entries[i].fields[2].name = "cocounter";
            tm->entries[i].fields[3].name = "priclass";
            tm->entries[i].fields[4].name = "allpri";
            break;
        case SOC_SBX_G2P3_OI2E_ID:
            tm->entries[i].fields[0].name = "eteptr";
            tm->entries[i].fields[1].name = "counter";
            tm->entries[i].fields[2].name = "cocounter";
            tm->entries[i].fields[3].name = "priclass";
            tm->entries[i].fields[4].name = "allpri";
            break;
        case SOC_SBX_G2P3_ETEENCAP_ID:
            tm->entries[i].fields[0].name = "l2ete";
            tm->entries[i].fields[1].name = "dmacset";
            tm->entries[i].fields[2].name = "dmacsetlsb";
            tm->entries[i].fields[3].name = "dscpremark";
            tm->entries[i].fields[4].name = "remark";
            tm->entries[i].fields[5].name = "mplsttldec";
            tm->entries[i].fields[6].name = "encaplen";
            tm->entries[i].fields[7].name = "encapmac";
            tm->entries[i].fields[8].name = "nostrip";
            tm->entries[i].fields[9].name = "noclass";
            tm->entries[i].fields[10].name = "etepid";
            tm->entries[i].fields[11].name = "tunnelenter";
            tm->entries[i].fields[12].name = "exp0remark";
            tm->entries[i].fields[13].name = "exp1remark";
            tm->entries[i].fields[14].name = "exp2remark";
            tm->entries[i].fields[15].name = "ttl0dec";
            tm->entries[i].fields[16].name = "ttl1dec";
            tm->entries[i].fields[17].name = "ttl2dec";
            tm->entries[i].fields[18].name = "smacset";
            tm->entries[i].fields[19].name = "nosplitcheck";
            tm->entries[i].fields[20].name = "ttlcheck";
            tm->entries[i].fields[21].name = "ipttldec";
            tm->entries[i].fields[22].name = "add_pwcw";
            tm->entries[i].fields[23].name = "dmac5";
            tm->entries[i].fields[24].name = "dmac4";
            tm->entries[i].fields[25].name = "dmac3";
            tm->entries[i].fields[26].name = "dmac2";
            tm->entries[i].fields[27].name = "dmac1";
            tm->entries[i].fields[28].name = "dmac0";
            tm->entries[i].fields[29].name = "vlan";
            tm->entries[i].fields[30].name = "vid";
            tm->entries[i].fields[31].name = "pricfi";
            tm->entries[i].fields[32].name = "tpid";
            tm->entries[i].fields[33].name = "mimtype";
            tm->entries[i].fields[34].name = "btag_vid";
            tm->entries[i].fields[35].name = "btag_pricfi";
            tm->entries[i].fields[36].name = "btag_tpid";
            tm->entries[i].fields[37].name = "ttl2";
            tm->entries[i].fields[38].name = "s2";
            tm->entries[i].fields[39].name = "exp2";
            tm->entries[i].fields[40].name = "label2";
            tm->entries[i].fields[41].name = "etype";
            tm->entries[i].fields[42].name = "pid";
            tm->entries[i].fields[43].name = "isid";
            tm->entries[i].fields[44].name = "rsvd";
            tm->entries[i].fields[45].name = "ucm";
            tm->entries[i].fields[46].name = "dei";
            tm->entries[i].fields[47].name = "pcp";
            tm->entries[i].fields[48].name = "ttl0";
            tm->entries[i].fields[49].name = "s0";
            tm->entries[i].fields[50].name = "exp0";
            tm->entries[i].fields[51].name = "label0";
            tm->entries[i].fields[52].name = "ttl1";
            tm->entries[i].fields[53].name = "s1";
            tm->entries[i].fields[54].name = "exp1";
            tm->entries[i].fields[55].name = "label1";
            break;
        case SOC_SBX_G2P3_ETEL2_ID:
            tm->entries[i].fields[0].name = "dscpremark";
            tm->entries[i].fields[1].name = "encaplen";
            tm->entries[i].fields[2].name = "nostrip";
            tm->entries[i].fields[3].name = "noclass";
            tm->entries[i].fields[4].name = "remark";
            tm->entries[i].fields[5].name = "nosplitcheck";
            tm->entries[i].fields[6].name = "usetag";
            tm->entries[i].fields[7].name = "dropuntagged";
            tm->entries[i].fields[8].name = "droptagged";
            tm->entries[i].fields[9].name = "smacindex";
            tm->entries[i].fields[10].name = "stpcheck";
            tm->entries[i].fields[11].name = "vid";
            tm->entries[i].fields[12].name = "defpricfi";
            tm->entries[i].fields[13].name = "mtu";
            tm->entries[i].fields[14].name = "usevid";
            break;
        case SOC_SBX_G2P3_OAMEP_ID:
            tm->entries[i].fields[0].name = "nextentry";
            tm->entries[i].fields[1].name = "function";
            tm->entries[i].fields[2].name = "type";
            tm->entries[i].fields[3].name = "interval";
            tm->entries[i].fields[4].name = "mdlevel";
            tm->entries[i].fields[5].name = "singletx";
            tm->entries[i].fields[6].name = "mode";
            tm->entries[i].fields[7].name = "dir";
            tm->entries[i].fields[8].name = "conttohost";
            tm->entries[i].fields[9].name = "singletohost";
            tm->entries[i].fields[10].name = "ftidx";
            tm->entries[i].fields[11].name = "m";
            tm->entries[i].fields[12].name = "d";
            tm->entries[i].fields[13].name = "a";
            tm->entries[i].fields[14].name = "c";
            tm->entries[i].fields[15].name = "unibi";
            tm->entries[i].fields[16].name = "cv";
            tm->entries[i].fields[17].name = "fbit";
            tm->entries[i].fields[18].name = "counteridx";
            tm->entries[i].fields[19].name = "multiplieridx";
            tm->entries[i].fields[20].name = "rxfc";
            tm->entries[i].fields[21].name = "rdi";
            tm->entries[i].fields[22].name = "mip";
            tm->entries[i].fields[23].name = "lm";
            tm->entries[i].fields[24].name = "notlm";
            tm->entries[i].fields[25].name = "mepid";
            tm->entries[i].fields[26].name = "intpri";
            tm->entries[i].fields[27].name = "smacaux";
            tm->entries[i].fields[28].name = "smacadd";
            tm->entries[i].fields[29].name = "smacoffset";
            tm->entries[i].fields[30].name = "sid";
            tm->entries[i].fields[31].name = "tx";
            tm->entries[i].fields[32].name = "yourdiscrim";
            tm->entries[i].fields[33].name = "mydiscrim";
            tm->entries[i].fields[34].name = "rxfcl";
            tm->entries[i].fields[35].name = "nextentry_store";
            tm->entries[i].fields[36].name = "ftidx_store";
            tm->entries[i].fields[37].name = "delaysec";
            tm->entries[i].fields[38].name = "remotesec";
            tm->entries[i].fields[39].name = "maidw3";
            tm->entries[i].fields[40].name = "maidw2";
            tm->entries[i].fields[41].name = "maidw9";
            tm->entries[i].fields[42].name = "maidw8";
            tm->entries[i].fields[43].name = "maidcrc";
            tm->entries[i].fields[44].name = "path";
            tm->entries[i].fields[45].name = "fpath";
            tm->entries[i].fields[46].name = "reserved";
            tm->entries[i].fields[47].name = "revertive";
            tm->entries[i].fields[48].name = "pt";
            tm->entries[i].fields[49].name = "request";
            tm->entries[i].fields[50].name = "version";
            tm->entries[i].fields[51].name = "pschdr";
            tm->entries[i].fields[52].name = "slowrate";
            tm->entries[i].fields[53].name = "filter";
            tm->entries[i].fields[54].name = "burst";
            tm->entries[i].fields[55].name = "pscentry";
            tm->entries[i].fields[56].name = "ipda";
            tm->entries[i].fields[57].name = "txfcf";
            tm->entries[i].fields[58].name = "txfcb";
            tm->entries[i].fields[59].name = "maidw1";
            tm->entries[i].fields[60].name = "maidw0";
            tm->entries[i].fields[61].name = "maidw7";
            tm->entries[i].fields[62].name = "maidw6";
            tm->entries[i].fields[63].name = "maxslowrate";
            tm->entries[i].fields[64].name = "peerrdi";
            tm->entries[i].fields[65].name = "ackrdi";
            tm->entries[i].fields[66].name = "ackrdi_rdi";
            tm->entries[i].fields[67].name = "policerid";
            tm->entries[i].fields[68].name = "udpsourceport";
            tm->entries[i].fields[69].name = "multipoint";
            tm->entries[i].fields[70].name = "peerstate";
            tm->entries[i].fields[71].name = "final";
            tm->entries[i].fields[72].name = "poll";
            tm->entries[i].fields[73].name = "localstate";
            tm->entries[i].fields[74].name = "diag";
            tm->entries[i].fields[75].name = "peerdetectmulti";
            tm->entries[i].fields[76].name = "localdetectmulti";
            tm->entries[i].fields[77].name = "framelossfar";
            tm->entries[i].fields[78].name = "framelossnear";
            tm->entries[i].fields[79].name = "delaynanosec";
            tm->entries[i].fields[80].name = "remotenanosec";
            tm->entries[i].fields[81].name = "maidw5";
            tm->entries[i].fields[82].name = "maidw4";
            tm->entries[i].fields[83].name = "maidw11";
            tm->entries[i].fields[84].name = "maidw10";
            tm->entries[i].fields[85].name = "maxfilter";
            tm->entries[i].fields[86].name = "tlvlength";
            tm->entries[i].fields[87].name = "tlv0_3";
            break;
        case SOC_SBX_G2P3_REMARK_ID:
            tm->entries[i].fields[0].name = "cfi";
            tm->entries[i].fields[1].name = "pri";
            tm->entries[i].fields[2].name = "exp";
            tm->entries[i].fields[3].name = "dscp";
            break;
        case SOC_SBX_G2P3_EPV2E_ID:
            tm->entries[i].fields[0].name = "drop";
            tm->entries[i].fields[1].name = "strip";
            break;
        case SOC_SBX_G2P3_ESMAC_ID:
            tm->entries[i].fields[0].name = "smac5";
            tm->entries[i].fields[1].name = "smac4";
            tm->entries[i].fields[2].name = "smac3";
            tm->entries[i].fields[3].name = "smac2";
            tm->entries[i].fields[4].name = "smac1";
            tm->entries[i].fields[5].name = "smac0";
            break;
        case SOC_SBX_G2P3_ERT_ID:
            tm->entries[i].fields[0].name = "mirror";
            tm->entries[i].fields[1].name = "drop";
            break;
        case SOC_SBX_G2P3_ERT_WRAP_ID:
            tm->entries[i].fields[0].name = "mirror";
            tm->entries[i].fields[1].name = "drop";
            break;
        case SOC_SBX_G2P3_V4MC_STR_SEL_ID:
            tm->entries[i].fields[0].name = "valid";
            break;
        case SOC_SBX_G2P3_EFP_ID:
            tm->entries[i].fields[0].name = "dbtype";
            tm->entries[i].fields[1].name = "usedbtype";
            tm->entries[i].fields[2].name = "port";
            tm->entries[i].fields[3].name = "useport";
            tm->entries[i].fields[4].name = "pbmpn";
            tm->entries[i].fields[5].name = "pri";
            tm->entries[i].fields[6].name = "usepri";
            tm->entries[i].fields[7].name = "fragment";
            tm->entries[i].fields[8].name = "usefragment";
            tm->entries[i].fields[9].name = "urg";
            tm->entries[i].fields[10].name = "useurg";
            tm->entries[i].fields[11].name = "ack";
            tm->entries[i].fields[12].name = "useack";
            tm->entries[i].fields[13].name = "psh";
            tm->entries[i].fields[14].name = "usepsh";
            tm->entries[i].fields[15].name = "rst";
            tm->entries[i].fields[16].name = "userst";
            tm->entries[i].fields[17].name = "syn";
            tm->entries[i].fields[18].name = "usesyn";
            tm->entries[i].fields[19].name = "fin";
            tm->entries[i].fields[20].name = "usefin";
            tm->entries[i].fields[21].name = "dscp";
            tm->entries[i].fields[22].name = "usedscp";
            tm->entries[i].fields[23].name = "ecn";
            tm->entries[i].fields[24].name = "useecn";
            tm->entries[i].fields[25].name = "proto";
            tm->entries[i].fields[26].name = "useproto";
            tm->entries[i].fields[27].name = "sporthi";
            tm->entries[i].fields[28].name = "sportlo";
            tm->entries[i].fields[29].name = "dporthi";
            tm->entries[i].fields[30].name = "dportlo";
            tm->entries[i].fields[31].name = "sa";
            tm->entries[i].fields[32].name = "sawidth";
            tm->entries[i].fields[33].name = "da";
            tm->entries[i].fields[34].name = "dawidth";
            tm->entries[i].fields[35].name = "etype";
            tm->entries[i].fields[36].name = "useetype";
            tm->entries[i].fields[37].name = "smac";
            tm->entries[i].fields[38].name = "smacwidth";
            tm->entries[i].fields[39].name = "dmac";
            tm->entries[i].fields[40].name = "dmacwidth";
            tm->entries[i].fields[41].name = "pvlan";
            tm->entries[i].fields[42].name = "usepvlan";
            tm->entries[i].fields[43].name = "ssaphi";
            tm->entries[i].fields[44].name = "ssaplo";
            tm->entries[i].fields[45].name = "usessap";
            tm->entries[i].fields[46].name = "dsaphi";
            tm->entries[i].fields[47].name = "dsaplo";
            tm->entries[i].fields[48].name = "usedsap";
            tm->entries[i].fields[49].name = "llcctrlhi";
            tm->entries[i].fields[50].name = "llcctrllo";
            tm->entries[i].fields[51].name = "usellcctrl";
            tm->entries[i].fields[52].name = "enable";
            tm->entries[i].fields[53].name = "mirror";
            tm->entries[i].fields[54].name = "drop";
            break;
        case SOC_SBX_G2P3_EFP_V6_ID:
            tm->entries[i].fields[0].name = "dbtype";
            tm->entries[i].fields[1].name = "usedbtype";
            tm->entries[i].fields[2].name = "port";
            tm->entries[i].fields[3].name = "useport";
            tm->entries[i].fields[4].name = "pbmpn";
            tm->entries[i].fields[5].name = "urg";
            tm->entries[i].fields[6].name = "useurg";
            tm->entries[i].fields[7].name = "ack";
            tm->entries[i].fields[8].name = "useack";
            tm->entries[i].fields[9].name = "psh";
            tm->entries[i].fields[10].name = "usepsh";
            tm->entries[i].fields[11].name = "rst";
            tm->entries[i].fields[12].name = "userst";
            tm->entries[i].fields[13].name = "syn";
            tm->entries[i].fields[14].name = "usesyn";
            tm->entries[i].fields[15].name = "fin";
            tm->entries[i].fields[16].name = "usefin";
            tm->entries[i].fields[17].name = "TC";
            tm->entries[i].fields[18].name = "useTC";
            tm->entries[i].fields[19].name = "nextheaderhi";
            tm->entries[i].fields[20].name = "nextheaderlo";
            tm->entries[i].fields[21].name = "sporthi";
            tm->entries[i].fields[22].name = "sportlo";
            tm->entries[i].fields[23].name = "dporthi";
            tm->entries[i].fields[24].name = "dportlo";
            tm->entries[i].fields[25].name = "sa";
            tm->entries[i].fields[26].name = "sawidth";
            tm->entries[i].fields[27].name = "da";
            tm->entries[i].fields[28].name = "dawidth";
            tm->entries[i].fields[29].name = "vid";
            tm->entries[i].fields[30].name = "usevid";
            tm->entries[i].fields[31].name = "enable";
            tm->entries[i].fields[32].name = "mirror";
            tm->entries[i].fields[33].name = "drop";
            break;
        case SOC_SBX_G2P3_OAMMULTIPLIER_ID:
            tm->entries[i].fields[0].name = "frameCount";
            break;
        case SOC_SBX_G2P3_OAMEPREMAP_ID:
            tm->entries[i].fields[0].name = "epIdx";
            break;
        case SOC_SBX_G2P3_IPV6DA_ID:
            tm->entries[i].fields[0].name = "ftidx";
            tm->entries[i].fields[1].name = "ecmpmask";
            tm->entries[i].fields[2].name = "vid";
            break;
        case SOC_SBX_G2P3_IPV6DAL0_ID:
            tm->entries[i].fields[0].name = "pattern";
            tm->entries[i].fields[1].name = "singleton";
            tm->entries[i].fields[2].name = "pointer";
            tm->entries[i].fields[3].name = "leaf";
            break;
        case SOC_SBX_G2P3_IPV6DAODD_ID:
            tm->entries[i].fields[0].name = "pattern";
            tm->entries[i].fields[1].name = "singleton";
            tm->entries[i].fields[2].name = "pointer";
            tm->entries[i].fields[3].name = "leaf";
            break;
        case SOC_SBX_G2P3_IPV6DAEVEN_ID:
            tm->entries[i].fields[0].name = "pattern";
            tm->entries[i].fields[1].name = "singleton";
            tm->entries[i].fields[2].name = "pointer";
            tm->entries[i].fields[3].name = "leaf";
            break;
        case SOC_SBX_G2P3_IPV6DAPAYLOAD_ID:
            tm->entries[i].fields[0].name = "ftidx";
            tm->entries[i].fields[1].name = "ecmpmask";
            tm->entries[i].fields[2].name = "vid";
            break;
        case SOC_SBX_G2P3_IPV6SA_ID:
            tm->entries[i].fields[0].name = "poe";
            tm->entries[i].fields[1].name = "rpfmode";
            tm->entries[i].fields[2].name = "srcdrop";
            tm->entries[i].fields[3].name = "srccnt";
            break;
        case SOC_SBX_G2P3_IPV6SAL0_ID:
            tm->entries[i].fields[0].name = "pattern";
            tm->entries[i].fields[1].name = "singleton";
            tm->entries[i].fields[2].name = "pointer";
            tm->entries[i].fields[3].name = "leaf";
            break;
        case SOC_SBX_G2P3_IPV6SAODD_ID:
            tm->entries[i].fields[0].name = "pattern";
            tm->entries[i].fields[1].name = "singleton";
            tm->entries[i].fields[2].name = "pointer";
            tm->entries[i].fields[3].name = "leaf";
            break;
        case SOC_SBX_G2P3_IPV6SAEVEN_ID:
            tm->entries[i].fields[0].name = "pattern";
            tm->entries[i].fields[1].name = "singleton";
            tm->entries[i].fields[2].name = "pointer";
            tm->entries[i].fields[3].name = "leaf";
            break;
        case SOC_SBX_G2P3_IPV6SAPAYLOAD_ID:
            tm->entries[i].fields[0].name = "poe";
            tm->entries[i].fields[1].name = "rpfmode";
            tm->entries[i].fields[2].name = "srcdrop";
            tm->entries[i].fields[3].name = "srccnt";
            break;
        case SOC_SBX_G2P3_IPV4DA_ID:
            tm->entries[i].fields[0].name = "ftidx";
            tm->entries[i].fields[1].name = "ecmpmask";
            tm->entries[i].fields[2].name = "vid";
            break;
        case SOC_SBX_G2P3_IPV4DAL0_ID:
            tm->entries[i].fields[0].name = "pattern";
            tm->entries[i].fields[1].name = "singleton";
            tm->entries[i].fields[2].name = "pointer";
            tm->entries[i].fields[3].name = "leaf";
            break;
        case SOC_SBX_G2P3_IPV4DAODD_ID:
            tm->entries[i].fields[0].name = "pattern";
            tm->entries[i].fields[1].name = "singleton";
            tm->entries[i].fields[2].name = "pointer";
            tm->entries[i].fields[3].name = "leaf";
            break;
        case SOC_SBX_G2P3_IPV4DAEVEN_ID:
            tm->entries[i].fields[0].name = "pattern";
            tm->entries[i].fields[1].name = "singleton";
            tm->entries[i].fields[2].name = "pointer";
            tm->entries[i].fields[3].name = "leaf";
            break;
        case SOC_SBX_G2P3_IPV4DAPAYLOAD_ID:
            tm->entries[i].fields[0].name = "ftidx";
            tm->entries[i].fields[1].name = "ecmpmask";
            tm->entries[i].fields[2].name = "vid";
            break;
        case SOC_SBX_G2P3_P2FTI_ID:
            tm->entries[i].fields[0].name = "ftidx";
            break;
        case SOC_SBX_G2P3_POLICER_ID:
            tm->entries[i].fields[0].name = "cbsbytes";
            tm->entries[i].fields[1].name = "cirkbps";
            tm->entries[i].fields[2].name = "ebsbytes";
            tm->entries[i].fields[3].name = "eirkbps";
            tm->entries[i].fields[4].name = "mode";
            tm->entries[i].fields[5].name = "lenshift";
            tm->entries[i].fields[6].name = "colorblind";
            tm->entries[i].fields[7].name = "dropred";
            tm->entries[i].fields[8].name = "coupling";
            tm->entries[i].fields[9].name = "nodebit";
            break;
        case SOC_SBX_G2P3_TIMER_ID:
            tm->entries[i].fields[0].name = "ms";
            tm->entries[i].fields[1].name = "started";
            tm->entries[i].fields[2].name = "ucodereset";
            tm->entries[i].fields[3].name = "interrupt";
            break;
        case SOC_SBX_G2P3_SEQUENCE_ID:
            tm->entries[i].fields[0].name = "seqnum";
            break;
        }

        for (j = 0; j < tm->entries[i].nfields; j++) {
            s = soc_sbx_g2p3_ucode_get(unit,
                        soc_sbx_g2p3_sym,
                        128,
                        &tm->entries[i].fields[j].pos,
                        e,
                        tm->entries[i].name,
                        -1,
                        tm->entries[i].fields[j].name,
                        "POSITION");
            if (s) {
                soc_sbx_g2p3_uninit(unit);
                return s;
            }
            s = soc_sbx_g2p3_ucode_get(unit,
                        soc_sbx_g2p3_sym,
                        128,
                        &tm->entries[i].fields[j].range,
                        e,
                        tm->entries[i].name,
                        -1,
                        tm->entries[i].fields[j].name,
                        "RANGE");
            if (s) {
                soc_sbx_g2p3_uninit(unit);
                return s;
            }
            s = soc_sbx_g2p3_ucode_get(unit,
                        soc_sbx_g2p3_sym,
                        128,
                        &tm->entries[i].fields[j].width,
                        e,
                        tm->entries[i].name,
                        -1,
                        tm->entries[i].fields[j].name,
                        "WIDTH");
            if (s) {
                soc_sbx_g2p3_uninit(unit);
                return s;
            }
        }
    }

    /*
     * Per-counter state initialization
     */
    for (i = 0; i < SOC_SBX_G2P3_COUNTER_BANKS_MAX; i++) {
        tm->counterbanks[i].base = -1;
    }
    tm->counters = UTG_MALLOC(sizeof(soc_sbx_g2p3_counter_desc_t)
                         * SOC_SBX_G2P3_COUNTER_MAX_ID);
    if (!tm->counters) {
        soc_sbx_g2p3_uninit(unit);
        return SOC_E_MEMORY;
    }

    tm->counters[SOC_SBX_G2P3_PDCTR_ID].name =
        "pdctr";
    tm->counters[SOC_SBX_G2P3_RTCTR_ID].name =
        "rtctr";
    tm->counters[SOC_SBX_G2P3_IRTCTR_ID].name =
        "irtctr";
    tm->counters[SOC_SBX_G2P3_IFPCTR_ID].name =
        "ifpctr";
    tm->counters[SOC_SBX_G2P3_IFP_V6CTR_ID].name =
        "ifp_v6ctr";
    tm->counters[SOC_SBX_G2P3_ERTCTR_ID].name =
        "ertctr";
    tm->counters[SOC_SBX_G2P3_EFPCTR_ID].name =
        "efpctr";
    tm->counters[SOC_SBX_G2P3_EFP_V6CTR_ID].name =
        "efp_v6ctr";
    tm->counters[SOC_SBX_G2P3_EXCCTR_ID].name =
        "excctr";
    tm->counters[SOC_SBX_G2P3_INGCTR_ID].name =
        "ingctr";
    tm->counters[SOC_SBX_G2P3_EGRCTR_ID].name =
        "egrctr";

    for (i = 0; i < SOC_SBX_G2P3_COUNTER_MAX_ID; i++) {
        s = soc_sbx_g2p3_ucode_get(unit,
                  soc_sbx_g2p3_sym,
                  128,
                  &tm->counters[i].bank,
                  e,
                  tm->counters[i].name, 
                  -1,
                  e,
                  "BANK");
        if (s) {
            soc_sbx_g2p3_uninit(unit);
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                  soc_sbx_g2p3_sym,
                  128,
                  &tm->counters[i].size,
                  e,
                  tm->counters[i].name, 
                  -1,
                  e,
                  "SIZE");
        if (s) {
            soc_sbx_g2p3_uninit(unit);
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                  soc_sbx_g2p3_sym,
                  128,
                  &tm->counters[i].base,
                  e,
                  tm->counters[i].name, 
                  -1,
                  e,
                  "BASE");
        if (s) {
            soc_sbx_g2p3_uninit(unit);
            return s;
        }
        tm->counters[i].base &= ((1 << 23) - 1);
        j = tm->counters[i].bank;
        if (0 <= j) {
            if (tm->counterbanks[j].base  == -1) {
                s = soc_sbx_g2p3_ucode_get(unit,
                            soc_sbx_g2p3_sym,
                            128,
                            &tm->counterbanks[j].memory,
                            e,
                            "COUNTER_BANK",
                            j,
                            e,
                            "MEMORY");
                if (s) {
                    soc_sbx_g2p3_uninit(unit);
                    return s;
                }
                s = soc_sbx_g2p3_ucode_get(unit,
                            soc_sbx_g2p3_sym,
                            128,
                            &tm->counterbanks[j].base,
                            e,
                            "COUNTER_BANK",
                            j,
                            e,
                            "BASE");
                if (s) {
                    soc_sbx_g2p3_uninit(unit);
                    return s;
                }
            }
            tm->counterbanks[j].size += tm->counters[i].size;
        }
    }

    /*
     * Per-policer state initialization
     */
    for (i = 0; i < SOC_SBX_G2P3_POLICER_BANKS_MAX; i++) {
        tm->policerbanks[i].base = -1;
    }
    tm->policers = UTG_MALLOC(sizeof(soc_sbx_g2p3_policer_desc_t)
                         * SOC_SBX_G2P3_POLICER_MAX_ID);
    if (!tm->policers) {
        soc_sbx_g2p3_uninit(unit);
        return SOC_E_MEMORY;
    }

    pbset = 0;
    tm->policers[SOC_SBX_G2P3_XTPOL_ID].name =
        "xtpol";
    tm->policers[SOC_SBX_G2P3_INGEGRPOL_ID].name =
        "ingegrpol";
    tm->policers[SOC_SBX_G2P3_OAMTIMER_ID].name =
        "oamtimer";
    tm->policers[SOC_SBX_G2P3_OAMSEQ_ID].name =
        "oamseq";

    for (i = 0; i < SOC_SBX_G2P3_POLICER_MAX_ID; i++) {
        s = soc_sbx_g2p3_ucode_get(unit,
                  soc_sbx_g2p3_sym,
                  128,
                  &tm->policers[i].bank,
                  e,
                  tm->policers[i].name, 
                  -1,
                  e,
                  "BANK");
        if (s) {
            soc_sbx_g2p3_uninit(unit);
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                  soc_sbx_g2p3_sym,
                  128,
                  &tm->policers[i].size,
                  e,
                  tm->policers[i].name, 
                  -1,
                  e,
                  "SIZE");
        if (s) {
            soc_sbx_g2p3_uninit(unit);
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                  soc_sbx_g2p3_sym,
                  128,
                  &tm->policers[i].base,
                  e,
                  tm->policers[i].name, 
                  -1,
                  e,
                  "BASE");
        if (s) {
            soc_sbx_g2p3_uninit(unit);
            return s;
        }
        j = tm->policers[i].bank;
        if (tm->policerbanks[j].base  == -1) {
            s = soc_sbx_g2p3_ucode_get(unit,
                        soc_sbx_g2p3_sym,
                        128,
                        &tm->policerbanks[j].memory,
                        e,
                        "POLICER_BANK",
                        j,
                        e,
                        "MEMORY");
            if (s) {
                soc_sbx_g2p3_uninit(unit);
                return s;
            }
            s = soc_sbx_g2p3_ucode_get(unit,
                        soc_sbx_g2p3_sym,
                        128,
                        &tm->policerbanks[j].base,
                        e,
                        "POLICER_BANK",
                        j,
                        e,
                        "BASE");
            if (s) {
                soc_sbx_g2p3_uninit(unit);
                return s;
            }
            if (!pbset) {
                tm->policerbase = tm->policerbanks[j].base;
                pbset = 1;
            }
            s = soc_sbx_g2p3_ucode_get(unit,
                        soc_sbx_g2p3_sym,
                        128,
                        &tm->policerbanks[j].kbps,
                        e,
                        "POLICER_BANK",
                        j,
                        e,
                        "KBPS");
            if (s) {
                soc_sbx_g2p3_uninit(unit);
                return s;
            }
            s = soc_sbx_g2p3_ucode_get(unit,
                        soc_sbx_g2p3_sym,
                        128,
                        &tm->policerbanks[j].type,
                        e,
                        "POLICER_BANK",
                        j,
                        e,
                        "TYPE");
            if (s) {
                soc_sbx_g2p3_uninit(unit);
                return s;
            }
        }
        tm->policers[i].base -= tm->policerbanks[j].base;
        tm->policerbanks[j].size += tm->policers[i].size;
    }

    /*
     * Per-memory state initialization
     */
    tm->memories = UTG_MALLOC(sizeof(soc_sbx_g2p3_memory_desc_t)
                              * SOC_SBX_G2P3_MEMORY_MAX_ID);
    if (!tm->memories) {
        soc_sbx_g2p3_uninit(unit);
        return SOC_E_MEMORY;
    }

    tm->memories[SOC_SBX_G2P3_MM0_NAR0_ID]
        .name = "mm0_nar0";
    tm->memories[SOC_SBX_G2P3_MM0_NAR0_ID]
        .dma = 1;
    tm->memories[SOC_SBX_G2P3_MM0_NAR0_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G2P3_MM0_NAR0_ID].reg
        = SAND_HAL_FE2000_REG_OFFSET(fe->regSet,
              MM0_NARROW_PORT0_MEM_ACC_CTRL);
    tm->memories[SOC_SBX_G2P3_MM0_NAR0_ID].alignedlist = -1;

    tm->memories[SOC_SBX_G2P3_MM0_NAR1_ID]
        .name = "mm0_nar1";
    tm->memories[SOC_SBX_G2P3_MM0_NAR1_ID]
        .dma = 1;
    tm->memories[SOC_SBX_G2P3_MM0_NAR1_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G2P3_MM0_NAR1_ID].reg
        = SAND_HAL_FE2000_REG_OFFSET(fe->regSet,
              MM0_NARROW_PORT1_MEM_ACC_CTRL);
    tm->memories[SOC_SBX_G2P3_MM0_NAR1_ID].alignedlist = -1;

    tm->memories[SOC_SBX_G2P3_MM0_WIDE_ID]
        .name = "mm0_wide";
    tm->memories[SOC_SBX_G2P3_MM0_WIDE_ID]
        .dma = 1;
    tm->memories[SOC_SBX_G2P3_MM0_WIDE_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G2P3_MM0_WIDE_ID].reg
        = SAND_HAL_FE2000_REG_OFFSET(fe->regSet,
              MM0_WIDE_PORT_MEM_ACC_CTRL);
    tm->memories[SOC_SBX_G2P3_MM0_WIDE_ID].alignedlist = -1;

    tm->memories[SOC_SBX_G2P3_MM0_INT0_ID]
        .name = "mm0_int0";
    tm->memories[SOC_SBX_G2P3_MM0_INT0_ID]
        .dma = 1;
    tm->memories[SOC_SBX_G2P3_MM0_INT0_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G2P3_MM0_INT0_ID].reg
        = SAND_HAL_FE2000_REG_OFFSET(fe->regSet,
              MM0_INT0_MEM_ACC_CTRL);
    tm->memories[SOC_SBX_G2P3_MM0_INT0_ID].alignedlist = -1;

    tm->memories[SOC_SBX_G2P3_MM0_INT1_ID]
        .name = "mm0_int1";
    tm->memories[SOC_SBX_G2P3_MM0_INT1_ID]
        .dma = 1;
    tm->memories[SOC_SBX_G2P3_MM0_INT1_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G2P3_MM0_INT1_ID].reg
        = SAND_HAL_FE2000_REG_OFFSET(fe->regSet,
              MM0_INT1_MEM_ACC_CTRL);
    tm->memories[SOC_SBX_G2P3_MM0_INT1_ID].alignedlist = -1;

    tm->memories[SOC_SBX_G2P3_MM1_NAR0_ID]
        .name = "mm1_nar0";
    tm->memories[SOC_SBX_G2P3_MM1_NAR0_ID]
        .dma = 1;
    tm->memories[SOC_SBX_G2P3_MM1_NAR0_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G2P3_MM1_NAR0_ID].reg
        = SAND_HAL_FE2000_REG_OFFSET(fe->regSet,
              MM1_NARROW_PORT0_MEM_ACC_CTRL);
    tm->memories[SOC_SBX_G2P3_MM1_NAR0_ID].alignedlist = -1;

    tm->memories[SOC_SBX_G2P3_MM1_NAR1_ID]
        .name = "mm1_nar1";
    tm->memories[SOC_SBX_G2P3_MM1_NAR1_ID]
        .dma = 1;
    tm->memories[SOC_SBX_G2P3_MM1_NAR1_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G2P3_MM1_NAR1_ID].reg
        = SAND_HAL_FE2000_REG_OFFSET(fe->regSet,
              MM1_NARROW_PORT1_MEM_ACC_CTRL);
    tm->memories[SOC_SBX_G2P3_MM1_NAR1_ID].alignedlist = -1;

    tm->memories[SOC_SBX_G2P3_MM1_WIDE_ID]
        .name = "mm1_wide";
    tm->memories[SOC_SBX_G2P3_MM1_WIDE_ID]
        .dma = 1;
    tm->memories[SOC_SBX_G2P3_MM1_WIDE_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G2P3_MM1_WIDE_ID].reg
        = SAND_HAL_FE2000_REG_OFFSET(fe->regSet,
              MM1_WIDE_PORT_MEM_ACC_CTRL);
    tm->memories[SOC_SBX_G2P3_MM1_WIDE_ID].alignedlist = -1;

    tm->memories[SOC_SBX_G2P3_MM1_INT0_ID]
        .name = "mm1_int0";
    tm->memories[SOC_SBX_G2P3_MM1_INT0_ID]
        .dma = 1;
    tm->memories[SOC_SBX_G2P3_MM1_INT0_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G2P3_MM1_INT0_ID].reg
        = SAND_HAL_FE2000_REG_OFFSET(fe->regSet,
              MM1_INT0_MEM_ACC_CTRL);
    tm->memories[SOC_SBX_G2P3_MM1_INT0_ID].alignedlist = -1;

    tm->memories[SOC_SBX_G2P3_MM1_INT1_ID]
        .name = "mm1_int1";
    tm->memories[SOC_SBX_G2P3_MM1_INT1_ID]
        .dma = 1;
    tm->memories[SOC_SBX_G2P3_MM1_INT1_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G2P3_MM1_INT1_ID].reg
        = SAND_HAL_FE2000_REG_OFFSET(fe->regSet,
              MM1_INT1_MEM_ACC_CTRL);
    tm->memories[SOC_SBX_G2P3_MM1_INT1_ID].alignedlist = -1;

    tm->memories[SOC_SBX_G2P3_RC0_RR_ID]
        .name = "rc0_rr";
    tm->memories[SOC_SBX_G2P3_RC0_RR_ID]
        .dma = 0;
    tm->memories[SOC_SBX_G2P3_RC0_RR_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G2P3_RC0_RR_ID].reg
        = SAND_HAL_FE2000_REG_OFFSET(fe->regSet,
              RC0_RR_MEM_ACC_CTRL);
    tm->memories[SOC_SBX_G2P3_RC0_RR_ID].alignedlist = -1;

    tm->memories[SOC_SBX_G2P3_RC1_RR_ID]
        .name = "rc1_rr";
    tm->memories[SOC_SBX_G2P3_RC1_RR_ID]
        .dma = 0;
    tm->memories[SOC_SBX_G2P3_RC1_RR_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G2P3_RC1_RR_ID].reg
        = SAND_HAL_FE2000_REG_OFFSET(fe->regSet,
              RC1_RR_MEM_ACC_CTRL);
    tm->memories[SOC_SBX_G2P3_RC1_RR_ID].alignedlist = -1;

    tm->memories[SOC_SBX_G2P3_RXPORTDATA_ID]
        .name = "rxportdata";
    tm->memories[SOC_SBX_G2P3_RXPORTDATA_ID]
        .dma = 0;
    tm->memories[SOC_SBX_G2P3_RXPORTDATA_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G2P3_RXPORTDATA_ID].reg
        = SAND_HAL_FE2000_REG_OFFSET(fe->regSet,
              PP_RX_PORT_DATA_MEM_ACC_CTRL);
    tm->memories[SOC_SBX_G2P3_RXPORTDATA_ID].alignedlist = -1;

    tm->memories[SOC_SBX_G2P3_INITIALQSTATE20_ID]
        .name = "initialqstate20";
    tm->memories[SOC_SBX_G2P3_INITIALQSTATE20_ID]
        .dma = 0;
    tm->memories[SOC_SBX_G2P3_INITIALQSTATE20_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G2P3_INITIALQSTATE20_ID].reg
        = SAND_HAL_FE2000_REG_OFFSET(fe->regSet,
              PP_INITIAL_QUEUE_STATE_MEM_ACC_CTRL);
    tm->memories[SOC_SBX_G2P3_INITIALQSTATE20_ID].alignedlist = -1;

    tm->memories[SOC_SBX_G2P3_INITIALQSTATE25_ID]
        .name = "initialqstate25";
    tm->memories[SOC_SBX_G2P3_INITIALQSTATE25_ID]
        .dma = 0;
    tm->memories[SOC_SBX_G2P3_INITIALQSTATE25_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G2P3_INITIALQSTATE25_ID].reg
        = SAND_HAL_FE2000_REG_OFFSET(fe->regSet,
              PP_INITIAL_QUEUE_STATE_MEM_ACC_CTRL);
    tm->memories[SOC_SBX_G2P3_INITIALQSTATE25_ID].alignedlist = -1;

    tm->memories[SOC_SBX_G2P3_EMIRRORHW20_ID]
        .name = "emirrorhw20";
    tm->memories[SOC_SBX_G2P3_EMIRRORHW20_ID]
        .dma = 0;
    tm->memories[SOC_SBX_G2P3_EMIRRORHW20_ID]
        .descending = 0;
    tm->memories[SOC_SBX_G2P3_EMIRRORHW20_ID].reg
        = SAND_HAL_FE2000_REG_OFFSET(fe->regSet,
              PT_MIRROR_INDEX_MEM_ACC_CTRL);
    tm->memories[SOC_SBX_G2P3_EMIRRORHW20_ID].alignedlist = -1;

    tm->memories[SOC_SBX_G2P3_EMIRRORHW25_ID]
        .name = "emirrorhw25";
    tm->memories[SOC_SBX_G2P3_EMIRRORHW25_ID]
        .dma = 0;
    tm->memories[SOC_SBX_G2P3_EMIRRORHW25_ID]
        .descending = 0;
    tm->memories[SOC_SBX_G2P3_EMIRRORHW25_ID].reg
        = SAND_HAL_FE2000_REG_OFFSET(fe->regSet,
              PT_MIRROR_INDEX_MEM_ACC_CTRL);
    tm->memories[SOC_SBX_G2P3_EMIRRORHW25_ID].alignedlist = -1;

    for (i = 0; i < SOC_SBX_G2P3_MEMORY_MAX_ID; i++) {
        s = soc_sbx_g2p3_ucode_get(unit,
                  soc_sbx_g2p3_sym,
                  128,
                  &tm->memories[i].width,
                  e,
                  tm->memories[i].name, 
                  -1,
                  e,
                  "WIDTH");
        if (s) {
            soc_sbx_g2p3_uninit(unit);
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                  soc_sbx_g2p3_sym,
                  128,
                  &tm->memories[i].size,
                  e,
                  tm->memories[i].name, 
                  -1,
                  e,
                  "SIZE");
        if (s) {
            soc_sbx_g2p3_uninit(unit);
            return s;
        }
    }

    j = 0;
    for (i = 0; i < SOC_SBX_G2P3_COUNTER_BANKS_MAX; i++){
        if (tm->counterbanks[i].base > 0) j++;
    }
    for (i = 0; i < SOC_SBX_G2P3_POLICER_BANKS_MAX; i++){
        if (tm->policerbanks[i].base > 0) j++;
    }
    j = SOC_SBX_G2P3_COUNTER_BANKS_MAX + SOC_SBX_G2P3_POLICER_BANKS_MAX;
    for (i = 0; i < SOC_SBX_G2P3_TABLE_MAX_ID; i++){
        j += tm->tables[i].nbanks;
    }

    tm->memorybanks = UTG_MALLOC(sizeof(soc_sbx_g2p3_memory_bank_desc_t) * j);
    if (!tm->memorybanks) {
        soc_sbx_g2p3_uninit(unit);
        return SOC_E_MEMORY;
    }

    soc_sbx_g2p3_memory_banks_init(tm);
    soc_sbx_g2p3_tables_aligned_topo_sort(unit);

    tm->bufsize = 1024;
    tm->entrydmabuf = soc_cm_salloc(unit, tm->bufsize * sizeof(uint32),
                             "entry dma");
    if (!tm->entrydmabuf) {
        return SOC_E_MEMORY;
    }
    tm->entrydmabufhba = soc_cm_l2p(unit, tm->entrydmabuf);
    tm->entrydmaop.dmaHandle.handle = INT_TO_PTR(unit);

    tm->dmabufmutex = sal_mutex_create("dma mutex");
    if (!tm->dmabufmutex) {
        return SOC_E_RESOURCE;
    }

    return SOC_E_NONE;
}

/*
 * Microcode complex table initializer implementation
 */
int soc_sbx_g2p3_complex_init(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td;
    soc_sbx_g2p3_complex_bank_desc_t cds[SOC_SBX_G2P3_COMPLEX_BANKS_MAX], *cd;
    char *e = "";
    int i, align, cbs, b, saltwidth;
    int s = SOC_E_NONE;
    soc_sbx_g2p3_ipv4sa_t eipv4sa;
    soc_sbx_g2p3_ipv6da_t eipv6da;
    soc_sbx_g2p3_ipv6sa_t eipv6sa;
    soc_sbx_g2p3_ipv4da_t eipv4da;

    td = &tm->tables[SOC_SBX_G2P3_MAC_TABLE_ID];
    if (td->type != SOC_SBX_G2P3_EML_TABLE_TYPE) {
        return SOC_E_INTERNAL;
    }
    s = soc_sbx_g2p3_ucode_get(unit,
                soc_sbx_g2p3_sym,
                128,
                &cbs,
                e,
                td->name,
                -1,
                e,
                "CBANKS");
    if (s) {
        return s;
    }
    for (i = 0; i < cbs; i++) {
        cd = &cds[i];
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &cd->pos,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_POS");
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &cd->width,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_WIDTH");
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &cd->type,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_TYPE");
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &b,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_BANK");
        if (s) {
            return s;
        }
        if (b >= td->nbanks) {
            return SOC_E_INTERNAL;
        }
        cd->memory = td->banks[b].memory;
        cd->base = td->banks[b].base;
        cd->size = td->banks[b].size;
    }
    s = soc_sbx_g2p3_ucode_get(unit,
                soc_sbx_g2p3_sym,
                128,
                &saltwidth,
                e,
                td->name,
                -1,
                e,
                "SALT");
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ucode_get(unit,
                soc_sbx_g2p3_sym,
                128,
                &align,
                e,
                td->name,
                -1,
                e,
                "TABLE_ALIGN");
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_eml_init_ext(unit, &td->cstate,
                 td->name, cbs, cds, saltwidth,
                 tm->entries[SOC_SBX_G2P3_MAC_ID].fields[0].pos,
                 tm->entries[SOC_SBX_G2P3_MAC_ID].fields[0].width,
                 tm->entries[SOC_SBX_G2P3_MAC_ID].fields[6].pos,
                 align);
    if (s) {
        return(s);
    }

    td = &tm->tables[SOC_SBX_G2P3_IPV6DHOST_TABLE_ID];
    if (td->type != SOC_SBX_G2P3_EML_TABLE_TYPE) {
        return SOC_E_INTERNAL;
    }
    s = soc_sbx_g2p3_ucode_get(unit,
                soc_sbx_g2p3_sym,
                128,
                &cbs,
                e,
                td->name,
                -1,
                e,
                "CBANKS");
    if (s) {
        return s;
    }
    for (i = 0; i < cbs; i++) {
        cd = &cds[i];
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &cd->pos,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_POS");
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &cd->width,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_WIDTH");
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &cd->type,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_TYPE");
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &b,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_BANK");
        if (s) {
            return s;
        }
        if (b >= td->nbanks) {
            return SOC_E_INTERNAL;
        }
        cd->memory = td->banks[b].memory;
        cd->base = td->banks[b].base;
        cd->size = td->banks[b].size;
    }
    s = soc_sbx_g2p3_ucode_get(unit,
                soc_sbx_g2p3_sym,
                128,
                &saltwidth,
                e,
                td->name,
                -1,
                e,
                "SALT");
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ucode_get(unit,
                soc_sbx_g2p3_sym,
                128,
                &align,
                e,
                td->name,
                -1,
                e,
                "TABLE_ALIGN");
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_eml_init_ext(unit, &td->cstate,
                 td->name, cbs, cds, saltwidth,
                 -1,
                 0,
                 -1,
                 align);
    if (s) {
        return(s);
    }

    td = &tm->tables[SOC_SBX_G2P3_IPV6SHOST_TABLE_ID];
    if (td->type != SOC_SBX_G2P3_EML_TABLE_TYPE) {
        return SOC_E_INTERNAL;
    }
    s = soc_sbx_g2p3_ucode_get(unit,
                soc_sbx_g2p3_sym,
                128,
                &cbs,
                e,
                td->name,
                -1,
                e,
                "CBANKS");
    if (s) {
        return s;
    }
    for (i = 0; i < cbs; i++) {
        cd = &cds[i];
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &cd->pos,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_POS");
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &cd->width,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_WIDTH");
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &cd->type,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_TYPE");
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &b,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_BANK");
        if (s) {
            return s;
        }
        if (b >= td->nbanks) {
            return SOC_E_INTERNAL;
        }
        cd->memory = td->banks[b].memory;
        cd->base = td->banks[b].base;
        cd->size = td->banks[b].size;
    }
    s = soc_sbx_g2p3_ucode_get(unit,
                soc_sbx_g2p3_sym,
                128,
                &saltwidth,
                e,
                td->name,
                -1,
                e,
                "SALT");
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ucode_get(unit,
                soc_sbx_g2p3_sym,
                128,
                &align,
                e,
                td->name,
                -1,
                e,
                "TABLE_ALIGN");
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_eml_init_ext(unit, &td->cstate,
                 td->name, cbs, cds, saltwidth,
                 -1,
                 0,
                 -1,
                 align);
    if (s) {
        return(s);
    }

    td = &tm->tables[SOC_SBX_G2P3_CUCKOO_TABLE_ID];
    if (td->type != SOC_SBX_G2P3_EM32_TABLE_TYPE) {
        return SOC_E_INTERNAL;
    }
    s = soc_sbx_g2p3_ucode_get(unit,
                soc_sbx_g2p3_sym,
                128,
                &cbs,
                e,
                td->name,
                -1,
                e,
                "CBANKS");
    if (s) {
        return s;
    }
    for (i = 0; i < cbs; i++) {
        cd = &cds[i];
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &cd->pos,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_POS");
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &cd->width,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_WIDTH");
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &cd->type,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_TYPE");
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &b,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_BANK");
        if (s) {
            return s;
        }
        if (b >= td->nbanks) {
            return SOC_E_INTERNAL;
        }
        cd->memory = td->banks[b].memory;
        cd->base = td->banks[b].base;
        cd->size = td->banks[b].size;
        cd = &cds[cbs + i];
        cd->pos = cds[i].pos;
        cd->width = cds[i].width;
        cd->type = cds[i].type;
        cd->memory = td->banks[b + td->nbanks / 2].memory;
        cd->base = td->banks[b + td->nbanks / 2].base;
        cd->size = td->banks[b + td->nbanks / 2].size;
    }
    s = soc_sbx_g2p3_em32_init_ext(unit, &td->cstate,
                   td->name, cbs * 2, cds);
    if (s) {
        return(s);
    }

    td = &tm->tables[SOC_SBX_G2P3_OUTERLABELCUCKOO_TABLE_ID];
    if (td->type != SOC_SBX_G2P3_EM32_TABLE_TYPE) {
        return SOC_E_INTERNAL;
    }
    s = soc_sbx_g2p3_ucode_get(unit,
                soc_sbx_g2p3_sym,
                128,
                &cbs,
                e,
                td->name,
                -1,
                e,
                "CBANKS");
    if (s) {
        return s;
    }
    for (i = 0; i < cbs; i++) {
        cd = &cds[i];
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &cd->pos,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_POS");
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &cd->width,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_WIDTH");
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &cd->type,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_TYPE");
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &b,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_BANK");
        if (s) {
            return s;
        }
        if (b >= td->nbanks) {
            return SOC_E_INTERNAL;
        }
        cd->memory = td->banks[b].memory;
        cd->base = td->banks[b].base;
        cd->size = td->banks[b].size;
        cd = &cds[cbs + i];
        cd->pos = cds[i].pos;
        cd->width = cds[i].width;
        cd->type = cds[i].type;
        cd->memory = td->banks[b + td->nbanks / 2].memory;
        cd->base = td->banks[b + td->nbanks / 2].base;
        cd->size = td->banks[b + td->nbanks / 2].size;
    }
    s = soc_sbx_g2p3_em32_init_ext(unit, &td->cstate,
                   td->name, cbs * 2, cds);
    if (s) {
        return(s);
    }

    td = &tm->tables[SOC_SBX_G2P3_INNERLABELCUCKOO_TABLE_ID];
    if (td->type != SOC_SBX_G2P3_EM32_TABLE_TYPE) {
        return SOC_E_INTERNAL;
    }
    s = soc_sbx_g2p3_ucode_get(unit,
                soc_sbx_g2p3_sym,
                128,
                &cbs,
                e,
                td->name,
                -1,
                e,
                "CBANKS");
    if (s) {
        return s;
    }
    for (i = 0; i < cbs; i++) {
        cd = &cds[i];
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &cd->pos,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_POS");
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &cd->width,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_WIDTH");
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &cd->type,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_TYPE");
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &b,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_BANK");
        if (s) {
            return s;
        }
        if (b >= td->nbanks) {
            return SOC_E_INTERNAL;
        }
        cd->memory = td->banks[b].memory;
        cd->base = td->banks[b].base;
        cd->size = td->banks[b].size;
        cd = &cds[cbs + i];
        cd->pos = cds[i].pos;
        cd->width = cds[i].width;
        cd->type = cds[i].type;
        cd->memory = td->banks[b + td->nbanks / 2].memory;
        cd->base = td->banks[b + td->nbanks / 2].base;
        cd->size = td->banks[b + td->nbanks / 2].size;
    }
    s = soc_sbx_g2p3_em32_init_ext(unit, &td->cstate,
                   td->name, cbs * 2, cds);
    if (s) {
        return(s);
    }

    td = &tm->tables[SOC_SBX_G2P3_IPV6MCSG_TABLE_ID];
    if (td->type != SOC_SBX_G2P3_EML_TABLE_TYPE) {
        return SOC_E_INTERNAL;
    }
    s = soc_sbx_g2p3_ucode_get(unit,
                soc_sbx_g2p3_sym,
                128,
                &cbs,
                e,
                td->name,
                -1,
                e,
                "CBANKS");
    if (s) {
        return s;
    }
    for (i = 0; i < cbs; i++) {
        cd = &cds[i];
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &cd->pos,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_POS");
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &cd->width,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_WIDTH");
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &cd->type,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_TYPE");
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &b,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_BANK");
        if (s) {
            return s;
        }
        if (b >= td->nbanks) {
            return SOC_E_INTERNAL;
        }
        cd->memory = td->banks[b].memory;
        cd->base = td->banks[b].base;
        cd->size = td->banks[b].size;
    }
    s = soc_sbx_g2p3_ucode_get(unit,
                soc_sbx_g2p3_sym,
                128,
                &saltwidth,
                e,
                td->name,
                -1,
                e,
                "SALT");
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ucode_get(unit,
                soc_sbx_g2p3_sym,
                128,
                &align,
                e,
                td->name,
                -1,
                e,
                "TABLE_ALIGN");
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_eml_init_ext(unit, &td->cstate,
                 td->name, cbs, cds, saltwidth,
                 -1,
                 0,
                 -1,
                 align);
    if (s) {
        return(s);
    }

    td = &tm->tables[SOC_SBX_G2P3_IPV6MCG_TABLE_ID];
    if (td->type != SOC_SBX_G2P3_EML_TABLE_TYPE) {
        return SOC_E_INTERNAL;
    }
    s = soc_sbx_g2p3_ucode_get(unit,
                soc_sbx_g2p3_sym,
                128,
                &cbs,
                e,
                td->name,
                -1,
                e,
                "CBANKS");
    if (s) {
        return s;
    }
    for (i = 0; i < cbs; i++) {
        cd = &cds[i];
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &cd->pos,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_POS");
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &cd->width,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_WIDTH");
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &cd->type,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_TYPE");
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &b,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_BANK");
        if (s) {
            return s;
        }
        if (b >= td->nbanks) {
            return SOC_E_INTERNAL;
        }
        cd->memory = td->banks[b].memory;
        cd->base = td->banks[b].base;
        cd->size = td->banks[b].size;
    }
    s = soc_sbx_g2p3_ucode_get(unit,
                soc_sbx_g2p3_sym,
                128,
                &saltwidth,
                e,
                td->name,
                -1,
                e,
                "SALT");
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ucode_get(unit,
                soc_sbx_g2p3_sym,
                128,
                &align,
                e,
                td->name,
                -1,
                e,
                "TABLE_ALIGN");
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_eml_init_ext(unit, &td->cstate,
                 td->name, cbs, cds, saltwidth,
                 -1,
                 0,
                 -1,
                 align);
    if (s) {
        return(s);
    }

    td = &tm->tables[SOC_SBX_G2P3_IPV4MCG_TABLE_ID];
    if (td->type != SOC_SBX_G2P3_EML_TABLE_TYPE) {
        return SOC_E_INTERNAL;
    }
    s = soc_sbx_g2p3_ucode_get(unit,
                soc_sbx_g2p3_sym,
                128,
                &cbs,
                e,
                td->name,
                -1,
                e,
                "CBANKS");
    if (s) {
        return s;
    }
    for (i = 0; i < cbs; i++) {
        cd = &cds[i];
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &cd->pos,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_POS");
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &cd->width,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_WIDTH");
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &cd->type,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_TYPE");
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &b,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_BANK");
        if (s) {
            return s;
        }
        if (b >= td->nbanks) {
            return SOC_E_INTERNAL;
        }
        cd->memory = td->banks[b].memory;
        cd->base = td->banks[b].base;
        cd->size = td->banks[b].size;
    }
    s = soc_sbx_g2p3_ucode_get(unit,
                soc_sbx_g2p3_sym,
                128,
                &saltwidth,
                e,
                td->name,
                -1,
                e,
                "SALT");
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ucode_get(unit,
                soc_sbx_g2p3_sym,
                128,
                &align,
                e,
                td->name,
                -1,
                e,
                "TABLE_ALIGN");
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_eml_init_ext(unit, &td->cstate,
                 td->name, cbs, cds, saltwidth,
                 -1,
                 0,
                 -1,
                 align);
    if (s) {
        return(s);
    }

    td = &tm->tables[SOC_SBX_G2P3_IPV4MCSG_TABLE_ID];
    if (td->type != SOC_SBX_G2P3_EML_TABLE_TYPE) {
        return SOC_E_INTERNAL;
    }
    s = soc_sbx_g2p3_ucode_get(unit,
                soc_sbx_g2p3_sym,
                128,
                &cbs,
                e,
                td->name,
                -1,
                e,
                "CBANKS");
    if (s) {
        return s;
    }
    for (i = 0; i < cbs; i++) {
        cd = &cds[i];
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &cd->pos,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_POS");
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &cd->width,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_WIDTH");
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &cd->type,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_TYPE");
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &b,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_BANK");
        if (s) {
            return s;
        }
        if (b >= td->nbanks) {
            return SOC_E_INTERNAL;
        }
        cd->memory = td->banks[b].memory;
        cd->base = td->banks[b].base;
        cd->size = td->banks[b].size;
    }
    s = soc_sbx_g2p3_ucode_get(unit,
                soc_sbx_g2p3_sym,
                128,
                &saltwidth,
                e,
                td->name,
                -1,
                e,
                "SALT");
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ucode_get(unit,
                soc_sbx_g2p3_sym,
                128,
                &align,
                e,
                td->name,
                -1,
                e,
                "TABLE_ALIGN");
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_eml_init_ext(unit, &td->cstate,
                 td->name, cbs, cds, saltwidth,
                 -1,
                 0,
                 -1,
                 align);
    if (s) {
        return(s);
    }

    td = &tm->tables[SOC_SBX_G2P3_IPV4SA_TABLE_ID];
    if (td->type != SOC_SBX_G2P3_LPM_TABLE_TYPE) {
        return SOC_E_INTERNAL;
    }
    s = soc_sbx_g2p3_ucode_get(unit,
                soc_sbx_g2p3_sym,
                128,
                &cbs,
                e,
                td->name,
                -1,
                e,
                "CBANKS");
    if (s) {
        return s;
    }
    for (i = 0; i < cbs; i++) {
        cd = &cds[i];
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &cd->pos,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_POS");
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &cd->width,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_WIDTH");
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &cd->type,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_TYPE");
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &b,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_BANK");
        if (s) {
            return s;
        }
        if (b >= td->nbanks) {
            return SOC_E_INTERNAL;
        }
        cd->memory = td->banks[b].memory;
        cd->base = td->banks[b].base;
        cd->size = td->banks[b].size;
        if (cd->type == SOC_SBX_G2P3_KEY_COMPLEX_BANK_TYPE) {
            s = soc_sbx_g2p3_ucode_get(unit,
                        soc_sbx_g2p3_sym,
                        128,
                        &cd->singleton,
                        e,
                        td->name,
                        i,
                        e,
                        "CBANK_SINGLETON");
            if (s) {
                return s;
            }
        }
    }
    soc_sbx_g2p3_ipv4sa_t_init(&eipv4sa);
    s = soc_sbx_g2p3_lpm_init_ext(unit, &td->cstate,
                 td->name, cbs, cds,
                 tm->entries[SOC_SBX_G2P3_IPV4SA_ID].esize,
                 tm->entries[SOC_SBX_G2P3_IPV4SA_ID].pack,
                 &eipv4sa);
    if (s) {
        return(s);
    }

    td = &tm->tables[SOC_SBX_G2P3_IPV6DA_TABLE_ID];
    if (td->type != SOC_SBX_G2P3_LPM_TABLE_TYPE) {
        return SOC_E_INTERNAL;
    }
    s = soc_sbx_g2p3_ucode_get(unit,
                soc_sbx_g2p3_sym,
                128,
                &cbs,
                e,
                td->name,
                -1,
                e,
                "CBANKS");
    if (s) {
        return s;
    }
    for (i = 0; i < cbs; i++) {
        cd = &cds[i];
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &cd->pos,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_POS");
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &cd->width,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_WIDTH");
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &cd->type,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_TYPE");
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &b,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_BANK");
        if (s) {
            return s;
        }
        if (b >= td->nbanks) {
            return SOC_E_INTERNAL;
        }
        cd->memory = td->banks[b].memory;
        cd->base = td->banks[b].base;
        cd->size = td->banks[b].size;
        if (cd->type == SOC_SBX_G2P3_KEY_COMPLEX_BANK_TYPE) {
            s = soc_sbx_g2p3_ucode_get(unit,
                        soc_sbx_g2p3_sym,
                        128,
                        &cd->singleton,
                        e,
                        td->name,
                        i,
                        e,
                        "CBANK_SINGLETON");
            if (s) {
                return s;
            }
        }
    }
    soc_sbx_g2p3_ipv6da_t_init(&eipv6da);
    s = soc_sbx_g2p3_lpm_init_ext(unit, &td->cstate,
                 td->name, cbs, cds,
                 tm->entries[SOC_SBX_G2P3_IPV6DA_ID].esize,
                 tm->entries[SOC_SBX_G2P3_IPV6DA_ID].pack,
                 &eipv6da);
    if (s) {
        return(s);
    }

    td = &tm->tables[SOC_SBX_G2P3_IPV6SA_TABLE_ID];
    if (td->type != SOC_SBX_G2P3_LPM_TABLE_TYPE) {
        return SOC_E_INTERNAL;
    }
    s = soc_sbx_g2p3_ucode_get(unit,
                soc_sbx_g2p3_sym,
                128,
                &cbs,
                e,
                td->name,
                -1,
                e,
                "CBANKS");
    if (s) {
        return s;
    }
    for (i = 0; i < cbs; i++) {
        cd = &cds[i];
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &cd->pos,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_POS");
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &cd->width,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_WIDTH");
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &cd->type,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_TYPE");
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &b,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_BANK");
        if (s) {
            return s;
        }
        if (b >= td->nbanks) {
            return SOC_E_INTERNAL;
        }
        cd->memory = td->banks[b].memory;
        cd->base = td->banks[b].base;
        cd->size = td->banks[b].size;
        if (cd->type == SOC_SBX_G2P3_KEY_COMPLEX_BANK_TYPE) {
            s = soc_sbx_g2p3_ucode_get(unit,
                        soc_sbx_g2p3_sym,
                        128,
                        &cd->singleton,
                        e,
                        td->name,
                        i,
                        e,
                        "CBANK_SINGLETON");
            if (s) {
                return s;
            }
        }
    }
    soc_sbx_g2p3_ipv6sa_t_init(&eipv6sa);
    s = soc_sbx_g2p3_lpm_init_ext(unit, &td->cstate,
                 td->name, cbs, cds,
                 tm->entries[SOC_SBX_G2P3_IPV6SA_ID].esize,
                 tm->entries[SOC_SBX_G2P3_IPV6SA_ID].pack,
                 &eipv6sa);
    if (s) {
        return(s);
    }

    td = &tm->tables[SOC_SBX_G2P3_IPV4DA_TABLE_ID];
    if (td->type != SOC_SBX_G2P3_LPM_TABLE_TYPE) {
        return SOC_E_INTERNAL;
    }
    s = soc_sbx_g2p3_ucode_get(unit,
                soc_sbx_g2p3_sym,
                128,
                &cbs,
                e,
                td->name,
                -1,
                e,
                "CBANKS");
    if (s) {
        return s;
    }
    for (i = 0; i < cbs; i++) {
        cd = &cds[i];
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &cd->pos,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_POS");
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &cd->width,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_WIDTH");
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &cd->type,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_TYPE");
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ucode_get(unit,
                    soc_sbx_g2p3_sym,
                    128,
                    &b,
                    e,
                    td->name,
                    i,
                    e,
                    "CBANK_BANK");
        if (s) {
            return s;
        }
        if (b >= td->nbanks) {
            return SOC_E_INTERNAL;
        }
        cd->memory = td->banks[b].memory;
        cd->base = td->banks[b].base;
        cd->size = td->banks[b].size;
        if (cd->type == SOC_SBX_G2P3_KEY_COMPLEX_BANK_TYPE) {
            s = soc_sbx_g2p3_ucode_get(unit,
                        soc_sbx_g2p3_sym,
                        128,
                        &cd->singleton,
                        e,
                        td->name,
                        i,
                        e,
                        "CBANK_SINGLETON");
            if (s) {
                return s;
            }
        }
    }
    soc_sbx_g2p3_ipv4da_t_init(&eipv4da);
    s = soc_sbx_g2p3_lpm_init_ext(unit, &td->cstate,
                 td->name, cbs, cds,
                 tm->entries[SOC_SBX_G2P3_IPV4DA_ID].esize,
                 tm->entries[SOC_SBX_G2P3_IPV4DA_ID].pack,
                 &eipv4da);
    if (s) {
        return(s);
    }

    return SOC_E_NONE;
}
/*
 * Microcode complex table recovery implementation
 */
int soc_sbx_g2p3_complex_recover(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td;
    int idx, rv = SOC_E_NONE;
    int em32_tables[] = {
        SOC_SBX_G2P3_CUCKOO_TABLE_ID,
        SOC_SBX_G2P3_OUTERLABELCUCKOO_TABLE_ID,
        SOC_SBX_G2P3_INNERLABELCUCKOO_TABLE_ID
    };
    int eml_tables[] = {
        SOC_SBX_G2P3_MAC_TABLE_ID,
        SOC_SBX_G2P3_IPV6DHOST_TABLE_ID,
        SOC_SBX_G2P3_IPV6SHOST_TABLE_ID,
        SOC_SBX_G2P3_IPV6MCSG_TABLE_ID,
        SOC_SBX_G2P3_IPV6MCG_TABLE_ID,
        SOC_SBX_G2P3_IPV4MCG_TABLE_ID,
        SOC_SBX_G2P3_IPV4MCSG_TABLE_ID
    };


    for (idx=0; idx<sizeof(em32_tables)/sizeof(em32_tables[0]); idx++) {
        td = &tm->tables[em32_tables[idx]];
        if (td->cstate) {
            rv = soc_sbx_g2p3_em32_recover_ext(unit, td->cstate);
        }
        if(rv) {
            return rv;
        }
    }

    for (idx=0; idx<sizeof(eml_tables)/sizeof(eml_tables[0]); idx++) {
        td = &tm->tables[eml_tables[idx]];
        if (td->cstate) {
            rv = soc_sbx_g2p3_eml_recover_ext(unit, td->cstate);
        }
        if(rv) {
            return rv;
        }
    }


    return SOC_E_NONE;
}

/*
 * Restore microcode push-down parameters
 */
int soc_sbx_g2p3_reload(int unit)
{
    int i, j, base, size;
    int s = SOC_E_NONE;
    soc_sbx_g2p3_state_t *fe =
      (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_memory_desc_t *md;
    soc_sbx_g2p3_memory_bank_desc_t *mb;
    char *e = "";

    for (i = 0; s == SOC_E_NONE && i < SOC_SBX_G2P3_GLOBAL_MAX_ID; i++) {
        s = soc_sbx_g2p3_ucode_set(unit, 
                    soc_sbx_g2p3_sym,
                    128,
                    tm->globals[i].value,
                    "GLOBAL", tm->globals[i].name, -1, e, e);
    }

    for (i = 0; s == SOC_E_NONE && i < SOC_SBX_G2P3_MEMORY_MAX_ID; i++) {
        md = &tm->memories[i];
        for (j = 0; s == SOC_E_NONE && j < md->nbanks; j++) {
            mb = &md->banks[j];
            soc_sbx_g2p3_memory_bank_params_get(&base, &size, mb, tm);
            switch (mb->type) {
            case SOC_SBX_G2P3_TABLE_BANK_TYPE:
                s = soc_sbx_g2p3_table_bank_base_set(unit,
                              mb->number, mb->bank, base);
                break;
            case SOC_SBX_G2P3_COUNTER_BANK_TYPE:
                s = soc_sbx_g2p3_counter_bank_base_set(unit,
                              mb->number, base);
                break;
            case SOC_SBX_G2P3_POLICER_BANK_TYPE:
                s = soc_sbx_g2p3_policer_bank_base_set(unit,
                              mb->number, base);
                break;
            }
        }
    }

    for (i = 0; s == SOC_E_NONE && i < SOC_SBX_G2P3_TABLE_MAX_ID; i++) {
        s = soc_sbx_g2p3_generic_table_size_set(unit, i,
                      tm->tables[i].banks[tm->tables[i].nbanks - 1].size, 0);
    }
    for (i = 0; s == SOC_E_NONE && i < SOC_SBX_G2P3_COUNTER_MAX_ID; i++) {
        s = soc_sbx_g2p3_generic_counter_size_set(unit, i,
                      tm->counters[i].size, 0);
    }
    for (i = 0; s == SOC_E_NONE && i < SOC_SBX_G2P3_POLICER_MAX_ID; i++) {
        s = soc_sbx_g2p3_generic_policer_size_set(unit, i,
                      tm->policers[i].size, 0);
    }
    return s;
}

/*
 * Microcode subsystem recovery implementation
 */
int soc_sbx_g2p3_recover(int unit)
{
    char *e = "";
    int i, s;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;

    /*
     * Global value recovery
     */
    for (i = 0; i < SOC_SBX_G2P3_GLOBAL_MAX_ID; i++) {
        s = soc_sbx_g2p3_ucode_get(unit,
                  soc_sbx_g2p3_sym,
                  128,
                  &tm->globals[i].value,
                  "GLOBAL",
                  tm->globals[i].name,
                  -1,
                  e,
                  e);
        if (s) {
            return s;
        }
    }
    
    return SOC_E_NONE;
}

/*
 * Memory accessor implementation
 */
int soc_sbx_g2p3_memory_params_get(int unit, int mid,
                soc_sbx_g2p3_memory_params_t *mp)
{
    soc_sbx_g2p3_state_t *fe =
      (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_memory_desc_t *md;

    if (mid > SOC_SBX_G2P3_MEMORY_MAX_ID) {
        return SOC_E_PARAM;
    }
    md = &tm->memories[mid];
    if (!md->dma) {
        return SOC_E_PARAM;
    }
    
    mp->width = md->width;
    mp->size = md->size;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_memory_size_set(int unit, int mid, int size)

{
    soc_sbx_g2p3_state_t *fe =
      (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_memory_desc_t *md;

    if (mid > SOC_SBX_G2P3_MEMORY_MAX_ID) {
        return SOC_E_PARAM;
    }
    md = &tm->memories[mid];
    if (!md->dma) {
        return SOC_E_PARAM;
    }
    
    md->size = size;

    return SOC_E_NONE;
}

/*
 * Shared constant accessors implementation
 */

int soc_sbx_g2p3_max_ports_get(int unit, uint32 *vp)
{
    char *s = "MAX_PORTS";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_ipv4_vrf_bits_get(int unit, uint32 *vp)
{
    char *s = "IPV4_VRF_BITS";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_exc_ip_checksum_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_IP_CHECKSUM_IDX";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_exc_stp_blocked_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_STP_BLOCKED_IDX";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_exc_smac_drop_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_SMAC_DROP_IDX";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_exc_smac_unknown_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_SMAC_UNKNOWN_IDX";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_exc_mac_hairpin_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_MAC_HAIRPIN_IDX";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_exc_dmac_drop_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_DMAC_DROP_IDX";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_exc_ttl_expired_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_TTL_EXPIRED_IDX";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_exc_egr_stp_blocked_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_EGR_STP_BLOCKED_IDX";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_exc_split_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_SPLIT_IDX";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_exc_mtu_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_MTU_IDX";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_exc_oam_mismatch_get(int unit, uint32 *vp)
{
    char *s = "EXC_OAM_MISMATCH";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_exc_oam_learn_get(int unit, uint32 *vp)
{
    char *s = "EXC_OAM_LEARN";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_exc_oam_no_endpoint_get(int unit, uint32 *vp)
{
    char *s = "EXC_OAM_NO_ENDPOINT";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_exc_oam_type_get(int unit, uint32 *vp)
{
    char *s = "EXC_OAM_TYPE";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_exc_oam_rdi_get(int unit, uint32 *vp)
{
    char *s = "EXC_OAM_RDI";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_exc_vlan_drop_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_VLAN_DROP_IDX";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_exc_v4mc_rpf_check_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_V4MC_RPF_CHECK_IDX";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_exc_urpf_drop_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_URPF_DROP_IDX";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_exc_ip_sa_drop_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_IP_SA_DROP_IDX";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_exc_mim_bad_format_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_MIM_BAD_FORMAT_IDX";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_exc_isid2e_miss_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_ISID2E_MISS_IDX";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_exc_oam_threshold_exceeded_get(int unit, uint32 *vp)
{
    char *s = "EXC_OAM_THRESHOLD_EXCEEDED";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_exc_oam_copy_to_host_get(int unit, uint32 *vp)
{
    char *s = "EXC_OAM_COPY_TO_HOST";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_exc_oam_param_change_get(int unit, uint32 *vp)
{
    char *s = "EXC_OAM_PARAM_CHANGE";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_exc_bad_outer_label_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_BAD_OUTER_LABEL_IDX";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_exc_bad_inner_label_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_BAD_INNER_LABEL_IDX";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_exc_lsp_ping_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_LSP_PING_IDX";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_exc_too_many_labels_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_TOO_MANY_LABELS_IDX";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_exc_egr_drop_tagged_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_EGR_DROP_TAGGED_IDX";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_exc_egr_drop_untagged_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_EGR_DROP_UNTAGGED_IDX";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_exc_egr_oam_link_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_EGR_OAM_LINK_IDX";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_exc_oam_ep_invalid_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_OAM_EP_INVALID_IDX";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_exc_dcn_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_DCN_IDX";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_exc_mpls_filter_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_MPLS_FILTER_IDX";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_exc_min_free_exception_get(int unit, uint32 *vp)
{
    char *s = "EXC_MIN_FREE_EXCEPTION";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_max_free_exception_get(int unit, uint32 *vp)
{
    char *s = "MAX_FREE_EXCEPTION";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_exc_smac_learn_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_SMAC_LEARN_IDX";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_exc_pim_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_PIM_IDX";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_exc_igmp_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_IGMP_IDX";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_exc_rt_copy_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_RT_COPY_IDX";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_exc_l2cp_copy_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_L2CP_COPY_IDX";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_exc_dmac_copy_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_DMAC_COPY_IDX";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_exc_ipredirect_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_IPREDIRECT_IDX";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_exc_bmac_learn_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_BMAC_LEARN_IDX";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_exc_copy_max_idx_get(int unit, uint32 *vp)
{
    char *s = "EXC_COPY_MAX_IDX";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_htype_erh_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_ERH";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_htype_etype_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_ETYPE";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_htype_eth_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_ETH";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_htype_ieth_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_IETH";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_htype_llc_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_LLC";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_htype_snap_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_SNAP";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_htype_vtag_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_VTAG";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_htype_dvtag_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_DVTAG";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_htype_mpls_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_MPLS";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_htype_ipv4_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_IPV4";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_htype_ipv6_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_IPV6";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_htype_ach_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_ACH";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_htype_mim_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_MIM";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_htype_elen_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_ELEN";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_htype_unkn_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_UNKN";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_trap_oamlabelpresent_get(int unit, uint32 *vp)
{
    char *s = "TRAP_OAMLABELPRESENT";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_trap_linkloopback_get(int unit, uint32 *vp)
{
    char *s = "TRAP_LINKLOOPBACK";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_lsmac_table_size_get(int unit, uint32 *vp)
{
    char *s = "LSMAC_TABLE_SIZE";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_l2cpmac_table_size_get(int unit, uint32 *vp)
{
    char *s = "L2CPMAC_TABLE_SIZE";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_oamupmac_table_size_get(int unit, uint32 *vp)
{
    char *s = "OAMUPMAC_TABLE_SIZE";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_oamepremap_c2_table_size_get(int unit, uint32 *vp)
{
    char *s = "OAMEPREMAP_C2_TABLE_SIZE";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_oammultiplier_c2_table_size_get(int unit, uint32 *vp)
{
    char *s = "OAMMULTIPLIER_C2_TABLE_SIZE";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_egrctr_ca_counter_size_get(int unit, uint32 *vp)
{
    char *s = "EGRCTR_CA_COUNTER_SIZE";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_mac_ca_table_size_get(int unit, uint32 *vp)
{
    char *s = "MAC_CA_TABLE_SIZE";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_ptype_unknown_unicast_get(int unit, uint32 *vp)
{
    char *s = "PTYPE_UNKNOWN_UNICAST";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_ptype_known_unicast_get(int unit, uint32 *vp)
{
    char *s = "PTYPE_KNOWN_UNICAST";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_ptype_multicast_get(int unit, uint32 *vp)
{
    char *s = "PTYPE_MULTICAST";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_ptype_broadcast_get(int unit, uint32 *vp)
{
    char *s = "PTYPE_BROADCAST";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_ptype_last_get(int unit, uint32 *vp)
{
    char *s = "PTYPE_LAST";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_cuckoo_type_pvv_get(int unit, uint32 *vp)
{
    char *s = "CUCKOO_TYPE_PVV";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_cuckoo_type_isid_get(int unit, uint32 *vp)
{
    char *s = "CUCKOO_TYPE_ISID";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_cuckoo_type_pvd_get(int unit, uint32 *vp)
{
    char *s = "CUCKOO_TYPE_PVD";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_cuckoo_type_maidmep_get(int unit, uint32 *vp)
{
    char *s = "CUCKOO_TYPE_MAIDMEP";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_cuckoo_type_shift_get(int unit, uint32 *vp)
{
    char *s = "CUCKOO_TYPE_SHIFT";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_oam_ep_subtype_ccm_get(int unit, uint32 *vp)
{
    char *s = "OAM_EP_SUBTYPE_CCM";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_oam_ep_subtype_lm_get(int unit, uint32 *vp)
{
    char *s = "OAM_EP_SUBTYPE_LM";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_oam_ep_subtype_dm_get(int unit, uint32 *vp)
{
    char *s = "OAM_EP_SUBTYPE_DM";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_oam_ep_subtype_shift_get(int unit, uint32 *vp)
{
    char *s = "OAM_EP_SUBTYPE_SHIFT";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_oam_type_invalid_get(int unit, uint32 *vp)
{
    char *s = "OAM_TYPE_INVALID";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_oam_type_enet_get(int unit, uint32 *vp)
{
    char *s = "OAM_TYPE_ENET";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_oam_type_mpls_pwe_get(int unit, uint32 *vp)
{
    char *s = "OAM_TYPE_MPLS_PWE";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_oam_type_mpls_lsp_get(int unit, uint32 *vp)
{
    char *s = "OAM_TYPE_MPLS_LSP";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_oam_function_unused_get(int unit, uint32 *vp)
{
    char *s = "OAM_FUNCTION_UNUSED";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_oam_function_bfd_get(int unit, uint32 *vp)
{
    char *s = "OAM_FUNCTION_BFD";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_oam_function_lm_get(int unit, uint32 *vp)
{
    char *s = "OAM_FUNCTION_LM";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_oam_function_dm_get(int unit, uint32 *vp)
{
    char *s = "OAM_FUNCTION_DM";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_oam_function_ccm_first_get(int unit, uint32 *vp)
{
    char *s = "OAM_FUNCTION_CCM_FIRST";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_oam_function_ccm_second_get(int unit, uint32 *vp)
{
    char *s = "OAM_FUNCTION_CCM_SECOND";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_oam_function_ccm_peer_get(int unit, uint32 *vp)
{
    char *s = "OAM_FUNCTION_CCM_PEER";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_oam_function_psc_get(int unit, uint32 *vp)
{
    char *s = "OAM_FUNCTION_PSC";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_oam_function_pm_get(int unit, uint32 *vp)
{
    char *s = "OAM_FUNCTION_PM";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_oam_function_ccm_local_get(int unit, uint32 *vp)
{
    char *s = "OAM_FUNCTION_CCM_LOCAL";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_oam_num_endpoints_get(int unit, uint32 *vp)
{
    char *s = "OAM_NUM_ENDPOINTS";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_oam_max_calendar_get(int unit, uint32 *vp)
{
    char *s = "OAM_MAX_CALENDAR";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_oam_bubble_timeout_get(int unit, uint32 *vp)
{
    char *s = "OAM_BUBBLE_TIMEOUT";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_oam_list_mgr_size_get(int unit, uint32 *vp)
{
    char *s = "OAM_LIST_MGR_SIZE";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_oam_list_mgr_size_ca_get(int unit, uint32 *vp)
{
    char *s = "OAM_LIST_MGR_SIZE_CA";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_oam_bubble_timer_addr_get(int unit, uint32 *vp)
{
    char *s = "OAM_BUBBLE_TIMER_ADDR";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_oam_list_mgr_addr_get(int unit, uint32 *vp)
{
    char *s = "OAM_LIST_MGR_ADDR";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_oam_interval1_get(int unit, uint32 *vp)
{
    char *s = "OAM_INTERVAL1";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_oam_interval2_get(int unit, uint32 *vp)
{
    char *s = "OAM_INTERVAL2";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_oam_interval3_get(int unit, uint32 *vp)
{
    char *s = "OAM_INTERVAL3";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_oam_interval4_get(int unit, uint32 *vp)
{
    char *s = "OAM_INTERVAL4";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_oam_interval5_get(int unit, uint32 *vp)
{
    char *s = "OAM_INTERVAL5";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_oam_interval6_get(int unit, uint32 *vp)
{
    char *s = "OAM_INTERVAL6";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_oam_interval7_get(int unit, uint32 *vp)
{
    char *s = "OAM_INTERVAL7";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_oam_remote_ep_base_get(int unit, uint32 *vp)
{
    char *s = "OAM_REMOTE_EP_BASE";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_max_qos_profile_index_get(int unit, uint32 *vp)
{
    char *s = "MAX_QOS_PROFILE_INDEX";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_max_qos_map_table_get(int unit, uint32 *vp)
{
    char *s = "MAX_QOS_MAP_TABLE";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_max_qos_remark_table_get(int unit, uint32 *vp)
{
    char *s = "MAX_QOS_REMARK_TABLE";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_max_l2cp_types_get(int unit, uint32 *vp)
{
    char *s = "MAX_L2CP_TYPES";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_max_l2cp_subtypes_get(int unit, uint32 *vp)
{
    char *s = "MAX_L2CP_SUBTYPES";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_urpf_default_pid_get(int unit, uint32 *vp)
{
    char *s = "URPF_DEFAULT_PID";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_stpstate_forward_get(int unit, uint32 *vp)
{
    char *s = "STPSTATE_FORWARD";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_stpstate_block_get(int unit, uint32 *vp)
{
    char *s = "STPSTATE_BLOCK";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_stpstate_learn_get(int unit, uint32 *vp)
{
    char *s = "STPSTATE_LEARN";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_mplstp_loopback_oam_get(int unit, uint32 *vp)
{
    char *s = "MPLSTP_LOOPBACK_OAM";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_mplstp_loopback_full_get(int unit, uint32 *vp)
{
    char *s = "MPLSTP_LOOPBACK_FULL";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_mplstp_loopback_none_get(int unit, uint32 *vp)
{
    char *s = "MPLSTP_LOOPBACK_NONE";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_label_lsr_get(int unit, uint32 *vp)
{
    char *s = "LABEL_LSR";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_label_eth_pwe3_get(int unit, uint32 *vp)
{
    char *s = "LABEL_ETH_PWE3";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_label_ler_get(int unit, uint32 *vp)
{
    char *s = "LABEL_LER";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

int soc_sbx_g2p3_label_ces_pwe3_get(int unit, uint32 *vp)
{
    char *s = "LABEL_CES_PWE3";
    soc_sbx_g2p3_errsym = s;
    return soc_sbx_g2p3_constant_get(unit, s, vp);
}

/*
 * Global value accessor implementation
 */

int soc_sbx_g2p3_contexts_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_CONTEXTS";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_CONTEXTS_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_CONTEXTS_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_contexts_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_CONTEXTS_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_tpid0_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_TPID0";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_TPID0_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_TPID0_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_tpid0_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_TPID0_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_tpid1_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_TPID1";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_TPID1_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_TPID1_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_tpid1_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_TPID1_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_tpid2_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_TPID2";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_TPID2_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_TPID2_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_tpid2_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_TPID2_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_defitag_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_DEFITAG";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_DEFITAG_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_DEFITAG_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_defitag_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_DEFITAG_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_age_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_AGE";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_AGE_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_AGE_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_age_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_AGE_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_labelcuckoo_abseed_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_LABELCUCKOO_ABSEED";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_LABELCUCKOO_ABSEED_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_LABELCUCKOO_ABSEED_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_labelcuckoo_abseed_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_LABELCUCKOO_ABSEED_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_cuckoo_abseed_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_CUCKOO_ABSEED";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_CUCKOO_ABSEED_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_CUCKOO_ABSEED_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_cuckoo_abseed_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_CUCKOO_ABSEED_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_node_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_NODE";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_NODE_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_NODE_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_node_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_NODE_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_vlan_ft_base_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_VLAN_FT_BASE";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_VLAN_FT_BASE_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_VLAN_FT_BASE_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_vlan_ft_base_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_VLAN_FT_BASE_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_vpws_vlan_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_VPWS_VLAN";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_VPWS_VLAN_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_VPWS_VLAN_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_vpws_vlan_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_VPWS_VLAN_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_vpws_ft_offset_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_VPWS_FT_OFFSET";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_VPWS_FT_OFFSET_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_VPWS_FT_OFFSET_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_vpws_ft_offset_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_VPWS_FT_OFFSET_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_eex_mirror0_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_EEX_MIRROR0";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_EEX_MIRROR0_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_EEX_MIRROR0_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_eex_mirror0_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_EEX_MIRROR0_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_eex_mirror1_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_EEX_MIRROR1";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_EEX_MIRROR1_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_EEX_MIRROR1_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_eex_mirror1_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_EEX_MIRROR1_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_max_pids_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_MAX_PIDS";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_MAX_PIDS_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_MAX_PIDS_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_max_pids_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_MAX_PIDS_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_mc_ft_offset_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_MC_FT_OFFSET";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_MC_FT_OFFSET_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_MC_FT_OFFSET_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_mc_ft_offset_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_MC_FT_OFFSET_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_drop_bit_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_OAM_DROP_BIT";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_OAM_DROP_BIT_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_OAM_DROP_BIT_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_drop_bit_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_OAM_DROP_BIT_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_enet_continue_byte_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_OAM_ENET_CONTINUE_BYTE";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_OAM_ENET_CONTINUE_BYTE_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_OAM_ENET_CONTINUE_BYTE_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_enet_continue_byte_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_OAM_ENET_CONTINUE_BYTE_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_mpls_continue_byte_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_OAM_MPLS_CONTINUE_BYTE";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_OAM_MPLS_CONTINUE_BYTE_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_OAM_MPLS_CONTINUE_BYTE_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_mpls_continue_byte_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_OAM_MPLS_CONTINUE_BYTE_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_enet_frame_len_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_OAM_ENET_FRAME_LEN";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_OAM_ENET_FRAME_LEN_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_OAM_ENET_FRAME_LEN_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_enet_frame_len_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_OAM_ENET_FRAME_LEN_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_mpls_frame_len_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_OAM_MPLS_FRAME_LEN";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_OAM_MPLS_FRAME_LEN_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_OAM_MPLS_FRAME_LEN_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_mpls_frame_len_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_OAM_MPLS_FRAME_LEN_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_source_queue_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_OAM_SOURCE_QUEUE";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_OAM_SOURCE_QUEUE_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_OAM_SOURCE_QUEUE_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_source_queue_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_OAM_SOURCE_QUEUE_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_dest_queue_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_OAM_DEST_QUEUE";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_OAM_DEST_QUEUE_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_OAM_DEST_QUEUE_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_dest_queue_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_OAM_DEST_QUEUE_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_source_buffer_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_OAM_SOURCE_BUFFER";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_OAM_SOURCE_BUFFER_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_OAM_SOURCE_BUFFER_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_source_buffer_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_OAM_SOURCE_BUFFER_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_bubble_timer_offset_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_OAM_BUBBLE_TIMER_OFFSET";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_OAM_BUBBLE_TIMER_OFFSET_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_OAM_BUBBLE_TIMER_OFFSET_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_bubble_timer_offset_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_OAM_BUBBLE_TIMER_OFFSET_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_sa_lm_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_OAM_SA_LM";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_OAM_SA_LM_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_OAM_SA_LM_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_sa_lm_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_OAM_SA_LM_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_sa_dm_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_OAM_SA_DM";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_OAM_SA_DM_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_OAM_SA_DM_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_sa_dm_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_OAM_SA_DM_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_mpls_sa_lm_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_OAM_MPLS_SA_LM";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_OAM_MPLS_SA_LM_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_OAM_MPLS_SA_LM_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_mpls_sa_lm_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_OAM_MPLS_SA_LM_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_mpls_sa_dm_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_OAM_MPLS_SA_DM";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_OAM_MPLS_SA_DM_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_OAM_MPLS_SA_DM_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_mpls_sa_dm_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_OAM_MPLS_SA_DM_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_pwe_ip_sa_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_OAM_PWE_IP_SA";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_OAM_PWE_IP_SA_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_OAM_PWE_IP_SA_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_pwe_ip_sa_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_OAM_PWE_IP_SA_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_pwe_udp_dest_port_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_OAM_PWE_UDP_DEST_PORT";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_OAM_PWE_UDP_DEST_PORT_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_OAM_PWE_UDP_DEST_PORT_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_pwe_udp_dest_port_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_OAM_PWE_UDP_DEST_PORT_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_mirror_index_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_OAM_MIRROR_INDEX";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_OAM_MIRROR_INDEX_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_OAM_MIRROR_INDEX_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_mirror_index_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_OAM_MIRROR_INDEX_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_loopback_qid_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_OAM_LOOPBACK_QID";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_OAM_LOOPBACK_QID_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_OAM_LOOPBACK_QID_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_loopback_qid_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_OAM_LOOPBACK_QID_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_sa_4lo_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_OAM_SA_4LO";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_OAM_SA_4LO_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_OAM_SA_4LO_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_sa_4lo_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_OAM_SA_4LO_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_sa_2hi_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_OAM_SA_2HI";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_OAM_SA_2HI_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_OAM_SA_2HI_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_sa_2hi_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_OAM_SA_2HI_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_sa_4lo_aux_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_OAM_SA_4LO_AUX";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_OAM_SA_4LO_AUX_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_OAM_SA_4LO_AUX_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_sa_4lo_aux_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_OAM_SA_4LO_AUX_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_sa_2hi_aux_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_OAM_SA_2HI_AUX";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_OAM_SA_2HI_AUX_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_OAM_SA_2HI_AUX_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_sa_2hi_aux_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_OAM_SA_2HI_AUX_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_bfd_state_table_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_OAM_BFD_STATE_TABLE";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_OAM_BFD_STATE_TABLE_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_OAM_BFD_STATE_TABLE_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_bfd_state_table_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_OAM_BFD_STATE_TABLE_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_bfd_rdi_diag_code_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_OAM_BFD_RDI_DIAG_CODE";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_OAM_BFD_RDI_DIAG_CODE_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_OAM_BFD_RDI_DIAG_CODE_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_bfd_rdi_diag_code_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_OAM_BFD_RDI_DIAG_CODE_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_tx_packets_per_bubble_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_OAM_TX_PACKETS_PER_BUBBLE";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_OAM_TX_PACKETS_PER_BUBBLE_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_OAM_TX_PACKETS_PER_BUBBLE_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_tx_packets_per_bubble_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_OAM_TX_PACKETS_PER_BUBBLE_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_tx_packets_per_bubble_ca_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_OAM_TX_PACKETS_PER_BUBBLE_CA";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_OAM_TX_PACKETS_PER_BUBBLE_CA_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_OAM_TX_PACKETS_PER_BUBBLE_CA_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_tx_packets_per_bubble_ca_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_OAM_TX_PACKETS_PER_BUBBLE_CA_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_psc_rx_filter_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_OAM_PSC_RX_FILTER";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_OAM_PSC_RX_FILTER_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_OAM_PSC_RX_FILTER_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_psc_rx_filter_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_OAM_PSC_RX_FILTER_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_local_fe_qid_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_OAM_LOCAL_FE_QID";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_OAM_LOCAL_FE_QID_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_OAM_LOCAL_FE_QID_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oam_local_fe_qid_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_OAM_LOCAL_FE_QID_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_blackhole_vlan_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_BLACKHOLE_VLAN";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_BLACKHOLE_VLAN_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_BLACKHOLE_VLAN_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_blackhole_vlan_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_BLACKHOLE_VLAN_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_igmp_proxy_mode_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_IGMP_PROXY_MODE";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_IGMP_PROXY_MODE_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_IGMP_PROXY_MODE_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_igmp_proxy_mode_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_IGMP_PROXY_MODE_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_static_lag_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_STATIC_LAG";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_STATIC_LAG_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_STATIC_LAG_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_static_lag_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_STATIC_LAG_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_ipv4_checksum_mode_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_IPV4_CHECKSUM_MODE";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_IPV4_CHECKSUM_MODE_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_IPV4_CHECKSUM_MODE_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_ipv4_checksum_mode_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_IPV4_CHECKSUM_MODE_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_exit_filter_on_btag_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_EXIT_FILTER_ON_BTAG";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_EXIT_FILTER_ON_BTAG_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_EXIT_FILTER_ON_BTAG_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_exit_filter_on_btag_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_EXIT_FILTER_ON_BTAG_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_switch_meter_adjust_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_SWITCH_METER_ADJUST";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_SWITCH_METER_ADJUST_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_SWITCH_METER_ADJUST_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_switch_meter_adjust_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_SWITCH_METER_ADJUST_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_rc1_rule_startidx_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_RC1_RULE_STARTIDX";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_RC1_RULE_STARTIDX_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_RC1_RULE_STARTIDX_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_rc1_rule_startidx_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_RC1_RULE_STARTIDX_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_ipv6_acl_enable_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_IPV6_ACL_ENABLE";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_IPV6_ACL_ENABLE_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_IPV6_ACL_ENABLE_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_ipv6_acl_enable_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_IPV6_ACL_ENABLE_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oi2eoff_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_OI2EOFF";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_OI2EOFF_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_OI2EOFF_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_oi2eoff_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_OI2EOFF_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_ete0plus1_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_ETE0PLUS1";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_ETE0PLUS1_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_ETE0PLUS1_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_ete0plus1_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_ETE0PLUS1_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_ete1plus1_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_ETE1PLUS1";
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2P3_ETE1PLUS1_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2p3_errsym = sym;
    s = soc_sbx_g2p3_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2P3_ETE1PLUS1_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2p3_ete1plus1_get(int unit, uint32 *vp)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2P3_ETE1PLUS1_ID].value;

    return SOC_E_NONE;
}

/*
 * Table state accessor implementations
 */

/* get table bank parameters for portdata20 */
int soc_sbx_g2p3_portdata20_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_PORTDATA20_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for portdata20 */
int soc_sbx_g2p3_portdata20_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_PORTDATA20_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for portdata20 */
int soc_sbx_g2p3_portdata20_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_PORTDATA20_TABLE_ID, size, 1);
}

/* get table bank parameters for portdata25 */
int soc_sbx_g2p3_portdata25_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_PORTDATA25_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for portdata25 */
int soc_sbx_g2p3_portdata25_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_PORTDATA25_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for portdata25 */
int soc_sbx_g2p3_portdata25_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_PORTDATA25_TABLE_ID, size, 1);
}

/* get table bank parameters for qos */
int soc_sbx_g2p3_qos_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_QOS_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for qos */
int soc_sbx_g2p3_qos_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_QOS_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for qos */
int soc_sbx_g2p3_qos_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_QOS_TABLE_ID, size, 1);
}

/* get table bank parameters for dscp_qos */
int soc_sbx_g2p3_dscp_qos_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_DSCP_QOS_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for dscp_qos */
int soc_sbx_g2p3_dscp_qos_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_DSCP_QOS_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for dscp_qos */
int soc_sbx_g2p3_dscp_qos_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_DSCP_QOS_TABLE_ID, size, 1);
}

/* get table bank parameters for irt */
int soc_sbx_g2p3_irt_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_IRT_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for irt */
int soc_sbx_g2p3_irt_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_IRT_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for irt */
int soc_sbx_g2p3_irt_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_IRT_TABLE_ID, size, 1);
}

/* get table bank parameters for rt_mt */
int soc_sbx_g2p3_rt_mt_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_RT_MT_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for rt_mt */
int soc_sbx_g2p3_rt_mt_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_RT_MT_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for rt_mt */
int soc_sbx_g2p3_rt_mt_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_RT_MT_TABLE_ID, size, 1);
}

/* get table bank parameters for rt_rr0 */
int soc_sbx_g2p3_rt_rr0_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_RT_RR0_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for rt_rr0 */
int soc_sbx_g2p3_rt_rr0_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_RT_RR0_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for rt_rr0 */
int soc_sbx_g2p3_rt_rr0_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_RT_RR0_TABLE_ID, size, 1);
}

/* get table bank parameters for rt_rr1 */
int soc_sbx_g2p3_rt_rr1_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_RT_RR1_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for rt_rr1 */
int soc_sbx_g2p3_rt_rr1_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_RT_RR1_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for rt_rr1 */
int soc_sbx_g2p3_rt_rr1_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_RT_RR1_TABLE_ID, size, 1);
}

/* get table bank parameters for lag */
int soc_sbx_g2p3_lag_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_LAG_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for lag */
int soc_sbx_g2p3_lag_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_LAG_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for lag */
int soc_sbx_g2p3_lag_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_LAG_TABLE_ID, size, 1);
}

/* get table bank parameters for rr */
int soc_sbx_g2p3_rr_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_RR_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for rr */
int soc_sbx_g2p3_rr_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_RR_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for rr */
int soc_sbx_g2p3_rr_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_RR_TABLE_ID, size, 1);
}

/* get table bank parameters for xt */
int soc_sbx_g2p3_xt_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_XT_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for xt */
int soc_sbx_g2p3_xt_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_XT_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for xt */
int soc_sbx_g2p3_xt_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_XT_TABLE_ID, size, 1);
}

/* get table bank parameters for mirror */
int soc_sbx_g2p3_mirror_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_MIRROR_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for mirror */
int soc_sbx_g2p3_mirror_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_MIRROR_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for mirror */
int soc_sbx_g2p3_mirror_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_MIRROR_TABLE_ID, size, 1);
}

/* get table bank parameters for emirror20 */
int soc_sbx_g2p3_emirror20_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_EMIRROR20_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for emirror20 */
int soc_sbx_g2p3_emirror20_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_EMIRROR20_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for emirror20 */
int soc_sbx_g2p3_emirror20_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_EMIRROR20_TABLE_ID, size, 1);
}

/* get table bank parameters for emirror25 */
int soc_sbx_g2p3_emirror25_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_EMIRROR25_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for emirror25 */
int soc_sbx_g2p3_emirror25_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_EMIRROR25_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for emirror25 */
int soc_sbx_g2p3_emirror25_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_EMIRROR25_TABLE_ID, size, 1);
}

/* get table bank parameters for mac */
int soc_sbx_g2p3_mac_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_MAC_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for mac */
int soc_sbx_g2p3_mac_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_MAC_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for mac */
int soc_sbx_g2p3_mac_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_MAC_TABLE_ID, size, 1);
}

/* mac get complex table state structure implementation */
void *soc_sbx_g2p3_mac_complex_state_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;

    return tm->tables[SOC_SBX_G2P3_MAC_TABLE_ID].cstate;
}

/* get table bank parameters for ipv6dhost */
int soc_sbx_g2p3_ipv6dhost_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_IPV6DHOST_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for ipv6dhost */
int soc_sbx_g2p3_ipv6dhost_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_IPV6DHOST_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for ipv6dhost */
int soc_sbx_g2p3_ipv6dhost_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_IPV6DHOST_TABLE_ID, size, 1);
}

/* ipv6dhost get complex table state structure implementation */
void *soc_sbx_g2p3_ipv6dhost_complex_state_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;

    return tm->tables[SOC_SBX_G2P3_IPV6DHOST_TABLE_ID].cstate;
}

/* get table bank parameters for mst */
int soc_sbx_g2p3_mst_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_MST_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for mst */
int soc_sbx_g2p3_mst_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_MST_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for mst */
int soc_sbx_g2p3_mst_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_MST_TABLE_ID, size, 1);
}

/* get table bank parameters for pv2e */
int soc_sbx_g2p3_pv2e_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_PV2E_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for pv2e */
int soc_sbx_g2p3_pv2e_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_PV2E_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for pv2e */
int soc_sbx_g2p3_pv2e_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_PV2E_TABLE_ID, size, 1);
}

/* get table bank parameters for p2appdata */
int soc_sbx_g2p3_p2appdata_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_P2APPDATA_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for p2appdata */
int soc_sbx_g2p3_p2appdata_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_P2APPDATA_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for p2appdata */
int soc_sbx_g2p3_p2appdata_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_P2APPDATA_TABLE_ID, size, 1);
}

/* get table bank parameters for pv2appdata */
int soc_sbx_g2p3_pv2appdata_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_PV2APPDATA_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for pv2appdata */
int soc_sbx_g2p3_pv2appdata_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_PV2APPDATA_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for pv2appdata */
int soc_sbx_g2p3_pv2appdata_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_PV2APPDATA_TABLE_ID, size, 1);
}

/* get table bank parameters for ipv6shost */
int soc_sbx_g2p3_ipv6shost_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_IPV6SHOST_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for ipv6shost */
int soc_sbx_g2p3_ipv6shost_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_IPV6SHOST_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for ipv6shost */
int soc_sbx_g2p3_ipv6shost_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_IPV6SHOST_TABLE_ID, size, 1);
}

/* ipv6shost get complex table state structure implementation */
void *soc_sbx_g2p3_ipv6shost_complex_state_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;

    return tm->tables[SOC_SBX_G2P3_IPV6SHOST_TABLE_ID].cstate;
}

/* get table bank parameters for cuckoo */
int soc_sbx_g2p3_cuckoo_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_CUCKOO_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for cuckoo */
int soc_sbx_g2p3_cuckoo_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_CUCKOO_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for cuckoo */
int soc_sbx_g2p3_cuckoo_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_CUCKOO_TABLE_ID, size, 1);
}

/* cuckoo get complex table state structure implementation */
void *soc_sbx_g2p3_cuckoo_complex_state_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;

    return tm->tables[SOC_SBX_G2P3_CUCKOO_TABLE_ID].cstate;
}

/* get table bank parameters for outerlabelcuckoo */
int soc_sbx_g2p3_outerlabelcuckoo_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_OUTERLABELCUCKOO_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for outerlabelcuckoo */
int soc_sbx_g2p3_outerlabelcuckoo_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_OUTERLABELCUCKOO_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for outerlabelcuckoo */
int soc_sbx_g2p3_outerlabelcuckoo_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_OUTERLABELCUCKOO_TABLE_ID, size, 1);
}

/* outerlabelcuckoo get complex table state structure implementation */
void *soc_sbx_g2p3_outerlabelcuckoo_complex_state_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;

    return tm->tables[SOC_SBX_G2P3_OUTERLABELCUCKOO_TABLE_ID].cstate;
}

/* get table bank parameters for innerlabelcuckoo */
int soc_sbx_g2p3_innerlabelcuckoo_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_INNERLABELCUCKOO_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for innerlabelcuckoo */
int soc_sbx_g2p3_innerlabelcuckoo_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_INNERLABELCUCKOO_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for innerlabelcuckoo */
int soc_sbx_g2p3_innerlabelcuckoo_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_INNERLABELCUCKOO_TABLE_ID, size, 1);
}

/* innerlabelcuckoo get complex table state structure implementation */
void *soc_sbx_g2p3_innerlabelcuckoo_complex_state_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;

    return tm->tables[SOC_SBX_G2P3_INNERLABELCUCKOO_TABLE_ID].cstate;
}

/* get table bank parameters for v2e */
int soc_sbx_g2p3_v2e_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_V2E_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for v2e */
int soc_sbx_g2p3_v2e_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_V2E_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for v2e */
int soc_sbx_g2p3_v2e_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_V2E_TABLE_ID, size, 1);
}

/* get table bank parameters for v2e1 */
int soc_sbx_g2p3_v2e1_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_V2E1_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for v2e1 */
int soc_sbx_g2p3_v2e1_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_V2E1_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for v2e1 */
int soc_sbx_g2p3_v2e1_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_V2E1_TABLE_ID, size, 1);
}

/* get table bank parameters for lp */
int soc_sbx_g2p3_lp_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_LP_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for lp */
int soc_sbx_g2p3_lp_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_LP_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for lp */
int soc_sbx_g2p3_lp_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_LP_TABLE_ID, size, 1);
}

/* get table bank parameters for l2e */
int soc_sbx_g2p3_l2e_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_L2E_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for l2e */
int soc_sbx_g2p3_l2e_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_L2E_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for l2e */
int soc_sbx_g2p3_l2e_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_L2E_TABLE_ID, size, 1);
}

/* get table bank parameters for l2cp */
int soc_sbx_g2p3_l2cp_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_L2CP_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for l2cp */
int soc_sbx_g2p3_l2cp_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_L2CP_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for l2cp */
int soc_sbx_g2p3_l2cp_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_L2CP_TABLE_ID, size, 1);
}

/* get table bank parameters for l2cpslow */
int soc_sbx_g2p3_l2cpslow_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_L2CPSLOW_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for l2cpslow */
int soc_sbx_g2p3_l2cpslow_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_L2CPSLOW_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for l2cpslow */
int soc_sbx_g2p3_l2cpslow_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_L2CPSLOW_TABLE_ID, size, 1);
}

/* get table bank parameters for l2cpnop */
int soc_sbx_g2p3_l2cpnop_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_L2CPNOP_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for l2cpnop */
int soc_sbx_g2p3_l2cpnop_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_L2CPNOP_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for l2cpnop */
int soc_sbx_g2p3_l2cpnop_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_L2CPNOP_TABLE_ID, size, 1);
}

/* get table bank parameters for ft */
int soc_sbx_g2p3_ft_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_FT_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for ft */
int soc_sbx_g2p3_ft_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_FT_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for ft */
int soc_sbx_g2p3_ft_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_FT_TABLE_ID, size, 1);
}

/* get table bank parameters for OamTimerCalendar */
int soc_sbx_g2p3_oamtimercalendar_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_OAMTIMERCALENDAR_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for OamTimerCalendar */
int soc_sbx_g2p3_oamtimercalendar_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_OAMTIMERCALENDAR_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for OamTimerCalendar */
int soc_sbx_g2p3_oamtimercalendar_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_OAMTIMERCALENDAR_TABLE_ID, size, 1);
}

/* get table bank parameters for OamPortMdLevel2Etc */
int soc_sbx_g2p3_oamportmdlevel2etc_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_OAMPORTMDLEVEL2ETC_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for OamPortMdLevel2Etc */
int soc_sbx_g2p3_oamportmdlevel2etc_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_OAMPORTMDLEVEL2ETC_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for OamPortMdLevel2Etc */
int soc_sbx_g2p3_oamportmdlevel2etc_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_OAMPORTMDLEVEL2ETC_TABLE_ID, size, 1);
}

/* get table bank parameters for ipv6mcsg */
int soc_sbx_g2p3_ipv6mcsg_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_IPV6MCSG_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for ipv6mcsg */
int soc_sbx_g2p3_ipv6mcsg_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_IPV6MCSG_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for ipv6mcsg */
int soc_sbx_g2p3_ipv6mcsg_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_IPV6MCSG_TABLE_ID, size, 1);
}

/* ipv6mcsg get complex table state structure implementation */
void *soc_sbx_g2p3_ipv6mcsg_complex_state_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;

    return tm->tables[SOC_SBX_G2P3_IPV6MCSG_TABLE_ID].cstate;
}

/* get table bank parameters for ipv6mcg */
int soc_sbx_g2p3_ipv6mcg_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_IPV6MCG_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for ipv6mcg */
int soc_sbx_g2p3_ipv6mcg_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_IPV6MCG_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for ipv6mcg */
int soc_sbx_g2p3_ipv6mcg_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_IPV6MCG_TABLE_ID, size, 1);
}

/* ipv6mcg get complex table state structure implementation */
void *soc_sbx_g2p3_ipv6mcg_complex_state_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;

    return tm->tables[SOC_SBX_G2P3_IPV6MCG_TABLE_ID].cstate;
}

/* get table bank parameters for ipv4mcg */
int soc_sbx_g2p3_ipv4mcg_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_IPV4MCG_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for ipv4mcg */
int soc_sbx_g2p3_ipv4mcg_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_IPV4MCG_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for ipv4mcg */
int soc_sbx_g2p3_ipv4mcg_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_IPV4MCG_TABLE_ID, size, 1);
}

/* ipv4mcg get complex table state structure implementation */
void *soc_sbx_g2p3_ipv4mcg_complex_state_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;

    return tm->tables[SOC_SBX_G2P3_IPV4MCG_TABLE_ID].cstate;
}

/* get table bank parameters for ipv4mcsg */
int soc_sbx_g2p3_ipv4mcsg_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_IPV4MCSG_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for ipv4mcsg */
int soc_sbx_g2p3_ipv4mcsg_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_IPV4MCSG_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for ipv4mcsg */
int soc_sbx_g2p3_ipv4mcsg_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_IPV4MCSG_TABLE_ID, size, 1);
}

/* ipv4mcsg get complex table state structure implementation */
void *soc_sbx_g2p3_ipv4mcsg_complex_state_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;

    return tm->tables[SOC_SBX_G2P3_IPV4MCSG_TABLE_ID].cstate;
}

/* get table bank parameters for ipv4sa */
int soc_sbx_g2p3_ipv4sa_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_IPV4SA_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for ipv4sa */
int soc_sbx_g2p3_ipv4sa_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_IPV4SA_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for ipv4sa */
int soc_sbx_g2p3_ipv4sa_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_IPV4SA_TABLE_ID, size, 1);
}

/* ipv4sa get complex table state structure implementation */
void *soc_sbx_g2p3_ipv4sa_complex_state_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;

    return tm->tables[SOC_SBX_G2P3_IPV4SA_TABLE_ID].cstate;
}

/* get table bank parameters for evp2e */
int soc_sbx_g2p3_evp2e_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_EVP2E_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for evp2e */
int soc_sbx_g2p3_evp2e_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_EVP2E_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for evp2e */
int soc_sbx_g2p3_evp2e_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_EVP2E_TABLE_ID, size, 1);
}

/* get table bank parameters for oi2e */
int soc_sbx_g2p3_oi2e_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_OI2E_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for oi2e */
int soc_sbx_g2p3_oi2e_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_OI2E_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for oi2e */
int soc_sbx_g2p3_oi2e_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_OI2E_TABLE_ID, size, 1);
}

/* get table bank parameters for ete */
int soc_sbx_g2p3_ete_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_ETE_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for ete */
int soc_sbx_g2p3_ete_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_ETE_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for ete */
int soc_sbx_g2p3_ete_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_ETE_TABLE_ID, size, 1);
}

/* get table bank parameters for oamEp */
int soc_sbx_g2p3_oamep_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_OAMEP_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for oamEp */
int soc_sbx_g2p3_oamep_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_OAMEP_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for oamEp */
int soc_sbx_g2p3_oamep_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_OAMEP_TABLE_ID, size, 1);
}

/* get table bank parameters for remark */
int soc_sbx_g2p3_remark_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_REMARK_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for remark */
int soc_sbx_g2p3_remark_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_REMARK_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for remark */
int soc_sbx_g2p3_remark_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_REMARK_TABLE_ID, size, 1);
}

/* get table bank parameters for epv2e */
int soc_sbx_g2p3_epv2e_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_EPV2E_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for epv2e */
int soc_sbx_g2p3_epv2e_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_EPV2E_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for epv2e */
int soc_sbx_g2p3_epv2e_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_EPV2E_TABLE_ID, size, 1);
}

/* get table bank parameters for esmac */
int soc_sbx_g2p3_esmac_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_ESMAC_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for esmac */
int soc_sbx_g2p3_esmac_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_ESMAC_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for esmac */
int soc_sbx_g2p3_esmac_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_ESMAC_TABLE_ID, size, 1);
}

/* get table bank parameters for ert */
int soc_sbx_g2p3_ert_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_ERT_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for ert */
int soc_sbx_g2p3_ert_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_ERT_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for ert */
int soc_sbx_g2p3_ert_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_ERT_TABLE_ID, size, 1);
}

/* get table bank parameters for oamMultiplier */
int soc_sbx_g2p3_oammultiplier_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_OAMMULTIPLIER_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for oamMultiplier */
int soc_sbx_g2p3_oammultiplier_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_OAMMULTIPLIER_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for oamMultiplier */
int soc_sbx_g2p3_oammultiplier_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_OAMMULTIPLIER_TABLE_ID, size, 1);
}

/* get table bank parameters for oamEpRemap */
int soc_sbx_g2p3_oamepremap_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_OAMEPREMAP_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for oamEpRemap */
int soc_sbx_g2p3_oamepremap_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_OAMEPREMAP_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for oamEpRemap */
int soc_sbx_g2p3_oamepremap_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_OAMEPREMAP_TABLE_ID, size, 1);
}

/* get table bank parameters for ipv6da */
int soc_sbx_g2p3_ipv6da_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_IPV6DA_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for ipv6da */
int soc_sbx_g2p3_ipv6da_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_IPV6DA_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for ipv6da */
int soc_sbx_g2p3_ipv6da_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_IPV6DA_TABLE_ID, size, 1);
}

/* ipv6da get complex table state structure implementation */
void *soc_sbx_g2p3_ipv6da_complex_state_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;

    return tm->tables[SOC_SBX_G2P3_IPV6DA_TABLE_ID].cstate;
}

/* get table bank parameters for ipv6sa */
int soc_sbx_g2p3_ipv6sa_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_IPV6SA_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for ipv6sa */
int soc_sbx_g2p3_ipv6sa_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_IPV6SA_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for ipv6sa */
int soc_sbx_g2p3_ipv6sa_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_IPV6SA_TABLE_ID, size, 1);
}

/* ipv6sa get complex table state structure implementation */
void *soc_sbx_g2p3_ipv6sa_complex_state_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;

    return tm->tables[SOC_SBX_G2P3_IPV6SA_TABLE_ID].cstate;
}

/* get table bank parameters for ipv4da */
int soc_sbx_g2p3_ipv4da_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_IPV4DA_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for ipv4da */
int soc_sbx_g2p3_ipv4da_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_IPV4DA_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for ipv4da */
int soc_sbx_g2p3_ipv4da_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_IPV4DA_TABLE_ID, size, 1);
}

/* ipv4da get complex table state structure implementation */
void *soc_sbx_g2p3_ipv4da_complex_state_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;

    return tm->tables[SOC_SBX_G2P3_IPV4DA_TABLE_ID].cstate;
}

/* get table bank parameters for P2FTI */
int soc_sbx_g2p3_p2fti_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_table_bank_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_P2FTI_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for P2FTI */
int soc_sbx_g2p3_p2fti_table_size_get(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[SOC_SBX_G2P3_P2FTI_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for P2FTI */
int soc_sbx_g2p3_p2fti_table_size_set(int unit, int size)
{
    return soc_sbx_g2p3_generic_table_size_set(unit,
                     SOC_SBX_G2P3_P2FTI_TABLE_ID, size, 1);
}

/*
 * Entry accessor implementation
 */

/*
 * Entry accessor implementations for p2e
 */

void soc_sbx_g2p3_p2e_t_init(
    soc_sbx_g2p3_p2e_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_p2e_t));
    e->defstrip = 0x1;
}

/* entry size function for p2e */
int soc_sbx_g2p3_p2e_size(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2E_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];

    return (eb->width + (eb->stridebits - 1)) / eb->stridebits;
}

/* entry pack accessor implementation for p2e */
int soc_sbx_g2p3_p2e_pack(int unit,
    soc_sbx_g2p3_p2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2E_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->port; break;
        case 1: p = (uint8 *) &e->nativevid; break;
        case 2: p = (uint8 *) &e->defcfi; break;
        case 3: p = (uint8 *) &e->defpri; break;
        case 4: p = (uint8 *) &e->defstrip; break;
        case 5: p = (uint8 *) &e->pstrip; break;
        case 6: p = (uint8 *) &e->mim; break;
        case 7: p = (uint8 *) &e->mplstp; break;
        case 8: p = (uint8 *) e->mask; break;
        case 9: p = (uint8 *) &e->customer; break;
        case 10: p = (uint8 *) &e->provider; break;
        case 11: p = (uint8 *) &e->oamloop; break;
        case 12: p = (uint8 *) &e->stpid1; break;
        case 13: p = (uint8 *) &e->twintpid; break;
        case 14: p = (uint8 *) &e->pbb; break;
        case 15: p = (uint8 *) &e->ipv4mc; break;
        case 16: p = (uint8 *) &e->state; break;
        case 17: p = (uint8 *) &e->pport; break;
        case 18: p = (uint8 *) &e->htype; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for p2e */
int soc_sbx_g2p3_p2e_unpack(int unit,
                soc_sbx_g2p3_p2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2E_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->port; break;
        case 1: p = (uint8 *) &e->nativevid; break;
        case 2: p = (uint8 *) &e->defcfi; break;
        case 3: p = (uint8 *) &e->defpri; break;
        case 4: p = (uint8 *) &e->defstrip; break;
        case 5: p = (uint8 *) &e->pstrip; break;
        case 6: p = (uint8 *) &e->mim; break;
        case 7: p = (uint8 *) &e->mplstp; break;
        case 8: p = (uint8 *) e->mask; break;
        case 9: p = (uint8 *) &e->customer; break;
        case 10: p = (uint8 *) &e->provider; break;
        case 11: p = (uint8 *) &e->oamloop; break;
        case 12: p = (uint8 *) &e->stpid1; break;
        case 13: p = (uint8 *) &e->twintpid; break;
        case 14: p = (uint8 *) &e->pbb; break;
        case 15: p = (uint8 *) &e->ipv4mc; break;
        case 16: p = (uint8 *) &e->state; break;
        case 17: p = (uint8 *) &e->pport; break;
        case 18: p = (uint8 *) &e->htype; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for p2e */
int soc_sbx_g2p3_p2e_index_check(int unit,
                int *vindex,
                int iport)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2E_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iport; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for p2e */
int soc_sbx_g2p3_p2e_entry_check(int unit,
                soc_sbx_g2p3_p2e_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2E_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->port; break;
        case 1: ev = e->nativevid; break;
        case 2: ev = e->defcfi; break;
        case 3: ev = e->defpri; break;
        case 4: ev = e->defstrip; break;
        case 5: ev = e->pstrip; break;
        case 6: ev = e->mim; break;
        case 7: ev = e->mplstp; break;
        case 8: ev = e->mask[0]; break;
        case 9: ev = e->customer; break;
        case 10: ev = e->provider; break;
        case 11: ev = e->oamloop; break;
        case 12: ev = e->stpid1; break;
        case 13: ev = e->twintpid; break;
        case 14: ev = e->pbb; break;
        case 15: ev = e->ipv4mc; break;
        case 16: ev = e->state; break;
        case 17: ev = e->pport; break;
        case 18: ev = e->htype; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for p2e */
int soc_sbx_g2p3_p2e_set(int unit,
                int iport,
                soc_sbx_g2p3_p2e_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_p2e_index_check(unit, key,
                iport);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_p2e_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_p2e_set_ext(unit,
                iport,
                e);

    return s;
}

/* entry get accessor implementation for p2e */
int soc_sbx_g2p3_p2e_get(int unit,
                int iport,
                soc_sbx_g2p3_p2e_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_p2e_index_check(unit, key,
                iport);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_p2e_get_ext(unit,
                iport,
                e);

    return s;
}

/*
 * Entry accessor implementations for ep2e
 */

void soc_sbx_g2p3_ep2e_t_init(
    soc_sbx_g2p3_ep2e_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ep2e_t));
}

/* entry size function for ep2e */
int soc_sbx_g2p3_ep2e_size(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EP2E_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];

    return (eb->width + (eb->stridebits - 1)) / eb->stridebits;
}

/* entry pack accessor implementation for ep2e */
int soc_sbx_g2p3_ep2e_pack(int unit,
    soc_sbx_g2p3_ep2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EP2E_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->mim; break;
        case 1: p = (uint8 *) &e->pid; break;
        case 2: p = (uint8 *) &e->stpid0; break;
        case 3: p = (uint8 *) &e->stpid1; break;
        case 4: p = (uint8 *) &e->customer; break;
        case 5: p = (uint8 *) &e->keeperh; break;
        case 6: p = (uint8 *) &e->port; break;
        case 7: p = (uint8 *) &e->mirroridx; break;
        case 8: p = (uint8 *) e->mask; break;
        case 9: p = (uint8 *) &e->oamloop; break;
        case 10: p = (uint8 *) &e->pbb; break;
        case 11: p = (uint8 *) &e->state; break;
        case 12: p = (uint8 *) &e->htype; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ep2e */
int soc_sbx_g2p3_ep2e_unpack(int unit,
                soc_sbx_g2p3_ep2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EP2E_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->mim; break;
        case 1: p = (uint8 *) &e->pid; break;
        case 2: p = (uint8 *) &e->stpid0; break;
        case 3: p = (uint8 *) &e->stpid1; break;
        case 4: p = (uint8 *) &e->customer; break;
        case 5: p = (uint8 *) &e->keeperh; break;
        case 6: p = (uint8 *) &e->port; break;
        case 7: p = (uint8 *) &e->mirroridx; break;
        case 8: p = (uint8 *) e->mask; break;
        case 9: p = (uint8 *) &e->oamloop; break;
        case 10: p = (uint8 *) &e->pbb; break;
        case 11: p = (uint8 *) &e->state; break;
        case 12: p = (uint8 *) &e->htype; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ep2e */
int soc_sbx_g2p3_ep2e_index_check(int unit,
                int *vindex,
                int iport)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EP2E_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iport; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ep2e */
int soc_sbx_g2p3_ep2e_entry_check(int unit,
                soc_sbx_g2p3_ep2e_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EP2E_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->mim; break;
        case 1: ev = e->pid; break;
        case 2: ev = e->stpid0; break;
        case 3: ev = e->stpid1; break;
        case 4: ev = e->customer; break;
        case 5: ev = e->keeperh; break;
        case 6: ev = e->port; break;
        case 7: ev = e->mirroridx; break;
        case 8: ev = e->mask[0]; break;
        case 9: ev = e->oamloop; break;
        case 10: ev = e->pbb; break;
        case 11: ev = e->state; break;
        case 12: ev = e->htype; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for ep2e */
int soc_sbx_g2p3_ep2e_set(int unit,
                int iport,
                soc_sbx_g2p3_ep2e_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_ep2e_index_check(unit, key,
                iport);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ep2e_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ep2e_set_ext(unit,
                iport,
                e);

    return s;
}

/* entry get accessor implementation for ep2e */
int soc_sbx_g2p3_ep2e_get(int unit,
                int iport,
                soc_sbx_g2p3_ep2e_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_ep2e_index_check(unit, key,
                iport);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ep2e_get_ext(unit,
                iport,
                e);

    return s;
}

/*
 * Entry accessor implementations for p2e20
 */

void soc_sbx_g2p3_p2e20_t_init(
    soc_sbx_g2p3_p2e20_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_p2e20_t));
    e->defstrip = 0x1;
}

/* entry pack accessor implementation for p2e20 */
int soc_sbx_g2p3_p2e20_pack(int unit,
    soc_sbx_g2p3_p2e20_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2E20_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->port; break;
        case 1: p = (uint8 *) &e->nativevid; break;
        case 2: p = (uint8 *) &e->defcfi; break;
        case 3: p = (uint8 *) &e->defpri; break;
        case 4: p = (uint8 *) &e->defstrip; break;
        case 5: p = (uint8 *) &e->pstrip; break;
        case 6: p = (uint8 *) &e->mim; break;
        case 7: p = (uint8 *) &e->mplstp; break;
        case 8: p = (uint8 *) e->mask; break;
        case 9: p = (uint8 *) &e->customer; break;
        case 10: p = (uint8 *) &e->provider; break;
        case 11: p = (uint8 *) &e->oamloop; break;
        case 12: p = (uint8 *) &e->stpid1; break;
        case 13: p = (uint8 *) &e->twintpid; break;
        case 14: p = (uint8 *) &e->pbb; break;
        case 15: p = (uint8 *) &e->ipv4mc; break;
        case 16: p = (uint8 *) &e->state; break;
        case 17: p = (uint8 *) &e->pport; break;
        case 18: p = (uint8 *) &e->htype; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for p2e20 */
int soc_sbx_g2p3_p2e20_unpack(int unit,
                soc_sbx_g2p3_p2e20_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2E20_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->port; break;
        case 1: p = (uint8 *) &e->nativevid; break;
        case 2: p = (uint8 *) &e->defcfi; break;
        case 3: p = (uint8 *) &e->defpri; break;
        case 4: p = (uint8 *) &e->defstrip; break;
        case 5: p = (uint8 *) &e->pstrip; break;
        case 6: p = (uint8 *) &e->mim; break;
        case 7: p = (uint8 *) &e->mplstp; break;
        case 8: p = (uint8 *) e->mask; break;
        case 9: p = (uint8 *) &e->customer; break;
        case 10: p = (uint8 *) &e->provider; break;
        case 11: p = (uint8 *) &e->oamloop; break;
        case 12: p = (uint8 *) &e->stpid1; break;
        case 13: p = (uint8 *) &e->twintpid; break;
        case 14: p = (uint8 *) &e->pbb; break;
        case 15: p = (uint8 *) &e->ipv4mc; break;
        case 16: p = (uint8 *) &e->state; break;
        case 17: p = (uint8 *) &e->pport; break;
        case 18: p = (uint8 *) &e->htype; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for p2e20 */
int soc_sbx_g2p3_p2e20_index_check(int unit,
                int *vindex,
                int iport)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2E20_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iport; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for p2e20 */
int soc_sbx_g2p3_p2e20_entry_check(int unit,
                soc_sbx_g2p3_p2e20_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2E20_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->port; break;
        case 1: ev = e->nativevid; break;
        case 2: ev = e->defcfi; break;
        case 3: ev = e->defpri; break;
        case 4: ev = e->defstrip; break;
        case 5: ev = e->pstrip; break;
        case 6: ev = e->mim; break;
        case 7: ev = e->mplstp; break;
        case 8: ev = e->mask[0]; break;
        case 9: ev = e->customer; break;
        case 10: ev = e->provider; break;
        case 11: ev = e->oamloop; break;
        case 12: ev = e->stpid1; break;
        case 13: ev = e->twintpid; break;
        case 14: ev = e->pbb; break;
        case 15: ev = e->ipv4mc; break;
        case 16: ev = e->state; break;
        case 17: ev = e->pport; break;
        case 18: ev = e->htype; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* p2e20 table size get */
int soc_sbx_g2p3_p2e20_entry_table_size_get(int unit,
                int *tsize,
                int iport)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2E20_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = iport; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for p2e20 */
int soc_sbx_g2p3_p2e20_set(int unit,
                int iport,
                soc_sbx_g2p3_p2e20_t *e)
{
    int s, key[32], sset;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2E20_ID];

    s = soc_sbx_g2p3_p2e20_index_check(unit, key,
                iport);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_p2e20_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_p2e20_set_hook(unit, &sset, key,
                iport,
                e);
    if (sset) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_p2e20_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for p2e20 */
int soc_sbx_g2p3_p2e20_get(int unit,
                int iport,
                soc_sbx_g2p3_p2e20_t *e)
{
    int s, key[32], sset;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2E20_ID];

    s = soc_sbx_g2p3_p2e20_index_check(unit, key,
                iport);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_p2e20_get_hook(unit, &sset, key,
                iport);
    if (sset) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_p2e20_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for ep2e20
 */

void soc_sbx_g2p3_ep2e20_t_init(
    soc_sbx_g2p3_ep2e20_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ep2e20_t));
}

/* entry pack accessor implementation for ep2e20 */
int soc_sbx_g2p3_ep2e20_pack(int unit,
    soc_sbx_g2p3_ep2e20_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EP2E20_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->mim; break;
        case 1: p = (uint8 *) &e->pid; break;
        case 2: p = (uint8 *) &e->stpid0; break;
        case 3: p = (uint8 *) &e->stpid1; break;
        case 4: p = (uint8 *) &e->customer; break;
        case 5: p = (uint8 *) &e->keeperh; break;
        case 6: p = (uint8 *) &e->port; break;
        case 7: p = (uint8 *) &e->mirroridx; break;
        case 8: p = (uint8 *) e->mask; break;
        case 9: p = (uint8 *) &e->oamloop; break;
        case 10: p = (uint8 *) &e->pbb; break;
        case 11: p = (uint8 *) &e->state; break;
        case 12: p = (uint8 *) &e->htype; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ep2e20 */
int soc_sbx_g2p3_ep2e20_unpack(int unit,
                soc_sbx_g2p3_ep2e20_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EP2E20_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->mim; break;
        case 1: p = (uint8 *) &e->pid; break;
        case 2: p = (uint8 *) &e->stpid0; break;
        case 3: p = (uint8 *) &e->stpid1; break;
        case 4: p = (uint8 *) &e->customer; break;
        case 5: p = (uint8 *) &e->keeperh; break;
        case 6: p = (uint8 *) &e->port; break;
        case 7: p = (uint8 *) &e->mirroridx; break;
        case 8: p = (uint8 *) e->mask; break;
        case 9: p = (uint8 *) &e->oamloop; break;
        case 10: p = (uint8 *) &e->pbb; break;
        case 11: p = (uint8 *) &e->state; break;
        case 12: p = (uint8 *) &e->htype; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ep2e20 */
int soc_sbx_g2p3_ep2e20_index_check(int unit,
                int *vindex,
                int iport)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EP2E20_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iport; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ep2e20 */
int soc_sbx_g2p3_ep2e20_entry_check(int unit,
                soc_sbx_g2p3_ep2e20_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EP2E20_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->mim; break;
        case 1: ev = e->pid; break;
        case 2: ev = e->stpid0; break;
        case 3: ev = e->stpid1; break;
        case 4: ev = e->customer; break;
        case 5: ev = e->keeperh; break;
        case 6: ev = e->port; break;
        case 7: ev = e->mirroridx; break;
        case 8: ev = e->mask[0]; break;
        case 9: ev = e->oamloop; break;
        case 10: ev = e->pbb; break;
        case 11: ev = e->state; break;
        case 12: ev = e->htype; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* ep2e20 table size get */
int soc_sbx_g2p3_ep2e20_entry_table_size_get(int unit,
                int *tsize,
                int iport)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EP2E20_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = iport; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for ep2e20 */
int soc_sbx_g2p3_ep2e20_set(int unit,
                int iport,
                soc_sbx_g2p3_ep2e20_t *e)
{
    int s, key[32], sset;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EP2E20_ID];

    s = soc_sbx_g2p3_ep2e20_index_check(unit, key,
                iport);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ep2e20_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ep2e20_set_hook(unit, &sset, key,
                iport,
                e);
    if (sset) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_ep2e20_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for ep2e20 */
int soc_sbx_g2p3_ep2e20_get(int unit,
                int iport,
                soc_sbx_g2p3_ep2e20_t *e)
{
    int s, key[32], sset;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EP2E20_ID];

    s = soc_sbx_g2p3_ep2e20_index_check(unit, key,
                iport);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ep2e20_get_hook(unit, &sset, key,
                iport);
    if (sset) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_ep2e20_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for p2e25
 */

void soc_sbx_g2p3_p2e25_t_init(
    soc_sbx_g2p3_p2e25_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_p2e25_t));
    e->defstrip = 0x1;
}

/* entry pack accessor implementation for p2e25 */
int soc_sbx_g2p3_p2e25_pack(int unit,
    soc_sbx_g2p3_p2e25_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2E25_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->port; break;
        case 1: p = (uint8 *) &e->nativevid; break;
        case 2: p = (uint8 *) &e->defcfi; break;
        case 3: p = (uint8 *) &e->defpri; break;
        case 4: p = (uint8 *) &e->defstrip; break;
        case 5: p = (uint8 *) &e->pstrip; break;
        case 6: p = (uint8 *) &e->mim; break;
        case 7: p = (uint8 *) &e->mplstp; break;
        case 8: p = (uint8 *) e->mask; break;
        case 9: p = (uint8 *) &e->customer; break;
        case 10: p = (uint8 *) &e->provider; break;
        case 11: p = (uint8 *) &e->oamloop; break;
        case 12: p = (uint8 *) &e->stpid1; break;
        case 13: p = (uint8 *) &e->twintpid; break;
        case 14: p = (uint8 *) &e->pbb; break;
        case 15: p = (uint8 *) &e->ipv4mc; break;
        case 16: p = (uint8 *) &e->state; break;
        case 17: p = (uint8 *) &e->pport; break;
        case 18: p = (uint8 *) &e->htype; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for p2e25 */
int soc_sbx_g2p3_p2e25_unpack(int unit,
                soc_sbx_g2p3_p2e25_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2E25_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->port; break;
        case 1: p = (uint8 *) &e->nativevid; break;
        case 2: p = (uint8 *) &e->defcfi; break;
        case 3: p = (uint8 *) &e->defpri; break;
        case 4: p = (uint8 *) &e->defstrip; break;
        case 5: p = (uint8 *) &e->pstrip; break;
        case 6: p = (uint8 *) &e->mim; break;
        case 7: p = (uint8 *) &e->mplstp; break;
        case 8: p = (uint8 *) e->mask; break;
        case 9: p = (uint8 *) &e->customer; break;
        case 10: p = (uint8 *) &e->provider; break;
        case 11: p = (uint8 *) &e->oamloop; break;
        case 12: p = (uint8 *) &e->stpid1; break;
        case 13: p = (uint8 *) &e->twintpid; break;
        case 14: p = (uint8 *) &e->pbb; break;
        case 15: p = (uint8 *) &e->ipv4mc; break;
        case 16: p = (uint8 *) &e->state; break;
        case 17: p = (uint8 *) &e->pport; break;
        case 18: p = (uint8 *) &e->htype; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for p2e25 */
int soc_sbx_g2p3_p2e25_index_check(int unit,
                int *vindex,
                int iport)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2E25_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iport; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for p2e25 */
int soc_sbx_g2p3_p2e25_entry_check(int unit,
                soc_sbx_g2p3_p2e25_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2E25_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->port; break;
        case 1: ev = e->nativevid; break;
        case 2: ev = e->defcfi; break;
        case 3: ev = e->defpri; break;
        case 4: ev = e->defstrip; break;
        case 5: ev = e->pstrip; break;
        case 6: ev = e->mim; break;
        case 7: ev = e->mplstp; break;
        case 8: ev = e->mask[0]; break;
        case 9: ev = e->customer; break;
        case 10: ev = e->provider; break;
        case 11: ev = e->oamloop; break;
        case 12: ev = e->stpid1; break;
        case 13: ev = e->twintpid; break;
        case 14: ev = e->pbb; break;
        case 15: ev = e->ipv4mc; break;
        case 16: ev = e->state; break;
        case 17: ev = e->pport; break;
        case 18: ev = e->htype; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* p2e25 table size get */
int soc_sbx_g2p3_p2e25_entry_table_size_get(int unit,
                int *tsize,
                int iport)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2E25_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = iport; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for p2e25 */
int soc_sbx_g2p3_p2e25_set(int unit,
                int iport,
                soc_sbx_g2p3_p2e25_t *e)
{
    int s, key[32], sset;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2E25_ID];

    s = soc_sbx_g2p3_p2e25_index_check(unit, key,
                iport);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_p2e25_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_p2e25_set_hook(unit, &sset, key,
                iport,
                e);
    if (sset) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_p2e25_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for p2e25 */
int soc_sbx_g2p3_p2e25_get(int unit,
                int iport,
                soc_sbx_g2p3_p2e25_t *e)
{
    int s, key[32], sset;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2E25_ID];

    s = soc_sbx_g2p3_p2e25_index_check(unit, key,
                iport);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_p2e25_get_hook(unit, &sset, key,
                iport);
    if (sset) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_p2e25_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for ep2e25
 */

void soc_sbx_g2p3_ep2e25_t_init(
    soc_sbx_g2p3_ep2e25_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ep2e25_t));
}

/* entry pack accessor implementation for ep2e25 */
int soc_sbx_g2p3_ep2e25_pack(int unit,
    soc_sbx_g2p3_ep2e25_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EP2E25_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->mim; break;
        case 1: p = (uint8 *) &e->pid; break;
        case 2: p = (uint8 *) &e->stpid0; break;
        case 3: p = (uint8 *) &e->stpid1; break;
        case 4: p = (uint8 *) &e->customer; break;
        case 5: p = (uint8 *) &e->keeperh; break;
        case 6: p = (uint8 *) &e->port; break;
        case 7: p = (uint8 *) &e->mirroridx; break;
        case 8: p = (uint8 *) e->mask; break;
        case 9: p = (uint8 *) &e->oamloop; break;
        case 10: p = (uint8 *) &e->pbb; break;
        case 11: p = (uint8 *) &e->state; break;
        case 12: p = (uint8 *) &e->htype; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ep2e25 */
int soc_sbx_g2p3_ep2e25_unpack(int unit,
                soc_sbx_g2p3_ep2e25_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EP2E25_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->mim; break;
        case 1: p = (uint8 *) &e->pid; break;
        case 2: p = (uint8 *) &e->stpid0; break;
        case 3: p = (uint8 *) &e->stpid1; break;
        case 4: p = (uint8 *) &e->customer; break;
        case 5: p = (uint8 *) &e->keeperh; break;
        case 6: p = (uint8 *) &e->port; break;
        case 7: p = (uint8 *) &e->mirroridx; break;
        case 8: p = (uint8 *) e->mask; break;
        case 9: p = (uint8 *) &e->oamloop; break;
        case 10: p = (uint8 *) &e->pbb; break;
        case 11: p = (uint8 *) &e->state; break;
        case 12: p = (uint8 *) &e->htype; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ep2e25 */
int soc_sbx_g2p3_ep2e25_index_check(int unit,
                int *vindex,
                int iport)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EP2E25_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iport; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ep2e25 */
int soc_sbx_g2p3_ep2e25_entry_check(int unit,
                soc_sbx_g2p3_ep2e25_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EP2E25_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->mim; break;
        case 1: ev = e->pid; break;
        case 2: ev = e->stpid0; break;
        case 3: ev = e->stpid1; break;
        case 4: ev = e->customer; break;
        case 5: ev = e->keeperh; break;
        case 6: ev = e->port; break;
        case 7: ev = e->mirroridx; break;
        case 8: ev = e->mask[0]; break;
        case 9: ev = e->oamloop; break;
        case 10: ev = e->pbb; break;
        case 11: ev = e->state; break;
        case 12: ev = e->htype; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* ep2e25 table size get */
int soc_sbx_g2p3_ep2e25_entry_table_size_get(int unit,
                int *tsize,
                int iport)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EP2E25_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = iport; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for ep2e25 */
int soc_sbx_g2p3_ep2e25_set(int unit,
                int iport,
                soc_sbx_g2p3_ep2e25_t *e)
{
    int s, key[32], sset;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EP2E25_ID];

    s = soc_sbx_g2p3_ep2e25_index_check(unit, key,
                iport);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ep2e25_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ep2e25_set_hook(unit, &sset, key,
                iport,
                e);
    if (sset) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_ep2e25_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for ep2e25 */
int soc_sbx_g2p3_ep2e25_get(int unit,
                int iport,
                soc_sbx_g2p3_ep2e25_t *e)
{
    int s, key[32], sset;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EP2E25_ID];

    s = soc_sbx_g2p3_ep2e25_index_check(unit, key,
                iport);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ep2e25_get_hook(unit, &sset, key,
                iport);
    if (sset) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_ep2e25_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for tpid
 */

void soc_sbx_g2p3_tpid_t_init(
    soc_sbx_g2p3_tpid_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_tpid_t));
}

/* entry size function for tpid */
int soc_sbx_g2p3_tpid_size(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_TPID_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];

    return (eb->width + (eb->stridebits - 1)) / eb->stridebits;
}

/* entry pack accessor implementation for tpid */
int soc_sbx_g2p3_tpid_pack(int unit,
    soc_sbx_g2p3_tpid_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_TPID_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->tpid; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for tpid */
int soc_sbx_g2p3_tpid_unpack(int unit,
                soc_sbx_g2p3_tpid_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_TPID_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->tpid; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for tpid */
int soc_sbx_g2p3_tpid_index_check(int unit,
                int *vindex,
                int itpidi)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_TPID_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &itpidi; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for tpid */
int soc_sbx_g2p3_tpid_entry_check(int unit,
                soc_sbx_g2p3_tpid_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_TPID_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->tpid; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for tpid */
int soc_sbx_g2p3_tpid_set(int unit,
                int itpidi,
                soc_sbx_g2p3_tpid_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_tpid_index_check(unit, key,
                itpidi);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_tpid_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_tpid_set_ext(unit,
                itpidi,
                e);

    return s;
}

/* entry get accessor implementation for tpid */
int soc_sbx_g2p3_tpid_get(int unit,
                int itpidi,
                soc_sbx_g2p3_tpid_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_tpid_index_check(unit, key,
                itpidi);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_tpid_get_ext(unit,
                itpidi,
                e);

    return s;
}

/*
 * Entry accessor implementations for oam_rx
 */

void soc_sbx_g2p3_oam_rx_t_init(
    soc_sbx_g2p3_oam_rx_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_oam_rx_t));
}

/* entry size function for oam_rx */
int soc_sbx_g2p3_oam_rx_size(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAM_RX_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];

    return (eb->width + (eb->stridebits - 1)) / eb->stridebits;
}

/* entry pack accessor implementation for oam_rx */
int soc_sbx_g2p3_oam_rx_pack(int unit,
    soc_sbx_g2p3_oam_rx_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAM_RX_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->valid; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for oam_rx */
int soc_sbx_g2p3_oam_rx_unpack(int unit,
                soc_sbx_g2p3_oam_rx_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAM_RX_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->valid; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for oam_rx */
int soc_sbx_g2p3_oam_rx_index_check(int unit,
                int *vindex,
                int irule)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAM_RX_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &irule; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for oam_rx */
int soc_sbx_g2p3_oam_rx_entry_check(int unit,
                soc_sbx_g2p3_oam_rx_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAM_RX_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->valid; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for oam_rx */
int soc_sbx_g2p3_oam_rx_set(int unit,
                int irule,
                soc_sbx_g2p3_oam_rx_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_oam_rx_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_oam_rx_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_oam_rx_set_ext(unit,
                irule,
                e);

    return s;
}

/* entry get accessor implementation for oam_rx */
int soc_sbx_g2p3_oam_rx_get(int unit,
                int irule,
                soc_sbx_g2p3_oam_rx_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_oam_rx_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_oam_rx_get_ext(unit,
                irule,
                e);

    return s;
}

/*
 * Entry accessor implementations for oam_tx
 */

void soc_sbx_g2p3_oam_tx_t_init(
    soc_sbx_g2p3_oam_tx_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_oam_tx_t));
}

/* entry size function for oam_tx */
int soc_sbx_g2p3_oam_tx_size(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAM_TX_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];

    return (eb->width + (eb->stridebits - 1)) / eb->stridebits;
}

/* entry pack accessor implementation for oam_tx */
int soc_sbx_g2p3_oam_tx_pack(int unit,
    soc_sbx_g2p3_oam_tx_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAM_TX_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->valid; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for oam_tx */
int soc_sbx_g2p3_oam_tx_unpack(int unit,
                soc_sbx_g2p3_oam_tx_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAM_TX_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->valid; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for oam_tx */
int soc_sbx_g2p3_oam_tx_index_check(int unit,
                int *vindex,
                int irule)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAM_TX_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &irule; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for oam_tx */
int soc_sbx_g2p3_oam_tx_entry_check(int unit,
                soc_sbx_g2p3_oam_tx_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAM_TX_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->valid; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for oam_tx */
int soc_sbx_g2p3_oam_tx_set(int unit,
                int irule,
                soc_sbx_g2p3_oam_tx_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_oam_tx_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_oam_tx_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_oam_tx_set_ext(unit,
                irule,
                e);

    return s;
}

/* entry get accessor implementation for oam_tx */
int soc_sbx_g2p3_oam_tx_get(int unit,
                int irule,
                soc_sbx_g2p3_oam_tx_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_oam_tx_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_oam_tx_get_ext(unit,
                irule,
                e);

    return s;
}

/*
 * Entry accessor implementations for lsmac
 */

void soc_sbx_g2p3_lsmac_t_init(
    soc_sbx_g2p3_lsmac_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_lsmac_t));
}

/* entry size function for lsmac */
int soc_sbx_g2p3_lsmac_size(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LSMAC_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];

    return (eb->width + (eb->stridebits - 1)) / eb->stridebits;
}

/* entry pack accessor implementation for lsmac */
int soc_sbx_g2p3_lsmac_pack(int unit,
    soc_sbx_g2p3_lsmac_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LSMAC_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->port; break;
        case 1: p = (uint8 *) &e->useport; break;
        case 2: p = (uint8 *) e->mac; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for lsmac */
int soc_sbx_g2p3_lsmac_unpack(int unit,
                soc_sbx_g2p3_lsmac_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LSMAC_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->port; break;
        case 1: p = (uint8 *) &e->useport; break;
        case 2: p = (uint8 *) e->mac; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for lsmac */
int soc_sbx_g2p3_lsmac_index_check(int unit,
                int *vindex,
                int ilsi)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LSMAC_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ilsi; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for lsmac */
int soc_sbx_g2p3_lsmac_entry_check(int unit,
                soc_sbx_g2p3_lsmac_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LSMAC_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->port; break;
        case 1: ev = e->useport; break;
        case 2: ev = e->mac[0]; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for lsmac */
int soc_sbx_g2p3_lsmac_set(int unit,
                int ilsi,
                soc_sbx_g2p3_lsmac_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_lsmac_index_check(unit, key,
                ilsi);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_lsmac_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_lsmac_set_ext(unit,
                ilsi,
                e);

    return s;
}

/* entry get accessor implementation for lsmac */
int soc_sbx_g2p3_lsmac_get(int unit,
                int ilsi,
                soc_sbx_g2p3_lsmac_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_lsmac_index_check(unit, key,
                ilsi);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_lsmac_get_ext(unit,
                ilsi,
                e);

    return s;
}

/*
 * Entry accessor implementations for l2cpmac
 */

void soc_sbx_g2p3_l2cpmac_t_init(
    soc_sbx_g2p3_l2cpmac_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_l2cpmac_t));
}

/* entry size function for l2cpmac */
int soc_sbx_g2p3_l2cpmac_size(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2CPMAC_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];

    return (eb->width + (eb->stridebits - 1)) / eb->stridebits;
}

/* entry pack accessor implementation for l2cpmac */
int soc_sbx_g2p3_l2cpmac_pack(int unit,
    soc_sbx_g2p3_l2cpmac_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2CPMAC_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->port; break;
        case 1: p = (uint8 *) &e->useport; break;
        case 2: p = (uint8 *) e->mac; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for l2cpmac */
int soc_sbx_g2p3_l2cpmac_unpack(int unit,
                soc_sbx_g2p3_l2cpmac_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2CPMAC_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->port; break;
        case 1: p = (uint8 *) &e->useport; break;
        case 2: p = (uint8 *) e->mac; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for l2cpmac */
int soc_sbx_g2p3_l2cpmac_index_check(int unit,
                int *vindex,
                int ilsi)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2CPMAC_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ilsi; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for l2cpmac */
int soc_sbx_g2p3_l2cpmac_entry_check(int unit,
                soc_sbx_g2p3_l2cpmac_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2CPMAC_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->port; break;
        case 1: ev = e->useport; break;
        case 2: ev = e->mac[0]; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for l2cpmac */
int soc_sbx_g2p3_l2cpmac_set(int unit,
                int ilsi,
                soc_sbx_g2p3_l2cpmac_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_l2cpmac_index_check(unit, key,
                ilsi);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_l2cpmac_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_l2cpmac_set_ext(unit,
                ilsi,
                e);

    return s;
}

/* entry get accessor implementation for l2cpmac */
int soc_sbx_g2p3_l2cpmac_get(int unit,
                int ilsi,
                soc_sbx_g2p3_l2cpmac_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_l2cpmac_index_check(unit, key,
                ilsi);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_l2cpmac_get_ext(unit,
                ilsi,
                e);

    return s;
}

/*
 * Entry accessor implementations for oamupmac
 */

void soc_sbx_g2p3_oamupmac_t_init(
    soc_sbx_g2p3_oamupmac_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_oamupmac_t));
}

/* entry size function for oamupmac */
int soc_sbx_g2p3_oamupmac_size(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMUPMAC_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];

    return (eb->width + (eb->stridebits - 1)) / eb->stridebits;
}

/* entry pack accessor implementation for oamupmac */
int soc_sbx_g2p3_oamupmac_pack(int unit,
    soc_sbx_g2p3_oamupmac_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMUPMAC_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) e->mac; break;
        case 1: p = (uint8 *) e->mask; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for oamupmac */
int soc_sbx_g2p3_oamupmac_unpack(int unit,
                soc_sbx_g2p3_oamupmac_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMUPMAC_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) e->mac; break;
        case 1: p = (uint8 *) e->mask; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for oamupmac */
int soc_sbx_g2p3_oamupmac_index_check(int unit,
                int *vindex,
                int ilsi)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMUPMAC_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ilsi; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for oamupmac */
int soc_sbx_g2p3_oamupmac_entry_check(int unit,
                soc_sbx_g2p3_oamupmac_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMUPMAC_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->mac[0]; break;
        case 1: ev = e->mask[0]; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for oamupmac */
int soc_sbx_g2p3_oamupmac_set(int unit,
                int ilsi,
                soc_sbx_g2p3_oamupmac_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_oamupmac_index_check(unit, key,
                ilsi);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_oamupmac_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_oamupmac_set_ext(unit,
                ilsi,
                e);

    return s;
}

/* entry get accessor implementation for oamupmac */
int soc_sbx_g2p3_oamupmac_get(int unit,
                int ilsi,
                soc_sbx_g2p3_oamupmac_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_oamupmac_index_check(unit, key,
                ilsi);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_oamupmac_get_ext(unit,
                ilsi,
                e);

    return s;
}

/*
 * Entry accessor implementations for qos
 */

void soc_sbx_g2p3_qos_t_init(
    soc_sbx_g2p3_qos_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_qos_t));
}

/* entry pack accessor implementation for qos */
int soc_sbx_g2p3_qos_pack(int unit,
    soc_sbx_g2p3_qos_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_QOS_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->e; break;
        case 1: p = (uint8 *) &e->dp; break;
        case 2: p = (uint8 *) &e->cos; break;
        case 3: p = (uint8 *) &e->fcos; break;
        case 4: p = (uint8 *) &e->mefcos; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for qos */
int soc_sbx_g2p3_qos_unpack(int unit,
                soc_sbx_g2p3_qos_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_QOS_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->e; break;
        case 1: p = (uint8 *) &e->dp; break;
        case 2: p = (uint8 *) &e->cos; break;
        case 3: p = (uint8 *) &e->fcos; break;
        case 4: p = (uint8 *) &e->mefcos; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for qos */
int soc_sbx_g2p3_qos_index_check(int unit,
                int *vindex,
                int ide,
                int ipri,
                int iprof)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_QOS_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ide; break;
        case 1: p = (uint8 *) &ipri; break;
        case 2: p = (uint8 *) &iprof; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for qos */
int soc_sbx_g2p3_qos_entry_check(int unit,
                soc_sbx_g2p3_qos_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_QOS_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->e; break;
        case 1: ev = e->dp; break;
        case 2: ev = e->cos; break;
        case 3: ev = e->fcos; break;
        case 4: ev = e->mefcos; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* qos table size get */
int soc_sbx_g2p3_qos_entry_table_size_get(int unit,
                int *tsize,
                int ide,
                int ipri,
                int iprof)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_QOS_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ide; break;
        case 1: v = ipri; break;
        case 2: v = iprof; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for qos */
int soc_sbx_g2p3_qos_set(int unit,
                int ide,
                int ipri,
                int iprof,
                soc_sbx_g2p3_qos_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_QOS_ID];

    s = soc_sbx_g2p3_qos_index_check(unit, key,
                ide,
                ipri,
                iprof);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_qos_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_qos_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for qos */
int soc_sbx_g2p3_qos_get(int unit,
                int ide,
                int ipri,
                int iprof,
                soc_sbx_g2p3_qos_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_QOS_ID];

    s = soc_sbx_g2p3_qos_index_check(unit, key,
                ide,
                ipri,
                iprof);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_qos_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for dscp_qos
 */

void soc_sbx_g2p3_dscp_qos_t_init(
    soc_sbx_g2p3_dscp_qos_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_dscp_qos_t));
}

/* entry pack accessor implementation for dscp_qos */
int soc_sbx_g2p3_dscp_qos_pack(int unit,
    soc_sbx_g2p3_dscp_qos_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_DSCP_QOS_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->e; break;
        case 1: p = (uint8 *) &e->dp; break;
        case 2: p = (uint8 *) &e->cos; break;
        case 3: p = (uint8 *) &e->fcos; break;
        case 4: p = (uint8 *) &e->mefcos; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for dscp_qos */
int soc_sbx_g2p3_dscp_qos_unpack(int unit,
                soc_sbx_g2p3_dscp_qos_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_DSCP_QOS_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->e; break;
        case 1: p = (uint8 *) &e->dp; break;
        case 2: p = (uint8 *) &e->cos; break;
        case 3: p = (uint8 *) &e->fcos; break;
        case 4: p = (uint8 *) &e->mefcos; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for dscp_qos */
int soc_sbx_g2p3_dscp_qos_index_check(int unit,
                int *vindex,
                int idscp,
                int iprof)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_DSCP_QOS_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &idscp; break;
        case 1: p = (uint8 *) &iprof; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for dscp_qos */
int soc_sbx_g2p3_dscp_qos_entry_check(int unit,
                soc_sbx_g2p3_dscp_qos_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_DSCP_QOS_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->e; break;
        case 1: ev = e->dp; break;
        case 2: ev = e->cos; break;
        case 3: ev = e->fcos; break;
        case 4: ev = e->mefcos; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* dscp_qos table size get */
int soc_sbx_g2p3_dscp_qos_entry_table_size_get(int unit,
                int *tsize,
                int idscp,
                int iprof)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_DSCP_QOS_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = idscp; break;
        case 1: v = iprof; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for dscp_qos */
int soc_sbx_g2p3_dscp_qos_set(int unit,
                int idscp,
                int iprof,
                soc_sbx_g2p3_dscp_qos_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_DSCP_QOS_ID];

    s = soc_sbx_g2p3_dscp_qos_index_check(unit, key,
                idscp,
                iprof);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_dscp_qos_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_dscp_qos_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for dscp_qos */
int soc_sbx_g2p3_dscp_qos_get(int unit,
                int idscp,
                int iprof,
                soc_sbx_g2p3_dscp_qos_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_DSCP_QOS_ID];

    s = soc_sbx_g2p3_dscp_qos_index_check(unit, key,
                idscp,
                iprof);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_dscp_qos_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for irt
 */

void soc_sbx_g2p3_irt_t_init(
    soc_sbx_g2p3_irt_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_irt_t));
}

/* entry pack accessor implementation for irt */
int soc_sbx_g2p3_irt_pack(int unit,
    soc_sbx_g2p3_irt_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IRT_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->vlan; break;
        case 1: p = (uint8 *) &e->ftidx; break;
        case 2: p = (uint8 *) &e->mirror; break;
        case 3: p = (uint8 *) &e->usevlan; break;
        case 4: p = (uint8 *) &e->useftidx; break;
        case 5: p = (uint8 *) &e->copy; break;
        case 6: p = (uint8 *) &e->dp; break;
        case 7: p = (uint8 *) &e->cos; break;
        case 8: p = (uint8 *) &e->fcos; break;
        case 9: p = (uint8 *) &e->usedp; break;
        case 10: p = (uint8 *) &e->usecos; break;
        case 11: p = (uint8 *) &e->policer; break;
        case 12: p = (uint8 *) &e->typedpolice; break;
        case 13: p = (uint8 *) &e->mefcos; break;
        case 14: p = (uint8 *) &e->mef; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for irt */
int soc_sbx_g2p3_irt_unpack(int unit,
                soc_sbx_g2p3_irt_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IRT_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->vlan; break;
        case 1: p = (uint8 *) &e->ftidx; break;
        case 2: p = (uint8 *) &e->mirror; break;
        case 3: p = (uint8 *) &e->usevlan; break;
        case 4: p = (uint8 *) &e->useftidx; break;
        case 5: p = (uint8 *) &e->copy; break;
        case 6: p = (uint8 *) &e->dp; break;
        case 7: p = (uint8 *) &e->cos; break;
        case 8: p = (uint8 *) &e->fcos; break;
        case 9: p = (uint8 *) &e->usedp; break;
        case 10: p = (uint8 *) &e->usecos; break;
        case 11: p = (uint8 *) &e->policer; break;
        case 12: p = (uint8 *) &e->typedpolice; break;
        case 13: p = (uint8 *) &e->mefcos; break;
        case 14: p = (uint8 *) &e->mef; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for irt */
int soc_sbx_g2p3_irt_index_check(int unit,
                int *vindex,
                int irule)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IRT_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &irule; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for irt */
int soc_sbx_g2p3_irt_entry_check(int unit,
                soc_sbx_g2p3_irt_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IRT_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->vlan; break;
        case 1: ev = e->ftidx; break;
        case 2: ev = e->mirror; break;
        case 3: ev = e->usevlan; break;
        case 4: ev = e->useftidx; break;
        case 5: ev = e->copy; break;
        case 6: ev = e->dp; break;
        case 7: ev = e->cos; break;
        case 8: ev = e->fcos; break;
        case 9: ev = e->usedp; break;
        case 10: ev = e->usecos; break;
        case 11: ev = e->policer; break;
        case 12: ev = e->typedpolice; break;
        case 13: ev = e->mefcos; break;
        case 14: ev = e->mef; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* irt table size get */
int soc_sbx_g2p3_irt_entry_table_size_get(int unit,
                int *tsize,
                int irule)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IRT_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = irule; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for irt */
int soc_sbx_g2p3_irt_set(int unit,
                int irule,
                soc_sbx_g2p3_irt_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IRT_ID];

    s = soc_sbx_g2p3_irt_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_irt_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_irt_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for irt */
int soc_sbx_g2p3_irt_get(int unit,
                int irule,
                soc_sbx_g2p3_irt_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IRT_ID];

    s = soc_sbx_g2p3_irt_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_irt_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for irt_wrap
 */

void soc_sbx_g2p3_irt_wrap_t_init(
    soc_sbx_g2p3_irt_wrap_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_irt_wrap_t));
}

/* entry size function for irt_wrap */
int soc_sbx_g2p3_irt_wrap_size(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IRT_WRAP_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];

    return (eb->width + (eb->stridebits - 1)) / eb->stridebits;
}

/* entry pack accessor implementation for irt_wrap */
int soc_sbx_g2p3_irt_wrap_pack(int unit,
    soc_sbx_g2p3_irt_wrap_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IRT_WRAP_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->vlan; break;
        case 1: p = (uint8 *) &e->ftidx; break;
        case 2: p = (uint8 *) &e->mirror; break;
        case 3: p = (uint8 *) &e->usevlan; break;
        case 4: p = (uint8 *) &e->useftidx; break;
        case 5: p = (uint8 *) &e->copy; break;
        case 6: p = (uint8 *) &e->dp; break;
        case 7: p = (uint8 *) &e->cos; break;
        case 8: p = (uint8 *) &e->fcos; break;
        case 9: p = (uint8 *) &e->usedp; break;
        case 10: p = (uint8 *) &e->usecos; break;
        case 11: p = (uint8 *) &e->policer; break;
        case 12: p = (uint8 *) &e->typedpolice; break;
        case 13: p = (uint8 *) &e->mefcos; break;
        case 14: p = (uint8 *) &e->mef; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for irt_wrap */
int soc_sbx_g2p3_irt_wrap_unpack(int unit,
                soc_sbx_g2p3_irt_wrap_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IRT_WRAP_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->vlan; break;
        case 1: p = (uint8 *) &e->ftidx; break;
        case 2: p = (uint8 *) &e->mirror; break;
        case 3: p = (uint8 *) &e->usevlan; break;
        case 4: p = (uint8 *) &e->useftidx; break;
        case 5: p = (uint8 *) &e->copy; break;
        case 6: p = (uint8 *) &e->dp; break;
        case 7: p = (uint8 *) &e->cos; break;
        case 8: p = (uint8 *) &e->fcos; break;
        case 9: p = (uint8 *) &e->usedp; break;
        case 10: p = (uint8 *) &e->usecos; break;
        case 11: p = (uint8 *) &e->policer; break;
        case 12: p = (uint8 *) &e->typedpolice; break;
        case 13: p = (uint8 *) &e->mefcos; break;
        case 14: p = (uint8 *) &e->mef; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for irt_wrap */
int soc_sbx_g2p3_irt_wrap_index_check(int unit,
                int *vindex,
                int irule)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IRT_WRAP_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &irule; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for irt_wrap */
int soc_sbx_g2p3_irt_wrap_entry_check(int unit,
                soc_sbx_g2p3_irt_wrap_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IRT_WRAP_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->vlan; break;
        case 1: ev = e->ftidx; break;
        case 2: ev = e->mirror; break;
        case 3: ev = e->usevlan; break;
        case 4: ev = e->useftidx; break;
        case 5: ev = e->copy; break;
        case 6: ev = e->dp; break;
        case 7: ev = e->cos; break;
        case 8: ev = e->fcos; break;
        case 9: ev = e->usedp; break;
        case 10: ev = e->usecos; break;
        case 11: ev = e->policer; break;
        case 12: ev = e->typedpolice; break;
        case 13: ev = e->mefcos; break;
        case 14: ev = e->mef; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for irt_wrap */
int soc_sbx_g2p3_irt_wrap_set(int unit,
                int irule,
                soc_sbx_g2p3_irt_wrap_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_irt_wrap_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_irt_wrap_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_irt_wrap_set_ext(unit,
                irule,
                e);

    return s;
}

/* entry get accessor implementation for irt_wrap */
int soc_sbx_g2p3_irt_wrap_get(int unit,
                int irule,
                soc_sbx_g2p3_irt_wrap_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_irt_wrap_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_irt_wrap_get_ext(unit,
                irule,
                e);

    return s;
}

/*
 * Entry accessor implementations for rt_mt
 */

void soc_sbx_g2p3_rt_mt_t_init(
    soc_sbx_g2p3_rt_mt_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_rt_mt_t));
}

/* entry pack accessor implementation for rt_mt */
int soc_sbx_g2p3_rt_mt_pack(int unit,
    soc_sbx_g2p3_rt_mt_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RT_MT_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->policer; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for rt_mt */
int soc_sbx_g2p3_rt_mt_unpack(int unit,
                soc_sbx_g2p3_rt_mt_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RT_MT_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->policer; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for rt_mt */
int soc_sbx_g2p3_rt_mt_index_check(int unit,
                int *vindex,
                int irule)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RT_MT_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &irule; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for rt_mt */
int soc_sbx_g2p3_rt_mt_entry_check(int unit,
                soc_sbx_g2p3_rt_mt_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RT_MT_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->policer; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* rt_mt table size get */
int soc_sbx_g2p3_rt_mt_entry_table_size_get(int unit,
                int *tsize,
                int irule)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RT_MT_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = irule; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for rt_mt */
int soc_sbx_g2p3_rt_mt_set(int unit,
                int irule,
                soc_sbx_g2p3_rt_mt_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RT_MT_ID];

    s = soc_sbx_g2p3_rt_mt_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_rt_mt_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_rt_mt_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for rt_mt */
int soc_sbx_g2p3_rt_mt_get(int unit,
                int irule,
                soc_sbx_g2p3_rt_mt_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RT_MT_ID];

    s = soc_sbx_g2p3_rt_mt_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_rt_mt_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for rt_rr0
 */

void soc_sbx_g2p3_rt_rr0_t_init(
    soc_sbx_g2p3_rt_rr0_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_rt_rr0_t));
}

/* entry pack accessor implementation for rt_rr0 */
int soc_sbx_g2p3_rt_rr0_pack(int unit,
    soc_sbx_g2p3_rt_rr0_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RT_RR0_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->resv; break;
        case 1: p = (uint8 *) &e->usevlan; break;
        case 2: p = (uint8 *) &e->useftidx; break;
        case 3: p = (uint8 *) &e->vlan; break;
        case 4: p = (uint8 *) &e->ftidx; break;
        case 5: p = (uint8 *) &e->copy; break;
        case 6: p = (uint8 *) &e->dp; break;
        case 7: p = (uint8 *) &e->usedp; break;
        case 8: p = (uint8 *) &e->mirror; break;
        case 9: p = (uint8 *) &e->typedpolice; break;
        case 10: p = (uint8 *) &e->mefcos; break;
        case 11: p = (uint8 *) &e->mef; break;
        case 12: p = (uint8 *) &e->cos; break;
        case 13: p = (uint8 *) &e->fcos; break;
        case 14: p = (uint8 *) &e->usecos; break;
        case 15: p = (uint8 *) &e->emirror; break;
        case 16: p = (uint8 *) &e->drop; break;
        case 17: p = (uint8 *) &e->rtidx; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for rt_rr0 */
int soc_sbx_g2p3_rt_rr0_unpack(int unit,
                soc_sbx_g2p3_rt_rr0_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RT_RR0_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->resv; break;
        case 1: p = (uint8 *) &e->usevlan; break;
        case 2: p = (uint8 *) &e->useftidx; break;
        case 3: p = (uint8 *) &e->vlan; break;
        case 4: p = (uint8 *) &e->ftidx; break;
        case 5: p = (uint8 *) &e->copy; break;
        case 6: p = (uint8 *) &e->dp; break;
        case 7: p = (uint8 *) &e->usedp; break;
        case 8: p = (uint8 *) &e->mirror; break;
        case 9: p = (uint8 *) &e->typedpolice; break;
        case 10: p = (uint8 *) &e->mefcos; break;
        case 11: p = (uint8 *) &e->mef; break;
        case 12: p = (uint8 *) &e->cos; break;
        case 13: p = (uint8 *) &e->fcos; break;
        case 14: p = (uint8 *) &e->usecos; break;
        case 15: p = (uint8 *) &e->emirror; break;
        case 16: p = (uint8 *) &e->drop; break;
        case 17: p = (uint8 *) &e->rtidx; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for rt_rr0 */
int soc_sbx_g2p3_rt_rr0_index_check(int unit,
                int *vindex,
                int irule)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RT_RR0_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &irule; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for rt_rr0 */
int soc_sbx_g2p3_rt_rr0_entry_check(int unit,
                soc_sbx_g2p3_rt_rr0_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RT_RR0_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->resv; break;
        case 1: ev = e->usevlan; break;
        case 2: ev = e->useftidx; break;
        case 3: ev = e->vlan; break;
        case 4: ev = e->ftidx; break;
        case 5: ev = e->copy; break;
        case 6: ev = e->dp; break;
        case 7: ev = e->usedp; break;
        case 8: ev = e->mirror; break;
        case 9: ev = e->typedpolice; break;
        case 10: ev = e->mefcos; break;
        case 11: ev = e->mef; break;
        case 12: ev = e->cos; break;
        case 13: ev = e->fcos; break;
        case 14: ev = e->usecos; break;
        case 15: ev = e->emirror; break;
        case 16: ev = e->drop; break;
        case 17: ev = e->rtidx; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* rt_rr0 table size get */
int soc_sbx_g2p3_rt_rr0_entry_table_size_get(int unit,
                int *tsize,
                int irule)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RT_RR0_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = irule; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for rt_rr0 */
int soc_sbx_g2p3_rt_rr0_set(int unit,
                int irule,
                soc_sbx_g2p3_rt_rr0_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RT_RR0_ID];

    s = soc_sbx_g2p3_rt_rr0_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_rt_rr0_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_rt_rr0_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for rt_rr0 */
int soc_sbx_g2p3_rt_rr0_get(int unit,
                int irule,
                soc_sbx_g2p3_rt_rr0_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RT_RR0_ID];

    s = soc_sbx_g2p3_rt_rr0_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_rt_rr0_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for rt_rr1
 */

void soc_sbx_g2p3_rt_rr1_t_init(
    soc_sbx_g2p3_rt_rr1_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_rt_rr1_t));
}

/* entry pack accessor implementation for rt_rr1 */
int soc_sbx_g2p3_rt_rr1_pack(int unit,
    soc_sbx_g2p3_rt_rr1_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RT_RR1_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->resv; break;
        case 1: p = (uint8 *) &e->usevlan; break;
        case 2: p = (uint8 *) &e->useftidx; break;
        case 3: p = (uint8 *) &e->vlan; break;
        case 4: p = (uint8 *) &e->ftidx; break;
        case 5: p = (uint8 *) &e->copy; break;
        case 6: p = (uint8 *) &e->dp; break;
        case 7: p = (uint8 *) &e->usedp; break;
        case 8: p = (uint8 *) &e->mirror; break;
        case 9: p = (uint8 *) &e->typedpolice; break;
        case 10: p = (uint8 *) &e->mefcos; break;
        case 11: p = (uint8 *) &e->mef; break;
        case 12: p = (uint8 *) &e->cos; break;
        case 13: p = (uint8 *) &e->fcos; break;
        case 14: p = (uint8 *) &e->usecos; break;
        case 15: p = (uint8 *) &e->emirror; break;
        case 16: p = (uint8 *) &e->drop; break;
        case 17: p = (uint8 *) &e->rtidx; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for rt_rr1 */
int soc_sbx_g2p3_rt_rr1_unpack(int unit,
                soc_sbx_g2p3_rt_rr1_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RT_RR1_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->resv; break;
        case 1: p = (uint8 *) &e->usevlan; break;
        case 2: p = (uint8 *) &e->useftidx; break;
        case 3: p = (uint8 *) &e->vlan; break;
        case 4: p = (uint8 *) &e->ftidx; break;
        case 5: p = (uint8 *) &e->copy; break;
        case 6: p = (uint8 *) &e->dp; break;
        case 7: p = (uint8 *) &e->usedp; break;
        case 8: p = (uint8 *) &e->mirror; break;
        case 9: p = (uint8 *) &e->typedpolice; break;
        case 10: p = (uint8 *) &e->mefcos; break;
        case 11: p = (uint8 *) &e->mef; break;
        case 12: p = (uint8 *) &e->cos; break;
        case 13: p = (uint8 *) &e->fcos; break;
        case 14: p = (uint8 *) &e->usecos; break;
        case 15: p = (uint8 *) &e->emirror; break;
        case 16: p = (uint8 *) &e->drop; break;
        case 17: p = (uint8 *) &e->rtidx; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for rt_rr1 */
int soc_sbx_g2p3_rt_rr1_index_check(int unit,
                int *vindex,
                int irule)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RT_RR1_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &irule; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for rt_rr1 */
int soc_sbx_g2p3_rt_rr1_entry_check(int unit,
                soc_sbx_g2p3_rt_rr1_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RT_RR1_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->resv; break;
        case 1: ev = e->usevlan; break;
        case 2: ev = e->useftidx; break;
        case 3: ev = e->vlan; break;
        case 4: ev = e->ftidx; break;
        case 5: ev = e->copy; break;
        case 6: ev = e->dp; break;
        case 7: ev = e->usedp; break;
        case 8: ev = e->mirror; break;
        case 9: ev = e->typedpolice; break;
        case 10: ev = e->mefcos; break;
        case 11: ev = e->mef; break;
        case 12: ev = e->cos; break;
        case 13: ev = e->fcos; break;
        case 14: ev = e->usecos; break;
        case 15: ev = e->emirror; break;
        case 16: ev = e->drop; break;
        case 17: ev = e->rtidx; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* rt_rr1 table size get */
int soc_sbx_g2p3_rt_rr1_entry_table_size_get(int unit,
                int *tsize,
                int irule)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RT_RR1_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = irule; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for rt_rr1 */
int soc_sbx_g2p3_rt_rr1_set(int unit,
                int irule,
                soc_sbx_g2p3_rt_rr1_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RT_RR1_ID];

    s = soc_sbx_g2p3_rt_rr1_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_rt_rr1_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_rt_rr1_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for rt_rr1 */
int soc_sbx_g2p3_rt_rr1_get(int unit,
                int irule,
                soc_sbx_g2p3_rt_rr1_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RT_RR1_ID];

    s = soc_sbx_g2p3_rt_rr1_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_rt_rr1_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for lag
 */

void soc_sbx_g2p3_lag_t_init(
    soc_sbx_g2p3_lag_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_lag_t));
}

/* entry pack accessor implementation for lag */
int soc_sbx_g2p3_lag_pack(int unit,
    soc_sbx_g2p3_lag_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LAG_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->qid; break;
        case 1: p = (uint8 *) &e->oi; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for lag */
int soc_sbx_g2p3_lag_unpack(int unit,
                soc_sbx_g2p3_lag_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LAG_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->qid; break;
        case 1: p = (uint8 *) &e->oi; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for lag */
int soc_sbx_g2p3_lag_index_check(int unit,
                int *vindex,
                int ilagi)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LAG_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ilagi; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for lag */
int soc_sbx_g2p3_lag_entry_check(int unit,
                soc_sbx_g2p3_lag_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LAG_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->qid; break;
        case 1: ev = e->oi; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* lag table size get */
int soc_sbx_g2p3_lag_entry_table_size_get(int unit,
                int *tsize,
                int ilagi)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LAG_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ilagi; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for lag */
int soc_sbx_g2p3_lag_set(int unit,
                int ilagi,
                soc_sbx_g2p3_lag_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LAG_ID];

    s = soc_sbx_g2p3_lag_index_check(unit, key,
                ilagi);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_lag_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_lag_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for lag */
int soc_sbx_g2p3_lag_get(int unit,
                int ilagi,
                soc_sbx_g2p3_lag_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LAG_ID];

    s = soc_sbx_g2p3_lag_index_check(unit, key,
                ilagi);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_lag_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for rr
 */

void soc_sbx_g2p3_rr_t_init(
    soc_sbx_g2p3_rr_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_rr_t));
}

/* entry pack accessor implementation for rr */
int soc_sbx_g2p3_rr_pack(int unit,
    soc_sbx_g2p3_rr_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RR_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->backup; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for rr */
int soc_sbx_g2p3_rr_unpack(int unit,
                soc_sbx_g2p3_rr_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RR_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->backup; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for rr */
int soc_sbx_g2p3_rr_index_check(int unit,
                int *vindex,
                int irri)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RR_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &irri; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for rr */
int soc_sbx_g2p3_rr_entry_check(int unit,
                soc_sbx_g2p3_rr_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RR_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->backup; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* rr table size get */
int soc_sbx_g2p3_rr_entry_table_size_get(int unit,
                int *tsize,
                int irri)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RR_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = irri; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for rr */
int soc_sbx_g2p3_rr_set(int unit,
                int irri,
                soc_sbx_g2p3_rr_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RR_ID];

    s = soc_sbx_g2p3_rr_index_check(unit, key,
                irri);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_rr_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_rr_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for rr */
int soc_sbx_g2p3_rr_get(int unit,
                int irri,
                soc_sbx_g2p3_rr_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RR_ID];

    s = soc_sbx_g2p3_rr_index_check(unit, key,
                irri);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_rr_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for xt
 */

void soc_sbx_g2p3_xt_t_init(
    soc_sbx_g2p3_xt_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_xt_t));
}

/* entry pack accessor implementation for xt */
int soc_sbx_g2p3_xt_pack(int unit,
    soc_sbx_g2p3_xt_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_XT_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->forward; break;
        case 1: p = (uint8 *) &e->dp; break;
        case 2: p = (uint8 *) &e->qid; break;
        case 3: p = (uint8 *) &e->trunc; break;
        case 4: p = (uint8 *) &e->learn; break;
        case 5: p = (uint8 *) &e->ppspolice; break;
        case 6: p = (uint8 *) &e->policer; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for xt */
int soc_sbx_g2p3_xt_unpack(int unit,
                soc_sbx_g2p3_xt_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_XT_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->forward; break;
        case 1: p = (uint8 *) &e->dp; break;
        case 2: p = (uint8 *) &e->qid; break;
        case 3: p = (uint8 *) &e->trunc; break;
        case 4: p = (uint8 *) &e->learn; break;
        case 5: p = (uint8 *) &e->ppspolice; break;
        case 6: p = (uint8 *) &e->policer; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for xt */
int soc_sbx_g2p3_xt_index_check(int unit,
                int *vindex,
                int ixi)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_XT_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ixi; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for xt */
int soc_sbx_g2p3_xt_entry_check(int unit,
                soc_sbx_g2p3_xt_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_XT_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->forward; break;
        case 1: ev = e->dp; break;
        case 2: ev = e->qid; break;
        case 3: ev = e->trunc; break;
        case 4: ev = e->learn; break;
        case 5: ev = e->ppspolice; break;
        case 6: ev = e->policer; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* xt table size get */
int soc_sbx_g2p3_xt_entry_table_size_get(int unit,
                int *tsize,
                int ixi)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_XT_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ixi; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for xt */
int soc_sbx_g2p3_xt_set(int unit,
                int ixi,
                soc_sbx_g2p3_xt_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_XT_ID];

    s = soc_sbx_g2p3_xt_index_check(unit, key,
                ixi);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_xt_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_xt_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for xt */
int soc_sbx_g2p3_xt_get(int unit,
                int ixi,
                soc_sbx_g2p3_xt_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_XT_ID];

    s = soc_sbx_g2p3_xt_index_check(unit, key,
                ixi);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_xt_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for mirror
 */

void soc_sbx_g2p3_mirror_t_init(
    soc_sbx_g2p3_mirror_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_mirror_t));
}

/* entry pack accessor implementation for mirror */
int soc_sbx_g2p3_mirror_pack(int unit,
    soc_sbx_g2p3_mirror_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MIRROR_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->yellow; break;
        case 1: p = (uint8 *) &e->qid; break;
        case 2: p = (uint8 *) &e->oi; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for mirror */
int soc_sbx_g2p3_mirror_unpack(int unit,
                soc_sbx_g2p3_mirror_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MIRROR_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->yellow; break;
        case 1: p = (uint8 *) &e->qid; break;
        case 2: p = (uint8 *) &e->oi; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for mirror */
int soc_sbx_g2p3_mirror_index_check(int unit,
                int *vindex,
                int imi)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MIRROR_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &imi; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for mirror */
int soc_sbx_g2p3_mirror_entry_check(int unit,
                soc_sbx_g2p3_mirror_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MIRROR_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->yellow; break;
        case 1: ev = e->qid; break;
        case 2: ev = e->oi; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* mirror table size get */
int soc_sbx_g2p3_mirror_entry_table_size_get(int unit,
                int *tsize,
                int imi)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MIRROR_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = imi; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for mirror */
int soc_sbx_g2p3_mirror_set(int unit,
                int imi,
                soc_sbx_g2p3_mirror_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MIRROR_ID];

    s = soc_sbx_g2p3_mirror_index_check(unit, key,
                imi);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_mirror_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_mirror_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for mirror */
int soc_sbx_g2p3_mirror_get(int unit,
                int imi,
                soc_sbx_g2p3_mirror_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MIRROR_ID];

    s = soc_sbx_g2p3_mirror_index_check(unit, key,
                imi);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_mirror_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for emirror
 */

void soc_sbx_g2p3_emirror_t_init(
    soc_sbx_g2p3_emirror_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_emirror_t));
}

/* entry size function for emirror */
int soc_sbx_g2p3_emirror_size(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EMIRROR_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];

    return (eb->width + (eb->stridebits - 1)) / eb->stridebits;
}

/* entry pack accessor implementation for emirror */
int soc_sbx_g2p3_emirror_pack(int unit,
    soc_sbx_g2p3_emirror_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EMIRROR_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->local; break;
        case 1: p = (uint8 *) &e->port; break;
        case 2: p = (uint8 *) &e->qid; break;
        case 3: p = (uint8 *) &e->oi; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for emirror */
int soc_sbx_g2p3_emirror_unpack(int unit,
                soc_sbx_g2p3_emirror_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EMIRROR_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->local; break;
        case 1: p = (uint8 *) &e->port; break;
        case 2: p = (uint8 *) &e->qid; break;
        case 3: p = (uint8 *) &e->oi; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for emirror */
int soc_sbx_g2p3_emirror_index_check(int unit,
                int *vindex,
                int imirror)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EMIRROR_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &imirror; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for emirror */
int soc_sbx_g2p3_emirror_entry_check(int unit,
                soc_sbx_g2p3_emirror_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EMIRROR_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->local; break;
        case 1: ev = e->port; break;
        case 2: ev = e->qid; break;
        case 3: ev = e->oi; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for emirror */
int soc_sbx_g2p3_emirror_set(int unit,
                int imirror,
                soc_sbx_g2p3_emirror_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_emirror_index_check(unit, key,
                imirror);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_emirror_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_emirror_set_ext(unit,
                imirror,
                e);

    return s;
}

/* entry get accessor implementation for emirror */
int soc_sbx_g2p3_emirror_get(int unit,
                int imirror,
                soc_sbx_g2p3_emirror_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_emirror_index_check(unit, key,
                imirror);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_emirror_get_ext(unit,
                imirror,
                e);

    return s;
}

/*
 * Entry accessor implementations for emirror20
 */

void soc_sbx_g2p3_emirror20_t_init(
    soc_sbx_g2p3_emirror20_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_emirror20_t));
}

/* entry pack accessor implementation for emirror20 */
int soc_sbx_g2p3_emirror20_pack(int unit,
    soc_sbx_g2p3_emirror20_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EMIRROR20_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->queue; break;
        case 1: p = (uint8 *) &e->hdrpresent; break;
        case 2: p = (uint8 *) &e->dropsrcpkt; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for emirror20 */
int soc_sbx_g2p3_emirror20_unpack(int unit,
                soc_sbx_g2p3_emirror20_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EMIRROR20_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->queue; break;
        case 1: p = (uint8 *) &e->hdrpresent; break;
        case 2: p = (uint8 *) &e->dropsrcpkt; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for emirror20 */
int soc_sbx_g2p3_emirror20_index_check(int unit,
                int *vindex,
                int imirror)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EMIRROR20_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &imirror; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for emirror20 */
int soc_sbx_g2p3_emirror20_entry_check(int unit,
                soc_sbx_g2p3_emirror20_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EMIRROR20_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->queue; break;
        case 1: ev = e->hdrpresent; break;
        case 2: ev = e->dropsrcpkt; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* emirror20 table size get */
int soc_sbx_g2p3_emirror20_entry_table_size_get(int unit,
                int *tsize,
                int imirror)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EMIRROR20_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = imirror; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for emirror20 */
int soc_sbx_g2p3_emirror20_set(int unit,
                int imirror,
                soc_sbx_g2p3_emirror20_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EMIRROR20_ID];

    s = soc_sbx_g2p3_emirror20_index_check(unit, key,
                imirror);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_emirror20_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_emirror20_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for emirror20 */
int soc_sbx_g2p3_emirror20_get(int unit,
                int imirror,
                soc_sbx_g2p3_emirror20_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EMIRROR20_ID];

    s = soc_sbx_g2p3_emirror20_index_check(unit, key,
                imirror);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_emirror20_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for emirror25
 */

void soc_sbx_g2p3_emirror25_t_init(
    soc_sbx_g2p3_emirror25_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_emirror25_t));
}

/* entry pack accessor implementation for emirror25 */
int soc_sbx_g2p3_emirror25_pack(int unit,
    soc_sbx_g2p3_emirror25_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EMIRROR25_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->queue; break;
        case 1: p = (uint8 *) &e->hdrpresent; break;
        case 2: p = (uint8 *) &e->dropsrcpkt; break;
        case 3: p = (uint8 *) &e->higighdr; break;
        case 4: p = (uint8 *) &e->overwritehdr; break;
        case 5: p = (uint8 *) &e->hdrdata0; break;
        case 6: p = (uint8 *) &e->hdrdata1; break;
        case 7: p = (uint8 *) &e->hdrdata2; break;
        case 8: p = (uint8 *) &e->hdrdata3; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for emirror25 */
int soc_sbx_g2p3_emirror25_unpack(int unit,
                soc_sbx_g2p3_emirror25_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EMIRROR25_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->queue; break;
        case 1: p = (uint8 *) &e->hdrpresent; break;
        case 2: p = (uint8 *) &e->dropsrcpkt; break;
        case 3: p = (uint8 *) &e->higighdr; break;
        case 4: p = (uint8 *) &e->overwritehdr; break;
        case 5: p = (uint8 *) &e->hdrdata0; break;
        case 6: p = (uint8 *) &e->hdrdata1; break;
        case 7: p = (uint8 *) &e->hdrdata2; break;
        case 8: p = (uint8 *) &e->hdrdata3; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for emirror25 */
int soc_sbx_g2p3_emirror25_index_check(int unit,
                int *vindex,
                int imirror)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EMIRROR25_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &imirror; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for emirror25 */
int soc_sbx_g2p3_emirror25_entry_check(int unit,
                soc_sbx_g2p3_emirror25_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EMIRROR25_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->queue; break;
        case 1: ev = e->hdrpresent; break;
        case 2: ev = e->dropsrcpkt; break;
        case 3: ev = e->higighdr; break;
        case 4: ev = e->overwritehdr; break;
        case 5: ev = e->hdrdata0; break;
        case 6: ev = e->hdrdata1; break;
        case 7: ev = e->hdrdata2; break;
        case 8: ev = e->hdrdata3; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* emirror25 table size get */
int soc_sbx_g2p3_emirror25_entry_table_size_get(int unit,
                int *tsize,
                int imirror)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EMIRROR25_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = imirror; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for emirror25 */
int soc_sbx_g2p3_emirror25_set(int unit,
                int imirror,
                soc_sbx_g2p3_emirror25_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EMIRROR25_ID];

    s = soc_sbx_g2p3_emirror25_index_check(unit, key,
                imirror);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_emirror25_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_emirror25_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for emirror25 */
int soc_sbx_g2p3_emirror25_get(int unit,
                int imirror,
                soc_sbx_g2p3_emirror25_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EMIRROR25_ID];

    s = soc_sbx_g2p3_emirror25_index_check(unit, key,
                imirror);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_emirror25_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for emll1
 */

void soc_sbx_g2p3_emll1_t_init(
    soc_sbx_g2p3_emll1_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_emll1_t));
}

/* entry size function for emll1 */
int soc_sbx_g2p3_emll1_size(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EMLL1_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];

    return (eb->width + (eb->stridebits - 1)) / eb->stridebits;
}

/* entry pack accessor implementation for emll1 */
int soc_sbx_g2p3_emll1_pack(int unit,
    soc_sbx_g2p3_emll1_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EMLL1_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->usemap; break;
        case 1: p = (uint8 *) &e->pointer; break;
        case 2: p = (uint8 *) &e->salt; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for emll1 */
int soc_sbx_g2p3_emll1_unpack(int unit,
                soc_sbx_g2p3_emll1_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EMLL1_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->usemap; break;
        case 1: p = (uint8 *) &e->pointer; break;
        case 2: p = (uint8 *) &e->salt; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/*
 * Entry accessor implementations for mac
 */

void soc_sbx_g2p3_mac_t_init(
    soc_sbx_g2p3_mac_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_mac_t));
}

/* entry pack accessor implementation for mac */
int soc_sbx_g2p3_mac_pack(int unit,
    soc_sbx_g2p3_mac_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MAC_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->age; break;
        case 1: p = (uint8 *) &e->pid; break;
        case 2: p = (uint8 *) &e->dcopy; break;
        case 3: p = (uint8 *) &e->dcopycos; break;
        case 4: p = (uint8 *) &e->ddrop; break;
        case 5: p = (uint8 *) &e->sdrop; break;
        case 6: p = (uint8 *) &e->dontage; break;
        case 7: p = (uint8 *) &e->bsdrop; break;
        case 8: p = (uint8 *) &e->bpid; break;
        case 9: p = (uint8 *) &e->btid; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for mac */
int soc_sbx_g2p3_mac_unpack(int unit,
                soc_sbx_g2p3_mac_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MAC_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->age; break;
        case 1: p = (uint8 *) &e->pid; break;
        case 2: p = (uint8 *) &e->dcopy; break;
        case 3: p = (uint8 *) &e->dcopycos; break;
        case 4: p = (uint8 *) &e->ddrop; break;
        case 5: p = (uint8 *) &e->sdrop; break;
        case 6: p = (uint8 *) &e->dontage; break;
        case 7: p = (uint8 *) &e->bsdrop; break;
        case 8: p = (uint8 *) &e->bpid; break;
        case 9: p = (uint8 *) &e->btid; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for mac */
int soc_sbx_g2p3_mac_index_check(int unit,
                int *vindex,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan,
                int ibmac)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MAC_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = 0;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) imac; break;
        case 1: p = (uint8 *) &ivlan; break;
        case 2: p = (uint8 *) &ibmac; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry index unpack for mac */
int soc_sbx_g2p3_mac_index_unpack(int unit,
                int *vindex,
                soc_sbx_g2p3_6_byte_t imac,
                int *ivlan,
                int *ibmac)
{
    int i, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MAC_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int be = tm->behost;
    int pkbe = 0;

    p0 = ((uint8 *) vindex);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
	fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) imac; break;
        case 1: p = (uint8 *) ivlan; break;
        case 2: p = (uint8 *) ibmac; break;
        default: return SOC_E_INTERNAL;
        }
        sal_memset(p, 0, width <= 32 ? (int) sizeof(int) : (width + 7) / 8);
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe =
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT 
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_extract(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for mac */
int soc_sbx_g2p3_mac_entry_check(int unit,
                soc_sbx_g2p3_mac_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MAC_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->age; break;
        case 1: ev = e->pid; break;
        case 2: ev = e->dcopy; break;
        case 3: ev = e->dcopycos; break;
        case 4: ev = e->ddrop; break;
        case 5: ev = e->sdrop; break;
        case 6: ev = e->dontage; break;
        case 7: ev = e->bsdrop; break;
        case 8: ev = e->bpid; break;
        case 9: ev = e->btid; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for mac */
int soc_sbx_g2p3_mac_set(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan,
                int ibmac,
                soc_sbx_g2p3_mac_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_mac_index_check(unit, key,
                imac,
                ivlan,
                ibmac);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_mac_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_mac_update(unit,
                imac,
                ivlan,
                ibmac,
                e);
    if (s == SOC_E_NOT_FOUND) {
        s = soc_sbx_g2p3_mac_add(unit,
                imac,
                ivlan,
                ibmac,
                e);
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_mac_commit(unit, 0xffffffff);
    }

    return s;
}

/* entry add accessor implementation for mac */
int soc_sbx_g2p3_mac_add(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan,
                int ibmac,
                soc_sbx_g2p3_mac_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MAC_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_mac_index_check(unit, key,
                imac,
                ivlan,
                ibmac);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_mac_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_mac_pack(unit,
                  e, epacked, ed->epsize);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_eml_add_ext(unit, cs,
                (uint8 *) key,
                epacked);

    return s;
}

/* entry get accessor implementation for mac */
int soc_sbx_g2p3_mac_get(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan,
                int ibmac,
                soc_sbx_g2p3_mac_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MAC_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_mac_index_check(unit, key,
                imac,
                ivlan,
                ibmac);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_eml_get_ext(unit, cs,
                (uint8 *) key,
                epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_mac_unpack(unit,
                    e, epacked, ed->epsize);

    return s;
}

/* entry update accessor implementation for mac */
int soc_sbx_g2p3_mac_update(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan,
                int ibmac,
                soc_sbx_g2p3_mac_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MAC_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_mac_index_check(unit, key,
                imac,
                ivlan,
                ibmac);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_mac_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_mac_pack(unit,
                  e, epacked, ed->epsize);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_eml_update_ext(unit, cs,
                (uint8 *) key,
                epacked);

    return s;
}

/* entry delete accessor implementation for mac */
int soc_sbx_g2p3_mac_delete(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan,
                int ibmac)
{
    int s, key[32];

    s = soc_sbx_g2p3_mac_index_check(unit, key,
                imac,
                ivlan,
                ibmac);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_mac_remove(unit,
                imac,
                ivlan,
                ibmac);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_mac_commit(unit, 0xffffffff);

    return s;
}

/* entry remove accessor implementation for mac */
int soc_sbx_g2p3_mac_remove(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan,
                int ibmac)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MAC_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_mac_index_check(unit, key,
                imac,
                ivlan,
                ibmac);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_eml_remove_ext(unit, cs,
                (uint8 *) key);

    return s;
}

/* Get the first element of mac */
int soc_sbx_g2p3_mac_first(int unit,
                soc_sbx_g2p3_6_byte_t nimac,
                int *nivlan,
                int *nibmac)
{
    int s;
    int nkey[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MAC_ID];
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    void *cs = td->cstate;

    s = soc_sbx_g2p3_eml_first_ext(unit, cs,
                (uint8 *) nkey);
    if (!s) {
        soc_sbx_g2p3_mac_index_unpack(unit, nkey,
                nimac,
                nivlan,
                nibmac);
    }
    return s;
}

/* Get the next element of mac */
int soc_sbx_g2p3_mac_next(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan,
                int ibmac,
                soc_sbx_g2p3_6_byte_t nimac,
                int *nivlan,
                int *nibmac)
{
    int key[32], s;
    int nkey[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MAC_ID];
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    void *cs = td->cstate;

    s = soc_sbx_g2p3_mac_index_check(unit, key,
                imac,
                ivlan,
                ibmac);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_eml_next_ext(unit, cs,
                (uint8 *) key,
                (uint8 *) nkey);
    if (!s) {
        soc_sbx_g2p3_mac_index_unpack(unit, nkey,
                nimac,
                nivlan,
                nibmac);
    }
    return s;
}

/* Batch commit implementation for mac */
int soc_sbx_g2p3_mac_commit(int unit, int runlength)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MAC_ID];
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    void *cs = td->cstate;

    return soc_sbx_g2p3_eml_commit_ext(unit, cs, runlength);
}

/*
 * Entry accessor implementations for macl1
 */

void soc_sbx_g2p3_macl1_t_init(
    soc_sbx_g2p3_macl1_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_macl1_t));
}

/* entry pack accessor implementation for macl1 */
int soc_sbx_g2p3_macl1_pack(int unit,
    soc_sbx_g2p3_macl1_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MACL1_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->usemap; break;
        case 1: p = (uint8 *) &e->pointer; break;
        case 2: p = (uint8 *) &e->salt; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for macl1 */
int soc_sbx_g2p3_macl1_unpack(int unit,
                soc_sbx_g2p3_macl1_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MACL1_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->usemap; break;
        case 1: p = (uint8 *) &e->pointer; break;
        case 2: p = (uint8 *) &e->salt; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for macl1 */
int soc_sbx_g2p3_macl1_index_check(int unit,
                int *vindex,
                int il1i)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MACL1_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &il1i; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for macl1 */
int soc_sbx_g2p3_macl1_entry_check(int unit,
                soc_sbx_g2p3_macl1_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MACL1_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->usemap; break;
        case 1: ev = e->pointer; break;
        case 2: ev = e->salt; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* macl1 table size get */
int soc_sbx_g2p3_macl1_entry_table_size_get(int unit,
                int *tsize,
                int il1i)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MACL1_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = il1i; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for macl1 */
int soc_sbx_g2p3_macl1_set(int unit,
                int il1i,
                soc_sbx_g2p3_macl1_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MACL1_ID];

    s = soc_sbx_g2p3_macl1_index_check(unit, key,
                il1i);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_macl1_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_macl1_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for macl1 */
int soc_sbx_g2p3_macl1_get(int unit,
                int il1i,
                soc_sbx_g2p3_macl1_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MACL1_ID];

    s = soc_sbx_g2p3_macl1_index_check(unit, key,
                il1i);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_macl1_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for macl2
 */

void soc_sbx_g2p3_macl2_t_init(
    soc_sbx_g2p3_macl2_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_macl2_t));
}

/* entry pack accessor implementation for macl2 */
int soc_sbx_g2p3_macl2_pack(int unit,
    soc_sbx_g2p3_macl2_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MACL2_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) e->mac; break;
        case 1: p = (uint8 *) &e->vlan; break;
        case 2: p = (uint8 *) &e->bmac; break;
        case 3: p = (uint8 *) &e->age; break;
        case 4: p = (uint8 *) &e->pid; break;
        case 5: p = (uint8 *) &e->dcopy; break;
        case 6: p = (uint8 *) &e->dcopycos; break;
        case 7: p = (uint8 *) &e->ddrop; break;
        case 8: p = (uint8 *) &e->sdrop; break;
        case 9: p = (uint8 *) &e->dontage; break;
        case 10: p = (uint8 *) &e->notage; break;
        case 11: p = (uint8 *) &e->bsdrop; break;
        case 12: p = (uint8 *) &e->bpid; break;
        case 13: p = (uint8 *) &e->btid; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for macl2 */
int soc_sbx_g2p3_macl2_unpack(int unit,
                soc_sbx_g2p3_macl2_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MACL2_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) e->mac; break;
        case 1: p = (uint8 *) &e->vlan; break;
        case 2: p = (uint8 *) &e->bmac; break;
        case 3: p = (uint8 *) &e->age; break;
        case 4: p = (uint8 *) &e->pid; break;
        case 5: p = (uint8 *) &e->dcopy; break;
        case 6: p = (uint8 *) &e->dcopycos; break;
        case 7: p = (uint8 *) &e->ddrop; break;
        case 8: p = (uint8 *) &e->sdrop; break;
        case 9: p = (uint8 *) &e->dontage; break;
        case 10: p = (uint8 *) &e->notage; break;
        case 11: p = (uint8 *) &e->bsdrop; break;
        case 12: p = (uint8 *) &e->bpid; break;
        case 13: p = (uint8 *) &e->btid; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for macl2 */
int soc_sbx_g2p3_macl2_index_check(int unit,
                int *vindex,
                int imaci)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MACL2_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &imaci; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for macl2 */
int soc_sbx_g2p3_macl2_entry_check(int unit,
                soc_sbx_g2p3_macl2_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MACL2_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->mac[0]; break;
        case 1: ev = e->vlan; break;
        case 2: ev = e->bmac; break;
        case 3: ev = e->age; break;
        case 4: ev = e->pid; break;
        case 5: ev = e->dcopy; break;
        case 6: ev = e->dcopycos; break;
        case 7: ev = e->ddrop; break;
        case 8: ev = e->sdrop; break;
        case 9: ev = e->dontage; break;
        case 10: ev = e->notage; break;
        case 11: ev = e->bsdrop; break;
        case 12: ev = e->bpid; break;
        case 13: ev = e->btid; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* macl2 table size get */
int soc_sbx_g2p3_macl2_entry_table_size_get(int unit,
                int *tsize,
                int imaci)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MACL2_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = imaci; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for macl2 */
int soc_sbx_g2p3_macl2_set(int unit,
                int imaci,
                soc_sbx_g2p3_macl2_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MACL2_ID];

    s = soc_sbx_g2p3_macl2_index_check(unit, key,
                imaci);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_macl2_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_macl2_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for macl2 */
int soc_sbx_g2p3_macl2_get(int unit,
                int imaci,
                soc_sbx_g2p3_macl2_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MACL2_ID];

    s = soc_sbx_g2p3_macl2_index_check(unit, key,
                imaci);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_macl2_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for ipv6dhost
 */

void soc_sbx_g2p3_ipv6dhost_t_init(
    soc_sbx_g2p3_ipv6dhost_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ipv6dhost_t));
}

/* entry pack accessor implementation for ipv6dhost */
int soc_sbx_g2p3_ipv6dhost_pack(int unit,
    soc_sbx_g2p3_ipv6dhost_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DHOST_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->ftidx; break;
        case 1: p = (uint8 *) &e->ecmpmask; break;
        case 2: p = (uint8 *) &e->vid; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ipv6dhost */
int soc_sbx_g2p3_ipv6dhost_unpack(int unit,
                soc_sbx_g2p3_ipv6dhost_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DHOST_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->ftidx; break;
        case 1: p = (uint8 *) &e->ecmpmask; break;
        case 2: p = (uint8 *) &e->vid; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ipv6dhost */
int soc_sbx_g2p3_ipv6dhost_index_check(int unit,
                int *vindex,
                soc_sbx_g2p3_16_byte_t iip)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DHOST_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = 0;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) iip; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry index unpack for ipv6dhost */
int soc_sbx_g2p3_ipv6dhost_index_unpack(int unit,
                int *vindex,
                soc_sbx_g2p3_16_byte_t iip)
{
    int i, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DHOST_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int be = tm->behost;
    int pkbe = 0;

    p0 = ((uint8 *) vindex);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
	fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) iip; break;
        default: return SOC_E_INTERNAL;
        }
        sal_memset(p, 0, width <= 32 ? (int) sizeof(int) : (width + 7) / 8);
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe =
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT 
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_extract(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ipv6dhost */
int soc_sbx_g2p3_ipv6dhost_entry_check(int unit,
                soc_sbx_g2p3_ipv6dhost_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DHOST_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->ftidx; break;
        case 1: ev = e->ecmpmask; break;
        case 2: ev = e->vid; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for ipv6dhost */
int soc_sbx_g2p3_ipv6dhost_set(int unit,
                soc_sbx_g2p3_16_byte_t iip,
                soc_sbx_g2p3_ipv6dhost_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_ipv6dhost_index_check(unit, key,
                iip);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv6dhost_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv6dhost_update(unit,
                iip,
                e);
    if (s == SOC_E_NOT_FOUND) {
        s = soc_sbx_g2p3_ipv6dhost_add(unit,
                iip,
                e);
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ipv6dhost_commit(unit, 0xffffffff);
    }

    return s;
}

/* entry add accessor implementation for ipv6dhost */
int soc_sbx_g2p3_ipv6dhost_add(int unit,
                soc_sbx_g2p3_16_byte_t iip,
                soc_sbx_g2p3_ipv6dhost_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DHOST_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_ipv6dhost_index_check(unit, key,
                iip);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv6dhost_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv6dhost_pack(unit,
                  e, epacked, ed->epsize);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_eml_add_ext(unit, cs,
                (uint8 *) key,
                epacked);

    return s;
}

/* entry get accessor implementation for ipv6dhost */
int soc_sbx_g2p3_ipv6dhost_get(int unit,
                soc_sbx_g2p3_16_byte_t iip,
                soc_sbx_g2p3_ipv6dhost_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DHOST_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_ipv6dhost_index_check(unit, key,
                iip);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_eml_get_ext(unit, cs,
                (uint8 *) key,
                epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv6dhost_unpack(unit,
                    e, epacked, ed->epsize);

    return s;
}

/* entry update accessor implementation for ipv6dhost */
int soc_sbx_g2p3_ipv6dhost_update(int unit,
                soc_sbx_g2p3_16_byte_t iip,
                soc_sbx_g2p3_ipv6dhost_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DHOST_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_ipv6dhost_index_check(unit, key,
                iip);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv6dhost_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv6dhost_pack(unit,
                  e, epacked, ed->epsize);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_eml_update_ext(unit, cs,
                (uint8 *) key,
                epacked);

    return s;
}

/* entry delete accessor implementation for ipv6dhost */
int soc_sbx_g2p3_ipv6dhost_delete(int unit,
                soc_sbx_g2p3_16_byte_t iip)
{
    int s, key[32];

    s = soc_sbx_g2p3_ipv6dhost_index_check(unit, key,
                iip);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv6dhost_remove(unit,
                iip);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv6dhost_commit(unit, 0xffffffff);

    return s;
}

/* entry remove accessor implementation for ipv6dhost */
int soc_sbx_g2p3_ipv6dhost_remove(int unit,
                soc_sbx_g2p3_16_byte_t iip)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DHOST_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_ipv6dhost_index_check(unit, key,
                iip);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_eml_remove_ext(unit, cs,
                (uint8 *) key);

    return s;
}

/* Get the first element of ipv6dhost */
int soc_sbx_g2p3_ipv6dhost_first(int unit,
                soc_sbx_g2p3_16_byte_t niip)
{
    int s;
    int nkey[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DHOST_ID];
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    void *cs = td->cstate;

    s = soc_sbx_g2p3_eml_first_ext(unit, cs,
                (uint8 *) nkey);
    if (!s) {
        soc_sbx_g2p3_ipv6dhost_index_unpack(unit, nkey,
                niip);
    }
    return s;
}

/* Get the next element of ipv6dhost */
int soc_sbx_g2p3_ipv6dhost_next(int unit,
                soc_sbx_g2p3_16_byte_t iip,
                soc_sbx_g2p3_16_byte_t niip)
{
    int key[32], s;
    int nkey[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DHOST_ID];
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    void *cs = td->cstate;

    s = soc_sbx_g2p3_ipv6dhost_index_check(unit, key,
                iip);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_eml_next_ext(unit, cs,
                (uint8 *) key,
                (uint8 *) nkey);
    if (!s) {
        soc_sbx_g2p3_ipv6dhost_index_unpack(unit, nkey,
                niip);
    }
    return s;
}

/* Batch commit implementation for ipv6dhost */
int soc_sbx_g2p3_ipv6dhost_commit(int unit, int runlength)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DHOST_ID];
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    void *cs = td->cstate;

    return soc_sbx_g2p3_eml_commit_ext(unit, cs, runlength);
}

/*
 * Entry accessor implementations for ipv6dhostl1
 */

void soc_sbx_g2p3_ipv6dhostl1_t_init(
    soc_sbx_g2p3_ipv6dhostl1_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ipv6dhostl1_t));
}

/* entry pack accessor implementation for ipv6dhostl1 */
int soc_sbx_g2p3_ipv6dhostl1_pack(int unit,
    soc_sbx_g2p3_ipv6dhostl1_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DHOSTL1_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->usemap; break;
        case 1: p = (uint8 *) &e->pointer; break;
        case 2: p = (uint8 *) &e->salt; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ipv6dhostl1 */
int soc_sbx_g2p3_ipv6dhostl1_unpack(int unit,
                soc_sbx_g2p3_ipv6dhostl1_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DHOSTL1_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->usemap; break;
        case 1: p = (uint8 *) &e->pointer; break;
        case 2: p = (uint8 *) &e->salt; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ipv6dhostl1 */
int soc_sbx_g2p3_ipv6dhostl1_index_check(int unit,
                int *vindex,
                int il1i)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DHOSTL1_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &il1i; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ipv6dhostl1 */
int soc_sbx_g2p3_ipv6dhostl1_entry_check(int unit,
                soc_sbx_g2p3_ipv6dhostl1_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DHOSTL1_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->usemap; break;
        case 1: ev = e->pointer; break;
        case 2: ev = e->salt; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* ipv6dhostl1 table size get */
int soc_sbx_g2p3_ipv6dhostl1_entry_table_size_get(int unit,
                int *tsize,
                int il1i)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DHOSTL1_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = il1i; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for ipv6dhostl1 */
int soc_sbx_g2p3_ipv6dhostl1_set(int unit,
                int il1i,
                soc_sbx_g2p3_ipv6dhostl1_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DHOSTL1_ID];

    s = soc_sbx_g2p3_ipv6dhostl1_index_check(unit, key,
                il1i);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv6dhostl1_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_ipv6dhostl1_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for ipv6dhostl1 */
int soc_sbx_g2p3_ipv6dhostl1_get(int unit,
                int il1i,
                soc_sbx_g2p3_ipv6dhostl1_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DHOSTL1_ID];

    s = soc_sbx_g2p3_ipv6dhostl1_index_check(unit, key,
                il1i);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_ipv6dhostl1_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for ipv6dhostl2
 */

void soc_sbx_g2p3_ipv6dhostl2_t_init(
    soc_sbx_g2p3_ipv6dhostl2_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ipv6dhostl2_t));
}

/* entry pack accessor implementation for ipv6dhostl2 */
int soc_sbx_g2p3_ipv6dhostl2_pack(int unit,
    soc_sbx_g2p3_ipv6dhostl2_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DHOSTL2_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) e->key; break;
        case 1: p = (uint8 *) &e->ftidx; break;
        case 2: p = (uint8 *) &e->ecmpmask; break;
        case 3: p = (uint8 *) &e->vid; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ipv6dhostl2 */
int soc_sbx_g2p3_ipv6dhostl2_unpack(int unit,
                soc_sbx_g2p3_ipv6dhostl2_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DHOSTL2_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) e->key; break;
        case 1: p = (uint8 *) &e->ftidx; break;
        case 2: p = (uint8 *) &e->ecmpmask; break;
        case 3: p = (uint8 *) &e->vid; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ipv6dhostl2 */
int soc_sbx_g2p3_ipv6dhostl2_index_check(int unit,
                int *vindex,
                int ihosti)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DHOSTL2_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ihosti; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ipv6dhostl2 */
int soc_sbx_g2p3_ipv6dhostl2_entry_check(int unit,
                soc_sbx_g2p3_ipv6dhostl2_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DHOSTL2_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->key[0]; break;
        case 1: ev = e->ftidx; break;
        case 2: ev = e->ecmpmask; break;
        case 3: ev = e->vid; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* ipv6dhostl2 table size get */
int soc_sbx_g2p3_ipv6dhostl2_entry_table_size_get(int unit,
                int *tsize,
                int ihosti)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DHOSTL2_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ihosti; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for ipv6dhostl2 */
int soc_sbx_g2p3_ipv6dhostl2_set(int unit,
                int ihosti,
                soc_sbx_g2p3_ipv6dhostl2_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DHOSTL2_ID];

    s = soc_sbx_g2p3_ipv6dhostl2_index_check(unit, key,
                ihosti);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv6dhostl2_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_ipv6dhostl2_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for ipv6dhostl2 */
int soc_sbx_g2p3_ipv6dhostl2_get(int unit,
                int ihosti,
                soc_sbx_g2p3_ipv6dhostl2_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DHOSTL2_ID];

    s = soc_sbx_g2p3_ipv6dhostl2_index_check(unit, key,
                ihosti);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_ipv6dhostl2_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for mst
 */

void soc_sbx_g2p3_mst_t_init(
    soc_sbx_g2p3_mst_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_mst_t));
}

/* entry pack accessor implementation for mst */
int soc_sbx_g2p3_mst_pack(int unit,
    soc_sbx_g2p3_mst_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MST_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->learn; break;
        case 1: p = (uint8 *) &e->pim; break;
        case 2: p = (uint8 *) &e->igmp; break;
        case 3: p = (uint8 *) &e->rtcopy; break;
        case 4: p = (uint8 *) &e->l2cpcopy; break;
        case 5: p = (uint8 *) &e->dcopy; break;
        case 6: p = (uint8 *) &e->ipredirect; break;
        case 7: p = (uint8 *) &e->learn_bmac; break;
        case 8: p = (uint8 *) &e->mirroridx; break;
        case 9: p = (uint8 *) &e->vsi; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for mst */
int soc_sbx_g2p3_mst_unpack(int unit,
                soc_sbx_g2p3_mst_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MST_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->learn; break;
        case 1: p = (uint8 *) &e->pim; break;
        case 2: p = (uint8 *) &e->igmp; break;
        case 3: p = (uint8 *) &e->rtcopy; break;
        case 4: p = (uint8 *) &e->l2cpcopy; break;
        case 5: p = (uint8 *) &e->dcopy; break;
        case 6: p = (uint8 *) &e->ipredirect; break;
        case 7: p = (uint8 *) &e->learn_bmac; break;
        case 8: p = (uint8 *) &e->mirroridx; break;
        case 9: p = (uint8 *) &e->vsi; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for mst */
int soc_sbx_g2p3_mst_index_check(int unit,
                int *vindex,
                int imsti)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MST_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &imsti; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for mst */
int soc_sbx_g2p3_mst_entry_check(int unit,
                soc_sbx_g2p3_mst_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MST_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->learn; break;
        case 1: ev = e->pim; break;
        case 2: ev = e->igmp; break;
        case 3: ev = e->rtcopy; break;
        case 4: ev = e->l2cpcopy; break;
        case 5: ev = e->dcopy; break;
        case 6: ev = e->ipredirect; break;
        case 7: ev = e->learn_bmac; break;
        case 8: ev = e->mirroridx; break;
        case 9: ev = e->vsi; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* mst table size get */
int soc_sbx_g2p3_mst_entry_table_size_get(int unit,
                int *tsize,
                int imsti)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MST_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = imsti; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for mst */
int soc_sbx_g2p3_mst_set(int unit,
                int imsti,
                soc_sbx_g2p3_mst_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MST_ID];

    s = soc_sbx_g2p3_mst_index_check(unit, key,
                imsti);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_mst_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_mst_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for mst */
int soc_sbx_g2p3_mst_get(int unit,
                int imsti,
                soc_sbx_g2p3_mst_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MST_ID];

    s = soc_sbx_g2p3_mst_index_check(unit, key,
                imsti);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_mst_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for pv2e
 */

void soc_sbx_g2p3_pv2e_t_init(
    soc_sbx_g2p3_pv2e_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_pv2e_t));
    e->untagged_strip = 0x1;
}

/* entry pack accessor implementation for pv2e */
int soc_sbx_g2p3_pv2e_pack(int unit,
    soc_sbx_g2p3_pv2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PV2E_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->lpi; break;
        case 1: p = (uint8 *) &e->vlan; break;
        case 2: p = (uint8 *) &e->stpstate; break;
        case 3: p = (uint8 *) &e->untagged_strip; break;
        case 4: p = (uint8 *) &e->vpws; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for pv2e */
int soc_sbx_g2p3_pv2e_unpack(int unit,
                soc_sbx_g2p3_pv2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PV2E_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->lpi; break;
        case 1: p = (uint8 *) &e->vlan; break;
        case 2: p = (uint8 *) &e->stpstate; break;
        case 3: p = (uint8 *) &e->untagged_strip; break;
        case 4: p = (uint8 *) &e->vpws; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for pv2e */
int soc_sbx_g2p3_pv2e_index_check(int unit,
                int *vindex,
                int ivid,
                int iport)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PV2E_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ivid; break;
        case 1: p = (uint8 *) &iport; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for pv2e */
int soc_sbx_g2p3_pv2e_entry_check(int unit,
                soc_sbx_g2p3_pv2e_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PV2E_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->lpi; break;
        case 1: ev = e->vlan; break;
        case 2: ev = e->stpstate; break;
        case 3: ev = e->untagged_strip; break;
        case 4: ev = e->vpws; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* pv2e table size get */
int soc_sbx_g2p3_pv2e_entry_table_size_get(int unit,
                int *tsize,
                int ivid,
                int iport)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PV2E_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ivid; break;
        case 1: v = iport; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for pv2e */
int soc_sbx_g2p3_pv2e_set(int unit,
                int ivid,
                int iport,
                soc_sbx_g2p3_pv2e_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PV2E_ID];

    s = soc_sbx_g2p3_pv2e_index_check(unit, key,
                ivid,
                iport);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_pv2e_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_pv2e_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}
int soc_sbx_g2p3_pv2e_lpi_fast_set(int unit,
                int ivid,
                int iport,
                int eivid,
                int eiport,
                int *sets,
                uint32 *vs,
                int vcount)
{
    int startvindex, endvindex, s;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PV2E_ID];
    soc_sbx_g2p3_field_desc_t *fd =
        &ed->fields[0];

    s = soc_sbx_g2p3_pv2e_index_check(unit, &startvindex,
                ivid,
                iport);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_pv2e_index_check(unit, &endvindex,
                eivid,
                eiport);
    if (s) {
        return s;
    }
    if (endvindex - startvindex >= vcount) {
        return SOC_E_PARAM;
    }

    s = soc_sbx_g2p3_entry_generic_fast_set(unit,
                  fd, ed, startvindex, endvindex, sets, vs);

    return s;
}

int soc_sbx_g2p3_pv2e_lpi_fast_get(int unit,
                int ivid,
                int iport,
                int eivid,
                int eiport,
                uint32 *vs,
                int vcount)
{
    int startvindex, endvindex, s;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PV2E_ID];
    soc_sbx_g2p3_field_desc_t *fd =
        &ed->fields[0];

    s = soc_sbx_g2p3_pv2e_index_check(unit, &startvindex,
                ivid,
                iport);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_pv2e_index_check(unit, &endvindex,
                eivid,
                eiport);
    if (s) {
        return s;
    }

    if (endvindex - startvindex >= vcount) {
        return SOC_E_PARAM;
    }

    s = soc_sbx_g2p3_entry_generic_fast_get(unit,
                  fd, ed, startvindex, endvindex, vs);

    return s;
}
int soc_sbx_g2p3_pv2e_vlan_fast_set(int unit,
                int ivid,
                int iport,
                int eivid,
                int eiport,
                int *sets,
                uint32 *vs,
                int vcount)
{
    int startvindex, endvindex, s;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PV2E_ID];
    soc_sbx_g2p3_field_desc_t *fd =
        &ed->fields[1];

    s = soc_sbx_g2p3_pv2e_index_check(unit, &startvindex,
                ivid,
                iport);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_pv2e_index_check(unit, &endvindex,
                eivid,
                eiport);
    if (s) {
        return s;
    }
    if (endvindex - startvindex >= vcount) {
        return SOC_E_PARAM;
    }

    s = soc_sbx_g2p3_entry_generic_fast_set(unit,
                  fd, ed, startvindex, endvindex, sets, vs);

    return s;
}

int soc_sbx_g2p3_pv2e_vlan_fast_get(int unit,
                int ivid,
                int iport,
                int eivid,
                int eiport,
                uint32 *vs,
                int vcount)
{
    int startvindex, endvindex, s;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PV2E_ID];
    soc_sbx_g2p3_field_desc_t *fd =
        &ed->fields[1];

    s = soc_sbx_g2p3_pv2e_index_check(unit, &startvindex,
                ivid,
                iport);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_pv2e_index_check(unit, &endvindex,
                eivid,
                eiport);
    if (s) {
        return s;
    }

    if (endvindex - startvindex >= vcount) {
        return SOC_E_PARAM;
    }

    s = soc_sbx_g2p3_entry_generic_fast_get(unit,
                  fd, ed, startvindex, endvindex, vs);

    return s;
}
int soc_sbx_g2p3_pv2e_stpstate_fast_set(int unit,
                int ivid,
                int iport,
                int eivid,
                int eiport,
                int *sets,
                uint32 *vs,
                int vcount)
{
    int startvindex, endvindex, s;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PV2E_ID];
    soc_sbx_g2p3_field_desc_t *fd =
        &ed->fields[2];

    s = soc_sbx_g2p3_pv2e_index_check(unit, &startvindex,
                ivid,
                iport);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_pv2e_index_check(unit, &endvindex,
                eivid,
                eiport);
    if (s) {
        return s;
    }
    if (endvindex - startvindex >= vcount) {
        return SOC_E_PARAM;
    }

    s = soc_sbx_g2p3_entry_generic_fast_set(unit,
                  fd, ed, startvindex, endvindex, sets, vs);

    return s;
}

int soc_sbx_g2p3_pv2e_stpstate_fast_get(int unit,
                int ivid,
                int iport,
                int eivid,
                int eiport,
                uint32 *vs,
                int vcount)
{
    int startvindex, endvindex, s;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PV2E_ID];
    soc_sbx_g2p3_field_desc_t *fd =
        &ed->fields[2];

    s = soc_sbx_g2p3_pv2e_index_check(unit, &startvindex,
                ivid,
                iport);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_pv2e_index_check(unit, &endvindex,
                eivid,
                eiport);
    if (s) {
        return s;
    }

    if (endvindex - startvindex >= vcount) {
        return SOC_E_PARAM;
    }

    s = soc_sbx_g2p3_entry_generic_fast_get(unit,
                  fd, ed, startvindex, endvindex, vs);

    return s;
}

int soc_sbx_g2p3_pv2e_untagged_strip_fast_get(int unit,
                int ivid,
                int iport,
                int eivid,
                int eiport,
                uint32 *vs,
                int vcount)
{
    int startvindex, endvindex, s;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PV2E_ID];
    soc_sbx_g2p3_field_desc_t *fd =
        &ed->fields[3];

    s = soc_sbx_g2p3_pv2e_index_check(unit, &startvindex,
                ivid,
                iport);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_pv2e_index_check(unit, &endvindex,
                eivid,
                eiport);
    if (s) {
        return s;
    }

    if (endvindex - startvindex >= vcount) {
        return SOC_E_PARAM;
    }

    s = soc_sbx_g2p3_entry_generic_fast_get(unit,
                  fd, ed, startvindex, endvindex, vs);

    return s;
}

/* entry get accessor implementation for pv2e */
int soc_sbx_g2p3_pv2e_get(int unit,
                int ivid,
                int iport,
                soc_sbx_g2p3_pv2e_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PV2E_ID];

    s = soc_sbx_g2p3_pv2e_index_check(unit, key,
                ivid,
                iport);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_pv2e_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for p2appdata
 */

void soc_sbx_g2p3_p2appdata_t_init(
    soc_sbx_g2p3_p2appdata_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_p2appdata_t));
}

/* entry pack accessor implementation for p2appdata */
int soc_sbx_g2p3_p2appdata_pack(int unit,
    soc_sbx_g2p3_p2appdata_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2APPDATA_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->ifilteren; break;
        case 1: p = (uint8 *) &e->efilteren; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for p2appdata */
int soc_sbx_g2p3_p2appdata_unpack(int unit,
                soc_sbx_g2p3_p2appdata_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2APPDATA_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->ifilteren; break;
        case 1: p = (uint8 *) &e->efilteren; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for p2appdata */
int soc_sbx_g2p3_p2appdata_index_check(int unit,
                int *vindex,
                int iport)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2APPDATA_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iport; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for p2appdata */
int soc_sbx_g2p3_p2appdata_entry_check(int unit,
                soc_sbx_g2p3_p2appdata_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2APPDATA_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->ifilteren; break;
        case 1: ev = e->efilteren; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* p2appdata table size get */
int soc_sbx_g2p3_p2appdata_entry_table_size_get(int unit,
                int *tsize,
                int iport)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2APPDATA_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = iport; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for p2appdata */
int soc_sbx_g2p3_p2appdata_set(int unit,
                int iport,
                soc_sbx_g2p3_p2appdata_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2APPDATA_ID];

    s = soc_sbx_g2p3_p2appdata_index_check(unit, key,
                iport);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_p2appdata_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_p2appdata_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for p2appdata */
int soc_sbx_g2p3_p2appdata_get(int unit,
                int iport,
                soc_sbx_g2p3_p2appdata_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2APPDATA_ID];

    s = soc_sbx_g2p3_p2appdata_index_check(unit, key,
                iport);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_p2appdata_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for pv2appdata
 */

void soc_sbx_g2p3_pv2appdata_t_init(
    soc_sbx_g2p3_pv2appdata_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_pv2appdata_t));
}

/* entry pack accessor implementation for pv2appdata */
int soc_sbx_g2p3_pv2appdata_pack(int unit,
    soc_sbx_g2p3_pv2appdata_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PV2APPDATA_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->member; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for pv2appdata */
int soc_sbx_g2p3_pv2appdata_unpack(int unit,
                soc_sbx_g2p3_pv2appdata_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PV2APPDATA_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->member; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for pv2appdata */
int soc_sbx_g2p3_pv2appdata_index_check(int unit,
                int *vindex,
                int ivid,
                int iport)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PV2APPDATA_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ivid; break;
        case 1: p = (uint8 *) &iport; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for pv2appdata */
int soc_sbx_g2p3_pv2appdata_entry_check(int unit,
                soc_sbx_g2p3_pv2appdata_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PV2APPDATA_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->member; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* pv2appdata table size get */
int soc_sbx_g2p3_pv2appdata_entry_table_size_get(int unit,
                int *tsize,
                int ivid,
                int iport)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PV2APPDATA_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ivid; break;
        case 1: v = iport; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for pv2appdata */
int soc_sbx_g2p3_pv2appdata_set(int unit,
                int ivid,
                int iport,
                soc_sbx_g2p3_pv2appdata_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PV2APPDATA_ID];

    s = soc_sbx_g2p3_pv2appdata_index_check(unit, key,
                ivid,
                iport);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_pv2appdata_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_pv2appdata_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

int soc_sbx_g2p3_pv2appdata_member_fast_get(int unit,
                int ivid,
                int iport,
                int eivid,
                int eiport,
                uint32 *vs,
                int vcount)
{
    int startvindex, endvindex, s;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PV2APPDATA_ID];
    soc_sbx_g2p3_field_desc_t *fd =
        &ed->fields[0];

    s = soc_sbx_g2p3_pv2appdata_index_check(unit, &startvindex,
                ivid,
                iport);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_pv2appdata_index_check(unit, &endvindex,
                eivid,
                eiport);
    if (s) {
        return s;
    }

    if (endvindex - startvindex >= vcount) {
        return SOC_E_PARAM;
    }

    s = soc_sbx_g2p3_entry_generic_fast_get(unit,
                  fd, ed, startvindex, endvindex, vs);

    return s;
}

/* entry get accessor implementation for pv2appdata */
int soc_sbx_g2p3_pv2appdata_get(int unit,
                int ivid,
                int iport,
                soc_sbx_g2p3_pv2appdata_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PV2APPDATA_ID];

    s = soc_sbx_g2p3_pv2appdata_index_check(unit, key,
                ivid,
                iport);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_pv2appdata_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for ipv6shost
 */

void soc_sbx_g2p3_ipv6shost_t_init(
    soc_sbx_g2p3_ipv6shost_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ipv6shost_t));
    e->poe = 0x3fff;
}

/* entry pack accessor implementation for ipv6shost */
int soc_sbx_g2p3_ipv6shost_pack(int unit,
    soc_sbx_g2p3_ipv6shost_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SHOST_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->poe; break;
        case 1: p = (uint8 *) &e->rpfmode; break;
        case 2: p = (uint8 *) &e->srcdrop; break;
        case 3: p = (uint8 *) &e->srccnt; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ipv6shost */
int soc_sbx_g2p3_ipv6shost_unpack(int unit,
                soc_sbx_g2p3_ipv6shost_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SHOST_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->poe; break;
        case 1: p = (uint8 *) &e->rpfmode; break;
        case 2: p = (uint8 *) &e->srcdrop; break;
        case 3: p = (uint8 *) &e->srccnt; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ipv6shost */
int soc_sbx_g2p3_ipv6shost_index_check(int unit,
                int *vindex,
                soc_sbx_g2p3_16_byte_t iip)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SHOST_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = 0;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) iip; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry index unpack for ipv6shost */
int soc_sbx_g2p3_ipv6shost_index_unpack(int unit,
                int *vindex,
                soc_sbx_g2p3_16_byte_t iip)
{
    int i, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SHOST_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int be = tm->behost;
    int pkbe = 0;

    p0 = ((uint8 *) vindex);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
	fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) iip; break;
        default: return SOC_E_INTERNAL;
        }
        sal_memset(p, 0, width <= 32 ? (int) sizeof(int) : (width + 7) / 8);
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe =
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT 
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_extract(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ipv6shost */
int soc_sbx_g2p3_ipv6shost_entry_check(int unit,
                soc_sbx_g2p3_ipv6shost_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SHOST_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->poe; break;
        case 1: ev = e->rpfmode; break;
        case 2: ev = e->srcdrop; break;
        case 3: ev = e->srccnt; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for ipv6shost */
int soc_sbx_g2p3_ipv6shost_set(int unit,
                soc_sbx_g2p3_16_byte_t iip,
                soc_sbx_g2p3_ipv6shost_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_ipv6shost_index_check(unit, key,
                iip);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv6shost_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv6shost_update(unit,
                iip,
                e);
    if (s == SOC_E_NOT_FOUND) {
        s = soc_sbx_g2p3_ipv6shost_add(unit,
                iip,
                e);
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ipv6shost_commit(unit, 0xffffffff);
    }

    return s;
}

/* entry add accessor implementation for ipv6shost */
int soc_sbx_g2p3_ipv6shost_add(int unit,
                soc_sbx_g2p3_16_byte_t iip,
                soc_sbx_g2p3_ipv6shost_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SHOST_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_ipv6shost_index_check(unit, key,
                iip);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv6shost_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv6shost_pack(unit,
                  e, epacked, ed->epsize);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_eml_add_ext(unit, cs,
                (uint8 *) key,
                epacked);

    return s;
}

/* entry get accessor implementation for ipv6shost */
int soc_sbx_g2p3_ipv6shost_get(int unit,
                soc_sbx_g2p3_16_byte_t iip,
                soc_sbx_g2p3_ipv6shost_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SHOST_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_ipv6shost_index_check(unit, key,
                iip);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_eml_get_ext(unit, cs,
                (uint8 *) key,
                epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv6shost_unpack(unit,
                    e, epacked, ed->epsize);

    return s;
}

/* entry update accessor implementation for ipv6shost */
int soc_sbx_g2p3_ipv6shost_update(int unit,
                soc_sbx_g2p3_16_byte_t iip,
                soc_sbx_g2p3_ipv6shost_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SHOST_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_ipv6shost_index_check(unit, key,
                iip);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv6shost_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv6shost_pack(unit,
                  e, epacked, ed->epsize);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_eml_update_ext(unit, cs,
                (uint8 *) key,
                epacked);

    return s;
}

/* entry delete accessor implementation for ipv6shost */
int soc_sbx_g2p3_ipv6shost_delete(int unit,
                soc_sbx_g2p3_16_byte_t iip)
{
    int s, key[32];

    s = soc_sbx_g2p3_ipv6shost_index_check(unit, key,
                iip);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv6shost_remove(unit,
                iip);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv6shost_commit(unit, 0xffffffff);

    return s;
}

/* entry remove accessor implementation for ipv6shost */
int soc_sbx_g2p3_ipv6shost_remove(int unit,
                soc_sbx_g2p3_16_byte_t iip)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SHOST_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_ipv6shost_index_check(unit, key,
                iip);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_eml_remove_ext(unit, cs,
                (uint8 *) key);

    return s;
}

/* Get the first element of ipv6shost */
int soc_sbx_g2p3_ipv6shost_first(int unit,
                soc_sbx_g2p3_16_byte_t niip)
{
    int s;
    int nkey[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SHOST_ID];
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    void *cs = td->cstate;

    s = soc_sbx_g2p3_eml_first_ext(unit, cs,
                (uint8 *) nkey);
    if (!s) {
        soc_sbx_g2p3_ipv6shost_index_unpack(unit, nkey,
                niip);
    }
    return s;
}

/* Get the next element of ipv6shost */
int soc_sbx_g2p3_ipv6shost_next(int unit,
                soc_sbx_g2p3_16_byte_t iip,
                soc_sbx_g2p3_16_byte_t niip)
{
    int key[32], s;
    int nkey[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SHOST_ID];
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    void *cs = td->cstate;

    s = soc_sbx_g2p3_ipv6shost_index_check(unit, key,
                iip);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_eml_next_ext(unit, cs,
                (uint8 *) key,
                (uint8 *) nkey);
    if (!s) {
        soc_sbx_g2p3_ipv6shost_index_unpack(unit, nkey,
                niip);
    }
    return s;
}

/* Batch commit implementation for ipv6shost */
int soc_sbx_g2p3_ipv6shost_commit(int unit, int runlength)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SHOST_ID];
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    void *cs = td->cstate;

    return soc_sbx_g2p3_eml_commit_ext(unit, cs, runlength);
}

/*
 * Entry accessor implementations for ipv6shostl1
 */

void soc_sbx_g2p3_ipv6shostl1_t_init(
    soc_sbx_g2p3_ipv6shostl1_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ipv6shostl1_t));
}

/* entry pack accessor implementation for ipv6shostl1 */
int soc_sbx_g2p3_ipv6shostl1_pack(int unit,
    soc_sbx_g2p3_ipv6shostl1_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SHOSTL1_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->usemap; break;
        case 1: p = (uint8 *) &e->pointer; break;
        case 2: p = (uint8 *) &e->salt; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ipv6shostl1 */
int soc_sbx_g2p3_ipv6shostl1_unpack(int unit,
                soc_sbx_g2p3_ipv6shostl1_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SHOSTL1_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->usemap; break;
        case 1: p = (uint8 *) &e->pointer; break;
        case 2: p = (uint8 *) &e->salt; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ipv6shostl1 */
int soc_sbx_g2p3_ipv6shostl1_index_check(int unit,
                int *vindex,
                int il1i)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SHOSTL1_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &il1i; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ipv6shostl1 */
int soc_sbx_g2p3_ipv6shostl1_entry_check(int unit,
                soc_sbx_g2p3_ipv6shostl1_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SHOSTL1_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->usemap; break;
        case 1: ev = e->pointer; break;
        case 2: ev = e->salt; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* ipv6shostl1 table size get */
int soc_sbx_g2p3_ipv6shostl1_entry_table_size_get(int unit,
                int *tsize,
                int il1i)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SHOSTL1_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = il1i; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for ipv6shostl1 */
int soc_sbx_g2p3_ipv6shostl1_set(int unit,
                int il1i,
                soc_sbx_g2p3_ipv6shostl1_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SHOSTL1_ID];

    s = soc_sbx_g2p3_ipv6shostl1_index_check(unit, key,
                il1i);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv6shostl1_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_ipv6shostl1_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for ipv6shostl1 */
int soc_sbx_g2p3_ipv6shostl1_get(int unit,
                int il1i,
                soc_sbx_g2p3_ipv6shostl1_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SHOSTL1_ID];

    s = soc_sbx_g2p3_ipv6shostl1_index_check(unit, key,
                il1i);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_ipv6shostl1_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for ipv6shostl2
 */

void soc_sbx_g2p3_ipv6shostl2_t_init(
    soc_sbx_g2p3_ipv6shostl2_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ipv6shostl2_t));
}

/* entry pack accessor implementation for ipv6shostl2 */
int soc_sbx_g2p3_ipv6shostl2_pack(int unit,
    soc_sbx_g2p3_ipv6shostl2_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SHOSTL2_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) e->key; break;
        case 1: p = (uint8 *) &e->ftidx; break;
        case 2: p = (uint8 *) &e->ecmpmask; break;
        case 3: p = (uint8 *) &e->vid; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ipv6shostl2 */
int soc_sbx_g2p3_ipv6shostl2_unpack(int unit,
                soc_sbx_g2p3_ipv6shostl2_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SHOSTL2_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) e->key; break;
        case 1: p = (uint8 *) &e->ftidx; break;
        case 2: p = (uint8 *) &e->ecmpmask; break;
        case 3: p = (uint8 *) &e->vid; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ipv6shostl2 */
int soc_sbx_g2p3_ipv6shostl2_index_check(int unit,
                int *vindex,
                int ihosti)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SHOSTL2_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ihosti; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ipv6shostl2 */
int soc_sbx_g2p3_ipv6shostl2_entry_check(int unit,
                soc_sbx_g2p3_ipv6shostl2_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SHOSTL2_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->key[0]; break;
        case 1: ev = e->ftidx; break;
        case 2: ev = e->ecmpmask; break;
        case 3: ev = e->vid; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* ipv6shostl2 table size get */
int soc_sbx_g2p3_ipv6shostl2_entry_table_size_get(int unit,
                int *tsize,
                int ihosti)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SHOSTL2_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ihosti; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for ipv6shostl2 */
int soc_sbx_g2p3_ipv6shostl2_set(int unit,
                int ihosti,
                soc_sbx_g2p3_ipv6shostl2_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SHOSTL2_ID];

    s = soc_sbx_g2p3_ipv6shostl2_index_check(unit, key,
                ihosti);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv6shostl2_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_ipv6shostl2_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for ipv6shostl2 */
int soc_sbx_g2p3_ipv6shostl2_get(int unit,
                int ihosti,
                soc_sbx_g2p3_ipv6shostl2_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SHOSTL2_ID];

    s = soc_sbx_g2p3_ipv6shostl2_index_check(unit, key,
                ihosti);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_ipv6shostl2_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for pvv2e
 */

void soc_sbx_g2p3_pvv2e_t_init(
    soc_sbx_g2p3_pvv2e_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_pvv2e_t));
}

/* entry size function for pvv2e */
int soc_sbx_g2p3_pvv2e_size(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PVV2E_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];

    return (eb->width + (eb->stridebits - 1)) / eb->stridebits;
}

/* entry pack accessor implementation for pvv2e */
int soc_sbx_g2p3_pvv2e_pack(int unit,
    soc_sbx_g2p3_pvv2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PVV2E_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->lpi; break;
        case 1: p = (uint8 *) &e->vlan; break;
        case 2: p = (uint8 *) &e->stpstate; break;
        case 3: p = (uint8 *) &e->untagged_strip; break;
        case 4: p = (uint8 *) &e->vpws; break;
        case 5: p = (uint8 *) &e->vid; break;
        case 6: p = (uint8 *) &e->replace; break;
        case 7: p = (uint8 *) &e->keeporstrip; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for pvv2e */
int soc_sbx_g2p3_pvv2e_unpack(int unit,
                soc_sbx_g2p3_pvv2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PVV2E_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->lpi; break;
        case 1: p = (uint8 *) &e->vlan; break;
        case 2: p = (uint8 *) &e->stpstate; break;
        case 3: p = (uint8 *) &e->untagged_strip; break;
        case 4: p = (uint8 *) &e->vpws; break;
        case 5: p = (uint8 *) &e->vid; break;
        case 6: p = (uint8 *) &e->replace; break;
        case 7: p = (uint8 *) &e->keeporstrip; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for pvv2e */
int soc_sbx_g2p3_pvv2e_index_check(int unit,
                int *vindex,
                int iivid,
                int iovid,
                int iport)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PVV2E_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iivid; break;
        case 1: p = (uint8 *) &iovid; break;
        case 2: p = (uint8 *) &iport; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for pvv2e */
int soc_sbx_g2p3_pvv2e_entry_check(int unit,
                soc_sbx_g2p3_pvv2e_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PVV2E_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->lpi; break;
        case 1: ev = e->vlan; break;
        case 2: ev = e->stpstate; break;
        case 3: ev = e->untagged_strip; break;
        case 4: ev = e->vpws; break;
        case 5: ev = e->vid; break;
        case 6: ev = e->replace; break;
        case 7: ev = e->keeporstrip; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for pvv2e */
int soc_sbx_g2p3_pvv2e_set(int unit,
                int iivid,
                int iovid,
                int iport,
                soc_sbx_g2p3_pvv2e_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_pvv2e_index_check(unit, key,
                iivid,
                iovid,
                iport);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_pvv2e_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_pvv2e_update(unit,
                iivid,
                iovid,
                iport,
                e);
    if (s == SOC_E_NOT_FOUND) {
        s = soc_sbx_g2p3_pvv2e_add(unit,
                iivid,
                iovid,
                iport,
                e);
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_pvv2e_commit(unit, 0xffffffff);
    }

    return s;
}

/* entry add accessor implementation for pvv2e */
int soc_sbx_g2p3_pvv2e_add(int unit,
                int iivid,
                int iovid,
                int iport,
                soc_sbx_g2p3_pvv2e_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_pvv2e_index_check(unit, key,
                iivid,
                iovid,
                iport);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_pvv2e_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_pvv2e_add_ext(unit,
                iivid,
                iovid,
                iport,
                e);

    return s;
}

/* entry get accessor implementation for pvv2e */
int soc_sbx_g2p3_pvv2e_get(int unit,
                int iivid,
                int iovid,
                int iport,
                soc_sbx_g2p3_pvv2e_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_pvv2e_index_check(unit, key,
                iivid,
                iovid,
                iport);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_pvv2e_get_ext(unit,
                iivid,
                iovid,
                iport,
                e);

    return s;
}

/* entry update accessor implementation for pvv2e */
int soc_sbx_g2p3_pvv2e_update(int unit,
                int iivid,
                int iovid,
                int iport,
                soc_sbx_g2p3_pvv2e_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_pvv2e_index_check(unit, key,
                iivid,
                iovid,
                iport);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_pvv2e_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_pvv2e_renew(unit,
                iivid,
                iovid,
                iport,
                e);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_pvv2e_commit(unit, 0xffffffff);

    return s;
}

/* entry renew accessor implementation for pvv2e */
int soc_sbx_g2p3_pvv2e_renew(int unit,
                int iivid,
                int iovid,
                int iport,
                soc_sbx_g2p3_pvv2e_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_pvv2e_index_check(unit, key,
                iivid,
                iovid,
                iport);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_pvv2e_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_pvv2e_renew_ext(unit,
                iivid,
                iovid,
                iport,
                e);

    return s;
}

/* entry delete accessor implementation for pvv2e */
int soc_sbx_g2p3_pvv2e_delete(int unit,
                int iivid,
                int iovid,
                int iport)
{
    int s, key[32];

    s = soc_sbx_g2p3_pvv2e_index_check(unit, key,
                iivid,
                iovid,
                iport);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_pvv2e_remove(unit,
                iivid,
                iovid,
                iport);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_pvv2e_commit(unit, 0xffffffff);

    return s;
}

/* entry remove accessor implementation for pvv2e */
int soc_sbx_g2p3_pvv2e_remove(int unit,
                int iivid,
                int iovid,
                int iport)
{
    int s, key[32];

    s = soc_sbx_g2p3_pvv2e_index_check(unit, key,
                iivid,
                iovid,
                iport);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_pvv2e_remove_ext(unit,
                iivid,
                iovid,
                iport);

    return s;
}

/* Get the first element of pvv2e */
int soc_sbx_g2p3_pvv2e_first(int unit,
                int *niivid,
                int *niovid,
                int *niport)
{
    return soc_sbx_g2p3_pvv2e_first_ext(unit,
                niivid,
                niovid,
                niport);
}

/* Get the next element of pvv2e */
int soc_sbx_g2p3_pvv2e_next(int unit,
                int iivid,
                int iovid,
                int iport,
                int *niivid,
                int *niovid,
                int *niport)
{
    int key[32], s;

    s = soc_sbx_g2p3_pvv2e_index_check(unit, key,
                iivid,
                iovid,
                iport);
    if (s) {
        return s;
    }

    return soc_sbx_g2p3_pvv2e_next_ext(unit,
                iivid,
                iovid,
                iport,
                niivid,
                niovid,
                niport);
}

/* Batch commit implementation for pvv2e */
int soc_sbx_g2p3_pvv2e_commit(int unit, int runlength)
{
    return soc_sbx_g2p3_pvv2e_commit_ext(unit, runlength);
}

/*
 * Entry accessor implementations for pvv2epack
 */

void soc_sbx_g2p3_pvv2epack_t_init(
    soc_sbx_g2p3_pvv2epack_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_pvv2epack_t));
}

/* entry size function for pvv2epack */
int soc_sbx_g2p3_pvv2epack_size(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PVV2EPACK_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];

    return (eb->width + (eb->stridebits - 1)) / eb->stridebits;
}

/* entry pack accessor implementation for pvv2epack */
int soc_sbx_g2p3_pvv2epack_pack(int unit,
    soc_sbx_g2p3_pvv2epack_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PVV2EPACK_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->lpi; break;
        case 1: p = (uint8 *) &e->vlan; break;
        case 2: p = (uint8 *) &e->stpstate; break;
        case 3: p = (uint8 *) &e->untagged_strip; break;
        case 4: p = (uint8 *) &e->vpws; break;
        case 5: p = (uint8 *) &e->vid; break;
        case 6: p = (uint8 *) &e->replace; break;
        case 7: p = (uint8 *) &e->keeporstrip; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for pvv2epack */
int soc_sbx_g2p3_pvv2epack_unpack(int unit,
                soc_sbx_g2p3_pvv2epack_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PVV2EPACK_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->lpi; break;
        case 1: p = (uint8 *) &e->vlan; break;
        case 2: p = (uint8 *) &e->stpstate; break;
        case 3: p = (uint8 *) &e->untagged_strip; break;
        case 4: p = (uint8 *) &e->vpws; break;
        case 5: p = (uint8 *) &e->vid; break;
        case 6: p = (uint8 *) &e->replace; break;
        case 7: p = (uint8 *) &e->keeporstrip; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for pvv2epack */
int soc_sbx_g2p3_pvv2epack_index_check(int unit,
                int *vindex,
                int iovid,
                int iport,
                int iivid)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PVV2EPACK_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iovid; break;
        case 1: p = (uint8 *) &iport; break;
        case 2: p = (uint8 *) &iivid; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry index unpack for pvv2epack */
int soc_sbx_g2p3_pvv2epack_index_unpack(int unit,
                int *vindex,
                int *iovid,
                int *iport,
                int *iivid)
{
    int i, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PVV2EPACK_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int be = tm->behost;
    int pkbe = be;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
	fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) iovid; break;
        case 1: p = (uint8 *) iport; break;
        case 2: p = (uint8 *) iivid; break;
        default: return SOC_E_INTERNAL;
        }
        sal_memset(p, 0, width <= 32 ? (int) sizeof(int) : (width + 7) / 8);
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe =
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT 
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_extract(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for pvv2epack */
int soc_sbx_g2p3_pvv2epack_entry_check(int unit,
                soc_sbx_g2p3_pvv2epack_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PVV2EPACK_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->lpi; break;
        case 1: ev = e->vlan; break;
        case 2: ev = e->stpstate; break;
        case 3: ev = e->untagged_strip; break;
        case 4: ev = e->vpws; break;
        case 5: ev = e->vid; break;
        case 6: ev = e->replace; break;
        case 7: ev = e->keeporstrip; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for pvv2epack */
int soc_sbx_g2p3_pvv2epack_set(int unit,
                int iovid,
                int iport,
                int iivid,
                soc_sbx_g2p3_pvv2epack_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_pvv2epack_index_check(unit, key,
                iovid,
                iport,
                iivid);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_pvv2epack_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_pvv2epack_update(unit,
                iovid,
                iport,
                iivid,
                e);
    if (s == SOC_E_NOT_FOUND) {
        s = soc_sbx_g2p3_pvv2epack_add(unit,
                iovid,
                iport,
                iivid,
                e);
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_pvv2epack_commit(unit, 0xffffffff);
    }

    return s;
}

/* entry add accessor implementation for pvv2epack */
int soc_sbx_g2p3_pvv2epack_add(int unit,
                int iovid,
                int iport,
                int iivid,
                soc_sbx_g2p3_pvv2epack_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PVV2EPACK_ID];

    s = soc_sbx_g2p3_pvv2epack_index_check(unit, key,
                iovid,
                iport,
                iivid);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_pvv2epack_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_pvv2epack_pack(unit,
                  e, epacked, ed->epsize);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_pvv2epack_add_ext(unit,
                (uint8 *) key,
                epacked);

    return s;
}

/* entry get accessor implementation for pvv2epack */
int soc_sbx_g2p3_pvv2epack_get(int unit,
                int iovid,
                int iport,
                int iivid,
                soc_sbx_g2p3_pvv2epack_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PVV2EPACK_ID];

    s = soc_sbx_g2p3_pvv2epack_index_check(unit, key,
                iovid,
                iport,
                iivid);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_pvv2epack_get_ext(unit,
                (uint8 *) key,
                epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_pvv2epack_unpack(unit,
                    e, epacked, ed->epsize);

    return s;
}

/* entry update accessor implementation for pvv2epack */
int soc_sbx_g2p3_pvv2epack_update(int unit,
                int iovid,
                int iport,
                int iivid,
                soc_sbx_g2p3_pvv2epack_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_pvv2epack_index_check(unit, key,
                iovid,
                iport,
                iivid);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_pvv2epack_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_pvv2epack_renew(unit,
                iovid,
                iport,
                iivid,
                e);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_pvv2epack_commit(unit, 0xffffffff);

    return s;
}

/* entry renew accessor implementation for pvv2epack */
int soc_sbx_g2p3_pvv2epack_renew(int unit,
                int iovid,
                int iport,
                int iivid,
                soc_sbx_g2p3_pvv2epack_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PVV2EPACK_ID];

    s = soc_sbx_g2p3_pvv2epack_index_check(unit, key,
                iovid,
                iport,
                iivid);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_pvv2epack_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_pvv2epack_pack(unit,
                  e, epacked, ed->epsize);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_pvv2epack_renew_ext(unit,
                (uint8 *) key,
                epacked);

    return s;
}

/* entry delete accessor implementation for pvv2epack */
int soc_sbx_g2p3_pvv2epack_delete(int unit,
                int iovid,
                int iport,
                int iivid)
{
    int s, key[32];

    s = soc_sbx_g2p3_pvv2epack_index_check(unit, key,
                iovid,
                iport,
                iivid);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_pvv2epack_remove(unit,
                iovid,
                iport,
                iivid);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_pvv2epack_commit(unit, 0xffffffff);

    return s;
}

/* entry remove accessor implementation for pvv2epack */
int soc_sbx_g2p3_pvv2epack_remove(int unit,
                int iovid,
                int iport,
                int iivid)
{
    int s, key[32];

    s = soc_sbx_g2p3_pvv2epack_index_check(unit, key,
                iovid,
                iport,
                iivid);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_pvv2epack_remove_ext(unit,
                (uint8 *) key);

    return s;
}

/* Get the first element of pvv2epack */
int soc_sbx_g2p3_pvv2epack_first(int unit,
                int *niovid,
                int *niport,
                int *niivid)
{
    int s;
    int nkey[32];

    s = soc_sbx_g2p3_pvv2epack_first_ext(unit,
                (uint8 *) nkey);
    if (!s) {
        soc_sbx_g2p3_pvv2epack_index_unpack(unit, nkey,
                niovid,
                niport,
                niivid);
    }
    return s;
}

/* Get the next element of pvv2epack */
int soc_sbx_g2p3_pvv2epack_next(int unit,
                int iovid,
                int iport,
                int iivid,
                int *niovid,
                int *niport,
                int *niivid)
{
    int key[32], s;
    int nkey[32];

    s = soc_sbx_g2p3_pvv2epack_index_check(unit, key,
                iovid,
                iport,
                iivid);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_pvv2epack_next_ext(unit,
                (uint8 *) key,
                (uint8 *) nkey);
    if (!s) {
        soc_sbx_g2p3_pvv2epack_index_unpack(unit, nkey,
                niovid,
                niport,
                niivid);
    }
    return s;
}

/* Batch commit implementation for pvv2epack */
int soc_sbx_g2p3_pvv2epack_commit(int unit, int runlength)
{
    return soc_sbx_g2p3_pvv2epack_commit_ext(unit, runlength);
}

/*
 * Entry accessor implementations for isid2e
 */

void soc_sbx_g2p3_isid2e_t_init(
    soc_sbx_g2p3_isid2e_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_isid2e_t));
}

/* entry size function for isid2e */
int soc_sbx_g2p3_isid2e_size(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ISID2E_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];

    return (eb->width + (eb->stridebits - 1)) / eb->stridebits;
}

/* entry pack accessor implementation for isid2e */
int soc_sbx_g2p3_isid2e_pack(int unit,
    soc_sbx_g2p3_isid2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ISID2E_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->lpi; break;
        case 1: p = (uint8 *) &e->vlan; break;
        case 2: p = (uint8 *) &e->stpstate; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for isid2e */
int soc_sbx_g2p3_isid2e_unpack(int unit,
                soc_sbx_g2p3_isid2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ISID2E_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->lpi; break;
        case 1: p = (uint8 *) &e->vlan; break;
        case 2: p = (uint8 *) &e->stpstate; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for isid2e */
int soc_sbx_g2p3_isid2e_index_check(int unit,
                int *vindex,
                int iisid)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ISID2E_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iisid; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry index unpack for isid2e */
int soc_sbx_g2p3_isid2e_index_unpack(int unit,
                int *vindex,
                int *iisid)
{
    int i, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ISID2E_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int be = tm->behost;
    int pkbe = be;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
	fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) iisid; break;
        default: return SOC_E_INTERNAL;
        }
        sal_memset(p, 0, width <= 32 ? (int) sizeof(int) : (width + 7) / 8);
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe =
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT 
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_extract(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for isid2e */
int soc_sbx_g2p3_isid2e_entry_check(int unit,
                soc_sbx_g2p3_isid2e_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ISID2E_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->lpi; break;
        case 1: ev = e->vlan; break;
        case 2: ev = e->stpstate; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for isid2e */
int soc_sbx_g2p3_isid2e_set(int unit,
                int iisid,
                soc_sbx_g2p3_isid2e_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_isid2e_index_check(unit, key,
                iisid);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_isid2e_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_isid2e_update(unit,
                iisid,
                e);
    if (s == SOC_E_NOT_FOUND) {
        s = soc_sbx_g2p3_isid2e_add(unit,
                iisid,
                e);
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_isid2e_commit(unit, 0xffffffff);
    }

    return s;
}

/* entry add accessor implementation for isid2e */
int soc_sbx_g2p3_isid2e_add(int unit,
                int iisid,
                soc_sbx_g2p3_isid2e_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ISID2E_ID];

    s = soc_sbx_g2p3_isid2e_index_check(unit, key,
                iisid);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_isid2e_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_isid2e_pack(unit,
                  e, epacked, ed->epsize);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_isid2e_add_ext(unit,
                (uint8 *) key,
                epacked);

    return s;
}

/* entry get accessor implementation for isid2e */
int soc_sbx_g2p3_isid2e_get(int unit,
                int iisid,
                soc_sbx_g2p3_isid2e_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ISID2E_ID];

    s = soc_sbx_g2p3_isid2e_index_check(unit, key,
                iisid);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_isid2e_get_ext(unit,
                (uint8 *) key,
                epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_isid2e_unpack(unit,
                    e, epacked, ed->epsize);

    return s;
}

/* entry update accessor implementation for isid2e */
int soc_sbx_g2p3_isid2e_update(int unit,
                int iisid,
                soc_sbx_g2p3_isid2e_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_isid2e_index_check(unit, key,
                iisid);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_isid2e_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_isid2e_renew(unit,
                iisid,
                e);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_isid2e_commit(unit, 0xffffffff);

    return s;
}

/* entry renew accessor implementation for isid2e */
int soc_sbx_g2p3_isid2e_renew(int unit,
                int iisid,
                soc_sbx_g2p3_isid2e_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ISID2E_ID];

    s = soc_sbx_g2p3_isid2e_index_check(unit, key,
                iisid);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_isid2e_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_isid2e_pack(unit,
                  e, epacked, ed->epsize);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_isid2e_renew_ext(unit,
                (uint8 *) key,
                epacked);

    return s;
}

/* entry delete accessor implementation for isid2e */
int soc_sbx_g2p3_isid2e_delete(int unit,
                int iisid)
{
    int s, key[32];

    s = soc_sbx_g2p3_isid2e_index_check(unit, key,
                iisid);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_isid2e_remove(unit,
                iisid);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_isid2e_commit(unit, 0xffffffff);

    return s;
}

/* entry remove accessor implementation for isid2e */
int soc_sbx_g2p3_isid2e_remove(int unit,
                int iisid)
{
    int s, key[32];

    s = soc_sbx_g2p3_isid2e_index_check(unit, key,
                iisid);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_isid2e_remove_ext(unit,
                (uint8 *) key);

    return s;
}

/* Get the first element of isid2e */
int soc_sbx_g2p3_isid2e_first(int unit,
                int *niisid)
{
    int s;
    int nkey[32];

    s = soc_sbx_g2p3_isid2e_first_ext(unit,
                (uint8 *) nkey);
    if (!s) {
        soc_sbx_g2p3_isid2e_index_unpack(unit, nkey,
                niisid);
    }
    return s;
}

/* Get the next element of isid2e */
int soc_sbx_g2p3_isid2e_next(int unit,
                int iisid,
                int *niisid)
{
    int key[32], s;
    int nkey[32];

    s = soc_sbx_g2p3_isid2e_index_check(unit, key,
                iisid);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_isid2e_next_ext(unit,
                (uint8 *) key,
                (uint8 *) nkey);
    if (!s) {
        soc_sbx_g2p3_isid2e_index_unpack(unit, nkey,
                niisid);
    }
    return s;
}

/* Batch commit implementation for isid2e */
int soc_sbx_g2p3_isid2e_commit(int unit, int runlength)
{
    return soc_sbx_g2p3_isid2e_commit_ext(unit, runlength);
}

/*
 * Entry accessor implementations for oampvd2e
 */

void soc_sbx_g2p3_oampvd2e_t_init(
    soc_sbx_g2p3_oampvd2e_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_oampvd2e_t));
}

/* entry size function for oampvd2e */
int soc_sbx_g2p3_oampvd2e_size(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMPVD2E_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];

    return (eb->width + (eb->stridebits - 1)) / eb->stridebits;
}

/* entry pack accessor implementation for oampvd2e */
int soc_sbx_g2p3_oampvd2e_pack(int unit,
    soc_sbx_g2p3_oampvd2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMPVD2E_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->endpointPtr; break;
        case 1: p = (uint8 *) &e->ftIdx; break;
        case 2: p = (uint8 *) &e->mdLevelEp; break;
        case 3: p = (uint8 *) &e->mdLevelFwd; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for oampvd2e */
int soc_sbx_g2p3_oampvd2e_unpack(int unit,
                soc_sbx_g2p3_oampvd2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMPVD2E_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->endpointPtr; break;
        case 1: p = (uint8 *) &e->ftIdx; break;
        case 2: p = (uint8 *) &e->mdLevelEp; break;
        case 3: p = (uint8 *) &e->mdLevelFwd; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for oampvd2e */
int soc_sbx_g2p3_oampvd2e_index_check(int unit,
                int *vindex,
                int iport,
                int ivid,
                int idir,
                int itag)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMPVD2E_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iport; break;
        case 1: p = (uint8 *) &ivid; break;
        case 2: p = (uint8 *) &idir; break;
        case 3: p = (uint8 *) &itag; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry index unpack for oampvd2e */
int soc_sbx_g2p3_oampvd2e_index_unpack(int unit,
                int *vindex,
                int *iport,
                int *ivid,
                int *idir,
                int *itag)
{
    int i, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMPVD2E_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int be = tm->behost;
    int pkbe = be;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
	fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) iport; break;
        case 1: p = (uint8 *) ivid; break;
        case 2: p = (uint8 *) idir; break;
        case 3: p = (uint8 *) itag; break;
        default: return SOC_E_INTERNAL;
        }
        sal_memset(p, 0, width <= 32 ? (int) sizeof(int) : (width + 7) / 8);
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe =
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT 
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_extract(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for oampvd2e */
int soc_sbx_g2p3_oampvd2e_entry_check(int unit,
                soc_sbx_g2p3_oampvd2e_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMPVD2E_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->endpointPtr; break;
        case 1: ev = e->ftIdx; break;
        case 2: ev = e->mdLevelEp; break;
        case 3: ev = e->mdLevelFwd; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for oampvd2e */
int soc_sbx_g2p3_oampvd2e_set(int unit,
                int iport,
                int ivid,
                int idir,
                int itag,
                soc_sbx_g2p3_oampvd2e_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_oampvd2e_index_check(unit, key,
                iport,
                ivid,
                idir,
                itag);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_oampvd2e_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_oampvd2e_update(unit,
                iport,
                ivid,
                idir,
                itag,
                e);
    if (s == SOC_E_NOT_FOUND) {
        s = soc_sbx_g2p3_oampvd2e_add(unit,
                iport,
                ivid,
                idir,
                itag,
                e);
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_oampvd2e_commit(unit, 0xffffffff);
    }

    return s;
}

/* entry add accessor implementation for oampvd2e */
int soc_sbx_g2p3_oampvd2e_add(int unit,
                int iport,
                int ivid,
                int idir,
                int itag,
                soc_sbx_g2p3_oampvd2e_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMPVD2E_ID];

    s = soc_sbx_g2p3_oampvd2e_index_check(unit, key,
                iport,
                ivid,
                idir,
                itag);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_oampvd2e_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_oampvd2e_pack(unit,
                  e, epacked, ed->epsize);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_oampvd2e_add_ext(unit,
                (uint8 *) key,
                epacked);

    return s;
}

/* entry get accessor implementation for oampvd2e */
int soc_sbx_g2p3_oampvd2e_get(int unit,
                int iport,
                int ivid,
                int idir,
                int itag,
                soc_sbx_g2p3_oampvd2e_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMPVD2E_ID];

    s = soc_sbx_g2p3_oampvd2e_index_check(unit, key,
                iport,
                ivid,
                idir,
                itag);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_oampvd2e_get_ext(unit,
                (uint8 *) key,
                epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_oampvd2e_unpack(unit,
                    e, epacked, ed->epsize);

    return s;
}

/* entry update accessor implementation for oampvd2e */
int soc_sbx_g2p3_oampvd2e_update(int unit,
                int iport,
                int ivid,
                int idir,
                int itag,
                soc_sbx_g2p3_oampvd2e_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_oampvd2e_index_check(unit, key,
                iport,
                ivid,
                idir,
                itag);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_oampvd2e_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_oampvd2e_renew(unit,
                iport,
                ivid,
                idir,
                itag,
                e);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_oampvd2e_commit(unit, 0xffffffff);

    return s;
}

/* entry renew accessor implementation for oampvd2e */
int soc_sbx_g2p3_oampvd2e_renew(int unit,
                int iport,
                int ivid,
                int idir,
                int itag,
                soc_sbx_g2p3_oampvd2e_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMPVD2E_ID];

    s = soc_sbx_g2p3_oampvd2e_index_check(unit, key,
                iport,
                ivid,
                idir,
                itag);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_oampvd2e_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_oampvd2e_pack(unit,
                  e, epacked, ed->epsize);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_oampvd2e_renew_ext(unit,
                (uint8 *) key,
                epacked);

    return s;
}

/* entry delete accessor implementation for oampvd2e */
int soc_sbx_g2p3_oampvd2e_delete(int unit,
                int iport,
                int ivid,
                int idir,
                int itag)
{
    int s, key[32];

    s = soc_sbx_g2p3_oampvd2e_index_check(unit, key,
                iport,
                ivid,
                idir,
                itag);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_oampvd2e_remove(unit,
                iport,
                ivid,
                idir,
                itag);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_oampvd2e_commit(unit, 0xffffffff);

    return s;
}

/* entry remove accessor implementation for oampvd2e */
int soc_sbx_g2p3_oampvd2e_remove(int unit,
                int iport,
                int ivid,
                int idir,
                int itag)
{
    int s, key[32];

    s = soc_sbx_g2p3_oampvd2e_index_check(unit, key,
                iport,
                ivid,
                idir,
                itag);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_oampvd2e_remove_ext(unit,
                (uint8 *) key);

    return s;
}

/* Get the first element of oampvd2e */
int soc_sbx_g2p3_oampvd2e_first(int unit,
                int *niport,
                int *nivid,
                int *nidir,
                int *nitag)
{
    int s;
    int nkey[32];

    s = soc_sbx_g2p3_oampvd2e_first_ext(unit,
                (uint8 *) nkey);
    if (!s) {
        soc_sbx_g2p3_oampvd2e_index_unpack(unit, nkey,
                niport,
                nivid,
                nidir,
                nitag);
    }
    return s;
}

/* Get the next element of oampvd2e */
int soc_sbx_g2p3_oampvd2e_next(int unit,
                int iport,
                int ivid,
                int idir,
                int itag,
                int *niport,
                int *nivid,
                int *nidir,
                int *nitag)
{
    int key[32], s;
    int nkey[32];

    s = soc_sbx_g2p3_oampvd2e_index_check(unit, key,
                iport,
                ivid,
                idir,
                itag);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_oampvd2e_next_ext(unit,
                (uint8 *) key,
                (uint8 *) nkey);
    if (!s) {
        soc_sbx_g2p3_oampvd2e_index_unpack(unit, nkey,
                niport,
                nivid,
                nidir,
                nitag);
    }
    return s;
}

/* Batch commit implementation for oampvd2e */
int soc_sbx_g2p3_oampvd2e_commit(int unit, int runlength)
{
    return soc_sbx_g2p3_oampvd2e_commit_ext(unit, runlength);
}

/*
 * Entry accessor implementations for oammaidmep2e
 */

void soc_sbx_g2p3_oammaidmep2e_t_init(
    soc_sbx_g2p3_oammaidmep2e_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_oammaidmep2e_t));
}

/* entry size function for oammaidmep2e */
int soc_sbx_g2p3_oammaidmep2e_size(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMMAIDMEP2E_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];

    return (eb->width + (eb->stridebits - 1)) / eb->stridebits;
}

/* entry pack accessor implementation for oammaidmep2e */
int soc_sbx_g2p3_oammaidmep2e_pack(int unit,
    soc_sbx_g2p3_oammaidmep2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMMAIDMEP2E_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->endpointPtr; break;
        case 1: p = (uint8 *) &e->epValid; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for oammaidmep2e */
int soc_sbx_g2p3_oammaidmep2e_unpack(int unit,
                soc_sbx_g2p3_oammaidmep2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMMAIDMEP2E_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->endpointPtr; break;
        case 1: p = (uint8 *) &e->epValid; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for oammaidmep2e */
int soc_sbx_g2p3_oammaidmep2e_index_check(int unit,
                int *vindex,
                int imaid,
                int imepid)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMMAIDMEP2E_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &imaid; break;
        case 1: p = (uint8 *) &imepid; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry index unpack for oammaidmep2e */
int soc_sbx_g2p3_oammaidmep2e_index_unpack(int unit,
                int *vindex,
                int *imaid,
                int *imepid)
{
    int i, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMMAIDMEP2E_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int be = tm->behost;
    int pkbe = be;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
	fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) imaid; break;
        case 1: p = (uint8 *) imepid; break;
        default: return SOC_E_INTERNAL;
        }
        sal_memset(p, 0, width <= 32 ? (int) sizeof(int) : (width + 7) / 8);
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe =
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT 
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_extract(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for oammaidmep2e */
int soc_sbx_g2p3_oammaidmep2e_entry_check(int unit,
                soc_sbx_g2p3_oammaidmep2e_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMMAIDMEP2E_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->endpointPtr; break;
        case 1: ev = e->epValid; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for oammaidmep2e */
int soc_sbx_g2p3_oammaidmep2e_set(int unit,
                int imaid,
                int imepid,
                soc_sbx_g2p3_oammaidmep2e_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_oammaidmep2e_index_check(unit, key,
                imaid,
                imepid);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_oammaidmep2e_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_oammaidmep2e_update(unit,
                imaid,
                imepid,
                e);
    if (s == SOC_E_NOT_FOUND) {
        s = soc_sbx_g2p3_oammaidmep2e_add(unit,
                imaid,
                imepid,
                e);
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_oammaidmep2e_commit(unit, 0xffffffff);
    }

    return s;
}

/* entry add accessor implementation for oammaidmep2e */
int soc_sbx_g2p3_oammaidmep2e_add(int unit,
                int imaid,
                int imepid,
                soc_sbx_g2p3_oammaidmep2e_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMMAIDMEP2E_ID];

    s = soc_sbx_g2p3_oammaidmep2e_index_check(unit, key,
                imaid,
                imepid);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_oammaidmep2e_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_oammaidmep2e_pack(unit,
                  e, epacked, ed->epsize);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_oammaidmep2e_add_ext(unit,
                (uint8 *) key,
                epacked);

    return s;
}

/* entry get accessor implementation for oammaidmep2e */
int soc_sbx_g2p3_oammaidmep2e_get(int unit,
                int imaid,
                int imepid,
                soc_sbx_g2p3_oammaidmep2e_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMMAIDMEP2E_ID];

    s = soc_sbx_g2p3_oammaidmep2e_index_check(unit, key,
                imaid,
                imepid);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_oammaidmep2e_get_ext(unit,
                (uint8 *) key,
                epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_oammaidmep2e_unpack(unit,
                    e, epacked, ed->epsize);

    return s;
}

/* entry update accessor implementation for oammaidmep2e */
int soc_sbx_g2p3_oammaidmep2e_update(int unit,
                int imaid,
                int imepid,
                soc_sbx_g2p3_oammaidmep2e_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_oammaidmep2e_index_check(unit, key,
                imaid,
                imepid);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_oammaidmep2e_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_oammaidmep2e_renew(unit,
                imaid,
                imepid,
                e);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_oammaidmep2e_commit(unit, 0xffffffff);

    return s;
}

/* entry renew accessor implementation for oammaidmep2e */
int soc_sbx_g2p3_oammaidmep2e_renew(int unit,
                int imaid,
                int imepid,
                soc_sbx_g2p3_oammaidmep2e_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMMAIDMEP2E_ID];

    s = soc_sbx_g2p3_oammaidmep2e_index_check(unit, key,
                imaid,
                imepid);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_oammaidmep2e_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_oammaidmep2e_pack(unit,
                  e, epacked, ed->epsize);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_oammaidmep2e_renew_ext(unit,
                (uint8 *) key,
                epacked);

    return s;
}

/* entry delete accessor implementation for oammaidmep2e */
int soc_sbx_g2p3_oammaidmep2e_delete(int unit,
                int imaid,
                int imepid)
{
    int s, key[32];

    s = soc_sbx_g2p3_oammaidmep2e_index_check(unit, key,
                imaid,
                imepid);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_oammaidmep2e_remove(unit,
                imaid,
                imepid);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_oammaidmep2e_commit(unit, 0xffffffff);

    return s;
}

/* entry remove accessor implementation for oammaidmep2e */
int soc_sbx_g2p3_oammaidmep2e_remove(int unit,
                int imaid,
                int imepid)
{
    int s, key[32];

    s = soc_sbx_g2p3_oammaidmep2e_index_check(unit, key,
                imaid,
                imepid);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_oammaidmep2e_remove_ext(unit,
                (uint8 *) key);

    return s;
}

/* Get the first element of oammaidmep2e */
int soc_sbx_g2p3_oammaidmep2e_first(int unit,
                int *nimaid,
                int *nimepid)
{
    int s;
    int nkey[32];

    s = soc_sbx_g2p3_oammaidmep2e_first_ext(unit,
                (uint8 *) nkey);
    if (!s) {
        soc_sbx_g2p3_oammaidmep2e_index_unpack(unit, nkey,
                nimaid,
                nimepid);
    }
    return s;
}

/* Get the next element of oammaidmep2e */
int soc_sbx_g2p3_oammaidmep2e_next(int unit,
                int imaid,
                int imepid,
                int *nimaid,
                int *nimepid)
{
    int key[32], s;
    int nkey[32];

    s = soc_sbx_g2p3_oammaidmep2e_index_check(unit, key,
                imaid,
                imepid);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_oammaidmep2e_next_ext(unit,
                (uint8 *) key,
                (uint8 *) nkey);
    if (!s) {
        soc_sbx_g2p3_oammaidmep2e_index_unpack(unit, nkey,
                nimaid,
                nimepid);
    }
    return s;
}

/* Batch commit implementation for oammaidmep2e */
int soc_sbx_g2p3_oammaidmep2e_commit(int unit, int runlength)
{
    return soc_sbx_g2p3_oammaidmep2e_commit_ext(unit, runlength);
}

/*
 * Entry accessor implementations for cuckoo
 */

void soc_sbx_g2p3_cuckoo_t_init(
    soc_sbx_g2p3_cuckoo_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_cuckoo_t));
}

/* entry pack accessor implementation for cuckoo */
int soc_sbx_g2p3_cuckoo_pack(int unit,
    soc_sbx_g2p3_cuckoo_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_CUCKOO_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) e->pay; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for cuckoo */
int soc_sbx_g2p3_cuckoo_unpack(int unit,
                soc_sbx_g2p3_cuckoo_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_CUCKOO_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) e->pay; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for cuckoo */
int soc_sbx_g2p3_cuckoo_index_check(int unit,
                int *vindex,
                int ikey,
                int itype)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_CUCKOO_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = 1;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (psize - 1);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ikey; break;
        case 1: p = (uint8 *) &itype; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry index unpack for cuckoo */
int soc_sbx_g2p3_cuckoo_index_unpack(int unit,
                int *vindex,
                int *ikey,
                int *itype)
{
    int i, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_CUCKOO_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int be = tm->behost;
    int pkbe = 1;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);

    p0 = ((uint8 *) vindex) + (psize - 1);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
	fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) ikey; break;
        case 1: p = (uint8 *) itype; break;
        default: return SOC_E_INTERNAL;
        }
        sal_memset(p, 0, width <= 32 ? (int) sizeof(int) : (width + 7) / 8);
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe =
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT 
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_extract(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for cuckoo */
int soc_sbx_g2p3_cuckoo_entry_check(int unit,
                soc_sbx_g2p3_cuckoo_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_CUCKOO_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->pay[0]; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for cuckoo */
int soc_sbx_g2p3_cuckoo_set(int unit,
                int ikey,
                int itype,
                soc_sbx_g2p3_cuckoo_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_cuckoo_index_check(unit, key,
                ikey,
                itype);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_cuckoo_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_cuckoo_update(unit,
                ikey,
                itype,
                e);
    if (s == SOC_E_NOT_FOUND) {
        s = soc_sbx_g2p3_cuckoo_add(unit,
                ikey,
                itype,
                e);
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_cuckoo_commit(unit, 0xffffffff);
    }

    return s;
}

/* entry add accessor implementation for cuckoo */
int soc_sbx_g2p3_cuckoo_add(int unit,
                int ikey,
                int itype,
                soc_sbx_g2p3_cuckoo_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_CUCKOO_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_cuckoo_index_check(unit, key,
                ikey,
                itype);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_cuckoo_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_cuckoo_pack(unit,
                  e, epacked, ed->epsize);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_em32_add_ext(unit, cs,
                (uint8 *) key,
                epacked);

    return s;
}

/* entry get accessor implementation for cuckoo */
int soc_sbx_g2p3_cuckoo_get(int unit,
                int ikey,
                int itype,
                soc_sbx_g2p3_cuckoo_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_CUCKOO_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_cuckoo_index_check(unit, key,
                ikey,
                itype);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_em32_get_ext(unit, cs,
                (uint8 *) key,
                epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_cuckoo_unpack(unit,
                    e, epacked, ed->epsize);

    return s;
}

/* entry update accessor implementation for cuckoo */
int soc_sbx_g2p3_cuckoo_update(int unit,
                int ikey,
                int itype,
                soc_sbx_g2p3_cuckoo_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_cuckoo_index_check(unit, key,
                ikey,
                itype);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_cuckoo_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_cuckoo_renew(unit,
                ikey,
                itype,
                e);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_cuckoo_commit(unit, 0xffffffff);

    return s;
}

/* entry renew accessor implementation for cuckoo */
int soc_sbx_g2p3_cuckoo_renew(int unit,
                int ikey,
                int itype,
                soc_sbx_g2p3_cuckoo_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_CUCKOO_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_cuckoo_index_check(unit, key,
                ikey,
                itype);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_cuckoo_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_cuckoo_pack(unit,
                  e, epacked, ed->epsize);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_em32_renew_ext(unit, cs,
                (uint8 *) key,
                epacked);

    return s;
}

/* entry delete accessor implementation for cuckoo */
int soc_sbx_g2p3_cuckoo_delete(int unit,
                int ikey,
                int itype)
{
    int s, key[32];

    s = soc_sbx_g2p3_cuckoo_index_check(unit, key,
                ikey,
                itype);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_cuckoo_remove(unit,
                ikey,
                itype);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_cuckoo_commit(unit, 0xffffffff);

    return s;
}

/* entry remove accessor implementation for cuckoo */
int soc_sbx_g2p3_cuckoo_remove(int unit,
                int ikey,
                int itype)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_CUCKOO_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_cuckoo_index_check(unit, key,
                ikey,
                itype);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_em32_remove_ext(unit, cs,
                (uint8 *) key);

    return s;
}

/* Get the first element of cuckoo */
int soc_sbx_g2p3_cuckoo_first(int unit,
                int *nikey,
                int *nitype)
{
    int s;
    int nkey[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_CUCKOO_ID];
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    void *cs = td->cstate;

    s = soc_sbx_g2p3_em32_first_ext(unit, cs,
                (uint8 *) nkey);
    if (!s) {
        soc_sbx_g2p3_cuckoo_index_unpack(unit, nkey,
                nikey,
                nitype);
    }
    return s;
}

/* Get the next element of cuckoo */
int soc_sbx_g2p3_cuckoo_next(int unit,
                int ikey,
                int itype,
                int *nikey,
                int *nitype)
{
    int key[32], s;
    int nkey[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_CUCKOO_ID];
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    void *cs = td->cstate;

    s = soc_sbx_g2p3_cuckoo_index_check(unit, key,
                ikey,
                itype);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_em32_next_ext(unit, cs,
                (uint8 *) key,
                (uint8 *) nkey);
    if (!s) {
        soc_sbx_g2p3_cuckoo_index_unpack(unit, nkey,
                nikey,
                nitype);
    }
    return s;
}

/* Batch commit implementation for cuckoo */
int soc_sbx_g2p3_cuckoo_commit(int unit, int runlength)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_CUCKOO_ID];
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    void *cs = td->cstate;

    return soc_sbx_g2p3_em32_commit_ext(unit, cs, runlength);
}

/*
 * Entry accessor implementations for left
 */

void soc_sbx_g2p3_left_t_init(
    soc_sbx_g2p3_left_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_left_t));
}

/* entry pack accessor implementation for left */
int soc_sbx_g2p3_left_pack(int unit,
    soc_sbx_g2p3_left_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LEFT_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) e->pay; break;
        case 1: p = (uint8 *) &e->key; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for left */
int soc_sbx_g2p3_left_unpack(int unit,
                soc_sbx_g2p3_left_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LEFT_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) e->pay; break;
        case 1: p = (uint8 *) &e->key; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for left */
int soc_sbx_g2p3_left_index_check(int unit,
                int *vindex,
                int ili)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LEFT_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ili; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for left */
int soc_sbx_g2p3_left_entry_check(int unit,
                soc_sbx_g2p3_left_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LEFT_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->pay[0]; break;
        case 1: ev = e->key; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* left table size get */
int soc_sbx_g2p3_left_entry_table_size_get(int unit,
                int *tsize,
                int ili)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LEFT_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ili; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for left */
int soc_sbx_g2p3_left_set(int unit,
                int ili,
                soc_sbx_g2p3_left_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LEFT_ID];

    s = soc_sbx_g2p3_left_index_check(unit, key,
                ili);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_left_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_left_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for left */
int soc_sbx_g2p3_left_get(int unit,
                int ili,
                soc_sbx_g2p3_left_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LEFT_ID];

    s = soc_sbx_g2p3_left_index_check(unit, key,
                ili);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_left_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for right
 */

void soc_sbx_g2p3_right_t_init(
    soc_sbx_g2p3_right_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_right_t));
}

/* entry pack accessor implementation for right */
int soc_sbx_g2p3_right_pack(int unit,
    soc_sbx_g2p3_right_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RIGHT_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) e->pay; break;
        case 1: p = (uint8 *) &e->key; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for right */
int soc_sbx_g2p3_right_unpack(int unit,
                soc_sbx_g2p3_right_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RIGHT_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) e->pay; break;
        case 1: p = (uint8 *) &e->key; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for right */
int soc_sbx_g2p3_right_index_check(int unit,
                int *vindex,
                int iri)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RIGHT_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iri; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for right */
int soc_sbx_g2p3_right_entry_check(int unit,
                soc_sbx_g2p3_right_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RIGHT_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->pay[0]; break;
        case 1: ev = e->key; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* right table size get */
int soc_sbx_g2p3_right_entry_table_size_get(int unit,
                int *tsize,
                int iri)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RIGHT_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = iri; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for right */
int soc_sbx_g2p3_right_set(int unit,
                int iri,
                soc_sbx_g2p3_right_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RIGHT_ID];

    s = soc_sbx_g2p3_right_index_check(unit, key,
                iri);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_right_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_right_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for right */
int soc_sbx_g2p3_right_get(int unit,
                int iri,
                soc_sbx_g2p3_right_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RIGHT_ID];

    s = soc_sbx_g2p3_right_index_check(unit, key,
                iri);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_right_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for outerlabelcuckoo
 */

void soc_sbx_g2p3_outerlabelcuckoo_t_init(
    soc_sbx_g2p3_outerlabelcuckoo_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_outerlabelcuckoo_t));
}

/* entry pack accessor implementation for outerlabelcuckoo */
int soc_sbx_g2p3_outerlabelcuckoo_pack(int unit,
    soc_sbx_g2p3_outerlabelcuckoo_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OUTERLABELCUCKOO_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) e->pay; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for outerlabelcuckoo */
int soc_sbx_g2p3_outerlabelcuckoo_unpack(int unit,
                soc_sbx_g2p3_outerlabelcuckoo_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OUTERLABELCUCKOO_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) e->pay; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for outerlabelcuckoo */
int soc_sbx_g2p3_outerlabelcuckoo_index_check(int unit,
                int *vindex,
                int ikey,
                int itype)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OUTERLABELCUCKOO_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = 1;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (psize - 1);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ikey; break;
        case 1: p = (uint8 *) &itype; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry index unpack for outerlabelcuckoo */
int soc_sbx_g2p3_outerlabelcuckoo_index_unpack(int unit,
                int *vindex,
                int *ikey,
                int *itype)
{
    int i, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OUTERLABELCUCKOO_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int be = tm->behost;
    int pkbe = 1;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);

    p0 = ((uint8 *) vindex) + (psize - 1);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
	fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) ikey; break;
        case 1: p = (uint8 *) itype; break;
        default: return SOC_E_INTERNAL;
        }
        sal_memset(p, 0, width <= 32 ? (int) sizeof(int) : (width + 7) / 8);
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe =
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT 
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_extract(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for outerlabelcuckoo */
int soc_sbx_g2p3_outerlabelcuckoo_entry_check(int unit,
                soc_sbx_g2p3_outerlabelcuckoo_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OUTERLABELCUCKOO_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->pay[0]; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for outerlabelcuckoo */
int soc_sbx_g2p3_outerlabelcuckoo_set(int unit,
                int ikey,
                int itype,
                soc_sbx_g2p3_outerlabelcuckoo_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_outerlabelcuckoo_index_check(unit, key,
                ikey,
                itype);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_outerlabelcuckoo_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_outerlabelcuckoo_update(unit,
                ikey,
                itype,
                e);
    if (s == SOC_E_NOT_FOUND) {
        s = soc_sbx_g2p3_outerlabelcuckoo_add(unit,
                ikey,
                itype,
                e);
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_outerlabelcuckoo_commit(unit, 0xffffffff);
    }

    return s;
}

/* entry add accessor implementation for outerlabelcuckoo */
int soc_sbx_g2p3_outerlabelcuckoo_add(int unit,
                int ikey,
                int itype,
                soc_sbx_g2p3_outerlabelcuckoo_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OUTERLABELCUCKOO_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_outerlabelcuckoo_index_check(unit, key,
                ikey,
                itype);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_outerlabelcuckoo_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_outerlabelcuckoo_pack(unit,
                  e, epacked, ed->epsize);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_em32_add_ext(unit, cs,
                (uint8 *) key,
                epacked);

    return s;
}

/* entry get accessor implementation for outerlabelcuckoo */
int soc_sbx_g2p3_outerlabelcuckoo_get(int unit,
                int ikey,
                int itype,
                soc_sbx_g2p3_outerlabelcuckoo_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OUTERLABELCUCKOO_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_outerlabelcuckoo_index_check(unit, key,
                ikey,
                itype);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_em32_get_ext(unit, cs,
                (uint8 *) key,
                epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_outerlabelcuckoo_unpack(unit,
                    e, epacked, ed->epsize);

    return s;
}

/* entry update accessor implementation for outerlabelcuckoo */
int soc_sbx_g2p3_outerlabelcuckoo_update(int unit,
                int ikey,
                int itype,
                soc_sbx_g2p3_outerlabelcuckoo_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_outerlabelcuckoo_index_check(unit, key,
                ikey,
                itype);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_outerlabelcuckoo_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_outerlabelcuckoo_renew(unit,
                ikey,
                itype,
                e);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_outerlabelcuckoo_commit(unit, 0xffffffff);

    return s;
}

/* entry renew accessor implementation for outerlabelcuckoo */
int soc_sbx_g2p3_outerlabelcuckoo_renew(int unit,
                int ikey,
                int itype,
                soc_sbx_g2p3_outerlabelcuckoo_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OUTERLABELCUCKOO_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_outerlabelcuckoo_index_check(unit, key,
                ikey,
                itype);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_outerlabelcuckoo_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_outerlabelcuckoo_pack(unit,
                  e, epacked, ed->epsize);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_em32_renew_ext(unit, cs,
                (uint8 *) key,
                epacked);

    return s;
}

/* entry delete accessor implementation for outerlabelcuckoo */
int soc_sbx_g2p3_outerlabelcuckoo_delete(int unit,
                int ikey,
                int itype)
{
    int s, key[32];

    s = soc_sbx_g2p3_outerlabelcuckoo_index_check(unit, key,
                ikey,
                itype);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_outerlabelcuckoo_remove(unit,
                ikey,
                itype);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_outerlabelcuckoo_commit(unit, 0xffffffff);

    return s;
}

/* entry remove accessor implementation for outerlabelcuckoo */
int soc_sbx_g2p3_outerlabelcuckoo_remove(int unit,
                int ikey,
                int itype)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OUTERLABELCUCKOO_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_outerlabelcuckoo_index_check(unit, key,
                ikey,
                itype);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_em32_remove_ext(unit, cs,
                (uint8 *) key);

    return s;
}

/* Get the first element of outerlabelcuckoo */
int soc_sbx_g2p3_outerlabelcuckoo_first(int unit,
                int *nikey,
                int *nitype)
{
    int s;
    int nkey[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OUTERLABELCUCKOO_ID];
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    void *cs = td->cstate;

    s = soc_sbx_g2p3_em32_first_ext(unit, cs,
                (uint8 *) nkey);
    if (!s) {
        soc_sbx_g2p3_outerlabelcuckoo_index_unpack(unit, nkey,
                nikey,
                nitype);
    }
    return s;
}

/* Get the next element of outerlabelcuckoo */
int soc_sbx_g2p3_outerlabelcuckoo_next(int unit,
                int ikey,
                int itype,
                int *nikey,
                int *nitype)
{
    int key[32], s;
    int nkey[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OUTERLABELCUCKOO_ID];
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    void *cs = td->cstate;

    s = soc_sbx_g2p3_outerlabelcuckoo_index_check(unit, key,
                ikey,
                itype);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_em32_next_ext(unit, cs,
                (uint8 *) key,
                (uint8 *) nkey);
    if (!s) {
        soc_sbx_g2p3_outerlabelcuckoo_index_unpack(unit, nkey,
                nikey,
                nitype);
    }
    return s;
}

/* Batch commit implementation for outerlabelcuckoo */
int soc_sbx_g2p3_outerlabelcuckoo_commit(int unit, int runlength)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OUTERLABELCUCKOO_ID];
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    void *cs = td->cstate;

    return soc_sbx_g2p3_em32_commit_ext(unit, cs, runlength);
}

/*
 * Entry accessor implementations for outerlabelleft
 */

void soc_sbx_g2p3_outerlabelleft_t_init(
    soc_sbx_g2p3_outerlabelleft_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_outerlabelleft_t));
}

/* entry pack accessor implementation for outerlabelleft */
int soc_sbx_g2p3_outerlabelleft_pack(int unit,
    soc_sbx_g2p3_outerlabelleft_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OUTERLABELLEFT_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) e->pay; break;
        case 1: p = (uint8 *) &e->key; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for outerlabelleft */
int soc_sbx_g2p3_outerlabelleft_unpack(int unit,
                soc_sbx_g2p3_outerlabelleft_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OUTERLABELLEFT_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) e->pay; break;
        case 1: p = (uint8 *) &e->key; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for outerlabelleft */
int soc_sbx_g2p3_outerlabelleft_index_check(int unit,
                int *vindex,
                int ili)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OUTERLABELLEFT_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ili; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for outerlabelleft */
int soc_sbx_g2p3_outerlabelleft_entry_check(int unit,
                soc_sbx_g2p3_outerlabelleft_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OUTERLABELLEFT_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->pay[0]; break;
        case 1: ev = e->key; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* outerlabelleft table size get */
int soc_sbx_g2p3_outerlabelleft_entry_table_size_get(int unit,
                int *tsize,
                int ili)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OUTERLABELLEFT_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ili; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for outerlabelleft */
int soc_sbx_g2p3_outerlabelleft_set(int unit,
                int ili,
                soc_sbx_g2p3_outerlabelleft_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OUTERLABELLEFT_ID];

    s = soc_sbx_g2p3_outerlabelleft_index_check(unit, key,
                ili);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_outerlabelleft_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_outerlabelleft_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for outerlabelleft */
int soc_sbx_g2p3_outerlabelleft_get(int unit,
                int ili,
                soc_sbx_g2p3_outerlabelleft_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OUTERLABELLEFT_ID];

    s = soc_sbx_g2p3_outerlabelleft_index_check(unit, key,
                ili);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_outerlabelleft_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for outerlabelright
 */

void soc_sbx_g2p3_outerlabelright_t_init(
    soc_sbx_g2p3_outerlabelright_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_outerlabelright_t));
}

/* entry pack accessor implementation for outerlabelright */
int soc_sbx_g2p3_outerlabelright_pack(int unit,
    soc_sbx_g2p3_outerlabelright_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OUTERLABELRIGHT_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) e->pay; break;
        case 1: p = (uint8 *) &e->key; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for outerlabelright */
int soc_sbx_g2p3_outerlabelright_unpack(int unit,
                soc_sbx_g2p3_outerlabelright_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OUTERLABELRIGHT_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) e->pay; break;
        case 1: p = (uint8 *) &e->key; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for outerlabelright */
int soc_sbx_g2p3_outerlabelright_index_check(int unit,
                int *vindex,
                int iri)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OUTERLABELRIGHT_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iri; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for outerlabelright */
int soc_sbx_g2p3_outerlabelright_entry_check(int unit,
                soc_sbx_g2p3_outerlabelright_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OUTERLABELRIGHT_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->pay[0]; break;
        case 1: ev = e->key; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* outerlabelright table size get */
int soc_sbx_g2p3_outerlabelright_entry_table_size_get(int unit,
                int *tsize,
                int iri)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OUTERLABELRIGHT_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = iri; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for outerlabelright */
int soc_sbx_g2p3_outerlabelright_set(int unit,
                int iri,
                soc_sbx_g2p3_outerlabelright_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OUTERLABELRIGHT_ID];

    s = soc_sbx_g2p3_outerlabelright_index_check(unit, key,
                iri);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_outerlabelright_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_outerlabelright_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for outerlabelright */
int soc_sbx_g2p3_outerlabelright_get(int unit,
                int iri,
                soc_sbx_g2p3_outerlabelright_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OUTERLABELRIGHT_ID];

    s = soc_sbx_g2p3_outerlabelright_index_check(unit, key,
                iri);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_outerlabelright_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for innerlabelcuckoo
 */

void soc_sbx_g2p3_innerlabelcuckoo_t_init(
    soc_sbx_g2p3_innerlabelcuckoo_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_innerlabelcuckoo_t));
}

/* entry pack accessor implementation for innerlabelcuckoo */
int soc_sbx_g2p3_innerlabelcuckoo_pack(int unit,
    soc_sbx_g2p3_innerlabelcuckoo_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_INNERLABELCUCKOO_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) e->pay; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for innerlabelcuckoo */
int soc_sbx_g2p3_innerlabelcuckoo_unpack(int unit,
                soc_sbx_g2p3_innerlabelcuckoo_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_INNERLABELCUCKOO_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) e->pay; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for innerlabelcuckoo */
int soc_sbx_g2p3_innerlabelcuckoo_index_check(int unit,
                int *vindex,
                int ikey,
                int itype)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_INNERLABELCUCKOO_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = 1;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (psize - 1);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ikey; break;
        case 1: p = (uint8 *) &itype; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry index unpack for innerlabelcuckoo */
int soc_sbx_g2p3_innerlabelcuckoo_index_unpack(int unit,
                int *vindex,
                int *ikey,
                int *itype)
{
    int i, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_INNERLABELCUCKOO_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int be = tm->behost;
    int pkbe = 1;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);

    p0 = ((uint8 *) vindex) + (psize - 1);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
	fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) ikey; break;
        case 1: p = (uint8 *) itype; break;
        default: return SOC_E_INTERNAL;
        }
        sal_memset(p, 0, width <= 32 ? (int) sizeof(int) : (width + 7) / 8);
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe =
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT 
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_extract(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for innerlabelcuckoo */
int soc_sbx_g2p3_innerlabelcuckoo_entry_check(int unit,
                soc_sbx_g2p3_innerlabelcuckoo_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_INNERLABELCUCKOO_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->pay[0]; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for innerlabelcuckoo */
int soc_sbx_g2p3_innerlabelcuckoo_set(int unit,
                int ikey,
                int itype,
                soc_sbx_g2p3_innerlabelcuckoo_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_innerlabelcuckoo_index_check(unit, key,
                ikey,
                itype);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_innerlabelcuckoo_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_innerlabelcuckoo_update(unit,
                ikey,
                itype,
                e);
    if (s == SOC_E_NOT_FOUND) {
        s = soc_sbx_g2p3_innerlabelcuckoo_add(unit,
                ikey,
                itype,
                e);
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_innerlabelcuckoo_commit(unit, 0xffffffff);
    }

    return s;
}

/* entry add accessor implementation for innerlabelcuckoo */
int soc_sbx_g2p3_innerlabelcuckoo_add(int unit,
                int ikey,
                int itype,
                soc_sbx_g2p3_innerlabelcuckoo_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_INNERLABELCUCKOO_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_innerlabelcuckoo_index_check(unit, key,
                ikey,
                itype);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_innerlabelcuckoo_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_innerlabelcuckoo_pack(unit,
                  e, epacked, ed->epsize);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_em32_add_ext(unit, cs,
                (uint8 *) key,
                epacked);

    return s;
}

/* entry get accessor implementation for innerlabelcuckoo */
int soc_sbx_g2p3_innerlabelcuckoo_get(int unit,
                int ikey,
                int itype,
                soc_sbx_g2p3_innerlabelcuckoo_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_INNERLABELCUCKOO_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_innerlabelcuckoo_index_check(unit, key,
                ikey,
                itype);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_em32_get_ext(unit, cs,
                (uint8 *) key,
                epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_innerlabelcuckoo_unpack(unit,
                    e, epacked, ed->epsize);

    return s;
}

/* entry update accessor implementation for innerlabelcuckoo */
int soc_sbx_g2p3_innerlabelcuckoo_update(int unit,
                int ikey,
                int itype,
                soc_sbx_g2p3_innerlabelcuckoo_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_innerlabelcuckoo_index_check(unit, key,
                ikey,
                itype);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_innerlabelcuckoo_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_innerlabelcuckoo_renew(unit,
                ikey,
                itype,
                e);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_innerlabelcuckoo_commit(unit, 0xffffffff);

    return s;
}

/* entry renew accessor implementation for innerlabelcuckoo */
int soc_sbx_g2p3_innerlabelcuckoo_renew(int unit,
                int ikey,
                int itype,
                soc_sbx_g2p3_innerlabelcuckoo_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_INNERLABELCUCKOO_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_innerlabelcuckoo_index_check(unit, key,
                ikey,
                itype);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_innerlabelcuckoo_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_innerlabelcuckoo_pack(unit,
                  e, epacked, ed->epsize);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_em32_renew_ext(unit, cs,
                (uint8 *) key,
                epacked);

    return s;
}

/* entry delete accessor implementation for innerlabelcuckoo */
int soc_sbx_g2p3_innerlabelcuckoo_delete(int unit,
                int ikey,
                int itype)
{
    int s, key[32];

    s = soc_sbx_g2p3_innerlabelcuckoo_index_check(unit, key,
                ikey,
                itype);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_innerlabelcuckoo_remove(unit,
                ikey,
                itype);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_innerlabelcuckoo_commit(unit, 0xffffffff);

    return s;
}

/* entry remove accessor implementation for innerlabelcuckoo */
int soc_sbx_g2p3_innerlabelcuckoo_remove(int unit,
                int ikey,
                int itype)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_INNERLABELCUCKOO_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_innerlabelcuckoo_index_check(unit, key,
                ikey,
                itype);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_em32_remove_ext(unit, cs,
                (uint8 *) key);

    return s;
}

/* Get the first element of innerlabelcuckoo */
int soc_sbx_g2p3_innerlabelcuckoo_first(int unit,
                int *nikey,
                int *nitype)
{
    int s;
    int nkey[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_INNERLABELCUCKOO_ID];
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    void *cs = td->cstate;

    s = soc_sbx_g2p3_em32_first_ext(unit, cs,
                (uint8 *) nkey);
    if (!s) {
        soc_sbx_g2p3_innerlabelcuckoo_index_unpack(unit, nkey,
                nikey,
                nitype);
    }
    return s;
}

/* Get the next element of innerlabelcuckoo */
int soc_sbx_g2p3_innerlabelcuckoo_next(int unit,
                int ikey,
                int itype,
                int *nikey,
                int *nitype)
{
    int key[32], s;
    int nkey[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_INNERLABELCUCKOO_ID];
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    void *cs = td->cstate;

    s = soc_sbx_g2p3_innerlabelcuckoo_index_check(unit, key,
                ikey,
                itype);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_em32_next_ext(unit, cs,
                (uint8 *) key,
                (uint8 *) nkey);
    if (!s) {
        soc_sbx_g2p3_innerlabelcuckoo_index_unpack(unit, nkey,
                nikey,
                nitype);
    }
    return s;
}

/* Batch commit implementation for innerlabelcuckoo */
int soc_sbx_g2p3_innerlabelcuckoo_commit(int unit, int runlength)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_INNERLABELCUCKOO_ID];
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    void *cs = td->cstate;

    return soc_sbx_g2p3_em32_commit_ext(unit, cs, runlength);
}

/*
 * Entry accessor implementations for innerlabelleft
 */

void soc_sbx_g2p3_innerlabelleft_t_init(
    soc_sbx_g2p3_innerlabelleft_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_innerlabelleft_t));
}

/* entry pack accessor implementation for innerlabelleft */
int soc_sbx_g2p3_innerlabelleft_pack(int unit,
    soc_sbx_g2p3_innerlabelleft_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_INNERLABELLEFT_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) e->pay; break;
        case 1: p = (uint8 *) &e->key; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for innerlabelleft */
int soc_sbx_g2p3_innerlabelleft_unpack(int unit,
                soc_sbx_g2p3_innerlabelleft_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_INNERLABELLEFT_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) e->pay; break;
        case 1: p = (uint8 *) &e->key; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for innerlabelleft */
int soc_sbx_g2p3_innerlabelleft_index_check(int unit,
                int *vindex,
                int ili)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_INNERLABELLEFT_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ili; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for innerlabelleft */
int soc_sbx_g2p3_innerlabelleft_entry_check(int unit,
                soc_sbx_g2p3_innerlabelleft_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_INNERLABELLEFT_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->pay[0]; break;
        case 1: ev = e->key; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* innerlabelleft table size get */
int soc_sbx_g2p3_innerlabelleft_entry_table_size_get(int unit,
                int *tsize,
                int ili)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_INNERLABELLEFT_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ili; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for innerlabelleft */
int soc_sbx_g2p3_innerlabelleft_set(int unit,
                int ili,
                soc_sbx_g2p3_innerlabelleft_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_INNERLABELLEFT_ID];

    s = soc_sbx_g2p3_innerlabelleft_index_check(unit, key,
                ili);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_innerlabelleft_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_innerlabelleft_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for innerlabelleft */
int soc_sbx_g2p3_innerlabelleft_get(int unit,
                int ili,
                soc_sbx_g2p3_innerlabelleft_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_INNERLABELLEFT_ID];

    s = soc_sbx_g2p3_innerlabelleft_index_check(unit, key,
                ili);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_innerlabelleft_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for innerlabelright
 */

void soc_sbx_g2p3_innerlabelright_t_init(
    soc_sbx_g2p3_innerlabelright_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_innerlabelright_t));
}

/* entry pack accessor implementation for innerlabelright */
int soc_sbx_g2p3_innerlabelright_pack(int unit,
    soc_sbx_g2p3_innerlabelright_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_INNERLABELRIGHT_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) e->pay; break;
        case 1: p = (uint8 *) &e->key; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for innerlabelright */
int soc_sbx_g2p3_innerlabelright_unpack(int unit,
                soc_sbx_g2p3_innerlabelright_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_INNERLABELRIGHT_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) e->pay; break;
        case 1: p = (uint8 *) &e->key; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for innerlabelright */
int soc_sbx_g2p3_innerlabelright_index_check(int unit,
                int *vindex,
                int iri)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_INNERLABELRIGHT_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iri; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for innerlabelright */
int soc_sbx_g2p3_innerlabelright_entry_check(int unit,
                soc_sbx_g2p3_innerlabelright_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_INNERLABELRIGHT_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->pay[0]; break;
        case 1: ev = e->key; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* innerlabelright table size get */
int soc_sbx_g2p3_innerlabelright_entry_table_size_get(int unit,
                int *tsize,
                int iri)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_INNERLABELRIGHT_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = iri; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for innerlabelright */
int soc_sbx_g2p3_innerlabelright_set(int unit,
                int iri,
                soc_sbx_g2p3_innerlabelright_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_INNERLABELRIGHT_ID];

    s = soc_sbx_g2p3_innerlabelright_index_check(unit, key,
                iri);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_innerlabelright_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_innerlabelright_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for innerlabelright */
int soc_sbx_g2p3_innerlabelright_get(int unit,
                int iri,
                soc_sbx_g2p3_innerlabelright_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_INNERLABELRIGHT_ID];

    s = soc_sbx_g2p3_innerlabelright_index_check(unit, key,
                iri);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_innerlabelright_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for label2e
 */

void soc_sbx_g2p3_label2e_t_init(
    soc_sbx_g2p3_label2e_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_label2e_t));
}

/* entry size function for label2e */
int soc_sbx_g2p3_label2e_size(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LABEL2E_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];

    return (eb->width + (eb->stridebits - 1)) / eb->stridebits;
}

/* entry pack accessor implementation for label2e */
int soc_sbx_g2p3_label2e_pack(int unit,
    soc_sbx_g2p3_label2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LABEL2E_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->vlan; break;
        case 1: if ((e->vlan==0)) {
                     p = (uint8 *) &e->ftidx0;
                 }else{
                     continue;
                 }
                 break;
        case 2: p = (uint8 *) &e->opcode; break;
        case 3: p = (uint8 *) &e->lpidx; break;
        case 4: p = (uint8 *) &e->cos; break;
        case 5: p = (uint8 *) &e->loopback; break;
        case 6: p = (uint8 *) &e->vpws; break;
        case 7: p = (uint8 *) &e->ftidx1; break;
        case 8: p = (uint8 *) &e->stpstate; break;
        case 9: p = (uint8 *) &e->elsp; break;
        case 10: p = (uint8 *) &e->pipe; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for label2e */
int soc_sbx_g2p3_label2e_unpack(int unit,
                soc_sbx_g2p3_label2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LABEL2E_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->vlan; break;
        case 1: p = (uint8 *) &e->ftidx0; break;
        case 2: p = (uint8 *) &e->opcode; break;
        case 3: p = (uint8 *) &e->lpidx; break;
        case 4: p = (uint8 *) &e->cos; break;
        case 5: p = (uint8 *) &e->loopback; break;
        case 6: p = (uint8 *) &e->vpws; break;
        case 7: p = (uint8 *) &e->ftidx1; break;
        case 8: p = (uint8 *) &e->stpstate; break;
        case 9: p = (uint8 *) &e->elsp; break;
        case 10: p = (uint8 *) &e->pipe; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for label2e */
int soc_sbx_g2p3_label2e_index_check(int unit,
                int *vindex,
                int ilabel)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LABEL2E_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ilabel; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry index unpack for label2e */
int soc_sbx_g2p3_label2e_index_unpack(int unit,
                int *vindex,
                int *ilabel)
{
    int i, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LABEL2E_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int be = tm->behost;
    int pkbe = be;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
	fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) ilabel; break;
        default: return SOC_E_INTERNAL;
        }
        sal_memset(p, 0, width <= 32 ? (int) sizeof(int) : (width + 7) / 8);
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe =
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT 
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_extract(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for label2e */
int soc_sbx_g2p3_label2e_entry_check(int unit,
                soc_sbx_g2p3_label2e_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LABEL2E_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->vlan; break;
        case 1: ev = e->ftidx0; break;
        case 2: ev = e->opcode; break;
        case 3: ev = e->lpidx; break;
        case 4: ev = e->cos; break;
        case 5: ev = e->loopback; break;
        case 6: ev = e->vpws; break;
        case 7: ev = e->ftidx1; break;
        case 8: ev = e->stpstate; break;
        case 9: ev = e->elsp; break;
        case 10: ev = e->pipe; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for label2e */
int soc_sbx_g2p3_label2e_set(int unit,
                int ilabel,
                soc_sbx_g2p3_label2e_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_label2e_index_check(unit, key,
                ilabel);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_label2e_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_label2e_update(unit,
                ilabel,
                e);
    if (s == SOC_E_NOT_FOUND) {
        s = soc_sbx_g2p3_label2e_add(unit,
                ilabel,
                e);
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_label2e_commit(unit, 0xffffffff);
    }

    return s;
}

/* entry add accessor implementation for label2e */
int soc_sbx_g2p3_label2e_add(int unit,
                int ilabel,
                soc_sbx_g2p3_label2e_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LABEL2E_ID];

    s = soc_sbx_g2p3_label2e_index_check(unit, key,
                ilabel);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_label2e_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_label2e_pack(unit,
                  e, epacked, ed->epsize);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_label2e_add_ext(unit,
                (uint8 *) key,
                epacked);

    return s;
}

/* entry get accessor implementation for label2e */
int soc_sbx_g2p3_label2e_get(int unit,
                int ilabel,
                soc_sbx_g2p3_label2e_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LABEL2E_ID];

    s = soc_sbx_g2p3_label2e_index_check(unit, key,
                ilabel);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_label2e_get_ext(unit,
                (uint8 *) key,
                epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_label2e_unpack(unit,
                    e, epacked, ed->epsize);

    return s;
}

/* entry update accessor implementation for label2e */
int soc_sbx_g2p3_label2e_update(int unit,
                int ilabel,
                soc_sbx_g2p3_label2e_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_label2e_index_check(unit, key,
                ilabel);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_label2e_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_label2e_renew(unit,
                ilabel,
                e);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_label2e_commit(unit, 0xffffffff);

    return s;
}

/* entry renew accessor implementation for label2e */
int soc_sbx_g2p3_label2e_renew(int unit,
                int ilabel,
                soc_sbx_g2p3_label2e_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LABEL2E_ID];

    s = soc_sbx_g2p3_label2e_index_check(unit, key,
                ilabel);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_label2e_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_label2e_pack(unit,
                  e, epacked, ed->epsize);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_label2e_renew_ext(unit,
                (uint8 *) key,
                epacked);

    return s;
}

/* entry delete accessor implementation for label2e */
int soc_sbx_g2p3_label2e_delete(int unit,
                int ilabel)
{
    int s, key[32];

    s = soc_sbx_g2p3_label2e_index_check(unit, key,
                ilabel);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_label2e_remove(unit,
                ilabel);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_label2e_commit(unit, 0xffffffff);

    return s;
}

/* entry remove accessor implementation for label2e */
int soc_sbx_g2p3_label2e_remove(int unit,
                int ilabel)
{
    int s, key[32];

    s = soc_sbx_g2p3_label2e_index_check(unit, key,
                ilabel);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_label2e_remove_ext(unit,
                (uint8 *) key);

    return s;
}

/* Get the first element of label2e */
int soc_sbx_g2p3_label2e_first(int unit,
                int *nilabel)
{
    int s;
    int nkey[32];

    s = soc_sbx_g2p3_label2e_first_ext(unit,
                (uint8 *) nkey);
    if (!s) {
        soc_sbx_g2p3_label2e_index_unpack(unit, nkey,
                nilabel);
    }
    return s;
}

/* Get the next element of label2e */
int soc_sbx_g2p3_label2e_next(int unit,
                int ilabel,
                int *nilabel)
{
    int key[32], s;
    int nkey[32];

    s = soc_sbx_g2p3_label2e_index_check(unit, key,
                ilabel);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_label2e_next_ext(unit,
                (uint8 *) key,
                (uint8 *) nkey);
    if (!s) {
        soc_sbx_g2p3_label2e_index_unpack(unit, nkey,
                nilabel);
    }
    return s;
}

/* Batch commit implementation for label2e */
int soc_sbx_g2p3_label2e_commit(int unit, int runlength)
{
    return soc_sbx_g2p3_label2e_commit_ext(unit, runlength);
}

/*
 * Entry accessor implementations for tagged_mpls
 */

void soc_sbx_g2p3_tagged_mpls_t_init(
    soc_sbx_g2p3_tagged_mpls_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_tagged_mpls_t));
}

/* entry size function for tagged_mpls */
int soc_sbx_g2p3_tagged_mpls_size(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_TAGGED_MPLS_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];

    return (eb->width + (eb->stridebits - 1)) / eb->stridebits;
}

/* entry pack accessor implementation for tagged_mpls */
int soc_sbx_g2p3_tagged_mpls_pack(int unit,
    soc_sbx_g2p3_tagged_mpls_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_TAGGED_MPLS_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->valid; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for tagged_mpls */
int soc_sbx_g2p3_tagged_mpls_unpack(int unit,
                soc_sbx_g2p3_tagged_mpls_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_TAGGED_MPLS_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->valid; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for tagged_mpls */
int soc_sbx_g2p3_tagged_mpls_index_check(int unit,
                int *vindex,
                int irule)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_TAGGED_MPLS_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &irule; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for tagged_mpls */
int soc_sbx_g2p3_tagged_mpls_entry_check(int unit,
                soc_sbx_g2p3_tagged_mpls_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_TAGGED_MPLS_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->valid; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for tagged_mpls */
int soc_sbx_g2p3_tagged_mpls_set(int unit,
                int irule,
                soc_sbx_g2p3_tagged_mpls_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_tagged_mpls_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_tagged_mpls_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_tagged_mpls_set_ext(unit,
                irule,
                e);

    return s;
}

/* entry get accessor implementation for tagged_mpls */
int soc_sbx_g2p3_tagged_mpls_get(int unit,
                int irule,
                soc_sbx_g2p3_tagged_mpls_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_tagged_mpls_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_tagged_mpls_get_ext(unit,
                irule,
                e);

    return s;
}

/*
 * Entry accessor implementations for v2e
 */

void soc_sbx_g2p3_v2e_t_init(
    soc_sbx_g2p3_v2e_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_v2e_t));
}

/* entry pack accessor implementation for v2e */
int soc_sbx_g2p3_v2e_pack(int unit,
    soc_sbx_g2p3_v2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_V2E_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->pim; break;
        case 1: p = (uint8 *) &e->igmp; break;
        case 2: p = (uint8 *) &e->forceflood; break;
        case 3: p = (uint8 *) &e->dropunksmac; break;
        case 4: p = (uint8 *) &e->dontlearn; break;
        case 5: p = (uint8 *) &e->vrf; break;
        case 6: p = (uint8 *) &e->v6mcmode; break;
        case 7: p = (uint8 *) &e->v4mcmode; break;
        case 8: p = (uint8 *) &e->laghash; break;
        case 9: p = (uint8 *) &e->v4route; break;
        case 10: p = (uint8 *) &e->v6route; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for v2e */
int soc_sbx_g2p3_v2e_unpack(int unit,
                soc_sbx_g2p3_v2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_V2E_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->pim; break;
        case 1: p = (uint8 *) &e->igmp; break;
        case 2: p = (uint8 *) &e->forceflood; break;
        case 3: p = (uint8 *) &e->dropunksmac; break;
        case 4: p = (uint8 *) &e->dontlearn; break;
        case 5: p = (uint8 *) &e->vrf; break;
        case 6: p = (uint8 *) &e->v6mcmode; break;
        case 7: p = (uint8 *) &e->v4mcmode; break;
        case 8: p = (uint8 *) &e->laghash; break;
        case 9: p = (uint8 *) &e->v4route; break;
        case 10: p = (uint8 *) &e->v6route; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for v2e */
int soc_sbx_g2p3_v2e_index_check(int unit,
                int *vindex,
                int ivlan)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_V2E_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ivlan; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for v2e */
int soc_sbx_g2p3_v2e_entry_check(int unit,
                soc_sbx_g2p3_v2e_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_V2E_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->pim; break;
        case 1: ev = e->igmp; break;
        case 2: ev = e->forceflood; break;
        case 3: ev = e->dropunksmac; break;
        case 4: ev = e->dontlearn; break;
        case 5: ev = e->vrf; break;
        case 6: ev = e->v6mcmode; break;
        case 7: ev = e->v4mcmode; break;
        case 8: ev = e->laghash; break;
        case 9: ev = e->v4route; break;
        case 10: ev = e->v6route; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* v2e table size get */
int soc_sbx_g2p3_v2e_entry_table_size_get(int unit,
                int *tsize,
                int ivlan)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_V2E_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ivlan; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for v2e */
int soc_sbx_g2p3_v2e_set(int unit,
                int ivlan,
                soc_sbx_g2p3_v2e_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_V2E_ID];

    s = soc_sbx_g2p3_v2e_index_check(unit, key,
                ivlan);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_v2e_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_v2e_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}
int soc_sbx_g2p3_v2e_forceflood_fast_set(int unit,
                int ivlan,
                int eivlan,
                int *sets,
                uint32 *vs,
                int vcount)
{
    int startvindex, endvindex, s;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_V2E_ID];
    soc_sbx_g2p3_field_desc_t *fd =
        &ed->fields[2];

    s = soc_sbx_g2p3_v2e_index_check(unit, &startvindex,
                ivlan);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_v2e_index_check(unit, &endvindex,
                eivlan);
    if (s) {
        return s;
    }
    if (endvindex - startvindex >= vcount) {
        return SOC_E_PARAM;
    }

    s = soc_sbx_g2p3_entry_generic_fast_set(unit,
                  fd, ed, startvindex, endvindex, sets, vs);

    return s;
}

/* entry get accessor implementation for v2e */
int soc_sbx_g2p3_v2e_get(int unit,
                int ivlan,
                soc_sbx_g2p3_v2e_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_V2E_ID];

    s = soc_sbx_g2p3_v2e_index_check(unit, key,
                ivlan);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_v2e_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for v2e1
 */

void soc_sbx_g2p3_v2e1_t_init(
    soc_sbx_g2p3_v2e1_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_v2e1_t));
}

/* entry pack accessor implementation for v2e1 */
int soc_sbx_g2p3_v2e1_pack(int unit,
    soc_sbx_g2p3_v2e1_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_V2E1_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->vrid0; break;
        case 1: p = (uint8 *) &e->vrid1; break;
        case 2: p = (uint8 *) &e->vrid2; break;
        case 3: p = (uint8 *) &e->vrid3; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for v2e1 */
int soc_sbx_g2p3_v2e1_unpack(int unit,
                soc_sbx_g2p3_v2e1_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_V2E1_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->vrid0; break;
        case 1: p = (uint8 *) &e->vrid1; break;
        case 2: p = (uint8 *) &e->vrid2; break;
        case 3: p = (uint8 *) &e->vrid3; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for v2e1 */
int soc_sbx_g2p3_v2e1_index_check(int unit,
                int *vindex,
                int ivlan)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_V2E1_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ivlan; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for v2e1 */
int soc_sbx_g2p3_v2e1_entry_check(int unit,
                soc_sbx_g2p3_v2e1_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_V2E1_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->vrid0; break;
        case 1: ev = e->vrid1; break;
        case 2: ev = e->vrid2; break;
        case 3: ev = e->vrid3; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* v2e1 table size get */
int soc_sbx_g2p3_v2e1_entry_table_size_get(int unit,
                int *tsize,
                int ivlan)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_V2E1_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ivlan; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for v2e1 */
int soc_sbx_g2p3_v2e1_set(int unit,
                int ivlan,
                soc_sbx_g2p3_v2e1_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_V2E1_ID];

    s = soc_sbx_g2p3_v2e1_index_check(unit, key,
                ivlan);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_v2e1_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_v2e1_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for v2e1 */
int soc_sbx_g2p3_v2e1_get(int unit,
                int ivlan,
                soc_sbx_g2p3_v2e1_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_V2E1_ID];

    s = soc_sbx_g2p3_v2e1_index_check(unit, key,
                ivlan);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_v2e1_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for lp
 */

void soc_sbx_g2p3_lp_t_init(
    soc_sbx_g2p3_lp_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_lp_t));
}

/* entry pack accessor implementation for lp */
int soc_sbx_g2p3_lp_pack(int unit,
    soc_sbx_g2p3_lp_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LP_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->pid; break;
        case 1: p = (uint8 *) &e->qos; break;
        case 2: p = (uint8 *) &e->useexp; break;
        case 3: p = (uint8 *) &e->usedscp; break;
        case 4: p = (uint8 *) &e->updatefdp; break;
        case 5: p = (uint8 *) &e->mirror; break;
        case 6: p = (uint8 *) &e->updaterdp; break;
        case 7: p = (uint8 *) &e->policer; break;
        case 8: p = (uint8 *) &e->typedpolice; break;
        case 9: p = (uint8 *) &e->mefcos; break;
        case 10: p = (uint8 *) &e->mef; break;
        case 11: p = (uint8 *) &e->cocounter; break;
        case 12: p = (uint8 *) &e->priclass; break;
        case 13: p = (uint8 *) &e->allpri; break;
        case 14: p = (uint8 *) &e->xtpolreplace; break;
        case 15: p = (uint8 *) &e->counter; break;
        case 16: p = (uint8 *) &e->typedcount; break;
        case 17: p = (uint8 *) &e->color; break;
        case 18: p = (uint8 *) &e->usecolor; break;
        case 19: p = (uint8 *) &e->oamepi; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for lp */
int soc_sbx_g2p3_lp_unpack(int unit,
                soc_sbx_g2p3_lp_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LP_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->pid; break;
        case 1: p = (uint8 *) &e->qos; break;
        case 2: p = (uint8 *) &e->useexp; break;
        case 3: p = (uint8 *) &e->usedscp; break;
        case 4: p = (uint8 *) &e->updatefdp; break;
        case 5: p = (uint8 *) &e->mirror; break;
        case 6: p = (uint8 *) &e->updaterdp; break;
        case 7: p = (uint8 *) &e->policer; break;
        case 8: p = (uint8 *) &e->typedpolice; break;
        case 9: p = (uint8 *) &e->mefcos; break;
        case 10: p = (uint8 *) &e->mef; break;
        case 11: p = (uint8 *) &e->cocounter; break;
        case 12: p = (uint8 *) &e->priclass; break;
        case 13: p = (uint8 *) &e->allpri; break;
        case 14: p = (uint8 *) &e->xtpolreplace; break;
        case 15: p = (uint8 *) &e->counter; break;
        case 16: p = (uint8 *) &e->typedcount; break;
        case 17: p = (uint8 *) &e->color; break;
        case 18: p = (uint8 *) &e->usecolor; break;
        case 19: p = (uint8 *) &e->oamepi; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for lp */
int soc_sbx_g2p3_lp_index_check(int unit,
                int *vindex,
                int ilpi)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LP_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ilpi; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for lp */
int soc_sbx_g2p3_lp_entry_check(int unit,
                soc_sbx_g2p3_lp_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LP_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->pid; break;
        case 1: ev = e->qos; break;
        case 2: ev = e->useexp; break;
        case 3: ev = e->usedscp; break;
        case 4: ev = e->updatefdp; break;
        case 5: ev = e->mirror; break;
        case 6: ev = e->updaterdp; break;
        case 7: ev = e->policer; break;
        case 8: ev = e->typedpolice; break;
        case 9: ev = e->mefcos; break;
        case 10: ev = e->mef; break;
        case 11: ev = e->cocounter; break;
        case 12: ev = e->priclass; break;
        case 13: ev = e->allpri; break;
        case 14: ev = e->xtpolreplace; break;
        case 15: ev = e->counter; break;
        case 16: ev = e->typedcount; break;
        case 17: ev = e->color; break;
        case 18: ev = e->usecolor; break;
        case 19: ev = e->oamepi; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* lp table size get */
int soc_sbx_g2p3_lp_entry_table_size_get(int unit,
                int *tsize,
                int ilpi)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LP_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ilpi; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for lp */
int soc_sbx_g2p3_lp_set(int unit,
                int ilpi,
                soc_sbx_g2p3_lp_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LP_ID];

    s = soc_sbx_g2p3_lp_index_check(unit, key,
                ilpi);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_lp_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_lp_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

int soc_sbx_g2p3_lp_policer_fast_get(int unit,
                int ilpi,
                int eilpi,
                uint32 *vs,
                int vcount)
{
    int startvindex, endvindex, s;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LP_ID];
    soc_sbx_g2p3_field_desc_t *fd =
        &ed->fields[7];

    s = soc_sbx_g2p3_lp_index_check(unit, &startvindex,
                ilpi);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_lp_index_check(unit, &endvindex,
                eilpi);
    if (s) {
        return s;
    }

    if (endvindex - startvindex >= vcount) {
        return SOC_E_PARAM;
    }

    s = soc_sbx_g2p3_entry_generic_fast_get(unit,
                  fd, ed, startvindex, endvindex, vs);

    return s;
}

/* entry get accessor implementation for lp */
int soc_sbx_g2p3_lp_get(int unit,
                int ilpi,
                soc_sbx_g2p3_lp_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LP_ID];

    s = soc_sbx_g2p3_lp_index_check(unit, key,
                ilpi);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_lp_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for l2e
 */

void soc_sbx_g2p3_l2e_t_init(
    soc_sbx_g2p3_l2e_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_l2e_t));
}

/* entry pack accessor implementation for l2e */
int soc_sbx_g2p3_l2e_pack(int unit,
    soc_sbx_g2p3_l2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2E_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->vlan; break;
        case 1: p = (uint8 *) &e->stpstate; break;
        case 2: p = (uint8 *) &e->elsp; break;
        case 3: p = (uint8 *) &e->pipe; break;
        case 4: p = (uint8 *) &e->ftidx; break;
        case 5: p = (uint8 *) &e->oamen; break;
        case 6: p = (uint8 *) &e->leren; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for l2e */
int soc_sbx_g2p3_l2e_unpack(int unit,
                soc_sbx_g2p3_l2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2E_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->vlan; break;
        case 1: p = (uint8 *) &e->stpstate; break;
        case 2: p = (uint8 *) &e->elsp; break;
        case 3: p = (uint8 *) &e->pipe; break;
        case 4: p = (uint8 *) &e->ftidx; break;
        case 5: p = (uint8 *) &e->oamen; break;
        case 6: p = (uint8 *) &e->leren; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for l2e */
int soc_sbx_g2p3_l2e_index_check(int unit,
                int *vindex,
                int ilabel)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2E_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ilabel; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for l2e */
int soc_sbx_g2p3_l2e_entry_check(int unit,
                soc_sbx_g2p3_l2e_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2E_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->vlan; break;
        case 1: ev = e->stpstate; break;
        case 2: ev = e->elsp; break;
        case 3: ev = e->pipe; break;
        case 4: ev = e->ftidx; break;
        case 5: ev = e->oamen; break;
        case 6: ev = e->leren; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* l2e table size get */
int soc_sbx_g2p3_l2e_entry_table_size_get(int unit,
                int *tsize,
                int ilabel)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2E_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ilabel; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for l2e */
int soc_sbx_g2p3_l2e_set(int unit,
                int ilabel,
                soc_sbx_g2p3_l2e_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2E_ID];

    s = soc_sbx_g2p3_l2e_index_check(unit, key,
                ilabel);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_l2e_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_l2e_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for l2e */
int soc_sbx_g2p3_l2e_get(int unit,
                int ilabel,
                soc_sbx_g2p3_l2e_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2E_ID];

    s = soc_sbx_g2p3_l2e_index_check(unit, key,
                ilabel);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_l2e_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for l2cp
 */

void soc_sbx_g2p3_l2cp_t_init(
    soc_sbx_g2p3_l2cp_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_l2cp_t));
}

/* entry pack accessor implementation for l2cp */
int soc_sbx_g2p3_l2cp_pack(int unit,
    soc_sbx_g2p3_l2cp_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2CP_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->ftidx; break;
        case 1: p = (uint8 *) &e->forward; break;
        case 2: p = (uint8 *) &e->passstp; break;
        case 3: p = (uint8 *) &e->copy; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for l2cp */
int soc_sbx_g2p3_l2cp_unpack(int unit,
                soc_sbx_g2p3_l2cp_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2CP_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->ftidx; break;
        case 1: p = (uint8 *) &e->forward; break;
        case 2: p = (uint8 *) &e->passstp; break;
        case 3: p = (uint8 *) &e->copy; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for l2cp */
int soc_sbx_g2p3_l2cp_index_check(int unit,
                int *vindex,
                int ilsb,
                int iport)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2CP_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ilsb; break;
        case 1: p = (uint8 *) &iport; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for l2cp */
int soc_sbx_g2p3_l2cp_entry_check(int unit,
                soc_sbx_g2p3_l2cp_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2CP_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->ftidx; break;
        case 1: ev = e->forward; break;
        case 2: ev = e->passstp; break;
        case 3: ev = e->copy; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* l2cp table size get */
int soc_sbx_g2p3_l2cp_entry_table_size_get(int unit,
                int *tsize,
                int ilsb,
                int iport)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2CP_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ilsb; break;
        case 1: v = iport; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for l2cp */
int soc_sbx_g2p3_l2cp_set(int unit,
                int ilsb,
                int iport,
                soc_sbx_g2p3_l2cp_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2CP_ID];

    s = soc_sbx_g2p3_l2cp_index_check(unit, key,
                ilsb,
                iport);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_l2cp_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_l2cp_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for l2cp */
int soc_sbx_g2p3_l2cp_get(int unit,
                int ilsb,
                int iport,
                soc_sbx_g2p3_l2cp_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2CP_ID];

    s = soc_sbx_g2p3_l2cp_index_check(unit, key,
                ilsb,
                iport);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_l2cp_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for l2cpslow
 */

void soc_sbx_g2p3_l2cpslow_t_init(
    soc_sbx_g2p3_l2cpslow_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_l2cpslow_t));
}

/* entry pack accessor implementation for l2cpslow */
int soc_sbx_g2p3_l2cpslow_pack(int unit,
    soc_sbx_g2p3_l2cpslow_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2CPSLOW_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->ftidx; break;
        case 1: p = (uint8 *) &e->forward; break;
        case 2: p = (uint8 *) &e->passstp; break;
        case 3: p = (uint8 *) &e->copy; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for l2cpslow */
int soc_sbx_g2p3_l2cpslow_unpack(int unit,
                soc_sbx_g2p3_l2cpslow_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2CPSLOW_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->ftidx; break;
        case 1: p = (uint8 *) &e->forward; break;
        case 2: p = (uint8 *) &e->passstp; break;
        case 3: p = (uint8 *) &e->copy; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for l2cpslow */
int soc_sbx_g2p3_l2cpslow_index_check(int unit,
                int *vindex,
                int isubcode,
                int iport)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2CPSLOW_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &isubcode; break;
        case 1: p = (uint8 *) &iport; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for l2cpslow */
int soc_sbx_g2p3_l2cpslow_entry_check(int unit,
                soc_sbx_g2p3_l2cpslow_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2CPSLOW_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->ftidx; break;
        case 1: ev = e->forward; break;
        case 2: ev = e->passstp; break;
        case 3: ev = e->copy; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* l2cpslow table size get */
int soc_sbx_g2p3_l2cpslow_entry_table_size_get(int unit,
                int *tsize,
                int isubcode,
                int iport)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2CPSLOW_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = isubcode; break;
        case 1: v = iport; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for l2cpslow */
int soc_sbx_g2p3_l2cpslow_set(int unit,
                int isubcode,
                int iport,
                soc_sbx_g2p3_l2cpslow_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2CPSLOW_ID];

    s = soc_sbx_g2p3_l2cpslow_index_check(unit, key,
                isubcode,
                iport);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_l2cpslow_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_l2cpslow_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for l2cpslow */
int soc_sbx_g2p3_l2cpslow_get(int unit,
                int isubcode,
                int iport,
                soc_sbx_g2p3_l2cpslow_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2CPSLOW_ID];

    s = soc_sbx_g2p3_l2cpslow_index_check(unit, key,
                isubcode,
                iport);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_l2cpslow_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for l2cpnop
 */

void soc_sbx_g2p3_l2cpnop_t_init(
    soc_sbx_g2p3_l2cpnop_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_l2cpnop_t));
}

/* entry pack accessor implementation for l2cpnop */
int soc_sbx_g2p3_l2cpnop_pack(int unit,
    soc_sbx_g2p3_l2cpnop_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2CPNOP_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->ftidx; break;
        case 1: p = (uint8 *) &e->forward; break;
        case 2: p = (uint8 *) &e->passstp; break;
        case 3: p = (uint8 *) &e->copy; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for l2cpnop */
int soc_sbx_g2p3_l2cpnop_unpack(int unit,
                soc_sbx_g2p3_l2cpnop_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2CPNOP_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->ftidx; break;
        case 1: p = (uint8 *) &e->forward; break;
        case 2: p = (uint8 *) &e->passstp; break;
        case 3: p = (uint8 *) &e->copy; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for l2cpnop */
int soc_sbx_g2p3_l2cpnop_index_check(int unit,
                int *vindex,
                int ii)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2CPNOP_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ii; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for l2cpnop */
int soc_sbx_g2p3_l2cpnop_entry_check(int unit,
                soc_sbx_g2p3_l2cpnop_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2CPNOP_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->ftidx; break;
        case 1: ev = e->forward; break;
        case 2: ev = e->passstp; break;
        case 3: ev = e->copy; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* l2cpnop table size get */
int soc_sbx_g2p3_l2cpnop_entry_table_size_get(int unit,
                int *tsize,
                int ii)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2CPNOP_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ii; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for l2cpnop */
int soc_sbx_g2p3_l2cpnop_set(int unit,
                int ii,
                soc_sbx_g2p3_l2cpnop_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2CPNOP_ID];

    s = soc_sbx_g2p3_l2cpnop_index_check(unit, key,
                ii);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_l2cpnop_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_l2cpnop_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for l2cpnop */
int soc_sbx_g2p3_l2cpnop_get(int unit,
                int ii,
                soc_sbx_g2p3_l2cpnop_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2CPNOP_ID];

    s = soc_sbx_g2p3_l2cpnop_index_check(unit, key,
                ii);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_l2cpnop_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for ft
 */

void soc_sbx_g2p3_ft_t_init(
    soc_sbx_g2p3_ft_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ft_t));
}

/* entry pack accessor implementation for ft */
int soc_sbx_g2p3_ft_pack(int unit,
    soc_sbx_g2p3_ft_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_FT_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->rridx; break;
        case 1: p = (uint8 *) &e->excidx; break;
        case 2: p = (uint8 *) &e->lenadj; break;
        case 3: p = (uint8 *) &e->mc; break;
        case 4: p = (uint8 *) &e->t; break;
        case 5: p = (uint8 *) &e->hc; break;
        case 6: p = (uint8 *) &e->oi; break;
        case 7: if ((e->lag==0)) {
                     p = (uint8 *) &e->qid;
                 }else{
                     continue;
                 }
                 break;
        case 8: if ((e->lag==1)) {
                     p = (uint8 *) &e->lagbase;
                 }else{
                     continue;
                 }
                 break;
        case 9: if ((e->lag==1)) {
                     p = (uint8 *) &e->lagsize;
                 }else{
                     continue;
                 }
                 break;
        case 10: p = (uint8 *) &e->lag; break;
        case 11: p = (uint8 *) &e->oib; break;
        case 12: if ((e->lagb==0)) {
                     p = (uint8 *) &e->qidb;
                 }else{
                     continue;
                 }
                 break;
        case 13: if ((e->lagb==1)) {
                     p = (uint8 *) &e->lagbaseb;
                 }else{
                     continue;
                 }
                 break;
        case 14: if ((e->lagb==1)) {
                     p = (uint8 *) &e->lagsizeb;
                 }else{
                     continue;
                 }
                 break;
        case 15: p = (uint8 *) &e->lagb; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ft */
int soc_sbx_g2p3_ft_unpack(int unit,
                soc_sbx_g2p3_ft_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_FT_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->rridx; break;
        case 1: p = (uint8 *) &e->excidx; break;
        case 2: p = (uint8 *) &e->lenadj; break;
        case 3: p = (uint8 *) &e->mc; break;
        case 4: p = (uint8 *) &e->t; break;
        case 5: p = (uint8 *) &e->hc; break;
        case 6: p = (uint8 *) &e->oi; break;
        case 7: p = (uint8 *) &e->qid; break;
        case 8: p = (uint8 *) &e->lagbase; break;
        case 9: p = (uint8 *) &e->lagsize; break;
        case 10: p = (uint8 *) &e->lag; break;
        case 11: p = (uint8 *) &e->oib; break;
        case 12: p = (uint8 *) &e->qidb; break;
        case 13: p = (uint8 *) &e->lagbaseb; break;
        case 14: p = (uint8 *) &e->lagsizeb; break;
        case 15: p = (uint8 *) &e->lagb; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ft */
int soc_sbx_g2p3_ft_index_check(int unit,
                int *vindex,
                int ifti)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_FT_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ifti; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ft */
int soc_sbx_g2p3_ft_entry_check(int unit,
                soc_sbx_g2p3_ft_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_FT_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->rridx; break;
        case 1: ev = e->excidx; break;
        case 2: ev = e->lenadj; break;
        case 3: ev = e->mc; break;
        case 4: ev = e->t; break;
        case 5: ev = e->hc; break;
        case 6: ev = e->oi; break;
        case 7: ev = e->qid; break;
        case 8: ev = e->lagbase; break;
        case 9: ev = e->lagsize; break;
        case 10: ev = e->lag; break;
        case 11: ev = e->oib; break;
        case 12: ev = e->qidb; break;
        case 13: ev = e->lagbaseb; break;
        case 14: ev = e->lagsizeb; break;
        case 15: ev = e->lagb; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* ft table size get */
int soc_sbx_g2p3_ft_entry_table_size_get(int unit,
                int *tsize,
                int ifti)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_FT_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ifti; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for ft */
int soc_sbx_g2p3_ft_set(int unit,
                int ifti,
                soc_sbx_g2p3_ft_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_FT_ID];

    s = soc_sbx_g2p3_ft_index_check(unit, key,
                ifti);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ft_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_ft_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for ft */
int soc_sbx_g2p3_ft_get(int unit,
                int ifti,
                soc_sbx_g2p3_ft_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_FT_ID];

    s = soc_sbx_g2p3_ft_index_check(unit, key,
                ifti);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_ft_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for OamTimerCalendar
 */

void soc_sbx_g2p3_oamtimercalendar_t_init(
    soc_sbx_g2p3_oamtimercalendar_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_oamtimercalendar_t));
}

/* entry pack accessor implementation for OamTimerCalendar */
int soc_sbx_g2p3_oamtimercalendar_pack(int unit,
    soc_sbx_g2p3_oamtimercalendar_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMTIMERCALENDAR_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->endpointPtr; break;
        case 1: p = (uint8 *) &e->xmitPeriod; break;
        case 2: p = (uint8 *) &e->xmitCount; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for OamTimerCalendar */
int soc_sbx_g2p3_oamtimercalendar_unpack(int unit,
                soc_sbx_g2p3_oamtimercalendar_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMTIMERCALENDAR_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->endpointPtr; break;
        case 1: p = (uint8 *) &e->xmitPeriod; break;
        case 2: p = (uint8 *) &e->xmitCount; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for OamTimerCalendar */
int soc_sbx_g2p3_oamtimercalendar_index_check(int unit,
                int *vindex,
                int ilistmgrindex)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMTIMERCALENDAR_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ilistmgrindex; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for OamTimerCalendar */
int soc_sbx_g2p3_oamtimercalendar_entry_check(int unit,
                soc_sbx_g2p3_oamtimercalendar_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMTIMERCALENDAR_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->endpointPtr; break;
        case 1: ev = e->xmitPeriod; break;
        case 2: ev = e->xmitCount; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* OamTimerCalendar table size get */
int soc_sbx_g2p3_oamtimercalendar_entry_table_size_get(int unit,
                int *tsize,
                int ilistmgrindex)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMTIMERCALENDAR_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ilistmgrindex; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for OamTimerCalendar */
int soc_sbx_g2p3_oamtimercalendar_set(int unit,
                int ilistmgrindex,
                soc_sbx_g2p3_oamtimercalendar_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMTIMERCALENDAR_ID];

    s = soc_sbx_g2p3_oamtimercalendar_index_check(unit, key,
                ilistmgrindex);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_oamtimercalendar_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_oamtimercalendar_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for OamTimerCalendar */
int soc_sbx_g2p3_oamtimercalendar_get(int unit,
                int ilistmgrindex,
                soc_sbx_g2p3_oamtimercalendar_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMTIMERCALENDAR_ID];

    s = soc_sbx_g2p3_oamtimercalendar_index_check(unit, key,
                ilistmgrindex);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_oamtimercalendar_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for OamPortMdLevel2Etc
 */

void soc_sbx_g2p3_oamportmdlevel2etc_t_init(
    soc_sbx_g2p3_oamportmdlevel2etc_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_oamportmdlevel2etc_t));
    e->fwd = 0x1;
}

/* entry pack accessor implementation for OamPortMdLevel2Etc */
int soc_sbx_g2p3_oamportmdlevel2etc_pack(int unit,
    soc_sbx_g2p3_oamportmdlevel2etc_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMPORTMDLEVEL2ETC_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->valid; break;
        case 1: p = (uint8 *) &e->fwd; break;
        case 2: p = (uint8 *) &e->epIdx; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for OamPortMdLevel2Etc */
int soc_sbx_g2p3_oamportmdlevel2etc_unpack(int unit,
                soc_sbx_g2p3_oamportmdlevel2etc_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMPORTMDLEVEL2ETC_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->valid; break;
        case 1: p = (uint8 *) &e->fwd; break;
        case 2: p = (uint8 *) &e->epIdx; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for OamPortMdLevel2Etc */
int soc_sbx_g2p3_oamportmdlevel2etc_index_check(int unit,
                int *vindex,
                int iportmd)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMPORTMDLEVEL2ETC_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iportmd; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for OamPortMdLevel2Etc */
int soc_sbx_g2p3_oamportmdlevel2etc_entry_check(int unit,
                soc_sbx_g2p3_oamportmdlevel2etc_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMPORTMDLEVEL2ETC_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->valid; break;
        case 1: ev = e->fwd; break;
        case 2: ev = e->epIdx; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* OamPortMdLevel2Etc table size get */
int soc_sbx_g2p3_oamportmdlevel2etc_entry_table_size_get(int unit,
                int *tsize,
                int iportmd)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMPORTMDLEVEL2ETC_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = iportmd; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for OamPortMdLevel2Etc */
int soc_sbx_g2p3_oamportmdlevel2etc_set(int unit,
                int iportmd,
                soc_sbx_g2p3_oamportmdlevel2etc_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMPORTMDLEVEL2ETC_ID];

    s = soc_sbx_g2p3_oamportmdlevel2etc_index_check(unit, key,
                iportmd);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_oamportmdlevel2etc_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_oamportmdlevel2etc_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for OamPortMdLevel2Etc */
int soc_sbx_g2p3_oamportmdlevel2etc_get(int unit,
                int iportmd,
                soc_sbx_g2p3_oamportmdlevel2etc_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMPORTMDLEVEL2ETC_ID];

    s = soc_sbx_g2p3_oamportmdlevel2etc_index_check(unit, key,
                iportmd);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_oamportmdlevel2etc_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for v4uc_str_sel
 */

void soc_sbx_g2p3_v4uc_str_sel_t_init(
    soc_sbx_g2p3_v4uc_str_sel_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_v4uc_str_sel_t));
}

/* entry size function for v4uc_str_sel */
int soc_sbx_g2p3_v4uc_str_sel_size(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_V4UC_STR_SEL_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];

    return (eb->width + (eb->stridebits - 1)) / eb->stridebits;
}

/* entry pack accessor implementation for v4uc_str_sel */
int soc_sbx_g2p3_v4uc_str_sel_pack(int unit,
    soc_sbx_g2p3_v4uc_str_sel_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_V4UC_STR_SEL_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->valid; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for v4uc_str_sel */
int soc_sbx_g2p3_v4uc_str_sel_unpack(int unit,
                soc_sbx_g2p3_v4uc_str_sel_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_V4UC_STR_SEL_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->valid; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for v4uc_str_sel */
int soc_sbx_g2p3_v4uc_str_sel_index_check(int unit,
                int *vindex,
                int irule)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_V4UC_STR_SEL_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &irule; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for v4uc_str_sel */
int soc_sbx_g2p3_v4uc_str_sel_entry_check(int unit,
                soc_sbx_g2p3_v4uc_str_sel_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_V4UC_STR_SEL_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->valid; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for v4uc_str_sel */
int soc_sbx_g2p3_v4uc_str_sel_set(int unit,
                int irule,
                soc_sbx_g2p3_v4uc_str_sel_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_v4uc_str_sel_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_v4uc_str_sel_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_v4uc_str_sel_set_ext(unit,
                irule,
                e);

    return s;
}

/* entry get accessor implementation for v4uc_str_sel */
int soc_sbx_g2p3_v4uc_str_sel_get(int unit,
                int irule,
                soc_sbx_g2p3_v4uc_str_sel_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_v4uc_str_sel_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_v4uc_str_sel_get_ext(unit,
                irule,
                e);

    return s;
}

/*
 * Entry accessor implementations for cmac
 */

void soc_sbx_g2p3_cmac_t_init(
    soc_sbx_g2p3_cmac_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_cmac_t));
}

/* entry size function for cmac */
int soc_sbx_g2p3_cmac_size(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_CMAC_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];

    return (eb->width + (eb->stridebits - 1)) / eb->stridebits;
}

/* entry pack accessor implementation for cmac */
int soc_sbx_g2p3_cmac_pack(int unit,
    soc_sbx_g2p3_cmac_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_CMAC_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->age; break;
        case 1: p = (uint8 *) &e->pid; break;
        case 2: p = (uint8 *) &e->dcopy; break;
        case 3: p = (uint8 *) &e->dcopycos; break;
        case 4: p = (uint8 *) &e->ddrop; break;
        case 5: p = (uint8 *) &e->sdrop; break;
        case 6: p = (uint8 *) &e->dontage; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for cmac */
int soc_sbx_g2p3_cmac_unpack(int unit,
                soc_sbx_g2p3_cmac_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_CMAC_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->age; break;
        case 1: p = (uint8 *) &e->pid; break;
        case 2: p = (uint8 *) &e->dcopy; break;
        case 3: p = (uint8 *) &e->dcopycos; break;
        case 4: p = (uint8 *) &e->ddrop; break;
        case 5: p = (uint8 *) &e->sdrop; break;
        case 6: p = (uint8 *) &e->dontage; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for cmac */
int soc_sbx_g2p3_cmac_index_check(int unit,
                int *vindex,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_CMAC_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) imac; break;
        case 1: p = (uint8 *) &ivlan; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for cmac */
int soc_sbx_g2p3_cmac_entry_check(int unit,
                soc_sbx_g2p3_cmac_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_CMAC_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->age; break;
        case 1: ev = e->pid; break;
        case 2: ev = e->dcopy; break;
        case 3: ev = e->dcopycos; break;
        case 4: ev = e->ddrop; break;
        case 5: ev = e->sdrop; break;
        case 6: ev = e->dontage; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for cmac */
int soc_sbx_g2p3_cmac_set(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan,
                soc_sbx_g2p3_cmac_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_cmac_index_check(unit, key,
                imac,
                ivlan);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_cmac_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_cmac_update(unit,
                imac,
                ivlan,
                e);
    if (s == SOC_E_NOT_FOUND) {
        s = soc_sbx_g2p3_cmac_add(unit,
                imac,
                ivlan,
                e);
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_cmac_commit(unit, 0xffffffff);
    }

    return s;
}

/* entry add accessor implementation for cmac */
int soc_sbx_g2p3_cmac_add(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan,
                soc_sbx_g2p3_cmac_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_cmac_index_check(unit, key,
                imac,
                ivlan);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_cmac_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_cmac_add_ext(unit,
                imac,
                ivlan,
                e);

    return s;
}

/* entry get accessor implementation for cmac */
int soc_sbx_g2p3_cmac_get(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan,
                soc_sbx_g2p3_cmac_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_cmac_index_check(unit, key,
                imac,
                ivlan);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_cmac_get_ext(unit,
                imac,
                ivlan,
                e);

    return s;
}

/* entry update accessor implementation for cmac */
int soc_sbx_g2p3_cmac_update(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan,
                soc_sbx_g2p3_cmac_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_cmac_index_check(unit, key,
                imac,
                ivlan);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_cmac_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_cmac_update_ext(unit,
                imac,
                ivlan,
                e);

    return s;
}

/* entry delete accessor implementation for cmac */
int soc_sbx_g2p3_cmac_delete(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan)
{
    int s, key[32];

    s = soc_sbx_g2p3_cmac_index_check(unit, key,
                imac,
                ivlan);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_cmac_remove(unit,
                imac,
                ivlan);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_cmac_commit(unit, 0xffffffff);

    return s;
}

/* entry remove accessor implementation for cmac */
int soc_sbx_g2p3_cmac_remove(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan)
{
    int s, key[32];

    s = soc_sbx_g2p3_cmac_index_check(unit, key,
                imac,
                ivlan);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_cmac_remove_ext(unit,
                imac,
                ivlan);

    return s;
}

/* Get the first element of cmac */
int soc_sbx_g2p3_cmac_first(int unit,
                soc_sbx_g2p3_6_byte_t nimac,
                int *nivlan)
{
    return soc_sbx_g2p3_cmac_first_ext(unit,
                nimac,
                nivlan);
}

/* Get the next element of cmac */
int soc_sbx_g2p3_cmac_next(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan,
                soc_sbx_g2p3_6_byte_t nimac,
                int *nivlan)
{
    int key[32], s;

    s = soc_sbx_g2p3_cmac_index_check(unit, key,
                imac,
                ivlan);
    if (s) {
        return s;
    }

    return soc_sbx_g2p3_cmac_next_ext(unit,
                imac,
                ivlan,
                nimac,
                nivlan);
}

/* Batch commit implementation for cmac */
int soc_sbx_g2p3_cmac_commit(int unit, int runlength)
{
    return soc_sbx_g2p3_cmac_commit_ext(unit, runlength);
}

/*
 * Entry accessor implementations for bmac
 */

void soc_sbx_g2p3_bmac_t_init(
    soc_sbx_g2p3_bmac_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_bmac_t));
}

/* entry size function for bmac */
int soc_sbx_g2p3_bmac_size(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_BMAC_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];

    return (eb->width + (eb->stridebits - 1)) / eb->stridebits;
}

/* entry pack accessor implementation for bmac */
int soc_sbx_g2p3_bmac_pack(int unit,
    soc_sbx_g2p3_bmac_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_BMAC_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->bsdrop; break;
        case 1: p = (uint8 *) &e->bpid; break;
        case 2: p = (uint8 *) &e->btid; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for bmac */
int soc_sbx_g2p3_bmac_unpack(int unit,
                soc_sbx_g2p3_bmac_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_BMAC_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->bsdrop; break;
        case 1: p = (uint8 *) &e->bpid; break;
        case 2: p = (uint8 *) &e->btid; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for bmac */
int soc_sbx_g2p3_bmac_index_check(int unit,
                int *vindex,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_BMAC_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) imac; break;
        case 1: p = (uint8 *) &ivlan; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for bmac */
int soc_sbx_g2p3_bmac_entry_check(int unit,
                soc_sbx_g2p3_bmac_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_BMAC_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->bsdrop; break;
        case 1: ev = e->bpid; break;
        case 2: ev = e->btid; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for bmac */
int soc_sbx_g2p3_bmac_set(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan,
                soc_sbx_g2p3_bmac_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_bmac_index_check(unit, key,
                imac,
                ivlan);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_bmac_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_bmac_update(unit,
                imac,
                ivlan,
                e);
    if (s == SOC_E_NOT_FOUND) {
        s = soc_sbx_g2p3_bmac_add(unit,
                imac,
                ivlan,
                e);
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_bmac_commit(unit, 0xffffffff);
    }

    return s;
}

/* entry add accessor implementation for bmac */
int soc_sbx_g2p3_bmac_add(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan,
                soc_sbx_g2p3_bmac_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_bmac_index_check(unit, key,
                imac,
                ivlan);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_bmac_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_bmac_add_ext(unit,
                imac,
                ivlan,
                e);

    return s;
}

/* entry get accessor implementation for bmac */
int soc_sbx_g2p3_bmac_get(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan,
                soc_sbx_g2p3_bmac_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_bmac_index_check(unit, key,
                imac,
                ivlan);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_bmac_get_ext(unit,
                imac,
                ivlan,
                e);

    return s;
}

/* entry update accessor implementation for bmac */
int soc_sbx_g2p3_bmac_update(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan,
                soc_sbx_g2p3_bmac_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_bmac_index_check(unit, key,
                imac,
                ivlan);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_bmac_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_bmac_update_ext(unit,
                imac,
                ivlan,
                e);

    return s;
}

/* entry delete accessor implementation for bmac */
int soc_sbx_g2p3_bmac_delete(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan)
{
    int s, key[32];

    s = soc_sbx_g2p3_bmac_index_check(unit, key,
                imac,
                ivlan);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_bmac_remove(unit,
                imac,
                ivlan);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_bmac_commit(unit, 0xffffffff);

    return s;
}

/* entry remove accessor implementation for bmac */
int soc_sbx_g2p3_bmac_remove(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan)
{
    int s, key[32];

    s = soc_sbx_g2p3_bmac_index_check(unit, key,
                imac,
                ivlan);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_bmac_remove_ext(unit,
                imac,
                ivlan);

    return s;
}

/* Get the first element of bmac */
int soc_sbx_g2p3_bmac_first(int unit,
                soc_sbx_g2p3_6_byte_t nimac,
                int *nivlan)
{
    return soc_sbx_g2p3_bmac_first_ext(unit,
                nimac,
                nivlan);
}

/* Get the next element of bmac */
int soc_sbx_g2p3_bmac_next(int unit,
                soc_sbx_g2p3_6_byte_t imac,
                int ivlan,
                soc_sbx_g2p3_6_byte_t nimac,
                int *nivlan)
{
    int key[32], s;

    s = soc_sbx_g2p3_bmac_index_check(unit, key,
                imac,
                ivlan);
    if (s) {
        return s;
    }

    return soc_sbx_g2p3_bmac_next_ext(unit,
                imac,
                ivlan,
                nimac,
                nivlan);
}

/* Batch commit implementation for bmac */
int soc_sbx_g2p3_bmac_commit(int unit, int runlength)
{
    return soc_sbx_g2p3_bmac_commit_ext(unit, runlength);
}

/*
 * Entry accessor implementations for ipv6mcsg
 */

void soc_sbx_g2p3_ipv6mcsg_t_init(
    soc_sbx_g2p3_ipv6mcsg_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ipv6mcsg_t));
}

/* entry pack accessor implementation for ipv6mcsg */
int soc_sbx_g2p3_ipv6mcsg_pack(int unit,
    soc_sbx_g2p3_ipv6mcsg_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCSG_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->ftidx; break;
        case 1: p = (uint8 *) &e->rpfunion; break;
        case 2: p = (uint8 *) &e->proccopy; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ipv6mcsg */
int soc_sbx_g2p3_ipv6mcsg_unpack(int unit,
                soc_sbx_g2p3_ipv6mcsg_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCSG_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->ftidx; break;
        case 1: p = (uint8 *) &e->rpfunion; break;
        case 2: p = (uint8 *) &e->proccopy; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ipv6mcsg */
int soc_sbx_g2p3_ipv6mcsg_index_check(int unit,
                int *vindex,
                soc_sbx_g2p3_16_byte_t ig,
                soc_sbx_g2p3_16_byte_t is,
                int ivlan)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCSG_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = 0;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) ig; break;
        case 1: p = (uint8 *) is; break;
        case 2: p = (uint8 *) &ivlan; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry index unpack for ipv6mcsg */
int soc_sbx_g2p3_ipv6mcsg_index_unpack(int unit,
                int *vindex,
                soc_sbx_g2p3_16_byte_t ig,
                soc_sbx_g2p3_16_byte_t is,
                int *ivlan)
{
    int i, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCSG_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int be = tm->behost;
    int pkbe = 0;

    p0 = ((uint8 *) vindex);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
	fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) ig; break;
        case 1: p = (uint8 *) is; break;
        case 2: p = (uint8 *) ivlan; break;
        default: return SOC_E_INTERNAL;
        }
        sal_memset(p, 0, width <= 32 ? (int) sizeof(int) : (width + 7) / 8);
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe =
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT 
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_extract(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ipv6mcsg */
int soc_sbx_g2p3_ipv6mcsg_entry_check(int unit,
                soc_sbx_g2p3_ipv6mcsg_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCSG_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->ftidx; break;
        case 1: ev = e->rpfunion; break;
        case 2: ev = e->proccopy; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for ipv6mcsg */
int soc_sbx_g2p3_ipv6mcsg_set(int unit,
                soc_sbx_g2p3_16_byte_t ig,
                soc_sbx_g2p3_16_byte_t is,
                int ivlan,
                soc_sbx_g2p3_ipv6mcsg_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_ipv6mcsg_index_check(unit, key,
                ig,
                is,
                ivlan);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv6mcsg_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv6mcsg_update(unit,
                ig,
                is,
                ivlan,
                e);
    if (s == SOC_E_NOT_FOUND) {
        s = soc_sbx_g2p3_ipv6mcsg_add(unit,
                ig,
                is,
                ivlan,
                e);
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ipv6mcsg_commit(unit, 0xffffffff);
    }

    return s;
}

/* entry add accessor implementation for ipv6mcsg */
int soc_sbx_g2p3_ipv6mcsg_add(int unit,
                soc_sbx_g2p3_16_byte_t ig,
                soc_sbx_g2p3_16_byte_t is,
                int ivlan,
                soc_sbx_g2p3_ipv6mcsg_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCSG_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_ipv6mcsg_index_check(unit, key,
                ig,
                is,
                ivlan);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv6mcsg_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv6mcsg_pack(unit,
                  e, epacked, ed->epsize);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_eml_add_ext(unit, cs,
                (uint8 *) key,
                epacked);

    return s;
}

/* entry get accessor implementation for ipv6mcsg */
int soc_sbx_g2p3_ipv6mcsg_get(int unit,
                soc_sbx_g2p3_16_byte_t ig,
                soc_sbx_g2p3_16_byte_t is,
                int ivlan,
                soc_sbx_g2p3_ipv6mcsg_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCSG_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_ipv6mcsg_index_check(unit, key,
                ig,
                is,
                ivlan);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_eml_get_ext(unit, cs,
                (uint8 *) key,
                epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv6mcsg_unpack(unit,
                    e, epacked, ed->epsize);

    return s;
}

/* entry update accessor implementation for ipv6mcsg */
int soc_sbx_g2p3_ipv6mcsg_update(int unit,
                soc_sbx_g2p3_16_byte_t ig,
                soc_sbx_g2p3_16_byte_t is,
                int ivlan,
                soc_sbx_g2p3_ipv6mcsg_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCSG_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_ipv6mcsg_index_check(unit, key,
                ig,
                is,
                ivlan);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv6mcsg_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv6mcsg_pack(unit,
                  e, epacked, ed->epsize);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_eml_update_ext(unit, cs,
                (uint8 *) key,
                epacked);

    return s;
}

/* entry delete accessor implementation for ipv6mcsg */
int soc_sbx_g2p3_ipv6mcsg_delete(int unit,
                soc_sbx_g2p3_16_byte_t ig,
                soc_sbx_g2p3_16_byte_t is,
                int ivlan)
{
    int s, key[32];

    s = soc_sbx_g2p3_ipv6mcsg_index_check(unit, key,
                ig,
                is,
                ivlan);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv6mcsg_remove(unit,
                ig,
                is,
                ivlan);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv6mcsg_commit(unit, 0xffffffff);

    return s;
}

/* entry remove accessor implementation for ipv6mcsg */
int soc_sbx_g2p3_ipv6mcsg_remove(int unit,
                soc_sbx_g2p3_16_byte_t ig,
                soc_sbx_g2p3_16_byte_t is,
                int ivlan)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCSG_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_ipv6mcsg_index_check(unit, key,
                ig,
                is,
                ivlan);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_eml_remove_ext(unit, cs,
                (uint8 *) key);

    return s;
}

/* Get the first element of ipv6mcsg */
int soc_sbx_g2p3_ipv6mcsg_first(int unit,
                soc_sbx_g2p3_16_byte_t nig,
                soc_sbx_g2p3_16_byte_t nis,
                int *nivlan)
{
    int s;
    int nkey[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCSG_ID];
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    void *cs = td->cstate;

    s = soc_sbx_g2p3_eml_first_ext(unit, cs,
                (uint8 *) nkey);
    if (!s) {
        soc_sbx_g2p3_ipv6mcsg_index_unpack(unit, nkey,
                nig,
                nis,
                nivlan);
    }
    return s;
}

/* Get the next element of ipv6mcsg */
int soc_sbx_g2p3_ipv6mcsg_next(int unit,
                soc_sbx_g2p3_16_byte_t ig,
                soc_sbx_g2p3_16_byte_t is,
                int ivlan,
                soc_sbx_g2p3_16_byte_t nig,
                soc_sbx_g2p3_16_byte_t nis,
                int *nivlan)
{
    int key[32], s;
    int nkey[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCSG_ID];
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    void *cs = td->cstate;

    s = soc_sbx_g2p3_ipv6mcsg_index_check(unit, key,
                ig,
                is,
                ivlan);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_eml_next_ext(unit, cs,
                (uint8 *) key,
                (uint8 *) nkey);
    if (!s) {
        soc_sbx_g2p3_ipv6mcsg_index_unpack(unit, nkey,
                nig,
                nis,
                nivlan);
    }
    return s;
}

/* Batch commit implementation for ipv6mcsg */
int soc_sbx_g2p3_ipv6mcsg_commit(int unit, int runlength)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCSG_ID];
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    void *cs = td->cstate;

    return soc_sbx_g2p3_eml_commit_ext(unit, cs, runlength);
}

/*
 * Entry accessor implementations for ipv6mcsgl1
 */

void soc_sbx_g2p3_ipv6mcsgl1_t_init(
    soc_sbx_g2p3_ipv6mcsgl1_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ipv6mcsgl1_t));
}

/* entry pack accessor implementation for ipv6mcsgl1 */
int soc_sbx_g2p3_ipv6mcsgl1_pack(int unit,
    soc_sbx_g2p3_ipv6mcsgl1_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCSGL1_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->usemap; break;
        case 1: p = (uint8 *) &e->pointer; break;
        case 2: p = (uint8 *) &e->salt; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ipv6mcsgl1 */
int soc_sbx_g2p3_ipv6mcsgl1_unpack(int unit,
                soc_sbx_g2p3_ipv6mcsgl1_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCSGL1_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->usemap; break;
        case 1: p = (uint8 *) &e->pointer; break;
        case 2: p = (uint8 *) &e->salt; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ipv6mcsgl1 */
int soc_sbx_g2p3_ipv6mcsgl1_index_check(int unit,
                int *vindex,
                int il1i)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCSGL1_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &il1i; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ipv6mcsgl1 */
int soc_sbx_g2p3_ipv6mcsgl1_entry_check(int unit,
                soc_sbx_g2p3_ipv6mcsgl1_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCSGL1_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->usemap; break;
        case 1: ev = e->pointer; break;
        case 2: ev = e->salt; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* ipv6mcsgl1 table size get */
int soc_sbx_g2p3_ipv6mcsgl1_entry_table_size_get(int unit,
                int *tsize,
                int il1i)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCSGL1_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = il1i; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for ipv6mcsgl1 */
int soc_sbx_g2p3_ipv6mcsgl1_set(int unit,
                int il1i,
                soc_sbx_g2p3_ipv6mcsgl1_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCSGL1_ID];

    s = soc_sbx_g2p3_ipv6mcsgl1_index_check(unit, key,
                il1i);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv6mcsgl1_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_ipv6mcsgl1_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for ipv6mcsgl1 */
int soc_sbx_g2p3_ipv6mcsgl1_get(int unit,
                int il1i,
                soc_sbx_g2p3_ipv6mcsgl1_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCSGL1_ID];

    s = soc_sbx_g2p3_ipv6mcsgl1_index_check(unit, key,
                il1i);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_ipv6mcsgl1_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for ipv6mcsgl2
 */

void soc_sbx_g2p3_ipv6mcsgl2_t_init(
    soc_sbx_g2p3_ipv6mcsgl2_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ipv6mcsgl2_t));
}

/* entry pack accessor implementation for ipv6mcsgl2 */
int soc_sbx_g2p3_ipv6mcsgl2_pack(int unit,
    soc_sbx_g2p3_ipv6mcsgl2_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCSGL2_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) e->g; break;
        case 1: p = (uint8 *) e->s; break;
        case 2: p = (uint8 *) &e->vlan; break;
        case 3: p = (uint8 *) &e->proccopy; break;
        case 4: p = (uint8 *) &e->ftidx; break;
        case 5: p = (uint8 *) &e->rpfunion; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ipv6mcsgl2 */
int soc_sbx_g2p3_ipv6mcsgl2_unpack(int unit,
                soc_sbx_g2p3_ipv6mcsgl2_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCSGL2_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) e->g; break;
        case 1: p = (uint8 *) e->s; break;
        case 2: p = (uint8 *) &e->vlan; break;
        case 3: p = (uint8 *) &e->proccopy; break;
        case 4: p = (uint8 *) &e->ftidx; break;
        case 5: p = (uint8 *) &e->rpfunion; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ipv6mcsgl2 */
int soc_sbx_g2p3_ipv6mcsgl2_index_check(int unit,
                int *vindex,
                int imcgi)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCSGL2_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &imcgi; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ipv6mcsgl2 */
int soc_sbx_g2p3_ipv6mcsgl2_entry_check(int unit,
                soc_sbx_g2p3_ipv6mcsgl2_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCSGL2_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->g[0]; break;
        case 1: ev = e->s[0]; break;
        case 2: ev = e->vlan; break;
        case 3: ev = e->proccopy; break;
        case 4: ev = e->ftidx; break;
        case 5: ev = e->rpfunion; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* ipv6mcsgl2 table size get */
int soc_sbx_g2p3_ipv6mcsgl2_entry_table_size_get(int unit,
                int *tsize,
                int imcgi)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCSGL2_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = imcgi; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for ipv6mcsgl2 */
int soc_sbx_g2p3_ipv6mcsgl2_set(int unit,
                int imcgi,
                soc_sbx_g2p3_ipv6mcsgl2_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCSGL2_ID];

    s = soc_sbx_g2p3_ipv6mcsgl2_index_check(unit, key,
                imcgi);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv6mcsgl2_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_ipv6mcsgl2_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for ipv6mcsgl2 */
int soc_sbx_g2p3_ipv6mcsgl2_get(int unit,
                int imcgi,
                soc_sbx_g2p3_ipv6mcsgl2_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCSGL2_ID];

    s = soc_sbx_g2p3_ipv6mcsgl2_index_check(unit, key,
                imcgi);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_ipv6mcsgl2_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for ipv6mcg
 */

void soc_sbx_g2p3_ipv6mcg_t_init(
    soc_sbx_g2p3_ipv6mcg_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ipv6mcg_t));
}

/* entry pack accessor implementation for ipv6mcg */
int soc_sbx_g2p3_ipv6mcg_pack(int unit,
    soc_sbx_g2p3_ipv6mcg_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCG_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->ftidx; break;
        case 1: p = (uint8 *) &e->rpfunion; break;
        case 2: p = (uint8 *) &e->proccopy; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ipv6mcg */
int soc_sbx_g2p3_ipv6mcg_unpack(int unit,
                soc_sbx_g2p3_ipv6mcg_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCG_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->ftidx; break;
        case 1: p = (uint8 *) &e->rpfunion; break;
        case 2: p = (uint8 *) &e->proccopy; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ipv6mcg */
int soc_sbx_g2p3_ipv6mcg_index_check(int unit,
                int *vindex,
                soc_sbx_g2p3_16_byte_t ig,
                int ivlan)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCG_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = 0;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) ig; break;
        case 1: p = (uint8 *) &ivlan; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry index unpack for ipv6mcg */
int soc_sbx_g2p3_ipv6mcg_index_unpack(int unit,
                int *vindex,
                soc_sbx_g2p3_16_byte_t ig,
                int *ivlan)
{
    int i, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCG_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int be = tm->behost;
    int pkbe = 0;

    p0 = ((uint8 *) vindex);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
	fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) ig; break;
        case 1: p = (uint8 *) ivlan; break;
        default: return SOC_E_INTERNAL;
        }
        sal_memset(p, 0, width <= 32 ? (int) sizeof(int) : (width + 7) / 8);
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe =
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT 
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_extract(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ipv6mcg */
int soc_sbx_g2p3_ipv6mcg_entry_check(int unit,
                soc_sbx_g2p3_ipv6mcg_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCG_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->ftidx; break;
        case 1: ev = e->rpfunion; break;
        case 2: ev = e->proccopy; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for ipv6mcg */
int soc_sbx_g2p3_ipv6mcg_set(int unit,
                soc_sbx_g2p3_16_byte_t ig,
                int ivlan,
                soc_sbx_g2p3_ipv6mcg_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_ipv6mcg_index_check(unit, key,
                ig,
                ivlan);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv6mcg_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv6mcg_update(unit,
                ig,
                ivlan,
                e);
    if (s == SOC_E_NOT_FOUND) {
        s = soc_sbx_g2p3_ipv6mcg_add(unit,
                ig,
                ivlan,
                e);
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ipv6mcg_commit(unit, 0xffffffff);
    }

    return s;
}

/* entry add accessor implementation for ipv6mcg */
int soc_sbx_g2p3_ipv6mcg_add(int unit,
                soc_sbx_g2p3_16_byte_t ig,
                int ivlan,
                soc_sbx_g2p3_ipv6mcg_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCG_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_ipv6mcg_index_check(unit, key,
                ig,
                ivlan);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv6mcg_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv6mcg_pack(unit,
                  e, epacked, ed->epsize);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_eml_add_ext(unit, cs,
                (uint8 *) key,
                epacked);

    return s;
}

/* entry get accessor implementation for ipv6mcg */
int soc_sbx_g2p3_ipv6mcg_get(int unit,
                soc_sbx_g2p3_16_byte_t ig,
                int ivlan,
                soc_sbx_g2p3_ipv6mcg_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCG_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_ipv6mcg_index_check(unit, key,
                ig,
                ivlan);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_eml_get_ext(unit, cs,
                (uint8 *) key,
                epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv6mcg_unpack(unit,
                    e, epacked, ed->epsize);

    return s;
}

/* entry update accessor implementation for ipv6mcg */
int soc_sbx_g2p3_ipv6mcg_update(int unit,
                soc_sbx_g2p3_16_byte_t ig,
                int ivlan,
                soc_sbx_g2p3_ipv6mcg_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCG_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_ipv6mcg_index_check(unit, key,
                ig,
                ivlan);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv6mcg_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv6mcg_pack(unit,
                  e, epacked, ed->epsize);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_eml_update_ext(unit, cs,
                (uint8 *) key,
                epacked);

    return s;
}

/* entry delete accessor implementation for ipv6mcg */
int soc_sbx_g2p3_ipv6mcg_delete(int unit,
                soc_sbx_g2p3_16_byte_t ig,
                int ivlan)
{
    int s, key[32];

    s = soc_sbx_g2p3_ipv6mcg_index_check(unit, key,
                ig,
                ivlan);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv6mcg_remove(unit,
                ig,
                ivlan);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv6mcg_commit(unit, 0xffffffff);

    return s;
}

/* entry remove accessor implementation for ipv6mcg */
int soc_sbx_g2p3_ipv6mcg_remove(int unit,
                soc_sbx_g2p3_16_byte_t ig,
                int ivlan)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCG_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_ipv6mcg_index_check(unit, key,
                ig,
                ivlan);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_eml_remove_ext(unit, cs,
                (uint8 *) key);

    return s;
}

/* Get the first element of ipv6mcg */
int soc_sbx_g2p3_ipv6mcg_first(int unit,
                soc_sbx_g2p3_16_byte_t nig,
                int *nivlan)
{
    int s;
    int nkey[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCG_ID];
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    void *cs = td->cstate;

    s = soc_sbx_g2p3_eml_first_ext(unit, cs,
                (uint8 *) nkey);
    if (!s) {
        soc_sbx_g2p3_ipv6mcg_index_unpack(unit, nkey,
                nig,
                nivlan);
    }
    return s;
}

/* Get the next element of ipv6mcg */
int soc_sbx_g2p3_ipv6mcg_next(int unit,
                soc_sbx_g2p3_16_byte_t ig,
                int ivlan,
                soc_sbx_g2p3_16_byte_t nig,
                int *nivlan)
{
    int key[32], s;
    int nkey[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCG_ID];
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    void *cs = td->cstate;

    s = soc_sbx_g2p3_ipv6mcg_index_check(unit, key,
                ig,
                ivlan);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_eml_next_ext(unit, cs,
                (uint8 *) key,
                (uint8 *) nkey);
    if (!s) {
        soc_sbx_g2p3_ipv6mcg_index_unpack(unit, nkey,
                nig,
                nivlan);
    }
    return s;
}

/* Batch commit implementation for ipv6mcg */
int soc_sbx_g2p3_ipv6mcg_commit(int unit, int runlength)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCG_ID];
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    void *cs = td->cstate;

    return soc_sbx_g2p3_eml_commit_ext(unit, cs, runlength);
}

/*
 * Entry accessor implementations for ipv6mcgl1
 */

void soc_sbx_g2p3_ipv6mcgl1_t_init(
    soc_sbx_g2p3_ipv6mcgl1_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ipv6mcgl1_t));
}

/* entry pack accessor implementation for ipv6mcgl1 */
int soc_sbx_g2p3_ipv6mcgl1_pack(int unit,
    soc_sbx_g2p3_ipv6mcgl1_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCGL1_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->usemap; break;
        case 1: p = (uint8 *) &e->pointer; break;
        case 2: p = (uint8 *) &e->salt; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ipv6mcgl1 */
int soc_sbx_g2p3_ipv6mcgl1_unpack(int unit,
                soc_sbx_g2p3_ipv6mcgl1_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCGL1_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->usemap; break;
        case 1: p = (uint8 *) &e->pointer; break;
        case 2: p = (uint8 *) &e->salt; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ipv6mcgl1 */
int soc_sbx_g2p3_ipv6mcgl1_index_check(int unit,
                int *vindex,
                int il1i)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCGL1_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &il1i; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ipv6mcgl1 */
int soc_sbx_g2p3_ipv6mcgl1_entry_check(int unit,
                soc_sbx_g2p3_ipv6mcgl1_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCGL1_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->usemap; break;
        case 1: ev = e->pointer; break;
        case 2: ev = e->salt; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* ipv6mcgl1 table size get */
int soc_sbx_g2p3_ipv6mcgl1_entry_table_size_get(int unit,
                int *tsize,
                int il1i)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCGL1_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = il1i; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for ipv6mcgl1 */
int soc_sbx_g2p3_ipv6mcgl1_set(int unit,
                int il1i,
                soc_sbx_g2p3_ipv6mcgl1_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCGL1_ID];

    s = soc_sbx_g2p3_ipv6mcgl1_index_check(unit, key,
                il1i);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv6mcgl1_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_ipv6mcgl1_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for ipv6mcgl1 */
int soc_sbx_g2p3_ipv6mcgl1_get(int unit,
                int il1i,
                soc_sbx_g2p3_ipv6mcgl1_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCGL1_ID];

    s = soc_sbx_g2p3_ipv6mcgl1_index_check(unit, key,
                il1i);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_ipv6mcgl1_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for ipv6mcgl2
 */

void soc_sbx_g2p3_ipv6mcgl2_t_init(
    soc_sbx_g2p3_ipv6mcgl2_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ipv6mcgl2_t));
}

/* entry pack accessor implementation for ipv6mcgl2 */
int soc_sbx_g2p3_ipv6mcgl2_pack(int unit,
    soc_sbx_g2p3_ipv6mcgl2_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCGL2_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) e->g; break;
        case 1: p = (uint8 *) &e->ftidx; break;
        case 2: p = (uint8 *) &e->rpfunion; break;
        case 3: p = (uint8 *) &e->vlan; break;
        case 4: p = (uint8 *) &e->proccopy; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ipv6mcgl2 */
int soc_sbx_g2p3_ipv6mcgl2_unpack(int unit,
                soc_sbx_g2p3_ipv6mcgl2_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCGL2_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) e->g; break;
        case 1: p = (uint8 *) &e->ftidx; break;
        case 2: p = (uint8 *) &e->rpfunion; break;
        case 3: p = (uint8 *) &e->vlan; break;
        case 4: p = (uint8 *) &e->proccopy; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ipv6mcgl2 */
int soc_sbx_g2p3_ipv6mcgl2_index_check(int unit,
                int *vindex,
                int imcgi)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCGL2_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &imcgi; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ipv6mcgl2 */
int soc_sbx_g2p3_ipv6mcgl2_entry_check(int unit,
                soc_sbx_g2p3_ipv6mcgl2_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCGL2_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->g[0]; break;
        case 1: ev = e->ftidx; break;
        case 2: ev = e->rpfunion; break;
        case 3: ev = e->vlan; break;
        case 4: ev = e->proccopy; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* ipv6mcgl2 table size get */
int soc_sbx_g2p3_ipv6mcgl2_entry_table_size_get(int unit,
                int *tsize,
                int imcgi)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCGL2_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = imcgi; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for ipv6mcgl2 */
int soc_sbx_g2p3_ipv6mcgl2_set(int unit,
                int imcgi,
                soc_sbx_g2p3_ipv6mcgl2_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCGL2_ID];

    s = soc_sbx_g2p3_ipv6mcgl2_index_check(unit, key,
                imcgi);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv6mcgl2_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_ipv6mcgl2_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for ipv6mcgl2 */
int soc_sbx_g2p3_ipv6mcgl2_get(int unit,
                int imcgi,
                soc_sbx_g2p3_ipv6mcgl2_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCGL2_ID];

    s = soc_sbx_g2p3_ipv6mcgl2_index_check(unit, key,
                imcgi);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_ipv6mcgl2_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for ipv4mcg
 */

void soc_sbx_g2p3_ipv4mcg_t_init(
    soc_sbx_g2p3_ipv4mcg_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ipv4mcg_t));
}

/* entry pack accessor implementation for ipv4mcg */
int soc_sbx_g2p3_ipv4mcg_pack(int unit,
    soc_sbx_g2p3_ipv4mcg_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCG_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->ftidx; break;
        case 1: p = (uint8 *) &e->rpfunion; break;
        case 2: p = (uint8 *) &e->proccopy; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ipv4mcg */
int soc_sbx_g2p3_ipv4mcg_unpack(int unit,
                soc_sbx_g2p3_ipv4mcg_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCG_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->ftidx; break;
        case 1: p = (uint8 *) &e->rpfunion; break;
        case 2: p = (uint8 *) &e->proccopy; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ipv4mcg */
int soc_sbx_g2p3_ipv4mcg_index_check(int unit,
                int *vindex,
                int ig,
                int ivlan)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCG_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = 0;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ig; break;
        case 1: p = (uint8 *) &ivlan; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry index unpack for ipv4mcg */
int soc_sbx_g2p3_ipv4mcg_index_unpack(int unit,
                int *vindex,
                int *ig,
                int *ivlan)
{
    int i, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCG_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int be = tm->behost;
    int pkbe = 0;

    p0 = ((uint8 *) vindex);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
	fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) ig; break;
        case 1: p = (uint8 *) ivlan; break;
        default: return SOC_E_INTERNAL;
        }
        sal_memset(p, 0, width <= 32 ? (int) sizeof(int) : (width + 7) / 8);
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe =
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT 
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_extract(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ipv4mcg */
int soc_sbx_g2p3_ipv4mcg_entry_check(int unit,
                soc_sbx_g2p3_ipv4mcg_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCG_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->ftidx; break;
        case 1: ev = e->rpfunion; break;
        case 2: ev = e->proccopy; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for ipv4mcg */
int soc_sbx_g2p3_ipv4mcg_set(int unit,
                int ig,
                int ivlan,
                soc_sbx_g2p3_ipv4mcg_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_ipv4mcg_index_check(unit, key,
                ig,
                ivlan);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv4mcg_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv4mcg_update(unit,
                ig,
                ivlan,
                e);
    if (s == SOC_E_NOT_FOUND) {
        s = soc_sbx_g2p3_ipv4mcg_add(unit,
                ig,
                ivlan,
                e);
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ipv4mcg_commit(unit, 0xffffffff);
    }

    return s;
}

/* entry add accessor implementation for ipv4mcg */
int soc_sbx_g2p3_ipv4mcg_add(int unit,
                int ig,
                int ivlan,
                soc_sbx_g2p3_ipv4mcg_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCG_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_ipv4mcg_index_check(unit, key,
                ig,
                ivlan);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv4mcg_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv4mcg_pack(unit,
                  e, epacked, ed->epsize);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_eml_add_ext(unit, cs,
                (uint8 *) key,
                epacked);

    return s;
}

/* entry get accessor implementation for ipv4mcg */
int soc_sbx_g2p3_ipv4mcg_get(int unit,
                int ig,
                int ivlan,
                soc_sbx_g2p3_ipv4mcg_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCG_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_ipv4mcg_index_check(unit, key,
                ig,
                ivlan);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_eml_get_ext(unit, cs,
                (uint8 *) key,
                epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv4mcg_unpack(unit,
                    e, epacked, ed->epsize);

    return s;
}

/* entry update accessor implementation for ipv4mcg */
int soc_sbx_g2p3_ipv4mcg_update(int unit,
                int ig,
                int ivlan,
                soc_sbx_g2p3_ipv4mcg_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCG_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_ipv4mcg_index_check(unit, key,
                ig,
                ivlan);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv4mcg_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv4mcg_pack(unit,
                  e, epacked, ed->epsize);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_eml_update_ext(unit, cs,
                (uint8 *) key,
                epacked);

    return s;
}

/* entry delete accessor implementation for ipv4mcg */
int soc_sbx_g2p3_ipv4mcg_delete(int unit,
                int ig,
                int ivlan)
{
    int s, key[32];

    s = soc_sbx_g2p3_ipv4mcg_index_check(unit, key,
                ig,
                ivlan);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv4mcg_remove(unit,
                ig,
                ivlan);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv4mcg_commit(unit, 0xffffffff);

    return s;
}

/* entry remove accessor implementation for ipv4mcg */
int soc_sbx_g2p3_ipv4mcg_remove(int unit,
                int ig,
                int ivlan)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCG_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_ipv4mcg_index_check(unit, key,
                ig,
                ivlan);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_eml_remove_ext(unit, cs,
                (uint8 *) key);

    return s;
}

/* Get the first element of ipv4mcg */
int soc_sbx_g2p3_ipv4mcg_first(int unit,
                int *nig,
                int *nivlan)
{
    int s;
    int nkey[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCG_ID];
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    void *cs = td->cstate;

    s = soc_sbx_g2p3_eml_first_ext(unit, cs,
                (uint8 *) nkey);
    if (!s) {
        soc_sbx_g2p3_ipv4mcg_index_unpack(unit, nkey,
                nig,
                nivlan);
    }
    return s;
}

/* Get the next element of ipv4mcg */
int soc_sbx_g2p3_ipv4mcg_next(int unit,
                int ig,
                int ivlan,
                int *nig,
                int *nivlan)
{
    int key[32], s;
    int nkey[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCG_ID];
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    void *cs = td->cstate;

    s = soc_sbx_g2p3_ipv4mcg_index_check(unit, key,
                ig,
                ivlan);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_eml_next_ext(unit, cs,
                (uint8 *) key,
                (uint8 *) nkey);
    if (!s) {
        soc_sbx_g2p3_ipv4mcg_index_unpack(unit, nkey,
                nig,
                nivlan);
    }
    return s;
}

/* Batch commit implementation for ipv4mcg */
int soc_sbx_g2p3_ipv4mcg_commit(int unit, int runlength)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCG_ID];
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    void *cs = td->cstate;

    return soc_sbx_g2p3_eml_commit_ext(unit, cs, runlength);
}

/*
 * Entry accessor implementations for ipv4mcgl1
 */

void soc_sbx_g2p3_ipv4mcgl1_t_init(
    soc_sbx_g2p3_ipv4mcgl1_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ipv4mcgl1_t));
}

/* entry pack accessor implementation for ipv4mcgl1 */
int soc_sbx_g2p3_ipv4mcgl1_pack(int unit,
    soc_sbx_g2p3_ipv4mcgl1_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCGL1_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->usemap; break;
        case 1: p = (uint8 *) &e->pointer; break;
        case 2: p = (uint8 *) &e->salt; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ipv4mcgl1 */
int soc_sbx_g2p3_ipv4mcgl1_unpack(int unit,
                soc_sbx_g2p3_ipv4mcgl1_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCGL1_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->usemap; break;
        case 1: p = (uint8 *) &e->pointer; break;
        case 2: p = (uint8 *) &e->salt; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ipv4mcgl1 */
int soc_sbx_g2p3_ipv4mcgl1_index_check(int unit,
                int *vindex,
                int il1i)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCGL1_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &il1i; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ipv4mcgl1 */
int soc_sbx_g2p3_ipv4mcgl1_entry_check(int unit,
                soc_sbx_g2p3_ipv4mcgl1_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCGL1_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->usemap; break;
        case 1: ev = e->pointer; break;
        case 2: ev = e->salt; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* ipv4mcgl1 table size get */
int soc_sbx_g2p3_ipv4mcgl1_entry_table_size_get(int unit,
                int *tsize,
                int il1i)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCGL1_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = il1i; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for ipv4mcgl1 */
int soc_sbx_g2p3_ipv4mcgl1_set(int unit,
                int il1i,
                soc_sbx_g2p3_ipv4mcgl1_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCGL1_ID];

    s = soc_sbx_g2p3_ipv4mcgl1_index_check(unit, key,
                il1i);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv4mcgl1_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_ipv4mcgl1_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for ipv4mcgl1 */
int soc_sbx_g2p3_ipv4mcgl1_get(int unit,
                int il1i,
                soc_sbx_g2p3_ipv4mcgl1_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCGL1_ID];

    s = soc_sbx_g2p3_ipv4mcgl1_index_check(unit, key,
                il1i);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_ipv4mcgl1_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for ipv4mcgl2
 */

void soc_sbx_g2p3_ipv4mcgl2_t_init(
    soc_sbx_g2p3_ipv4mcgl2_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ipv4mcgl2_t));
}

/* entry pack accessor implementation for ipv4mcgl2 */
int soc_sbx_g2p3_ipv4mcgl2_pack(int unit,
    soc_sbx_g2p3_ipv4mcgl2_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCGL2_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->g; break;
        case 1: p = (uint8 *) &e->ftidx; break;
        case 2: p = (uint8 *) &e->rpfunion; break;
        case 3: p = (uint8 *) &e->vlan; break;
        case 4: p = (uint8 *) &e->proccopy; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ipv4mcgl2 */
int soc_sbx_g2p3_ipv4mcgl2_unpack(int unit,
                soc_sbx_g2p3_ipv4mcgl2_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCGL2_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->g; break;
        case 1: p = (uint8 *) &e->ftidx; break;
        case 2: p = (uint8 *) &e->rpfunion; break;
        case 3: p = (uint8 *) &e->vlan; break;
        case 4: p = (uint8 *) &e->proccopy; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ipv4mcgl2 */
int soc_sbx_g2p3_ipv4mcgl2_index_check(int unit,
                int *vindex,
                int imcgi)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCGL2_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &imcgi; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ipv4mcgl2 */
int soc_sbx_g2p3_ipv4mcgl2_entry_check(int unit,
                soc_sbx_g2p3_ipv4mcgl2_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCGL2_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->g; break;
        case 1: ev = e->ftidx; break;
        case 2: ev = e->rpfunion; break;
        case 3: ev = e->vlan; break;
        case 4: ev = e->proccopy; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* ipv4mcgl2 table size get */
int soc_sbx_g2p3_ipv4mcgl2_entry_table_size_get(int unit,
                int *tsize,
                int imcgi)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCGL2_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = imcgi; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for ipv4mcgl2 */
int soc_sbx_g2p3_ipv4mcgl2_set(int unit,
                int imcgi,
                soc_sbx_g2p3_ipv4mcgl2_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCGL2_ID];

    s = soc_sbx_g2p3_ipv4mcgl2_index_check(unit, key,
                imcgi);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv4mcgl2_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_ipv4mcgl2_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for ipv4mcgl2 */
int soc_sbx_g2p3_ipv4mcgl2_get(int unit,
                int imcgi,
                soc_sbx_g2p3_ipv4mcgl2_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCGL2_ID];

    s = soc_sbx_g2p3_ipv4mcgl2_index_check(unit, key,
                imcgi);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_ipv4mcgl2_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for ipv4mcsg
 */

void soc_sbx_g2p3_ipv4mcsg_t_init(
    soc_sbx_g2p3_ipv4mcsg_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ipv4mcsg_t));
}

/* entry pack accessor implementation for ipv4mcsg */
int soc_sbx_g2p3_ipv4mcsg_pack(int unit,
    soc_sbx_g2p3_ipv4mcsg_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCSG_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->ftidx; break;
        case 1: p = (uint8 *) &e->rpfunion; break;
        case 2: p = (uint8 *) &e->proccopy; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ipv4mcsg */
int soc_sbx_g2p3_ipv4mcsg_unpack(int unit,
                soc_sbx_g2p3_ipv4mcsg_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCSG_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->ftidx; break;
        case 1: p = (uint8 *) &e->rpfunion; break;
        case 2: p = (uint8 *) &e->proccopy; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ipv4mcsg */
int soc_sbx_g2p3_ipv4mcsg_index_check(int unit,
                int *vindex,
                int ig,
                int is,
                int ivlan)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCSG_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = 0;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ig; break;
        case 1: p = (uint8 *) &is; break;
        case 2: p = (uint8 *) &ivlan; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry index unpack for ipv4mcsg */
int soc_sbx_g2p3_ipv4mcsg_index_unpack(int unit,
                int *vindex,
                int *ig,
                int *is,
                int *ivlan)
{
    int i, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCSG_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int be = tm->behost;
    int pkbe = 0;

    p0 = ((uint8 *) vindex);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
	fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) ig; break;
        case 1: p = (uint8 *) is; break;
        case 2: p = (uint8 *) ivlan; break;
        default: return SOC_E_INTERNAL;
        }
        sal_memset(p, 0, width <= 32 ? (int) sizeof(int) : (width + 7) / 8);
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe =
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT 
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_extract(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ipv4mcsg */
int soc_sbx_g2p3_ipv4mcsg_entry_check(int unit,
                soc_sbx_g2p3_ipv4mcsg_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCSG_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->ftidx; break;
        case 1: ev = e->rpfunion; break;
        case 2: ev = e->proccopy; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for ipv4mcsg */
int soc_sbx_g2p3_ipv4mcsg_set(int unit,
                int ig,
                int is,
                int ivlan,
                soc_sbx_g2p3_ipv4mcsg_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_ipv4mcsg_index_check(unit, key,
                ig,
                is,
                ivlan);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv4mcsg_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv4mcsg_update(unit,
                ig,
                is,
                ivlan,
                e);
    if (s == SOC_E_NOT_FOUND) {
        s = soc_sbx_g2p3_ipv4mcsg_add(unit,
                ig,
                is,
                ivlan,
                e);
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ipv4mcsg_commit(unit, 0xffffffff);
    }

    return s;
}

/* entry add accessor implementation for ipv4mcsg */
int soc_sbx_g2p3_ipv4mcsg_add(int unit,
                int ig,
                int is,
                int ivlan,
                soc_sbx_g2p3_ipv4mcsg_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCSG_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_ipv4mcsg_index_check(unit, key,
                ig,
                is,
                ivlan);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv4mcsg_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv4mcsg_pack(unit,
                  e, epacked, ed->epsize);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_eml_add_ext(unit, cs,
                (uint8 *) key,
                epacked);

    return s;
}

/* entry get accessor implementation for ipv4mcsg */
int soc_sbx_g2p3_ipv4mcsg_get(int unit,
                int ig,
                int is,
                int ivlan,
                soc_sbx_g2p3_ipv4mcsg_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCSG_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_ipv4mcsg_index_check(unit, key,
                ig,
                is,
                ivlan);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_eml_get_ext(unit, cs,
                (uint8 *) key,
                epacked);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv4mcsg_unpack(unit,
                    e, epacked, ed->epsize);

    return s;
}

/* entry update accessor implementation for ipv4mcsg */
int soc_sbx_g2p3_ipv4mcsg_update(int unit,
                int ig,
                int is,
                int ivlan,
                soc_sbx_g2p3_ipv4mcsg_t *e)
{
    int s, key[32];
    uint8 epacked[128];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCSG_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_ipv4mcsg_index_check(unit, key,
                ig,
                is,
                ivlan);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv4mcsg_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv4mcsg_pack(unit,
                  e, epacked, ed->epsize);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_eml_update_ext(unit, cs,
                (uint8 *) key,
                epacked);

    return s;
}

/* entry delete accessor implementation for ipv4mcsg */
int soc_sbx_g2p3_ipv4mcsg_delete(int unit,
                int ig,
                int is,
                int ivlan)
{
    int s, key[32];

    s = soc_sbx_g2p3_ipv4mcsg_index_check(unit, key,
                ig,
                is,
                ivlan);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv4mcsg_remove(unit,
                ig,
                is,
                ivlan);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv4mcsg_commit(unit, 0xffffffff);

    return s;
}

/* entry remove accessor implementation for ipv4mcsg */
int soc_sbx_g2p3_ipv4mcsg_remove(int unit,
                int ig,
                int is,
                int ivlan)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCSG_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_ipv4mcsg_index_check(unit, key,
                ig,
                is,
                ivlan);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_eml_remove_ext(unit, cs,
                (uint8 *) key);

    return s;
}

/* Get the first element of ipv4mcsg */
int soc_sbx_g2p3_ipv4mcsg_first(int unit,
                int *nig,
                int *nis,
                int *nivlan)
{
    int s;
    int nkey[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCSG_ID];
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    void *cs = td->cstate;

    s = soc_sbx_g2p3_eml_first_ext(unit, cs,
                (uint8 *) nkey);
    if (!s) {
        soc_sbx_g2p3_ipv4mcsg_index_unpack(unit, nkey,
                nig,
                nis,
                nivlan);
    }
    return s;
}

/* Get the next element of ipv4mcsg */
int soc_sbx_g2p3_ipv4mcsg_next(int unit,
                int ig,
                int is,
                int ivlan,
                int *nig,
                int *nis,
                int *nivlan)
{
    int key[32], s;
    int nkey[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCSG_ID];
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    void *cs = td->cstate;

    s = soc_sbx_g2p3_ipv4mcsg_index_check(unit, key,
                ig,
                is,
                ivlan);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_eml_next_ext(unit, cs,
                (uint8 *) key,
                (uint8 *) nkey);
    if (!s) {
        soc_sbx_g2p3_ipv4mcsg_index_unpack(unit, nkey,
                nig,
                nis,
                nivlan);
    }
    return s;
}

/* Batch commit implementation for ipv4mcsg */
int soc_sbx_g2p3_ipv4mcsg_commit(int unit, int runlength)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCSG_ID];
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    void *cs = td->cstate;

    return soc_sbx_g2p3_eml_commit_ext(unit, cs, runlength);
}

/*
 * Entry accessor implementations for ipv4mcsgl1
 */

void soc_sbx_g2p3_ipv4mcsgl1_t_init(
    soc_sbx_g2p3_ipv4mcsgl1_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ipv4mcsgl1_t));
}

/* entry pack accessor implementation for ipv4mcsgl1 */
int soc_sbx_g2p3_ipv4mcsgl1_pack(int unit,
    soc_sbx_g2p3_ipv4mcsgl1_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCSGL1_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->usemap; break;
        case 1: p = (uint8 *) &e->pointer; break;
        case 2: p = (uint8 *) &e->salt; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ipv4mcsgl1 */
int soc_sbx_g2p3_ipv4mcsgl1_unpack(int unit,
                soc_sbx_g2p3_ipv4mcsgl1_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCSGL1_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->usemap; break;
        case 1: p = (uint8 *) &e->pointer; break;
        case 2: p = (uint8 *) &e->salt; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ipv4mcsgl1 */
int soc_sbx_g2p3_ipv4mcsgl1_index_check(int unit,
                int *vindex,
                int il1i)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCSGL1_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &il1i; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ipv4mcsgl1 */
int soc_sbx_g2p3_ipv4mcsgl1_entry_check(int unit,
                soc_sbx_g2p3_ipv4mcsgl1_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCSGL1_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->usemap; break;
        case 1: ev = e->pointer; break;
        case 2: ev = e->salt; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* ipv4mcsgl1 table size get */
int soc_sbx_g2p3_ipv4mcsgl1_entry_table_size_get(int unit,
                int *tsize,
                int il1i)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCSGL1_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = il1i; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for ipv4mcsgl1 */
int soc_sbx_g2p3_ipv4mcsgl1_set(int unit,
                int il1i,
                soc_sbx_g2p3_ipv4mcsgl1_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCSGL1_ID];

    s = soc_sbx_g2p3_ipv4mcsgl1_index_check(unit, key,
                il1i);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv4mcsgl1_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_ipv4mcsgl1_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for ipv4mcsgl1 */
int soc_sbx_g2p3_ipv4mcsgl1_get(int unit,
                int il1i,
                soc_sbx_g2p3_ipv4mcsgl1_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCSGL1_ID];

    s = soc_sbx_g2p3_ipv4mcsgl1_index_check(unit, key,
                il1i);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_ipv4mcsgl1_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for ipv4mcsgl2
 */

void soc_sbx_g2p3_ipv4mcsgl2_t_init(
    soc_sbx_g2p3_ipv4mcsgl2_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ipv4mcsgl2_t));
}

/* entry pack accessor implementation for ipv4mcsgl2 */
int soc_sbx_g2p3_ipv4mcsgl2_pack(int unit,
    soc_sbx_g2p3_ipv4mcsgl2_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCSGL2_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->g; break;
        case 1: p = (uint8 *) &e->s; break;
        case 2: p = (uint8 *) &e->ftidx; break;
        case 3: p = (uint8 *) &e->rpfunion; break;
        case 4: p = (uint8 *) &e->vlan; break;
        case 5: p = (uint8 *) &e->proccopy; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ipv4mcsgl2 */
int soc_sbx_g2p3_ipv4mcsgl2_unpack(int unit,
                soc_sbx_g2p3_ipv4mcsgl2_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCSGL2_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->g; break;
        case 1: p = (uint8 *) &e->s; break;
        case 2: p = (uint8 *) &e->ftidx; break;
        case 3: p = (uint8 *) &e->rpfunion; break;
        case 4: p = (uint8 *) &e->vlan; break;
        case 5: p = (uint8 *) &e->proccopy; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ipv4mcsgl2 */
int soc_sbx_g2p3_ipv4mcsgl2_index_check(int unit,
                int *vindex,
                int imcgi)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCSGL2_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &imcgi; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ipv4mcsgl2 */
int soc_sbx_g2p3_ipv4mcsgl2_entry_check(int unit,
                soc_sbx_g2p3_ipv4mcsgl2_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCSGL2_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->g; break;
        case 1: ev = e->s; break;
        case 2: ev = e->ftidx; break;
        case 3: ev = e->rpfunion; break;
        case 4: ev = e->vlan; break;
        case 5: ev = e->proccopy; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* ipv4mcsgl2 table size get */
int soc_sbx_g2p3_ipv4mcsgl2_entry_table_size_get(int unit,
                int *tsize,
                int imcgi)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCSGL2_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = imcgi; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for ipv4mcsgl2 */
int soc_sbx_g2p3_ipv4mcsgl2_set(int unit,
                int imcgi,
                soc_sbx_g2p3_ipv4mcsgl2_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCSGL2_ID];

    s = soc_sbx_g2p3_ipv4mcsgl2_index_check(unit, key,
                imcgi);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv4mcsgl2_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_ipv4mcsgl2_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for ipv4mcsgl2 */
int soc_sbx_g2p3_ipv4mcsgl2_get(int unit,
                int imcgi,
                soc_sbx_g2p3_ipv4mcsgl2_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCSGL2_ID];

    s = soc_sbx_g2p3_ipv4mcsgl2_index_check(unit, key,
                imcgi);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_ipv4mcsgl2_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for lpmnode
 */

void soc_sbx_g2p3_lpmnode_t_init(
    soc_sbx_g2p3_lpmnode_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_lpmnode_t));
}

/* entry size function for lpmnode */
int soc_sbx_g2p3_lpmnode_size(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LPMNODE_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];

    return (eb->width + (eb->stridebits - 1)) / eb->stridebits;
}

/* entry pack accessor implementation for lpmnode */
int soc_sbx_g2p3_lpmnode_pack(int unit,
    soc_sbx_g2p3_lpmnode_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LPMNODE_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->pattern; break;
        case 1: p = (uint8 *) &e->singleton; break;
        case 2: p = (uint8 *) &e->pointer; break;
        case 3: p = (uint8 *) &e->leaf; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for lpmnode */
int soc_sbx_g2p3_lpmnode_unpack(int unit,
                soc_sbx_g2p3_lpmnode_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LPMNODE_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->pattern; break;
        case 1: p = (uint8 *) &e->singleton; break;
        case 2: p = (uint8 *) &e->pointer; break;
        case 3: p = (uint8 *) &e->leaf; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/*
 * Entry accessor implementations for ipv4sa
 */

void soc_sbx_g2p3_ipv4sa_t_init(
    soc_sbx_g2p3_ipv4sa_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ipv4sa_t));
    e->poe = 0x3fff;
}

/* entry pack accessor implementation for ipv4sa */
int soc_sbx_g2p3_ipv4sa_pack(int unit,
    soc_sbx_g2p3_ipv4sa_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SA_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->poe; break;
        case 1: p = (uint8 *) &e->rpfmode; break;
        case 2: p = (uint8 *) &e->srcdrop; break;
        case 3: p = (uint8 *) &e->srccnt; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ipv4sa */
int soc_sbx_g2p3_ipv4sa_unpack(int unit,
                soc_sbx_g2p3_ipv4sa_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SA_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->poe; break;
        case 1: p = (uint8 *) &e->rpfmode; break;
        case 2: p = (uint8 *) &e->srcdrop; break;
        case 3: p = (uint8 *) &e->srccnt; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ipv4sa */
int soc_sbx_g2p3_ipv4sa_index_check(int unit,
                int *vindex,
                int iprefixbits,
                int iip,
                int iipcxt)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SA_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iprefixbits; break;
        case 1: p = (uint8 *) &iip; break;
        case 2: p = (uint8 *) &iipcxt; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!i) continue;
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry index unpack for ipv4sa */
int soc_sbx_g2p3_ipv4sa_index_unpack(int unit,
                int *vindex,
                int *iprefixbits,
                int *iip,
                int *iipcxt)
{
    int i, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SA_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int be = tm->behost;
    int pkbe = be;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    iprefixbits = iprefixbits;

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 1; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
	fmt = id->format;
        switch (i) {
        case 1: p = (uint8 *) iip; break;
        case 2: p = (uint8 *) iipcxt; break;
        default: return SOC_E_INTERNAL;
        }
        sal_memset(p, 0, width <= 32 ? (int) sizeof(int) : (width + 7) / 8);
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe =
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT 
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_extract(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ipv4sa */
int soc_sbx_g2p3_ipv4sa_entry_check(int unit,
                soc_sbx_g2p3_ipv4sa_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SA_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->poe; break;
        case 1: ev = e->rpfmode; break;
        case 2: ev = e->srcdrop; break;
        case 3: ev = e->srccnt; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for ipv4sa */
int soc_sbx_g2p3_ipv4sa_set(int unit,
                int iprefixbits,
                int iip,
                int iipcxt,
                soc_sbx_g2p3_ipv4sa_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_ipv4sa_index_check(unit, key,
                iprefixbits,
                iip,
                iipcxt);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv4sa_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv4sa_update(unit,
                iprefixbits,
                iip,
                iipcxt,
                e);
    if (s == SOC_E_NOT_FOUND) {
        s = soc_sbx_g2p3_ipv4sa_add(unit,
                iprefixbits,
                iip,
                iipcxt,
                e);
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ipv4sa_commit(unit, 0xffffffff);
    }

    return s;
}

/* entry add accessor implementation for ipv4sa */
int soc_sbx_g2p3_ipv4sa_add(int unit,
                int iprefixbits,
                int iip,
                int iipcxt,
                soc_sbx_g2p3_ipv4sa_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SA_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_ipv4sa_index_check(unit, key,
                iprefixbits,
                iip,
                iipcxt);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv4sa_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_lpm_add_ext(unit, cs,
                iprefixbits,
                (uint8 *) key,
                e);

    return s;
}

/* entry get accessor implementation for ipv4sa */
int soc_sbx_g2p3_ipv4sa_get(int unit,
                int iprefixbits,
                int iip,
                int iipcxt,
                soc_sbx_g2p3_ipv4sa_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SA_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_ipv4sa_index_check(unit, key,
                iprefixbits,
                iip,
                iipcxt);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_lpm_get_ext(unit, cs,
                iprefixbits,
                (uint8 *) key,
                e);

    return s;
}

/* entry update accessor implementation for ipv4sa */
int soc_sbx_g2p3_ipv4sa_update(int unit,
                int iprefixbits,
                int iip,
                int iipcxt,
                soc_sbx_g2p3_ipv4sa_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_ipv4sa_index_check(unit, key,
                iprefixbits,
                iip,
                iipcxt);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv4sa_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv4sa_renew(unit,
                iprefixbits,
                iip,
                iipcxt,
                e);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv4sa_commit(unit, 0xffffffff);

    return s;
}

/* entry renew accessor implementation for ipv4sa */
int soc_sbx_g2p3_ipv4sa_renew(int unit,
                int iprefixbits,
                int iip,
                int iipcxt,
                soc_sbx_g2p3_ipv4sa_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SA_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_ipv4sa_index_check(unit, key,
                iprefixbits,
                iip,
                iipcxt);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv4sa_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_lpm_renew_ext(unit, cs,
                iprefixbits,
                (uint8 *) key,
                e);

    return s;
}

/* entry delete accessor implementation for ipv4sa */
int soc_sbx_g2p3_ipv4sa_delete(int unit,
                int iprefixbits,
                int iip,
                int iipcxt)
{
    int s, key[32];

    s = soc_sbx_g2p3_ipv4sa_index_check(unit, key,
                iprefixbits,
                iip,
                iipcxt);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv4sa_remove(unit,
                iprefixbits,
                iip,
                iipcxt);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv4sa_commit(unit, 0xffffffff);

    return s;
}

/* entry remove accessor implementation for ipv4sa */
int soc_sbx_g2p3_ipv4sa_remove(int unit,
                int iprefixbits,
                int iip,
                int iipcxt)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SA_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_ipv4sa_index_check(unit, key,
                iprefixbits,
                iip,
                iipcxt);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_lpm_remove_ext(unit, cs,
                iprefixbits,
                (uint8 *) key);

    return s;
}

/* Get the first element of ipv4sa */
int soc_sbx_g2p3_ipv4sa_first(int unit,
                int *niprefixbits,
                int *niip,
                int *niipcxt)
{
    int s;
    int nkey[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SA_ID];
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    void *cs = td->cstate;

    s = soc_sbx_g2p3_lpm_first_ext(unit, cs,
                niprefixbits,
                (uint8 *) nkey);
    if (!s) {
        soc_sbx_g2p3_ipv4sa_index_unpack(unit, nkey,
                niprefixbits,
                niip,
                niipcxt);
    }
    return s;
}

/* Get the next element of ipv4sa */
int soc_sbx_g2p3_ipv4sa_next(int unit,
                int iprefixbits,
                int iip,
                int iipcxt,
                int *niprefixbits,
                int *niip,
                int *niipcxt)
{
    int key[32], s;
    int nkey[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SA_ID];
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    void *cs = td->cstate;

    s = soc_sbx_g2p3_ipv4sa_index_check(unit, key,
                iprefixbits,
                iip,
                iipcxt);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_lpm_next_ext(unit, cs,
                iprefixbits,
                (uint8 *) key,
                niprefixbits,
                (uint8 *) nkey);
    if (!s) {
        soc_sbx_g2p3_ipv4sa_index_unpack(unit, nkey,
                niprefixbits,
                niip,
                niipcxt);
    }
    return s;
}

/* Batch commit implementation for ipv4sa */
int soc_sbx_g2p3_ipv4sa_commit(int unit, int runlength)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SA_ID];
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    void *cs = td->cstate;

    return soc_sbx_g2p3_lpm_commit_ext(unit, cs, runlength);
}

/*
 * Entry accessor implementations for ipv4sal0
 */

void soc_sbx_g2p3_ipv4sal0_t_init(
    soc_sbx_g2p3_ipv4sal0_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ipv4sal0_t));
}

/* entry pack accessor implementation for ipv4sal0 */
int soc_sbx_g2p3_ipv4sal0_pack(int unit,
    soc_sbx_g2p3_ipv4sal0_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SAL0_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->pattern; break;
        case 1: p = (uint8 *) &e->singleton; break;
        case 2: p = (uint8 *) &e->pointer; break;
        case 3: p = (uint8 *) &e->leaf; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ipv4sal0 */
int soc_sbx_g2p3_ipv4sal0_unpack(int unit,
                soc_sbx_g2p3_ipv4sal0_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SAL0_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->pattern; break;
        case 1: p = (uint8 *) &e->singleton; break;
        case 2: p = (uint8 *) &e->pointer; break;
        case 3: p = (uint8 *) &e->leaf; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ipv4sal0 */
int soc_sbx_g2p3_ipv4sal0_index_check(int unit,
                int *vindex,
                int iaddr)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SAL0_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iaddr; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ipv4sal0 */
int soc_sbx_g2p3_ipv4sal0_entry_check(int unit,
                soc_sbx_g2p3_ipv4sal0_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SAL0_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->pattern; break;
        case 1: ev = e->singleton; break;
        case 2: ev = e->pointer; break;
        case 3: ev = e->leaf; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* ipv4sal0 table size get */
int soc_sbx_g2p3_ipv4sal0_entry_table_size_get(int unit,
                int *tsize,
                int iaddr)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SAL0_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = iaddr; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for ipv4sal0 */
int soc_sbx_g2p3_ipv4sal0_set(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv4sal0_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SAL0_ID];

    s = soc_sbx_g2p3_ipv4sal0_index_check(unit, key,
                iaddr);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv4sal0_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_ipv4sal0_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for ipv4sal0 */
int soc_sbx_g2p3_ipv4sal0_get(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv4sal0_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SAL0_ID];

    s = soc_sbx_g2p3_ipv4sal0_index_check(unit, key,
                iaddr);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_ipv4sal0_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for ipv4saodd
 */

void soc_sbx_g2p3_ipv4saodd_t_init(
    soc_sbx_g2p3_ipv4saodd_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ipv4saodd_t));
}

/* entry pack accessor implementation for ipv4saodd */
int soc_sbx_g2p3_ipv4saodd_pack(int unit,
    soc_sbx_g2p3_ipv4saodd_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SAODD_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->pattern; break;
        case 1: p = (uint8 *) &e->singleton; break;
        case 2: p = (uint8 *) &e->pointer; break;
        case 3: p = (uint8 *) &e->leaf; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ipv4saodd */
int soc_sbx_g2p3_ipv4saodd_unpack(int unit,
                soc_sbx_g2p3_ipv4saodd_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SAODD_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->pattern; break;
        case 1: p = (uint8 *) &e->singleton; break;
        case 2: p = (uint8 *) &e->pointer; break;
        case 3: p = (uint8 *) &e->leaf; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ipv4saodd */
int soc_sbx_g2p3_ipv4saodd_index_check(int unit,
                int *vindex,
                int iaddr)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SAODD_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iaddr; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ipv4saodd */
int soc_sbx_g2p3_ipv4saodd_entry_check(int unit,
                soc_sbx_g2p3_ipv4saodd_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SAODD_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->pattern; break;
        case 1: ev = e->singleton; break;
        case 2: ev = e->pointer; break;
        case 3: ev = e->leaf; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* ipv4saodd table size get */
int soc_sbx_g2p3_ipv4saodd_entry_table_size_get(int unit,
                int *tsize,
                int iaddr)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SAODD_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = iaddr; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for ipv4saodd */
int soc_sbx_g2p3_ipv4saodd_set(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv4saodd_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SAODD_ID];

    s = soc_sbx_g2p3_ipv4saodd_index_check(unit, key,
                iaddr);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv4saodd_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_ipv4saodd_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for ipv4saodd */
int soc_sbx_g2p3_ipv4saodd_get(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv4saodd_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SAODD_ID];

    s = soc_sbx_g2p3_ipv4saodd_index_check(unit, key,
                iaddr);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_ipv4saodd_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for ipv4saeven
 */

void soc_sbx_g2p3_ipv4saeven_t_init(
    soc_sbx_g2p3_ipv4saeven_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ipv4saeven_t));
}

/* entry pack accessor implementation for ipv4saeven */
int soc_sbx_g2p3_ipv4saeven_pack(int unit,
    soc_sbx_g2p3_ipv4saeven_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SAEVEN_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->pattern; break;
        case 1: p = (uint8 *) &e->singleton; break;
        case 2: p = (uint8 *) &e->pointer; break;
        case 3: p = (uint8 *) &e->leaf; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ipv4saeven */
int soc_sbx_g2p3_ipv4saeven_unpack(int unit,
                soc_sbx_g2p3_ipv4saeven_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SAEVEN_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->pattern; break;
        case 1: p = (uint8 *) &e->singleton; break;
        case 2: p = (uint8 *) &e->pointer; break;
        case 3: p = (uint8 *) &e->leaf; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ipv4saeven */
int soc_sbx_g2p3_ipv4saeven_index_check(int unit,
                int *vindex,
                int iaddr)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SAEVEN_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iaddr; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ipv4saeven */
int soc_sbx_g2p3_ipv4saeven_entry_check(int unit,
                soc_sbx_g2p3_ipv4saeven_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SAEVEN_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->pattern; break;
        case 1: ev = e->singleton; break;
        case 2: ev = e->pointer; break;
        case 3: ev = e->leaf; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* ipv4saeven table size get */
int soc_sbx_g2p3_ipv4saeven_entry_table_size_get(int unit,
                int *tsize,
                int iaddr)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SAEVEN_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = iaddr; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for ipv4saeven */
int soc_sbx_g2p3_ipv4saeven_set(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv4saeven_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SAEVEN_ID];

    s = soc_sbx_g2p3_ipv4saeven_index_check(unit, key,
                iaddr);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv4saeven_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_ipv4saeven_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for ipv4saeven */
int soc_sbx_g2p3_ipv4saeven_get(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv4saeven_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SAEVEN_ID];

    s = soc_sbx_g2p3_ipv4saeven_index_check(unit, key,
                iaddr);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_ipv4saeven_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for ipv4sapayload
 */

void soc_sbx_g2p3_ipv4sapayload_t_init(
    soc_sbx_g2p3_ipv4sapayload_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ipv4sapayload_t));
    e->poe = 0x3fff;
}

/* entry pack accessor implementation for ipv4sapayload */
int soc_sbx_g2p3_ipv4sapayload_pack(int unit,
    soc_sbx_g2p3_ipv4sapayload_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SAPAYLOAD_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->poe; break;
        case 1: p = (uint8 *) &e->rpfmode; break;
        case 2: p = (uint8 *) &e->srcdrop; break;
        case 3: p = (uint8 *) &e->srccnt; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ipv4sapayload */
int soc_sbx_g2p3_ipv4sapayload_unpack(int unit,
                soc_sbx_g2p3_ipv4sapayload_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SAPAYLOAD_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->poe; break;
        case 1: p = (uint8 *) &e->rpfmode; break;
        case 2: p = (uint8 *) &e->srcdrop; break;
        case 3: p = (uint8 *) &e->srccnt; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ipv4sapayload */
int soc_sbx_g2p3_ipv4sapayload_index_check(int unit,
                int *vindex,
                int iaddr)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SAPAYLOAD_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iaddr; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ipv4sapayload */
int soc_sbx_g2p3_ipv4sapayload_entry_check(int unit,
                soc_sbx_g2p3_ipv4sapayload_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SAPAYLOAD_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->poe; break;
        case 1: ev = e->rpfmode; break;
        case 2: ev = e->srcdrop; break;
        case 3: ev = e->srccnt; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* ipv4sapayload table size get */
int soc_sbx_g2p3_ipv4sapayload_entry_table_size_get(int unit,
                int *tsize,
                int iaddr)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SAPAYLOAD_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = iaddr; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for ipv4sapayload */
int soc_sbx_g2p3_ipv4sapayload_set(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv4sapayload_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SAPAYLOAD_ID];

    s = soc_sbx_g2p3_ipv4sapayload_index_check(unit, key,
                iaddr);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv4sapayload_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_ipv4sapayload_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for ipv4sapayload */
int soc_sbx_g2p3_ipv4sapayload_get(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv4sapayload_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SAPAYLOAD_ID];

    s = soc_sbx_g2p3_ipv4sapayload_index_check(unit, key,
                iaddr);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_ipv4sapayload_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for ifp
 */

void soc_sbx_g2p3_ifp_t_init(
    soc_sbx_g2p3_ifp_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ifp_t));
    e->usedbtype = 0x1;
    e->sporthi = 0xffff;
    e->dporthi = 0xffff;
    e->ssaphi = 0xff;
    e->dsaphi = 0xff;
    e->llcctrlhi = 0xff;
    e->enable = 0x1;
}

/* entry size function for ifp */
int soc_sbx_g2p3_ifp_size(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IFP_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];

    return (eb->width + (eb->stridebits - 1)) / eb->stridebits;
}

/* entry pack accessor implementation for ifp */
int soc_sbx_g2p3_ifp_pack(int unit,
    soc_sbx_g2p3_ifp_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IFP_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->dbtype; break;
        case 1: p = (uint8 *) &e->usedbtype; break;
        case 2: p = (uint8 *) &e->port; break;
        case 3: p = (uint8 *) &e->useport; break;
        case 4: p = (uint8 *) e->pbmpn; break;
        case 5: p = (uint8 *) &e->pri; break;
        case 6: p = (uint8 *) &e->usepri; break;
        case 7: p = (uint8 *) &e->fragment; break;
        case 8: p = (uint8 *) &e->usefragment; break;
        case 9: p = (uint8 *) &e->urg; break;
        case 10: p = (uint8 *) &e->useurg; break;
        case 11: p = (uint8 *) &e->ack; break;
        case 12: p = (uint8 *) &e->useack; break;
        case 13: p = (uint8 *) &e->psh; break;
        case 14: p = (uint8 *) &e->usepsh; break;
        case 15: p = (uint8 *) &e->rst; break;
        case 16: p = (uint8 *) &e->userst; break;
        case 17: p = (uint8 *) &e->syn; break;
        case 18: p = (uint8 *) &e->usesyn; break;
        case 19: p = (uint8 *) &e->fin; break;
        case 20: p = (uint8 *) &e->usefin; break;
        case 21: p = (uint8 *) &e->dscp; break;
        case 22: p = (uint8 *) &e->usedscp; break;
        case 23: p = (uint8 *) &e->ecn; break;
        case 24: p = (uint8 *) &e->useecn; break;
        case 25: p = (uint8 *) &e->proto; break;
        case 26: p = (uint8 *) &e->useproto; break;
        case 27: p = (uint8 *) &e->sporthi; break;
        case 28: p = (uint8 *) &e->sportlo; break;
        case 29: p = (uint8 *) &e->dporthi; break;
        case 30: p = (uint8 *) &e->dportlo; break;
        case 31: p = (uint8 *) &e->sa; break;
        case 32: p = (uint8 *) &e->sawidth; break;
        case 33: p = (uint8 *) &e->da; break;
        case 34: p = (uint8 *) &e->dawidth; break;
        case 35: p = (uint8 *) &e->etype; break;
        case 36: p = (uint8 *) &e->useetype; break;
        case 37: p = (uint8 *) e->smac; break;
        case 38: p = (uint8 *) &e->smacwidth; break;
        case 39: p = (uint8 *) e->dmac; break;
        case 40: p = (uint8 *) &e->dmacwidth; break;
        case 41: p = (uint8 *) &e->vid; break;
        case 42: p = (uint8 *) &e->usevid; break;
        case 43: p = (uint8 *) &e->ssaphi; break;
        case 44: p = (uint8 *) &e->ssaplo; break;
        case 45: p = (uint8 *) &e->usessap; break;
        case 46: p = (uint8 *) &e->dsaphi; break;
        case 47: p = (uint8 *) &e->dsaplo; break;
        case 48: p = (uint8 *) &e->usedsap; break;
        case 49: p = (uint8 *) &e->llcctrlhi; break;
        case 50: p = (uint8 *) &e->llcctrllo; break;
        case 51: p = (uint8 *) &e->usellcctrl; break;
        case 52: p = (uint8 *) &e->enable; break;
        case 53: p = (uint8 *) &e->vlan; break;
        case 54: p = (uint8 *) &e->ftidx; break;
        case 55: p = (uint8 *) &e->mirror; break;
        case 56: p = (uint8 *) &e->usevlan; break;
        case 57: p = (uint8 *) &e->useftidx; break;
        case 58: p = (uint8 *) &e->copy; break;
        case 59: p = (uint8 *) &e->dp; break;
        case 60: p = (uint8 *) &e->cos; break;
        case 61: p = (uint8 *) &e->fcos; break;
        case 62: p = (uint8 *) &e->usedp; break;
        case 63: p = (uint8 *) &e->usecos; break;
        case 64: p = (uint8 *) &e->policer; break;
        case 65: p = (uint8 *) &e->typedpolice; break;
        case 66: p = (uint8 *) &e->mefcos; break;
        case 67: p = (uint8 *) &e->mef; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ifp */
int soc_sbx_g2p3_ifp_unpack(int unit,
                soc_sbx_g2p3_ifp_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IFP_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->dbtype; break;
        case 1: p = (uint8 *) &e->usedbtype; break;
        case 2: p = (uint8 *) &e->port; break;
        case 3: p = (uint8 *) &e->useport; break;
        case 4: p = (uint8 *) e->pbmpn; break;
        case 5: p = (uint8 *) &e->pri; break;
        case 6: p = (uint8 *) &e->usepri; break;
        case 7: p = (uint8 *) &e->fragment; break;
        case 8: p = (uint8 *) &e->usefragment; break;
        case 9: p = (uint8 *) &e->urg; break;
        case 10: p = (uint8 *) &e->useurg; break;
        case 11: p = (uint8 *) &e->ack; break;
        case 12: p = (uint8 *) &e->useack; break;
        case 13: p = (uint8 *) &e->psh; break;
        case 14: p = (uint8 *) &e->usepsh; break;
        case 15: p = (uint8 *) &e->rst; break;
        case 16: p = (uint8 *) &e->userst; break;
        case 17: p = (uint8 *) &e->syn; break;
        case 18: p = (uint8 *) &e->usesyn; break;
        case 19: p = (uint8 *) &e->fin; break;
        case 20: p = (uint8 *) &e->usefin; break;
        case 21: p = (uint8 *) &e->dscp; break;
        case 22: p = (uint8 *) &e->usedscp; break;
        case 23: p = (uint8 *) &e->ecn; break;
        case 24: p = (uint8 *) &e->useecn; break;
        case 25: p = (uint8 *) &e->proto; break;
        case 26: p = (uint8 *) &e->useproto; break;
        case 27: p = (uint8 *) &e->sporthi; break;
        case 28: p = (uint8 *) &e->sportlo; break;
        case 29: p = (uint8 *) &e->dporthi; break;
        case 30: p = (uint8 *) &e->dportlo; break;
        case 31: p = (uint8 *) &e->sa; break;
        case 32: p = (uint8 *) &e->sawidth; break;
        case 33: p = (uint8 *) &e->da; break;
        case 34: p = (uint8 *) &e->dawidth; break;
        case 35: p = (uint8 *) &e->etype; break;
        case 36: p = (uint8 *) &e->useetype; break;
        case 37: p = (uint8 *) e->smac; break;
        case 38: p = (uint8 *) &e->smacwidth; break;
        case 39: p = (uint8 *) e->dmac; break;
        case 40: p = (uint8 *) &e->dmacwidth; break;
        case 41: p = (uint8 *) &e->vid; break;
        case 42: p = (uint8 *) &e->usevid; break;
        case 43: p = (uint8 *) &e->ssaphi; break;
        case 44: p = (uint8 *) &e->ssaplo; break;
        case 45: p = (uint8 *) &e->usessap; break;
        case 46: p = (uint8 *) &e->dsaphi; break;
        case 47: p = (uint8 *) &e->dsaplo; break;
        case 48: p = (uint8 *) &e->usedsap; break;
        case 49: p = (uint8 *) &e->llcctrlhi; break;
        case 50: p = (uint8 *) &e->llcctrllo; break;
        case 51: p = (uint8 *) &e->usellcctrl; break;
        case 52: p = (uint8 *) &e->enable; break;
        case 53: p = (uint8 *) &e->vlan; break;
        case 54: p = (uint8 *) &e->ftidx; break;
        case 55: p = (uint8 *) &e->mirror; break;
        case 56: p = (uint8 *) &e->usevlan; break;
        case 57: p = (uint8 *) &e->useftidx; break;
        case 58: p = (uint8 *) &e->copy; break;
        case 59: p = (uint8 *) &e->dp; break;
        case 60: p = (uint8 *) &e->cos; break;
        case 61: p = (uint8 *) &e->fcos; break;
        case 62: p = (uint8 *) &e->usedp; break;
        case 63: p = (uint8 *) &e->usecos; break;
        case 64: p = (uint8 *) &e->policer; break;
        case 65: p = (uint8 *) &e->typedpolice; break;
        case 66: p = (uint8 *) &e->mefcos; break;
        case 67: p = (uint8 *) &e->mef; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ifp */
int soc_sbx_g2p3_ifp_index_check(int unit,
                int *vindex,
                int irule)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IFP_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &irule; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ifp */
int soc_sbx_g2p3_ifp_entry_check(int unit,
                soc_sbx_g2p3_ifp_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IFP_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->dbtype; break;
        case 1: ev = e->usedbtype; break;
        case 2: ev = e->port; break;
        case 3: ev = e->useport; break;
        case 4: ev = e->pbmpn[0]; break;
        case 5: ev = e->pri; break;
        case 6: ev = e->usepri; break;
        case 7: ev = e->fragment; break;
        case 8: ev = e->usefragment; break;
        case 9: ev = e->urg; break;
        case 10: ev = e->useurg; break;
        case 11: ev = e->ack; break;
        case 12: ev = e->useack; break;
        case 13: ev = e->psh; break;
        case 14: ev = e->usepsh; break;
        case 15: ev = e->rst; break;
        case 16: ev = e->userst; break;
        case 17: ev = e->syn; break;
        case 18: ev = e->usesyn; break;
        case 19: ev = e->fin; break;
        case 20: ev = e->usefin; break;
        case 21: ev = e->dscp; break;
        case 22: ev = e->usedscp; break;
        case 23: ev = e->ecn; break;
        case 24: ev = e->useecn; break;
        case 25: ev = e->proto; break;
        case 26: ev = e->useproto; break;
        case 27: ev = e->sporthi; break;
        case 28: ev = e->sportlo; break;
        case 29: ev = e->dporthi; break;
        case 30: ev = e->dportlo; break;
        case 31: ev = e->sa; break;
        case 32: ev = e->sawidth; break;
        case 33: ev = e->da; break;
        case 34: ev = e->dawidth; break;
        case 35: ev = e->etype; break;
        case 36: ev = e->useetype; break;
        case 37: ev = e->smac[0]; break;
        case 38: ev = e->smacwidth; break;
        case 39: ev = e->dmac[0]; break;
        case 40: ev = e->dmacwidth; break;
        case 41: ev = e->vid; break;
        case 42: ev = e->usevid; break;
        case 43: ev = e->ssaphi; break;
        case 44: ev = e->ssaplo; break;
        case 45: ev = e->usessap; break;
        case 46: ev = e->dsaphi; break;
        case 47: ev = e->dsaplo; break;
        case 48: ev = e->usedsap; break;
        case 49: ev = e->llcctrlhi; break;
        case 50: ev = e->llcctrllo; break;
        case 51: ev = e->usellcctrl; break;
        case 52: ev = e->enable; break;
        case 53: ev = e->vlan; break;
        case 54: ev = e->ftidx; break;
        case 55: ev = e->mirror; break;
        case 56: ev = e->usevlan; break;
        case 57: ev = e->useftidx; break;
        case 58: ev = e->copy; break;
        case 59: ev = e->dp; break;
        case 60: ev = e->cos; break;
        case 61: ev = e->fcos; break;
        case 62: ev = e->usedp; break;
        case 63: ev = e->usecos; break;
        case 64: ev = e->policer; break;
        case 65: ev = e->typedpolice; break;
        case 66: ev = e->mefcos; break;
        case 67: ev = e->mef; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for ifp */
int soc_sbx_g2p3_ifp_set(int unit,
                int irule,
                soc_sbx_g2p3_ifp_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_ifp_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ifp_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ifp_update(unit,
                irule,
                e);
    if (s == SOC_E_NOT_FOUND) {
        s = soc_sbx_g2p3_ifp_add(unit,
                irule,
                e);
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ifp_commit(unit, 0xffffffff);
    }

    return s;
}

/* entry add accessor implementation for ifp */
int soc_sbx_g2p3_ifp_add(int unit,
                int irule,
                soc_sbx_g2p3_ifp_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_ifp_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ifp_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ifp_add_ext(unit,
                irule,
                e);

    return s;
}

/* entry get accessor implementation for ifp */
int soc_sbx_g2p3_ifp_get(int unit,
                int irule,
                soc_sbx_g2p3_ifp_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_ifp_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ifp_get_ext(unit,
                irule,
                e);

    return s;
}

/* entry update accessor implementation for ifp */
int soc_sbx_g2p3_ifp_update(int unit,
                int irule,
                soc_sbx_g2p3_ifp_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_ifp_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ifp_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ifp_update_ext(unit,
                irule,
                e);

    return s;
}

/* entry delete accessor implementation for ifp */
int soc_sbx_g2p3_ifp_delete(int unit,
                int irule)
{
    int s, key[32];

    s = soc_sbx_g2p3_ifp_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ifp_remove(unit,
                irule);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ifp_commit(unit, 0xffffffff);

    return s;
}

/* entry remove accessor implementation for ifp */
int soc_sbx_g2p3_ifp_remove(int unit,
                int irule)
{
    int s, key[32];

    s = soc_sbx_g2p3_ifp_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ifp_remove_ext(unit,
                irule);

    return s;
}

/* Get the first element of ifp */
int soc_sbx_g2p3_ifp_first(int unit,
                int *nirule)
{
    return soc_sbx_g2p3_ifp_first_ext(unit,
                nirule);
}

/* Get the next element of ifp */
int soc_sbx_g2p3_ifp_next(int unit,
                int irule,
                int *nirule)
{
    int key[32], s;

    s = soc_sbx_g2p3_ifp_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }

    return soc_sbx_g2p3_ifp_next_ext(unit,
                irule,
                nirule);
}

/* Batch commit implementation for ifp */
int soc_sbx_g2p3_ifp_commit(int unit, int runlength)
{
    return soc_sbx_g2p3_ifp_commit_ext(unit, runlength);
}

/*
 * Entry accessor implementations for ifp_v6
 */

void soc_sbx_g2p3_ifp_v6_t_init(
    soc_sbx_g2p3_ifp_v6_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ifp_v6_t));
    e->dbtype = 0x1;
    e->usedbtype = 0x1;
    e->nextheaderhi = 0xff;
    e->sporthi = 0xffff;
    e->dporthi = 0xffff;
    e->enable = 0x1;
}

/* entry size function for ifp_v6 */
int soc_sbx_g2p3_ifp_v6_size(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IFP_V6_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];

    return (eb->width + (eb->stridebits - 1)) / eb->stridebits;
}

/* entry pack accessor implementation for ifp_v6 */
int soc_sbx_g2p3_ifp_v6_pack(int unit,
    soc_sbx_g2p3_ifp_v6_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IFP_V6_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->dbtype; break;
        case 1: p = (uint8 *) &e->usedbtype; break;
        case 2: p = (uint8 *) &e->port; break;
        case 3: p = (uint8 *) &e->useport; break;
        case 4: p = (uint8 *) e->pbmpn; break;
        case 5: p = (uint8 *) &e->urg; break;
        case 6: p = (uint8 *) &e->useurg; break;
        case 7: p = (uint8 *) &e->ack; break;
        case 8: p = (uint8 *) &e->useack; break;
        case 9: p = (uint8 *) &e->psh; break;
        case 10: p = (uint8 *) &e->usepsh; break;
        case 11: p = (uint8 *) &e->rst; break;
        case 12: p = (uint8 *) &e->userst; break;
        case 13: p = (uint8 *) &e->syn; break;
        case 14: p = (uint8 *) &e->usesyn; break;
        case 15: p = (uint8 *) &e->fin; break;
        case 16: p = (uint8 *) &e->usefin; break;
        case 17: p = (uint8 *) &e->TC; break;
        case 18: p = (uint8 *) &e->useTC; break;
        case 19: p = (uint8 *) &e->nextheaderhi; break;
        case 20: p = (uint8 *) &e->nextheaderlo; break;
        case 21: p = (uint8 *) &e->sporthi; break;
        case 22: p = (uint8 *) &e->sportlo; break;
        case 23: p = (uint8 *) &e->dporthi; break;
        case 24: p = (uint8 *) &e->dportlo; break;
        case 25: p = (uint8 *) e->sa; break;
        case 26: p = (uint8 *) &e->sawidth; break;
        case 27: p = (uint8 *) e->da; break;
        case 28: p = (uint8 *) &e->dawidth; break;
        case 29: p = (uint8 *) &e->vid; break;
        case 30: p = (uint8 *) &e->usevid; break;
        case 31: p = (uint8 *) &e->enable; break;
        case 32: p = (uint8 *) &e->vlan; break;
        case 33: p = (uint8 *) &e->ftidx; break;
        case 34: p = (uint8 *) &e->mirror; break;
        case 35: p = (uint8 *) &e->usevlan; break;
        case 36: p = (uint8 *) &e->useftidx; break;
        case 37: p = (uint8 *) &e->copy; break;
        case 38: p = (uint8 *) &e->dp; break;
        case 39: p = (uint8 *) &e->cos; break;
        case 40: p = (uint8 *) &e->fcos; break;
        case 41: p = (uint8 *) &e->usedp; break;
        case 42: p = (uint8 *) &e->usecos; break;
        case 43: p = (uint8 *) &e->policer; break;
        case 44: p = (uint8 *) &e->typedpolice; break;
        case 45: p = (uint8 *) &e->mefcos; break;
        case 46: p = (uint8 *) &e->mef; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ifp_v6 */
int soc_sbx_g2p3_ifp_v6_unpack(int unit,
                soc_sbx_g2p3_ifp_v6_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IFP_V6_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->dbtype; break;
        case 1: p = (uint8 *) &e->usedbtype; break;
        case 2: p = (uint8 *) &e->port; break;
        case 3: p = (uint8 *) &e->useport; break;
        case 4: p = (uint8 *) e->pbmpn; break;
        case 5: p = (uint8 *) &e->urg; break;
        case 6: p = (uint8 *) &e->useurg; break;
        case 7: p = (uint8 *) &e->ack; break;
        case 8: p = (uint8 *) &e->useack; break;
        case 9: p = (uint8 *) &e->psh; break;
        case 10: p = (uint8 *) &e->usepsh; break;
        case 11: p = (uint8 *) &e->rst; break;
        case 12: p = (uint8 *) &e->userst; break;
        case 13: p = (uint8 *) &e->syn; break;
        case 14: p = (uint8 *) &e->usesyn; break;
        case 15: p = (uint8 *) &e->fin; break;
        case 16: p = (uint8 *) &e->usefin; break;
        case 17: p = (uint8 *) &e->TC; break;
        case 18: p = (uint8 *) &e->useTC; break;
        case 19: p = (uint8 *) &e->nextheaderhi; break;
        case 20: p = (uint8 *) &e->nextheaderlo; break;
        case 21: p = (uint8 *) &e->sporthi; break;
        case 22: p = (uint8 *) &e->sportlo; break;
        case 23: p = (uint8 *) &e->dporthi; break;
        case 24: p = (uint8 *) &e->dportlo; break;
        case 25: p = (uint8 *) e->sa; break;
        case 26: p = (uint8 *) &e->sawidth; break;
        case 27: p = (uint8 *) e->da; break;
        case 28: p = (uint8 *) &e->dawidth; break;
        case 29: p = (uint8 *) &e->vid; break;
        case 30: p = (uint8 *) &e->usevid; break;
        case 31: p = (uint8 *) &e->enable; break;
        case 32: p = (uint8 *) &e->vlan; break;
        case 33: p = (uint8 *) &e->ftidx; break;
        case 34: p = (uint8 *) &e->mirror; break;
        case 35: p = (uint8 *) &e->usevlan; break;
        case 36: p = (uint8 *) &e->useftidx; break;
        case 37: p = (uint8 *) &e->copy; break;
        case 38: p = (uint8 *) &e->dp; break;
        case 39: p = (uint8 *) &e->cos; break;
        case 40: p = (uint8 *) &e->fcos; break;
        case 41: p = (uint8 *) &e->usedp; break;
        case 42: p = (uint8 *) &e->usecos; break;
        case 43: p = (uint8 *) &e->policer; break;
        case 44: p = (uint8 *) &e->typedpolice; break;
        case 45: p = (uint8 *) &e->mefcos; break;
        case 46: p = (uint8 *) &e->mef; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ifp_v6 */
int soc_sbx_g2p3_ifp_v6_index_check(int unit,
                int *vindex,
                int irule)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IFP_V6_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &irule; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ifp_v6 */
int soc_sbx_g2p3_ifp_v6_entry_check(int unit,
                soc_sbx_g2p3_ifp_v6_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IFP_V6_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->dbtype; break;
        case 1: ev = e->usedbtype; break;
        case 2: ev = e->port; break;
        case 3: ev = e->useport; break;
        case 4: ev = e->pbmpn[0]; break;
        case 5: ev = e->urg; break;
        case 6: ev = e->useurg; break;
        case 7: ev = e->ack; break;
        case 8: ev = e->useack; break;
        case 9: ev = e->psh; break;
        case 10: ev = e->usepsh; break;
        case 11: ev = e->rst; break;
        case 12: ev = e->userst; break;
        case 13: ev = e->syn; break;
        case 14: ev = e->usesyn; break;
        case 15: ev = e->fin; break;
        case 16: ev = e->usefin; break;
        case 17: ev = e->TC; break;
        case 18: ev = e->useTC; break;
        case 19: ev = e->nextheaderhi; break;
        case 20: ev = e->nextheaderlo; break;
        case 21: ev = e->sporthi; break;
        case 22: ev = e->sportlo; break;
        case 23: ev = e->dporthi; break;
        case 24: ev = e->dportlo; break;
        case 25: ev = e->sa[0]; break;
        case 26: ev = e->sawidth; break;
        case 27: ev = e->da[0]; break;
        case 28: ev = e->dawidth; break;
        case 29: ev = e->vid; break;
        case 30: ev = e->usevid; break;
        case 31: ev = e->enable; break;
        case 32: ev = e->vlan; break;
        case 33: ev = e->ftidx; break;
        case 34: ev = e->mirror; break;
        case 35: ev = e->usevlan; break;
        case 36: ev = e->useftidx; break;
        case 37: ev = e->copy; break;
        case 38: ev = e->dp; break;
        case 39: ev = e->cos; break;
        case 40: ev = e->fcos; break;
        case 41: ev = e->usedp; break;
        case 42: ev = e->usecos; break;
        case 43: ev = e->policer; break;
        case 44: ev = e->typedpolice; break;
        case 45: ev = e->mefcos; break;
        case 46: ev = e->mef; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for ifp_v6 */
int soc_sbx_g2p3_ifp_v6_set(int unit,
                int irule,
                soc_sbx_g2p3_ifp_v6_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_ifp_v6_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ifp_v6_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ifp_v6_update(unit,
                irule,
                e);
    if (s == SOC_E_NOT_FOUND) {
        s = soc_sbx_g2p3_ifp_v6_add(unit,
                irule,
                e);
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ifp_v6_commit(unit, 0xffffffff);
    }

    return s;
}

/* entry add accessor implementation for ifp_v6 */
int soc_sbx_g2p3_ifp_v6_add(int unit,
                int irule,
                soc_sbx_g2p3_ifp_v6_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_ifp_v6_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ifp_v6_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ifp_v6_add_ext(unit,
                irule,
                e);

    return s;
}

/* entry get accessor implementation for ifp_v6 */
int soc_sbx_g2p3_ifp_v6_get(int unit,
                int irule,
                soc_sbx_g2p3_ifp_v6_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_ifp_v6_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ifp_v6_get_ext(unit,
                irule,
                e);

    return s;
}

/* entry update accessor implementation for ifp_v6 */
int soc_sbx_g2p3_ifp_v6_update(int unit,
                int irule,
                soc_sbx_g2p3_ifp_v6_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_ifp_v6_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ifp_v6_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ifp_v6_update_ext(unit,
                irule,
                e);

    return s;
}

/* entry delete accessor implementation for ifp_v6 */
int soc_sbx_g2p3_ifp_v6_delete(int unit,
                int irule)
{
    int s, key[32];

    s = soc_sbx_g2p3_ifp_v6_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ifp_v6_remove(unit,
                irule);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ifp_v6_commit(unit, 0xffffffff);

    return s;
}

/* entry remove accessor implementation for ifp_v6 */
int soc_sbx_g2p3_ifp_v6_remove(int unit,
                int irule)
{
    int s, key[32];

    s = soc_sbx_g2p3_ifp_v6_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ifp_v6_remove_ext(unit,
                irule);

    return s;
}

/* Get the first element of ifp_v6 */
int soc_sbx_g2p3_ifp_v6_first(int unit,
                int *nirule)
{
    return soc_sbx_g2p3_ifp_v6_first_ext(unit,
                nirule);
}

/* Get the next element of ifp_v6 */
int soc_sbx_g2p3_ifp_v6_next(int unit,
                int irule,
                int *nirule)
{
    int key[32], s;

    s = soc_sbx_g2p3_ifp_v6_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }

    return soc_sbx_g2p3_ifp_v6_next_ext(unit,
                irule,
                nirule);
}

/* Batch commit implementation for ifp_v6 */
int soc_sbx_g2p3_ifp_v6_commit(int unit, int runlength)
{
    return soc_sbx_g2p3_ifp_v6_commit_ext(unit, runlength);
}

/*
 * Entry accessor implementations for evp2e
 */

void soc_sbx_g2p3_evp2e_t_init(
    soc_sbx_g2p3_evp2e_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_evp2e_t));
}

/* entry pack accessor implementation for evp2e */
int soc_sbx_g2p3_evp2e_pack(int unit,
    soc_sbx_g2p3_evp2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EVP2E_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->eteptr; break;
        case 1: p = (uint8 *) &e->counter; break;
        case 2: p = (uint8 *) &e->cocounter; break;
        case 3: p = (uint8 *) &e->priclass; break;
        case 4: p = (uint8 *) &e->allpri; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for evp2e */
int soc_sbx_g2p3_evp2e_unpack(int unit,
                soc_sbx_g2p3_evp2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EVP2E_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->eteptr; break;
        case 1: p = (uint8 *) &e->counter; break;
        case 2: p = (uint8 *) &e->cocounter; break;
        case 3: p = (uint8 *) &e->priclass; break;
        case 4: p = (uint8 *) &e->allpri; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for evp2e */
int soc_sbx_g2p3_evp2e_index_check(int unit,
                int *vindex,
                int ivlan,
                int iport)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EVP2E_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ivlan; break;
        case 1: p = (uint8 *) &iport; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for evp2e */
int soc_sbx_g2p3_evp2e_entry_check(int unit,
                soc_sbx_g2p3_evp2e_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EVP2E_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->eteptr; break;
        case 1: ev = e->counter; break;
        case 2: ev = e->cocounter; break;
        case 3: ev = e->priclass; break;
        case 4: ev = e->allpri; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* evp2e table size get */
int soc_sbx_g2p3_evp2e_entry_table_size_get(int unit,
                int *tsize,
                int ivlan,
                int iport)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EVP2E_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ivlan; break;
        case 1: v = iport; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for evp2e */
int soc_sbx_g2p3_evp2e_set(int unit,
                int ivlan,
                int iport,
                soc_sbx_g2p3_evp2e_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EVP2E_ID];

    s = soc_sbx_g2p3_evp2e_index_check(unit, key,
                ivlan,
                iport);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_evp2e_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_evp2e_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for evp2e */
int soc_sbx_g2p3_evp2e_get(int unit,
                int ivlan,
                int iport,
                soc_sbx_g2p3_evp2e_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EVP2E_ID];

    s = soc_sbx_g2p3_evp2e_index_check(unit, key,
                ivlan,
                iport);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_evp2e_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for oi2e
 */

void soc_sbx_g2p3_oi2e_t_init(
    soc_sbx_g2p3_oi2e_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_oi2e_t));
}

/* entry pack accessor implementation for oi2e */
int soc_sbx_g2p3_oi2e_pack(int unit,
    soc_sbx_g2p3_oi2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OI2E_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->eteptr; break;
        case 1: p = (uint8 *) &e->counter; break;
        case 2: p = (uint8 *) &e->cocounter; break;
        case 3: p = (uint8 *) &e->priclass; break;
        case 4: p = (uint8 *) &e->allpri; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for oi2e */
int soc_sbx_g2p3_oi2e_unpack(int unit,
                soc_sbx_g2p3_oi2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OI2E_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->eteptr; break;
        case 1: p = (uint8 *) &e->counter; break;
        case 2: p = (uint8 *) &e->cocounter; break;
        case 3: p = (uint8 *) &e->priclass; break;
        case 4: p = (uint8 *) &e->allpri; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for oi2e */
int soc_sbx_g2p3_oi2e_index_check(int unit,
                int *vindex,
                int ioi)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OI2E_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ioi; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for oi2e */
int soc_sbx_g2p3_oi2e_entry_check(int unit,
                soc_sbx_g2p3_oi2e_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OI2E_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->eteptr; break;
        case 1: ev = e->counter; break;
        case 2: ev = e->cocounter; break;
        case 3: ev = e->priclass; break;
        case 4: ev = e->allpri; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* oi2e table size get */
int soc_sbx_g2p3_oi2e_entry_table_size_get(int unit,
                int *tsize,
                int ioi)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OI2E_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ioi; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for oi2e */
int soc_sbx_g2p3_oi2e_set(int unit,
                int ioi,
                soc_sbx_g2p3_oi2e_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OI2E_ID];

    s = soc_sbx_g2p3_oi2e_index_check(unit, key,
                ioi);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_oi2e_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_oi2e_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for oi2e */
int soc_sbx_g2p3_oi2e_get(int unit,
                int ioi,
                soc_sbx_g2p3_oi2e_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OI2E_ID];

    s = soc_sbx_g2p3_oi2e_index_check(unit, key,
                ioi);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_oi2e_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for eteencap
 */

void soc_sbx_g2p3_eteencap_t_init(
    soc_sbx_g2p3_eteencap_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_eteencap_t));
    e->dmacset = 0x1;
    e->dmacsetlsb = 0x1;
    e->smacset = 0x1;
    e->nosplitcheck = 0x1;
    e->ttlcheck = 0x1;
    e->ipttldec = 0x1;
}

/* variable sized entry size function for eteencap */
int soc_sbx_g2p3_eteencap_size(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ETEENCAP_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];

    return (eb->width + (eb->stridebits - 1)) / eb->stridebits;
}

/* entry pack accessor implementation for eteencap */
int soc_sbx_g2p3_eteencap_pack(int unit,
    soc_sbx_g2p3_eteencap_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ETEENCAP_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->l2ete; break;
        case 1: p = (uint8 *) &e->dmacset; break;
        case 2: p = (uint8 *) &e->dmacsetlsb; break;
        case 3: p = (uint8 *) &e->dscpremark; break;
        case 4: p = (uint8 *) &e->remark; break;
        case 5: p = (uint8 *) &e->mplsttldec; break;
        case 6: p = (uint8 *) &e->encaplen; break;
        case 7: p = (uint8 *) &e->encapmac; break;
        case 8: p = (uint8 *) &e->nostrip; break;
        case 9: p = (uint8 *) &e->noclass; break;
        case 10: p = (uint8 *) &e->etepid; break;
        case 11: p = (uint8 *) &e->tunnelenter; break;
        case 12: p = (uint8 *) &e->exp0remark; break;
        case 13: p = (uint8 *) &e->exp1remark; break;
        case 14: p = (uint8 *) &e->exp2remark; break;
        case 15: p = (uint8 *) &e->ttl0dec; break;
        case 16: p = (uint8 *) &e->ttl1dec; break;
        case 17: p = (uint8 *) &e->ttl2dec; break;
        case 18: p = (uint8 *) &e->smacset; break;
        case 19: p = (uint8 *) &e->nosplitcheck; break;
        case 20: p = (uint8 *) &e->ttlcheck; break;
        case 21: p = (uint8 *) &e->ipttldec; break;
        case 22: p = (uint8 *) &e->add_pwcw; break;
        case 23: p = (uint8 *) &e->dmac5; break;
        case 24: p = (uint8 *) &e->dmac4; break;
        case 25: p = (uint8 *) &e->dmac3; break;
        case 26: p = (uint8 *) &e->dmac2; break;
        case 27: p = (uint8 *) &e->dmac1; break;
        case 28: p = (uint8 *) &e->dmac0; break;
        case 29: p = (uint8 *) &e->vlan; break;
        case 30: p = (uint8 *) &e->vid; break;
        case 31: p = (uint8 *) &e->pricfi; break;
        case 32: p = (uint8 *) &e->tpid; break;
        case 33: p = (uint8 *) &e->mimtype; break;
        case 34: p = (uint8 *) &e->btag_vid; break;
        case 35: p = (uint8 *) &e->btag_pricfi; break;
        case 36: p = (uint8 *) &e->btag_tpid; break;
        case 37: p = (uint8 *) &e->ttl2; break;
        case 38: p = (uint8 *) &e->s2; break;
        case 39: p = (uint8 *) &e->exp2; break;
        case 40: p = (uint8 *) &e->label2; break;
        case 41: p = (uint8 *) &e->etype; break;
        case 42: p = (uint8 *) &e->pid; break;
        case 43: p = (uint8 *) &e->isid; break;
        case 44: p = (uint8 *) &e->rsvd; break;
        case 45: p = (uint8 *) &e->ucm; break;
        case 46: p = (uint8 *) &e->dei; break;
        case 47: p = (uint8 *) &e->pcp; break;
        case 48: p = (uint8 *) &e->ttl0; break;
        case 49: p = (uint8 *) &e->s0; break;
        case 50: p = (uint8 *) &e->exp0; break;
        case 51: p = (uint8 *) &e->label0; break;
        case 52: p = (uint8 *) &e->ttl1; break;
        case 53: p = (uint8 *) &e->s1; break;
        case 54: p = (uint8 *) &e->exp1; break;
        case 55: p = (uint8 *) &e->label1; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for eteencap */
int soc_sbx_g2p3_eteencap_unpack(int unit,
                soc_sbx_g2p3_eteencap_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ETEENCAP_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->l2ete; break;
        case 1: p = (uint8 *) &e->dmacset; break;
        case 2: p = (uint8 *) &e->dmacsetlsb; break;
        case 3: p = (uint8 *) &e->dscpremark; break;
        case 4: p = (uint8 *) &e->remark; break;
        case 5: p = (uint8 *) &e->mplsttldec; break;
        case 6: p = (uint8 *) &e->encaplen; break;
        case 7: p = (uint8 *) &e->encapmac; break;
        case 8: p = (uint8 *) &e->nostrip; break;
        case 9: p = (uint8 *) &e->noclass; break;
        case 10: p = (uint8 *) &e->etepid; break;
        case 11: p = (uint8 *) &e->tunnelenter; break;
        case 12: p = (uint8 *) &e->exp0remark; break;
        case 13: p = (uint8 *) &e->exp1remark; break;
        case 14: p = (uint8 *) &e->exp2remark; break;
        case 15: p = (uint8 *) &e->ttl0dec; break;
        case 16: p = (uint8 *) &e->ttl1dec; break;
        case 17: p = (uint8 *) &e->ttl2dec; break;
        case 18: p = (uint8 *) &e->smacset; break;
        case 19: p = (uint8 *) &e->nosplitcheck; break;
        case 20: p = (uint8 *) &e->ttlcheck; break;
        case 21: p = (uint8 *) &e->ipttldec; break;
        case 22: p = (uint8 *) &e->add_pwcw; break;
        case 23: p = (uint8 *) &e->dmac5; break;
        case 24: p = (uint8 *) &e->dmac4; break;
        case 25: p = (uint8 *) &e->dmac3; break;
        case 26: p = (uint8 *) &e->dmac2; break;
        case 27: p = (uint8 *) &e->dmac1; break;
        case 28: p = (uint8 *) &e->dmac0; break;
        case 29: p = (uint8 *) &e->vlan; break;
        case 30: p = (uint8 *) &e->vid; break;
        case 31: p = (uint8 *) &e->pricfi; break;
        case 32: p = (uint8 *) &e->tpid; break;
        case 33: p = (uint8 *) &e->mimtype; break;
        case 34: p = (uint8 *) &e->btag_vid; break;
        case 35: p = (uint8 *) &e->btag_pricfi; break;
        case 36: p = (uint8 *) &e->btag_tpid; break;
        case 37: p = (uint8 *) &e->ttl2; break;
        case 38: p = (uint8 *) &e->s2; break;
        case 39: p = (uint8 *) &e->exp2; break;
        case 40: p = (uint8 *) &e->label2; break;
        case 41: p = (uint8 *) &e->etype; break;
        case 42: p = (uint8 *) &e->pid; break;
        case 43: p = (uint8 *) &e->isid; break;
        case 44: p = (uint8 *) &e->rsvd; break;
        case 45: p = (uint8 *) &e->ucm; break;
        case 46: p = (uint8 *) &e->dei; break;
        case 47: p = (uint8 *) &e->pcp; break;
        case 48: p = (uint8 *) &e->ttl0; break;
        case 49: p = (uint8 *) &e->s0; break;
        case 50: p = (uint8 *) &e->exp0; break;
        case 51: p = (uint8 *) &e->label0; break;
        case 52: p = (uint8 *) &e->ttl1; break;
        case 53: p = (uint8 *) &e->s1; break;
        case 54: p = (uint8 *) &e->exp1; break;
        case 55: p = (uint8 *) &e->label1; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for eteencap */
int soc_sbx_g2p3_eteencap_index_check(int unit,
                int *vindex,
                int ietei)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ETEENCAP_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ietei; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for eteencap */
int soc_sbx_g2p3_eteencap_entry_check(int unit,
                soc_sbx_g2p3_eteencap_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ETEENCAP_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->l2ete; break;
        case 1: ev = e->dmacset; break;
        case 2: ev = e->dmacsetlsb; break;
        case 3: ev = e->dscpremark; break;
        case 4: ev = e->remark; break;
        case 5: ev = e->mplsttldec; break;
        case 6: ev = e->encaplen; break;
        case 7: ev = e->encapmac; break;
        case 8: ev = e->nostrip; break;
        case 9: ev = e->noclass; break;
        case 10: ev = e->etepid; break;
        case 11: ev = e->tunnelenter; break;
        case 12: ev = e->exp0remark; break;
        case 13: ev = e->exp1remark; break;
        case 14: ev = e->exp2remark; break;
        case 15: ev = e->ttl0dec; break;
        case 16: ev = e->ttl1dec; break;
        case 17: ev = e->ttl2dec; break;
        case 18: ev = e->smacset; break;
        case 19: ev = e->nosplitcheck; break;
        case 20: ev = e->ttlcheck; break;
        case 21: ev = e->ipttldec; break;
        case 22: ev = e->add_pwcw; break;
        case 23: ev = e->dmac5; break;
        case 24: ev = e->dmac4; break;
        case 25: ev = e->dmac3; break;
        case 26: ev = e->dmac2; break;
        case 27: ev = e->dmac1; break;
        case 28: ev = e->dmac0; break;
        case 29: ev = e->vlan; break;
        case 30: ev = e->vid; break;
        case 31: ev = e->pricfi; break;
        case 32: ev = e->tpid; break;
        case 33: ev = e->mimtype; break;
        case 34: ev = e->btag_vid; break;
        case 35: ev = e->btag_pricfi; break;
        case 36: ev = e->btag_tpid; break;
        case 37: ev = e->ttl2; break;
        case 38: ev = e->s2; break;
        case 39: ev = e->exp2; break;
        case 40: ev = e->label2; break;
        case 41: ev = e->etype; break;
        case 42: ev = e->pid; break;
        case 43: ev = e->isid; break;
        case 44: ev = e->rsvd; break;
        case 45: ev = e->ucm; break;
        case 46: ev = e->dei; break;
        case 47: ev = e->pcp; break;
        case 48: ev = e->ttl0; break;
        case 49: ev = e->s0; break;
        case 50: ev = e->exp0; break;
        case 51: ev = e->label0; break;
        case 52: ev = e->ttl1; break;
        case 53: ev = e->s1; break;
        case 54: ev = e->exp1; break;
        case 55: ev = e->label1; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* eteencap table size get */
int soc_sbx_g2p3_eteencap_entry_table_size_get(int unit,
                int *tsize,
                int ietei)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ETEENCAP_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ietei; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for eteencap */
int soc_sbx_g2p3_eteencap_set(int unit,
                int ietei,
                soc_sbx_g2p3_eteencap_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ETEENCAP_ID];

    s = soc_sbx_g2p3_eteencap_index_check(unit, key,
                ietei);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_eteencap_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_eteencap_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for eteencap */
int soc_sbx_g2p3_eteencap_get(int unit,
                int ietei,
                soc_sbx_g2p3_eteencap_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ETEENCAP_ID];

    s = soc_sbx_g2p3_eteencap_index_check(unit, key,
                ietei);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_eteencap_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for etel2
 */

void soc_sbx_g2p3_etel2_t_init(
    soc_sbx_g2p3_etel2_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_etel2_t));
    e->stpcheck = 0x1;
}

/* variable sized entry size function for etel2 */
int soc_sbx_g2p3_etel2_size(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ETEL2_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];

    return (eb->width + (eb->stridebits - 1)) / eb->stridebits;
}

/* entry pack accessor implementation for etel2 */
int soc_sbx_g2p3_etel2_pack(int unit,
    soc_sbx_g2p3_etel2_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ETEL2_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->dscpremark; break;
        case 1: p = (uint8 *) &e->encaplen; break;
        case 2: p = (uint8 *) &e->nostrip; break;
        case 3: p = (uint8 *) &e->noclass; break;
        case 4: p = (uint8 *) &e->remark; break;
        case 5: p = (uint8 *) &e->nosplitcheck; break;
        case 6: p = (uint8 *) &e->usetag; break;
        case 7: p = (uint8 *) &e->dropuntagged; break;
        case 8: p = (uint8 *) &e->droptagged; break;
        case 9: p = (uint8 *) &e->smacindex; break;
        case 10: p = (uint8 *) &e->stpcheck; break;
        case 11: p = (uint8 *) &e->vid; break;
        case 12: p = (uint8 *) &e->defpricfi; break;
        case 13: p = (uint8 *) &e->mtu; break;
        case 14: p = (uint8 *) &e->usevid; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for etel2 */
int soc_sbx_g2p3_etel2_unpack(int unit,
                soc_sbx_g2p3_etel2_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ETEL2_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->dscpremark; break;
        case 1: p = (uint8 *) &e->encaplen; break;
        case 2: p = (uint8 *) &e->nostrip; break;
        case 3: p = (uint8 *) &e->noclass; break;
        case 4: p = (uint8 *) &e->remark; break;
        case 5: p = (uint8 *) &e->nosplitcheck; break;
        case 6: p = (uint8 *) &e->usetag; break;
        case 7: p = (uint8 *) &e->dropuntagged; break;
        case 8: p = (uint8 *) &e->droptagged; break;
        case 9: p = (uint8 *) &e->smacindex; break;
        case 10: p = (uint8 *) &e->stpcheck; break;
        case 11: p = (uint8 *) &e->vid; break;
        case 12: p = (uint8 *) &e->defpricfi; break;
        case 13: p = (uint8 *) &e->mtu; break;
        case 14: p = (uint8 *) &e->usevid; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for etel2 */
int soc_sbx_g2p3_etel2_index_check(int unit,
                int *vindex,
                int ietei)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ETEL2_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ietei; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for etel2 */
int soc_sbx_g2p3_etel2_entry_check(int unit,
                soc_sbx_g2p3_etel2_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ETEL2_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->dscpremark; break;
        case 1: ev = e->encaplen; break;
        case 2: ev = e->nostrip; break;
        case 3: ev = e->noclass; break;
        case 4: ev = e->remark; break;
        case 5: ev = e->nosplitcheck; break;
        case 6: ev = e->usetag; break;
        case 7: ev = e->dropuntagged; break;
        case 8: ev = e->droptagged; break;
        case 9: ev = e->smacindex; break;
        case 10: ev = e->stpcheck; break;
        case 11: ev = e->vid; break;
        case 12: ev = e->defpricfi; break;
        case 13: ev = e->mtu; break;
        case 14: ev = e->usevid; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* etel2 table size get */
int soc_sbx_g2p3_etel2_entry_table_size_get(int unit,
                int *tsize,
                int ietei)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ETEL2_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ietei; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for etel2 */
int soc_sbx_g2p3_etel2_set(int unit,
                int ietei,
                soc_sbx_g2p3_etel2_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ETEL2_ID];

    s = soc_sbx_g2p3_etel2_index_check(unit, key,
                ietei);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_etel2_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_etel2_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for etel2 */
int soc_sbx_g2p3_etel2_get(int unit,
                int ietei,
                soc_sbx_g2p3_etel2_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ETEL2_ID];

    s = soc_sbx_g2p3_etel2_index_check(unit, key,
                ietei);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_etel2_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for oamEp
 */

void soc_sbx_g2p3_oamep_t_init(
    soc_sbx_g2p3_oamep_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_oamep_t));
    e->notlm = 0x1;
}

/* entry pack accessor implementation for oamEp */
int soc_sbx_g2p3_oamep_pack(int unit,
    soc_sbx_g2p3_oamep_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMEP_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: if (((e->function==1) || (e->function==3) || (e->function==4) ||
                    (e->function==5) || (e->function==6) || (e->function==7))) {
                     p = (uint8 *) &e->nextentry;
                 }else{
                     continue;
                 }
                 break;
        case 1: p = (uint8 *) &e->function; break;
        case 2: p = (uint8 *) &e->type; break;
        case 3: if (((e->function==1) || (e->function==4))) {
                     p = (uint8 *) &e->interval;
                 }else{
                     continue;
                 }
                 break;
        case 4: if (((e->function==2) || (e->function==3) || (e->function==4))) {
                     p = (uint8 *) &e->mdlevel;
                 }else{
                     continue;
                 }
                 break;
        case 5: if (((e->function==2) || (e->function==3))) {
                     p = (uint8 *) &e->singletx;
                 }else{
                     continue;
                 }
                 break;
        case 6: if (((e->function==1) || (e->function==2) || (e->function==3))) {
                     p = (uint8 *) &e->mode;
                 }else{
                     continue;
                 }
                 break;
        case 7: if (((e->function==2) || (e->function==3) || (e->function==4))) {
                     p = (uint8 *) &e->dir;
                 }else{
                     continue;
                 }
                 break;
        case 8: if (((e->function==1) || (e->function==2) || (e->function==3) ||
                    (e->function==4))) {
                     p = (uint8 *) &e->conttohost;
                 }else{
                     continue;
                 }
                 break;
        case 9: if (((e->function==1) || (e->function==2) || (e->function==3) ||
                    (e->function==4))) {
                     p = (uint8 *) &e->singletohost;
                 }else{
                     continue;
                 }
                 break;
        case 10: if (((e->function==0) || (e->function==1) ||
                    (e->function==3) || (e->function==5) || (e->function==7))) {
                     p = (uint8 *) &e->ftidx;
                 }else{
                     continue;
                 }
                 break;
        case 11: if ((e->function==1)) {
                     p = (uint8 *) &e->m;
                 }else{
                     continue;
                 }
                 break;
        case 12: if ((e->function==1)) {
                     p = (uint8 *) &e->d;
                 }else{
                     continue;
                 }
                 break;
        case 13: if ((e->function==1)) {
                     p = (uint8 *) &e->a;
                 }else{
                     continue;
                 }
                 break;
        case 14: if ((e->function==1)) {
                     p = (uint8 *) &e->c;
                 }else{
                     continue;
                 }
                 break;
        case 15: if ((e->function==1)) {
                     p = (uint8 *) &e->unibi;
                 }else{
                     continue;
                 }
                 break;
        case 16: if ((e->function==1)) {
                     p = (uint8 *) &e->cv;
                 }else{
                     continue;
                 }
                 break;
        case 17: if ((e->function==1)) {
                     p = (uint8 *) &e->fbit;
                 }else{
                     continue;
                 }
                 break;
        case 18: if ((e->function==2)) {
                     p = (uint8 *) &e->counteridx;
                 }else{
                     continue;
                 }
                 break;
        case 19: if ((e->function==2)) {
                     p = (uint8 *) &e->multiplieridx;
                 }else{
                     continue;
                 }
                 break;
        case 20: if ((e->function==2)) {
                     p = (uint8 *) &e->rxfc;
                 }else{
                     continue;
                 }
                 break;
        case 21: if ((e->function==4)) {
                     p = (uint8 *) &e->rdi;
                 }else{
                     continue;
                 }
                 break;
        case 22: if ((e->function==4)) {
                     p = (uint8 *) &e->mip;
                 }else{
                     continue;
                 }
                 break;
        case 23: if ((e->function==4)) {
                     p = (uint8 *) &e->lm;
                 }else{
                     continue;
                 }
                 break;
        case 24: if ((e->function==4)) {
                     p = (uint8 *) &e->notlm;
                 }else{
                     continue;
                 }
                 break;
        case 25: if ((e->function==4)) {
                     p = (uint8 *) &e->mepid;
                 }else{
                     continue;
                 }
                 break;
        case 26: if ((e->function==4)) {
                     p = (uint8 *) &e->intpri;
                 }else{
                     continue;
                 }
                 break;
        case 27: if ((e->function==5)) {
                     p = (uint8 *) &e->smacaux;
                 }else{
                     continue;
                 }
                 break;
        case 28: if ((e->function==5)) {
                     p = (uint8 *) &e->smacadd;
                 }else{
                     continue;
                 }
                 break;
        case 29: if ((e->function==5)) {
                     p = (uint8 *) &e->smacoffset;
                 }else{
                     continue;
                 }
                 break;
        case 30: if ((e->function==5)) {
                     p = (uint8 *) &e->sid;
                 }else{
                     continue;
                 }
                 break;
        case 31: if ((e->function==7)) {
                     p = (uint8 *) &e->tx;
                 }else{
                     continue;
                 }
                 break;
        case 32: if ((e->function==1)) {
                     p = (uint8 *) &e->yourdiscrim;
                 }else{
                     continue;
                 }
                 break;
        case 33: if ((e->function==1)) {
                     p = (uint8 *) &e->mydiscrim;
                 }else{
                     continue;
                 }
                 break;
        case 34: if ((e->function==2)) {
                     p = (uint8 *) &e->rxfcl;
                 }else{
                     continue;
                 }
                 break;
        case 35: if ((e->function==2)) {
                     p = (uint8 *) &e->nextentry_store;
                 }else{
                     continue;
                 }
                 break;
        case 36: if ((e->function==2)) {
                     p = (uint8 *) &e->ftidx_store;
                 }else{
                     continue;
                 }
                 break;
        case 37: if ((e->function==3)) {
                     p = (uint8 *) &e->delaysec;
                 }else{
                     continue;
                 }
                 break;
        case 38: if ((e->function==3)) {
                     p = (uint8 *) &e->remotesec;
                 }else{
                     continue;
                 }
                 break;
        case 39: if ((e->function==4)) {
                     p = (uint8 *) &e->maidw3;
                 }else{
                     continue;
                 }
                 break;
        case 40: if ((e->function==4)) {
                     p = (uint8 *) &e->maidw2;
                 }else{
                     continue;
                 }
                 break;
        case 41: if ((e->function==5)) {
                     p = (uint8 *) &e->maidw9;
                 }else{
                     continue;
                 }
                 break;
        case 42: if ((e->function==5)) {
                     p = (uint8 *) &e->maidw8;
                 }else{
                     continue;
                 }
                 break;
        case 43: if ((e->function==6)) {
                     p = (uint8 *) &e->maidcrc;
                 }else{
                     continue;
                 }
                 break;
        case 44: if ((e->function==7)) {
                     p = (uint8 *) &e->path;
                 }else{
                     continue;
                 }
                 break;
        case 45: if ((e->function==7)) {
                     p = (uint8 *) &e->fpath;
                 }else{
                     continue;
                 }
                 break;
        case 46: if ((e->function==7)) {
                     p = (uint8 *) &e->reserved;
                 }else{
                     continue;
                 }
                 break;
        case 47: if ((e->function==7)) {
                     p = (uint8 *) &e->revertive;
                 }else{
                     continue;
                 }
                 break;
        case 48: if ((e->function==7)) {
                     p = (uint8 *) &e->pt;
                 }else{
                     continue;
                 }
                 break;
        case 49: if ((e->function==7)) {
                     p = (uint8 *) &e->request;
                 }else{
                     continue;
                 }
                 break;
        case 50: if ((e->function==7)) {
                     p = (uint8 *) &e->version;
                 }else{
                     continue;
                 }
                 break;
        case 51: if ((e->function==7)) {
                     p = (uint8 *) &e->pschdr;
                 }else{
                     continue;
                 }
                 break;
        case 52: if ((e->function==7)) {
                     p = (uint8 *) &e->slowrate;
                 }else{
                     continue;
                 }
                 break;
        case 53: if ((e->function==7)) {
                     p = (uint8 *) &e->filter;
                 }else{
                     continue;
                 }
                 break;
        case 54: if ((e->function==7)) {
                     p = (uint8 *) &e->burst;
                 }else{
                     continue;
                 }
                 break;
        case 55: if ((e->function==1)) {
                     p = (uint8 *) &e->pscentry;
                 }else{
                     continue;
                 }
                 break;
        case 56: if ((e->function==1)) {
                     p = (uint8 *) &e->ipda;
                 }else{
                     continue;
                 }
                 break;
        case 57: if ((e->function==2)) {
                     p = (uint8 *) &e->txfcf;
                 }else{
                     continue;
                 }
                 break;
        case 58: if ((e->function==2)) {
                     p = (uint8 *) &e->txfcb;
                 }else{
                     continue;
                 }
                 break;
        case 59: if ((e->function==4)) {
                     p = (uint8 *) &e->maidw1;
                 }else{
                     continue;
                 }
                 break;
        case 60: if ((e->function==4)) {
                     p = (uint8 *) &e->maidw0;
                 }else{
                     continue;
                 }
                 break;
        case 61: if ((e->function==5)) {
                     p = (uint8 *) &e->maidw7;
                 }else{
                     continue;
                 }
                 break;
        case 62: if ((e->function==5)) {
                     p = (uint8 *) &e->maidw6;
                 }else{
                     continue;
                 }
                 break;
        case 63: if ((e->function==7)) {
                     p = (uint8 *) &e->maxslowrate;
                 }else{
                     continue;
                 }
                 break;
        case 64: if (((e->function==1) || (e->function==6))) {
                     p = (uint8 *) &e->peerrdi;
                 }else{
                     continue;
                 }
                 break;
        case 65: if (((e->function==1) || (e->function==6))) {
                     p = (uint8 *) &e->ackrdi;
                 }else{
                     continue;
                 }
                 break;
        case 66: if (((e->function==1) || (e->function==6))) {
                     p = (uint8 *) &e->ackrdi_rdi;
                 }else{
                     continue;
                 }
                 break;
        case 67: if (((e->function==1) || (e->function==6))) {
                     p = (uint8 *) &e->policerid;
                 }else{
                     continue;
                 }
                 break;
        case 68: if ((e->function==1)) {
                     p = (uint8 *) &e->udpsourceport;
                 }else{
                     continue;
                 }
                 break;
        case 69: if ((e->function==1)) {
                     p = (uint8 *) &e->multipoint;
                 }else{
                     continue;
                 }
                 break;
        case 70: if ((e->function==1)) {
                     p = (uint8 *) &e->peerstate;
                 }else{
                     continue;
                 }
                 break;
        case 71: if ((e->function==1)) {
                     p = (uint8 *) &e->final;
                 }else{
                     continue;
                 }
                 break;
        case 72: if ((e->function==1)) {
                     p = (uint8 *) &e->poll;
                 }else{
                     continue;
                 }
                 break;
        case 73: if ((e->function==1)) {
                     p = (uint8 *) &e->localstate;
                 }else{
                     continue;
                 }
                 break;
        case 74: if ((e->function==1)) {
                     p = (uint8 *) &e->diag;
                 }else{
                     continue;
                 }
                 break;
        case 75: if ((e->function==1)) {
                     p = (uint8 *) &e->peerdetectmulti;
                 }else{
                     continue;
                 }
                 break;
        case 76: if ((e->function==1)) {
                     p = (uint8 *) &e->localdetectmulti;
                 }else{
                     continue;
                 }
                 break;
        case 77: if ((e->function==2)) {
                     p = (uint8 *) &e->framelossfar;
                 }else{
                     continue;
                 }
                 break;
        case 78: if ((e->function==2)) {
                     p = (uint8 *) &e->framelossnear;
                 }else{
                     continue;
                 }
                 break;
        case 79: if ((e->function==3)) {
                     p = (uint8 *) &e->delaynanosec;
                 }else{
                     continue;
                 }
                 break;
        case 80: if ((e->function==3)) {
                     p = (uint8 *) &e->remotenanosec;
                 }else{
                     continue;
                 }
                 break;
        case 81: if ((e->function==4)) {
                     p = (uint8 *) &e->maidw5;
                 }else{
                     continue;
                 }
                 break;
        case 82: if ((e->function==4)) {
                     p = (uint8 *) &e->maidw4;
                 }else{
                     continue;
                 }
                 break;
        case 83: if ((e->function==5)) {
                     p = (uint8 *) &e->maidw11;
                 }else{
                     continue;
                 }
                 break;
        case 84: if ((e->function==5)) {
                     p = (uint8 *) &e->maidw10;
                 }else{
                     continue;
                 }
                 break;
        case 85: if ((e->function==7)) {
                     p = (uint8 *) &e->maxfilter;
                 }else{
                     continue;
                 }
                 break;
        case 86: if ((e->function==7)) {
                     p = (uint8 *) &e->tlvlength;
                 }else{
                     continue;
                 }
                 break;
        case 87: if ((e->function==7)) {
                     p = (uint8 *) &e->tlv0_3;
                 }else{
                     continue;
                 }
                 break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for oamEp */
int soc_sbx_g2p3_oamep_unpack(int unit,
                soc_sbx_g2p3_oamep_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMEP_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->nextentry; break;
        case 1: p = (uint8 *) &e->function; break;
        case 2: p = (uint8 *) &e->type; break;
        case 3: p = (uint8 *) &e->interval; break;
        case 4: p = (uint8 *) &e->mdlevel; break;
        case 5: p = (uint8 *) &e->singletx; break;
        case 6: p = (uint8 *) &e->mode; break;
        case 7: p = (uint8 *) &e->dir; break;
        case 8: p = (uint8 *) &e->conttohost; break;
        case 9: p = (uint8 *) &e->singletohost; break;
        case 10: p = (uint8 *) &e->ftidx; break;
        case 11: p = (uint8 *) &e->m; break;
        case 12: p = (uint8 *) &e->d; break;
        case 13: p = (uint8 *) &e->a; break;
        case 14: p = (uint8 *) &e->c; break;
        case 15: p = (uint8 *) &e->unibi; break;
        case 16: p = (uint8 *) &e->cv; break;
        case 17: p = (uint8 *) &e->fbit; break;
        case 18: p = (uint8 *) &e->counteridx; break;
        case 19: p = (uint8 *) &e->multiplieridx; break;
        case 20: p = (uint8 *) &e->rxfc; break;
        case 21: p = (uint8 *) &e->rdi; break;
        case 22: p = (uint8 *) &e->mip; break;
        case 23: p = (uint8 *) &e->lm; break;
        case 24: p = (uint8 *) &e->notlm; break;
        case 25: p = (uint8 *) &e->mepid; break;
        case 26: p = (uint8 *) &e->intpri; break;
        case 27: p = (uint8 *) &e->smacaux; break;
        case 28: p = (uint8 *) &e->smacadd; break;
        case 29: p = (uint8 *) &e->smacoffset; break;
        case 30: p = (uint8 *) &e->sid; break;
        case 31: p = (uint8 *) &e->tx; break;
        case 32: p = (uint8 *) &e->yourdiscrim; break;
        case 33: p = (uint8 *) &e->mydiscrim; break;
        case 34: p = (uint8 *) &e->rxfcl; break;
        case 35: p = (uint8 *) &e->nextentry_store; break;
        case 36: p = (uint8 *) &e->ftidx_store; break;
        case 37: p = (uint8 *) &e->delaysec; break;
        case 38: p = (uint8 *) &e->remotesec; break;
        case 39: p = (uint8 *) &e->maidw3; break;
        case 40: p = (uint8 *) &e->maidw2; break;
        case 41: p = (uint8 *) &e->maidw9; break;
        case 42: p = (uint8 *) &e->maidw8; break;
        case 43: p = (uint8 *) &e->maidcrc; break;
        case 44: p = (uint8 *) &e->path; break;
        case 45: p = (uint8 *) &e->fpath; break;
        case 46: p = (uint8 *) &e->reserved; break;
        case 47: p = (uint8 *) &e->revertive; break;
        case 48: p = (uint8 *) &e->pt; break;
        case 49: p = (uint8 *) &e->request; break;
        case 50: p = (uint8 *) &e->version; break;
        case 51: p = (uint8 *) &e->pschdr; break;
        case 52: p = (uint8 *) &e->slowrate; break;
        case 53: p = (uint8 *) &e->filter; break;
        case 54: p = (uint8 *) &e->burst; break;
        case 55: p = (uint8 *) &e->pscentry; break;
        case 56: p = (uint8 *) &e->ipda; break;
        case 57: p = (uint8 *) &e->txfcf; break;
        case 58: p = (uint8 *) &e->txfcb; break;
        case 59: p = (uint8 *) &e->maidw1; break;
        case 60: p = (uint8 *) &e->maidw0; break;
        case 61: p = (uint8 *) &e->maidw7; break;
        case 62: p = (uint8 *) &e->maidw6; break;
        case 63: p = (uint8 *) &e->maxslowrate; break;
        case 64: p = (uint8 *) &e->peerrdi; break;
        case 65: p = (uint8 *) &e->ackrdi; break;
        case 66: p = (uint8 *) &e->ackrdi_rdi; break;
        case 67: p = (uint8 *) &e->policerid; break;
        case 68: p = (uint8 *) &e->udpsourceport; break;
        case 69: p = (uint8 *) &e->multipoint; break;
        case 70: p = (uint8 *) &e->peerstate; break;
        case 71: p = (uint8 *) &e->final; break;
        case 72: p = (uint8 *) &e->poll; break;
        case 73: p = (uint8 *) &e->localstate; break;
        case 74: p = (uint8 *) &e->diag; break;
        case 75: p = (uint8 *) &e->peerdetectmulti; break;
        case 76: p = (uint8 *) &e->localdetectmulti; break;
        case 77: p = (uint8 *) &e->framelossfar; break;
        case 78: p = (uint8 *) &e->framelossnear; break;
        case 79: p = (uint8 *) &e->delaynanosec; break;
        case 80: p = (uint8 *) &e->remotenanosec; break;
        case 81: p = (uint8 *) &e->maidw5; break;
        case 82: p = (uint8 *) &e->maidw4; break;
        case 83: p = (uint8 *) &e->maidw11; break;
        case 84: p = (uint8 *) &e->maidw10; break;
        case 85: p = (uint8 *) &e->maxfilter; break;
        case 86: p = (uint8 *) &e->tlvlength; break;
        case 87: p = (uint8 *) &e->tlv0_3; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for oamEp */
int soc_sbx_g2p3_oamep_index_check(int unit,
                int *vindex,
                int iepidx)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMEP_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iepidx; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for oamEp */
int soc_sbx_g2p3_oamep_entry_check(int unit,
                soc_sbx_g2p3_oamep_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMEP_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->nextentry; break;
        case 1: ev = e->function; break;
        case 2: ev = e->type; break;
        case 3: ev = e->interval; break;
        case 4: ev = e->mdlevel; break;
        case 5: ev = e->singletx; break;
        case 6: ev = e->mode; break;
        case 7: ev = e->dir; break;
        case 8: ev = e->conttohost; break;
        case 9: ev = e->singletohost; break;
        case 10: ev = e->ftidx; break;
        case 11: ev = e->m; break;
        case 12: ev = e->d; break;
        case 13: ev = e->a; break;
        case 14: ev = e->c; break;
        case 15: ev = e->unibi; break;
        case 16: ev = e->cv; break;
        case 17: ev = e->fbit; break;
        case 18: ev = e->counteridx; break;
        case 19: ev = e->multiplieridx; break;
        case 20: ev = e->rxfc; break;
        case 21: ev = e->rdi; break;
        case 22: ev = e->mip; break;
        case 23: ev = e->lm; break;
        case 24: ev = e->notlm; break;
        case 25: ev = e->mepid; break;
        case 26: ev = e->intpri; break;
        case 27: ev = e->smacaux; break;
        case 28: ev = e->smacadd; break;
        case 29: ev = e->smacoffset; break;
        case 30: ev = e->sid; break;
        case 31: ev = e->tx; break;
        case 32: ev = e->yourdiscrim; break;
        case 33: ev = e->mydiscrim; break;
        case 34: ev = e->rxfcl; break;
        case 35: ev = e->nextentry_store; break;
        case 36: ev = e->ftidx_store; break;
        case 37: ev = e->delaysec; break;
        case 38: ev = e->remotesec; break;
        case 39: ev = e->maidw3; break;
        case 40: ev = e->maidw2; break;
        case 41: ev = e->maidw9; break;
        case 42: ev = e->maidw8; break;
        case 43: ev = e->maidcrc; break;
        case 44: ev = e->path; break;
        case 45: ev = e->fpath; break;
        case 46: ev = e->reserved; break;
        case 47: ev = e->revertive; break;
        case 48: ev = e->pt; break;
        case 49: ev = e->request; break;
        case 50: ev = e->version; break;
        case 51: ev = e->pschdr; break;
        case 52: ev = e->slowrate; break;
        case 53: ev = e->filter; break;
        case 54: ev = e->burst; break;
        case 55: ev = e->pscentry; break;
        case 56: ev = e->ipda; break;
        case 57: ev = e->txfcf; break;
        case 58: ev = e->txfcb; break;
        case 59: ev = e->maidw1; break;
        case 60: ev = e->maidw0; break;
        case 61: ev = e->maidw7; break;
        case 62: ev = e->maidw6; break;
        case 63: ev = e->maxslowrate; break;
        case 64: ev = e->peerrdi; break;
        case 65: ev = e->ackrdi; break;
        case 66: ev = e->ackrdi_rdi; break;
        case 67: ev = e->policerid; break;
        case 68: ev = e->udpsourceport; break;
        case 69: ev = e->multipoint; break;
        case 70: ev = e->peerstate; break;
        case 71: ev = e->final; break;
        case 72: ev = e->poll; break;
        case 73: ev = e->localstate; break;
        case 74: ev = e->diag; break;
        case 75: ev = e->peerdetectmulti; break;
        case 76: ev = e->localdetectmulti; break;
        case 77: ev = e->framelossfar; break;
        case 78: ev = e->framelossnear; break;
        case 79: ev = e->delaynanosec; break;
        case 80: ev = e->remotenanosec; break;
        case 81: ev = e->maidw5; break;
        case 82: ev = e->maidw4; break;
        case 83: ev = e->maidw11; break;
        case 84: ev = e->maidw10; break;
        case 85: ev = e->maxfilter; break;
        case 86: ev = e->tlvlength; break;
        case 87: ev = e->tlv0_3; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* oamEp table size get */
int soc_sbx_g2p3_oamep_entry_table_size_get(int unit,
                int *tsize,
                int iepidx)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMEP_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = iepidx; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for oamEp */
int soc_sbx_g2p3_oamep_set(int unit,
                int iepidx,
                soc_sbx_g2p3_oamep_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMEP_ID];

    s = soc_sbx_g2p3_oamep_index_check(unit, key,
                iepidx);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_oamep_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_oamep_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for oamEp */
int soc_sbx_g2p3_oamep_get(int unit,
                int iepidx,
                soc_sbx_g2p3_oamep_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMEP_ID];

    s = soc_sbx_g2p3_oamep_index_check(unit, key,
                iepidx);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_oamep_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for remark
 */

void soc_sbx_g2p3_remark_t_init(
    soc_sbx_g2p3_remark_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_remark_t));
}

/* entry pack accessor implementation for remark */
int soc_sbx_g2p3_remark_pack(int unit,
    soc_sbx_g2p3_remark_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_REMARK_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->cfi; break;
        case 1: p = (uint8 *) &e->pri; break;
        case 2: p = (uint8 *) &e->exp; break;
        case 3: p = (uint8 *) &e->dscp; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for remark */
int soc_sbx_g2p3_remark_unpack(int unit,
                soc_sbx_g2p3_remark_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_REMARK_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->cfi; break;
        case 1: p = (uint8 *) &e->pri; break;
        case 2: p = (uint8 *) &e->exp; break;
        case 3: p = (uint8 *) &e->dscp; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for remark */
int soc_sbx_g2p3_remark_index_check(int unit,
                int *vindex,
                int ie,
                int idp,
                int icos,
                int iprof)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_REMARK_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ie; break;
        case 1: p = (uint8 *) &idp; break;
        case 2: p = (uint8 *) &icos; break;
        case 3: p = (uint8 *) &iprof; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for remark */
int soc_sbx_g2p3_remark_entry_check(int unit,
                soc_sbx_g2p3_remark_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_REMARK_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->cfi; break;
        case 1: ev = e->pri; break;
        case 2: ev = e->exp; break;
        case 3: ev = e->dscp; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* remark table size get */
int soc_sbx_g2p3_remark_entry_table_size_get(int unit,
                int *tsize,
                int ie,
                int idp,
                int icos,
                int iprof)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_REMARK_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ie; break;
        case 1: v = idp; break;
        case 2: v = icos; break;
        case 3: v = iprof; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for remark */
int soc_sbx_g2p3_remark_set(int unit,
                int ie,
                int idp,
                int icos,
                int iprof,
                soc_sbx_g2p3_remark_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_REMARK_ID];

    s = soc_sbx_g2p3_remark_index_check(unit, key,
                ie,
                idp,
                icos,
                iprof);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_remark_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_remark_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for remark */
int soc_sbx_g2p3_remark_get(int unit,
                int ie,
                int idp,
                int icos,
                int iprof,
                soc_sbx_g2p3_remark_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_REMARK_ID];

    s = soc_sbx_g2p3_remark_index_check(unit, key,
                ie,
                idp,
                icos,
                iprof);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_remark_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for epv2e
 */

void soc_sbx_g2p3_epv2e_t_init(
    soc_sbx_g2p3_epv2e_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_epv2e_t));
}

/* entry pack accessor implementation for epv2e */
int soc_sbx_g2p3_epv2e_pack(int unit,
    soc_sbx_g2p3_epv2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EPV2E_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->drop; break;
        case 1: p = (uint8 *) &e->strip; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for epv2e */
int soc_sbx_g2p3_epv2e_unpack(int unit,
                soc_sbx_g2p3_epv2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EPV2E_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->drop; break;
        case 1: p = (uint8 *) &e->strip; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for epv2e */
int soc_sbx_g2p3_epv2e_index_check(int unit,
                int *vindex,
                int ivid,
                int iport)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EPV2E_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ivid; break;
        case 1: p = (uint8 *) &iport; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for epv2e */
int soc_sbx_g2p3_epv2e_entry_check(int unit,
                soc_sbx_g2p3_epv2e_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EPV2E_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->drop; break;
        case 1: ev = e->strip; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* epv2e table size get */
int soc_sbx_g2p3_epv2e_entry_table_size_get(int unit,
                int *tsize,
                int ivid,
                int iport)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EPV2E_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ivid; break;
        case 1: v = iport; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for epv2e */
int soc_sbx_g2p3_epv2e_set(int unit,
                int ivid,
                int iport,
                soc_sbx_g2p3_epv2e_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EPV2E_ID];

    s = soc_sbx_g2p3_epv2e_index_check(unit, key,
                ivid,
                iport);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_epv2e_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_epv2e_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}
int soc_sbx_g2p3_epv2e_drop_fast_set(int unit,
                int ivid,
                int iport,
                int eivid,
                int eiport,
                int *sets,
                uint32 *vs,
                int vcount)
{
    int startvindex, endvindex, s;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EPV2E_ID];
    soc_sbx_g2p3_field_desc_t *fd =
        &ed->fields[0];

    s = soc_sbx_g2p3_epv2e_index_check(unit, &startvindex,
                ivid,
                iport);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_epv2e_index_check(unit, &endvindex,
                eivid,
                eiport);
    if (s) {
        return s;
    }
    if (endvindex - startvindex >= vcount) {
        return SOC_E_PARAM;
    }

    s = soc_sbx_g2p3_entry_generic_fast_set(unit,
                  fd, ed, startvindex, endvindex, sets, vs);

    return s;
}
int soc_sbx_g2p3_epv2e_strip_fast_set(int unit,
                int ivid,
                int iport,
                int eivid,
                int eiport,
                int *sets,
                uint32 *vs,
                int vcount)
{
    int startvindex, endvindex, s;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EPV2E_ID];
    soc_sbx_g2p3_field_desc_t *fd =
        &ed->fields[1];

    s = soc_sbx_g2p3_epv2e_index_check(unit, &startvindex,
                ivid,
                iport);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_epv2e_index_check(unit, &endvindex,
                eivid,
                eiport);
    if (s) {
        return s;
    }
    if (endvindex - startvindex >= vcount) {
        return SOC_E_PARAM;
    }

    s = soc_sbx_g2p3_entry_generic_fast_set(unit,
                  fd, ed, startvindex, endvindex, sets, vs);

    return s;
}

/* entry get accessor implementation for epv2e */
int soc_sbx_g2p3_epv2e_get(int unit,
                int ivid,
                int iport,
                soc_sbx_g2p3_epv2e_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EPV2E_ID];

    s = soc_sbx_g2p3_epv2e_index_check(unit, key,
                ivid,
                iport);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_epv2e_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for esmac
 */

void soc_sbx_g2p3_esmac_t_init(
    soc_sbx_g2p3_esmac_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_esmac_t));
}

/* entry pack accessor implementation for esmac */
int soc_sbx_g2p3_esmac_pack(int unit,
    soc_sbx_g2p3_esmac_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ESMAC_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->smac5; break;
        case 1: p = (uint8 *) &e->smac4; break;
        case 2: p = (uint8 *) &e->smac3; break;
        case 3: p = (uint8 *) &e->smac2; break;
        case 4: p = (uint8 *) &e->smac1; break;
        case 5: p = (uint8 *) &e->smac0; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for esmac */
int soc_sbx_g2p3_esmac_unpack(int unit,
                soc_sbx_g2p3_esmac_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ESMAC_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->smac5; break;
        case 1: p = (uint8 *) &e->smac4; break;
        case 2: p = (uint8 *) &e->smac3; break;
        case 3: p = (uint8 *) &e->smac2; break;
        case 4: p = (uint8 *) &e->smac1; break;
        case 5: p = (uint8 *) &e->smac0; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for esmac */
int soc_sbx_g2p3_esmac_index_check(int unit,
                int *vindex,
                int ismaci)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ESMAC_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ismaci; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for esmac */
int soc_sbx_g2p3_esmac_entry_check(int unit,
                soc_sbx_g2p3_esmac_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ESMAC_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->smac5; break;
        case 1: ev = e->smac4; break;
        case 2: ev = e->smac3; break;
        case 3: ev = e->smac2; break;
        case 4: ev = e->smac1; break;
        case 5: ev = e->smac0; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* esmac table size get */
int soc_sbx_g2p3_esmac_entry_table_size_get(int unit,
                int *tsize,
                int ismaci)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ESMAC_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ismaci; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for esmac */
int soc_sbx_g2p3_esmac_set(int unit,
                int ismaci,
                soc_sbx_g2p3_esmac_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ESMAC_ID];

    s = soc_sbx_g2p3_esmac_index_check(unit, key,
                ismaci);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_esmac_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_esmac_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for esmac */
int soc_sbx_g2p3_esmac_get(int unit,
                int ismaci,
                soc_sbx_g2p3_esmac_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ESMAC_ID];

    s = soc_sbx_g2p3_esmac_index_check(unit, key,
                ismaci);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_esmac_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for ert
 */

void soc_sbx_g2p3_ert_t_init(
    soc_sbx_g2p3_ert_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ert_t));
}

/* entry pack accessor implementation for ert */
int soc_sbx_g2p3_ert_pack(int unit,
    soc_sbx_g2p3_ert_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ERT_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->mirror; break;
        case 1: p = (uint8 *) &e->drop; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ert */
int soc_sbx_g2p3_ert_unpack(int unit,
                soc_sbx_g2p3_ert_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ERT_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->mirror; break;
        case 1: p = (uint8 *) &e->drop; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ert */
int soc_sbx_g2p3_ert_index_check(int unit,
                int *vindex,
                int irule)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ERT_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &irule; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ert */
int soc_sbx_g2p3_ert_entry_check(int unit,
                soc_sbx_g2p3_ert_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ERT_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->mirror; break;
        case 1: ev = e->drop; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* ert table size get */
int soc_sbx_g2p3_ert_entry_table_size_get(int unit,
                int *tsize,
                int irule)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ERT_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = irule; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for ert */
int soc_sbx_g2p3_ert_set(int unit,
                int irule,
                soc_sbx_g2p3_ert_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ERT_ID];

    s = soc_sbx_g2p3_ert_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ert_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_ert_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for ert */
int soc_sbx_g2p3_ert_get(int unit,
                int irule,
                soc_sbx_g2p3_ert_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ERT_ID];

    s = soc_sbx_g2p3_ert_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_ert_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for ert_wrap
 */

void soc_sbx_g2p3_ert_wrap_t_init(
    soc_sbx_g2p3_ert_wrap_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ert_wrap_t));
}

/* entry size function for ert_wrap */
int soc_sbx_g2p3_ert_wrap_size(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ERT_WRAP_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];

    return (eb->width + (eb->stridebits - 1)) / eb->stridebits;
}

/* entry pack accessor implementation for ert_wrap */
int soc_sbx_g2p3_ert_wrap_pack(int unit,
    soc_sbx_g2p3_ert_wrap_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ERT_WRAP_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->mirror; break;
        case 1: p = (uint8 *) &e->drop; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ert_wrap */
int soc_sbx_g2p3_ert_wrap_unpack(int unit,
                soc_sbx_g2p3_ert_wrap_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ERT_WRAP_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->mirror; break;
        case 1: p = (uint8 *) &e->drop; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ert_wrap */
int soc_sbx_g2p3_ert_wrap_index_check(int unit,
                int *vindex,
                int irule)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ERT_WRAP_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &irule; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ert_wrap */
int soc_sbx_g2p3_ert_wrap_entry_check(int unit,
                soc_sbx_g2p3_ert_wrap_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ERT_WRAP_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->mirror; break;
        case 1: ev = e->drop; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for ert_wrap */
int soc_sbx_g2p3_ert_wrap_set(int unit,
                int irule,
                soc_sbx_g2p3_ert_wrap_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_ert_wrap_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ert_wrap_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ert_wrap_set_ext(unit,
                irule,
                e);

    return s;
}

/* entry get accessor implementation for ert_wrap */
int soc_sbx_g2p3_ert_wrap_get(int unit,
                int irule,
                soc_sbx_g2p3_ert_wrap_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_ert_wrap_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ert_wrap_get_ext(unit,
                irule,
                e);

    return s;
}

/*
 * Entry accessor implementations for v4mc_str_sel
 */

void soc_sbx_g2p3_v4mc_str_sel_t_init(
    soc_sbx_g2p3_v4mc_str_sel_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_v4mc_str_sel_t));
}

/* entry size function for v4mc_str_sel */
int soc_sbx_g2p3_v4mc_str_sel_size(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_V4MC_STR_SEL_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];

    return (eb->width + (eb->stridebits - 1)) / eb->stridebits;
}

/* entry pack accessor implementation for v4mc_str_sel */
int soc_sbx_g2p3_v4mc_str_sel_pack(int unit,
    soc_sbx_g2p3_v4mc_str_sel_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_V4MC_STR_SEL_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->valid; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for v4mc_str_sel */
int soc_sbx_g2p3_v4mc_str_sel_unpack(int unit,
                soc_sbx_g2p3_v4mc_str_sel_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_V4MC_STR_SEL_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->valid; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for v4mc_str_sel */
int soc_sbx_g2p3_v4mc_str_sel_index_check(int unit,
                int *vindex,
                int irule)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_V4MC_STR_SEL_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &irule; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for v4mc_str_sel */
int soc_sbx_g2p3_v4mc_str_sel_entry_check(int unit,
                soc_sbx_g2p3_v4mc_str_sel_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_V4MC_STR_SEL_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->valid; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for v4mc_str_sel */
int soc_sbx_g2p3_v4mc_str_sel_set(int unit,
                int irule,
                soc_sbx_g2p3_v4mc_str_sel_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_v4mc_str_sel_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_v4mc_str_sel_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_v4mc_str_sel_set_ext(unit,
                irule,
                e);

    return s;
}

/* entry get accessor implementation for v4mc_str_sel */
int soc_sbx_g2p3_v4mc_str_sel_get(int unit,
                int irule,
                soc_sbx_g2p3_v4mc_str_sel_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_v4mc_str_sel_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_v4mc_str_sel_get_ext(unit,
                irule,
                e);

    return s;
}

/*
 * Entry accessor implementations for efp
 */

void soc_sbx_g2p3_efp_t_init(
    soc_sbx_g2p3_efp_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_efp_t));
    e->usedbtype = 0x1;
    e->sporthi = 0xffff;
    e->dporthi = 0xffff;
    e->ssaphi = 0xff;
    e->dsaphi = 0xff;
    e->llcctrlhi = 0xff;
    e->enable = 0x1;
}

/* entry size function for efp */
int soc_sbx_g2p3_efp_size(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EFP_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];

    return (eb->width + (eb->stridebits - 1)) / eb->stridebits;
}

/* entry pack accessor implementation for efp */
int soc_sbx_g2p3_efp_pack(int unit,
    soc_sbx_g2p3_efp_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EFP_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->dbtype; break;
        case 1: p = (uint8 *) &e->usedbtype; break;
        case 2: p = (uint8 *) &e->port; break;
        case 3: p = (uint8 *) &e->useport; break;
        case 4: p = (uint8 *) e->pbmpn; break;
        case 5: p = (uint8 *) &e->pri; break;
        case 6: p = (uint8 *) &e->usepri; break;
        case 7: p = (uint8 *) &e->fragment; break;
        case 8: p = (uint8 *) &e->usefragment; break;
        case 9: p = (uint8 *) &e->urg; break;
        case 10: p = (uint8 *) &e->useurg; break;
        case 11: p = (uint8 *) &e->ack; break;
        case 12: p = (uint8 *) &e->useack; break;
        case 13: p = (uint8 *) &e->psh; break;
        case 14: p = (uint8 *) &e->usepsh; break;
        case 15: p = (uint8 *) &e->rst; break;
        case 16: p = (uint8 *) &e->userst; break;
        case 17: p = (uint8 *) &e->syn; break;
        case 18: p = (uint8 *) &e->usesyn; break;
        case 19: p = (uint8 *) &e->fin; break;
        case 20: p = (uint8 *) &e->usefin; break;
        case 21: p = (uint8 *) &e->dscp; break;
        case 22: p = (uint8 *) &e->usedscp; break;
        case 23: p = (uint8 *) &e->ecn; break;
        case 24: p = (uint8 *) &e->useecn; break;
        case 25: p = (uint8 *) &e->proto; break;
        case 26: p = (uint8 *) &e->useproto; break;
        case 27: p = (uint8 *) &e->sporthi; break;
        case 28: p = (uint8 *) &e->sportlo; break;
        case 29: p = (uint8 *) &e->dporthi; break;
        case 30: p = (uint8 *) &e->dportlo; break;
        case 31: p = (uint8 *) &e->sa; break;
        case 32: p = (uint8 *) &e->sawidth; break;
        case 33: p = (uint8 *) &e->da; break;
        case 34: p = (uint8 *) &e->dawidth; break;
        case 35: p = (uint8 *) &e->etype; break;
        case 36: p = (uint8 *) &e->useetype; break;
        case 37: p = (uint8 *) e->smac; break;
        case 38: p = (uint8 *) &e->smacwidth; break;
        case 39: p = (uint8 *) e->dmac; break;
        case 40: p = (uint8 *) &e->dmacwidth; break;
        case 41: p = (uint8 *) &e->pvlan; break;
        case 42: p = (uint8 *) &e->usepvlan; break;
        case 43: p = (uint8 *) &e->ssaphi; break;
        case 44: p = (uint8 *) &e->ssaplo; break;
        case 45: p = (uint8 *) &e->usessap; break;
        case 46: p = (uint8 *) &e->dsaphi; break;
        case 47: p = (uint8 *) &e->dsaplo; break;
        case 48: p = (uint8 *) &e->usedsap; break;
        case 49: p = (uint8 *) &e->llcctrlhi; break;
        case 50: p = (uint8 *) &e->llcctrllo; break;
        case 51: p = (uint8 *) &e->usellcctrl; break;
        case 52: p = (uint8 *) &e->enable; break;
        case 53: p = (uint8 *) &e->mirror; break;
        case 54: p = (uint8 *) &e->drop; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for efp */
int soc_sbx_g2p3_efp_unpack(int unit,
                soc_sbx_g2p3_efp_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EFP_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->dbtype; break;
        case 1: p = (uint8 *) &e->usedbtype; break;
        case 2: p = (uint8 *) &e->port; break;
        case 3: p = (uint8 *) &e->useport; break;
        case 4: p = (uint8 *) e->pbmpn; break;
        case 5: p = (uint8 *) &e->pri; break;
        case 6: p = (uint8 *) &e->usepri; break;
        case 7: p = (uint8 *) &e->fragment; break;
        case 8: p = (uint8 *) &e->usefragment; break;
        case 9: p = (uint8 *) &e->urg; break;
        case 10: p = (uint8 *) &e->useurg; break;
        case 11: p = (uint8 *) &e->ack; break;
        case 12: p = (uint8 *) &e->useack; break;
        case 13: p = (uint8 *) &e->psh; break;
        case 14: p = (uint8 *) &e->usepsh; break;
        case 15: p = (uint8 *) &e->rst; break;
        case 16: p = (uint8 *) &e->userst; break;
        case 17: p = (uint8 *) &e->syn; break;
        case 18: p = (uint8 *) &e->usesyn; break;
        case 19: p = (uint8 *) &e->fin; break;
        case 20: p = (uint8 *) &e->usefin; break;
        case 21: p = (uint8 *) &e->dscp; break;
        case 22: p = (uint8 *) &e->usedscp; break;
        case 23: p = (uint8 *) &e->ecn; break;
        case 24: p = (uint8 *) &e->useecn; break;
        case 25: p = (uint8 *) &e->proto; break;
        case 26: p = (uint8 *) &e->useproto; break;
        case 27: p = (uint8 *) &e->sporthi; break;
        case 28: p = (uint8 *) &e->sportlo; break;
        case 29: p = (uint8 *) &e->dporthi; break;
        case 30: p = (uint8 *) &e->dportlo; break;
        case 31: p = (uint8 *) &e->sa; break;
        case 32: p = (uint8 *) &e->sawidth; break;
        case 33: p = (uint8 *) &e->da; break;
        case 34: p = (uint8 *) &e->dawidth; break;
        case 35: p = (uint8 *) &e->etype; break;
        case 36: p = (uint8 *) &e->useetype; break;
        case 37: p = (uint8 *) e->smac; break;
        case 38: p = (uint8 *) &e->smacwidth; break;
        case 39: p = (uint8 *) e->dmac; break;
        case 40: p = (uint8 *) &e->dmacwidth; break;
        case 41: p = (uint8 *) &e->pvlan; break;
        case 42: p = (uint8 *) &e->usepvlan; break;
        case 43: p = (uint8 *) &e->ssaphi; break;
        case 44: p = (uint8 *) &e->ssaplo; break;
        case 45: p = (uint8 *) &e->usessap; break;
        case 46: p = (uint8 *) &e->dsaphi; break;
        case 47: p = (uint8 *) &e->dsaplo; break;
        case 48: p = (uint8 *) &e->usedsap; break;
        case 49: p = (uint8 *) &e->llcctrlhi; break;
        case 50: p = (uint8 *) &e->llcctrllo; break;
        case 51: p = (uint8 *) &e->usellcctrl; break;
        case 52: p = (uint8 *) &e->enable; break;
        case 53: p = (uint8 *) &e->mirror; break;
        case 54: p = (uint8 *) &e->drop; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for efp */
int soc_sbx_g2p3_efp_index_check(int unit,
                int *vindex,
                int irule)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EFP_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &irule; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for efp */
int soc_sbx_g2p3_efp_entry_check(int unit,
                soc_sbx_g2p3_efp_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EFP_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->dbtype; break;
        case 1: ev = e->usedbtype; break;
        case 2: ev = e->port; break;
        case 3: ev = e->useport; break;
        case 4: ev = e->pbmpn[0]; break;
        case 5: ev = e->pri; break;
        case 6: ev = e->usepri; break;
        case 7: ev = e->fragment; break;
        case 8: ev = e->usefragment; break;
        case 9: ev = e->urg; break;
        case 10: ev = e->useurg; break;
        case 11: ev = e->ack; break;
        case 12: ev = e->useack; break;
        case 13: ev = e->psh; break;
        case 14: ev = e->usepsh; break;
        case 15: ev = e->rst; break;
        case 16: ev = e->userst; break;
        case 17: ev = e->syn; break;
        case 18: ev = e->usesyn; break;
        case 19: ev = e->fin; break;
        case 20: ev = e->usefin; break;
        case 21: ev = e->dscp; break;
        case 22: ev = e->usedscp; break;
        case 23: ev = e->ecn; break;
        case 24: ev = e->useecn; break;
        case 25: ev = e->proto; break;
        case 26: ev = e->useproto; break;
        case 27: ev = e->sporthi; break;
        case 28: ev = e->sportlo; break;
        case 29: ev = e->dporthi; break;
        case 30: ev = e->dportlo; break;
        case 31: ev = e->sa; break;
        case 32: ev = e->sawidth; break;
        case 33: ev = e->da; break;
        case 34: ev = e->dawidth; break;
        case 35: ev = e->etype; break;
        case 36: ev = e->useetype; break;
        case 37: ev = e->smac[0]; break;
        case 38: ev = e->smacwidth; break;
        case 39: ev = e->dmac[0]; break;
        case 40: ev = e->dmacwidth; break;
        case 41: ev = e->pvlan; break;
        case 42: ev = e->usepvlan; break;
        case 43: ev = e->ssaphi; break;
        case 44: ev = e->ssaplo; break;
        case 45: ev = e->usessap; break;
        case 46: ev = e->dsaphi; break;
        case 47: ev = e->dsaplo; break;
        case 48: ev = e->usedsap; break;
        case 49: ev = e->llcctrlhi; break;
        case 50: ev = e->llcctrllo; break;
        case 51: ev = e->usellcctrl; break;
        case 52: ev = e->enable; break;
        case 53: ev = e->mirror; break;
        case 54: ev = e->drop; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for efp */
int soc_sbx_g2p3_efp_set(int unit,
                int irule,
                soc_sbx_g2p3_efp_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_efp_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_efp_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_efp_update(unit,
                irule,
                e);
    if (s == SOC_E_NOT_FOUND) {
        s = soc_sbx_g2p3_efp_add(unit,
                irule,
                e);
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_efp_commit(unit, 0xffffffff);
    }

    return s;
}

/* entry add accessor implementation for efp */
int soc_sbx_g2p3_efp_add(int unit,
                int irule,
                soc_sbx_g2p3_efp_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_efp_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_efp_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_efp_add_ext(unit,
                irule,
                e);

    return s;
}

/* entry get accessor implementation for efp */
int soc_sbx_g2p3_efp_get(int unit,
                int irule,
                soc_sbx_g2p3_efp_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_efp_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_efp_get_ext(unit,
                irule,
                e);

    return s;
}

/* entry update accessor implementation for efp */
int soc_sbx_g2p3_efp_update(int unit,
                int irule,
                soc_sbx_g2p3_efp_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_efp_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_efp_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_efp_update_ext(unit,
                irule,
                e);

    return s;
}

/* entry delete accessor implementation for efp */
int soc_sbx_g2p3_efp_delete(int unit,
                int irule)
{
    int s, key[32];

    s = soc_sbx_g2p3_efp_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_efp_remove(unit,
                irule);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_efp_commit(unit, 0xffffffff);

    return s;
}

/* entry remove accessor implementation for efp */
int soc_sbx_g2p3_efp_remove(int unit,
                int irule)
{
    int s, key[32];

    s = soc_sbx_g2p3_efp_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_efp_remove_ext(unit,
                irule);

    return s;
}

/* Get the first element of efp */
int soc_sbx_g2p3_efp_first(int unit,
                int *nirule)
{
    return soc_sbx_g2p3_efp_first_ext(unit,
                nirule);
}

/* Get the next element of efp */
int soc_sbx_g2p3_efp_next(int unit,
                int irule,
                int *nirule)
{
    int key[32], s;

    s = soc_sbx_g2p3_efp_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }

    return soc_sbx_g2p3_efp_next_ext(unit,
                irule,
                nirule);
}

/* Batch commit implementation for efp */
int soc_sbx_g2p3_efp_commit(int unit, int runlength)
{
    return soc_sbx_g2p3_efp_commit_ext(unit, runlength);
}

/*
 * Entry accessor implementations for efp_v6
 */

void soc_sbx_g2p3_efp_v6_t_init(
    soc_sbx_g2p3_efp_v6_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_efp_v6_t));
    e->dbtype = 0x1;
    e->usedbtype = 0x1;
    e->nextheaderhi = 0xff;
    e->sporthi = 0xffff;
    e->dporthi = 0xffff;
    e->enable = 0x1;
}

/* entry size function for efp_v6 */
int soc_sbx_g2p3_efp_v6_size(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EFP_V6_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];

    return (eb->width + (eb->stridebits - 1)) / eb->stridebits;
}

/* entry pack accessor implementation for efp_v6 */
int soc_sbx_g2p3_efp_v6_pack(int unit,
    soc_sbx_g2p3_efp_v6_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EFP_V6_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->dbtype; break;
        case 1: p = (uint8 *) &e->usedbtype; break;
        case 2: p = (uint8 *) &e->port; break;
        case 3: p = (uint8 *) &e->useport; break;
        case 4: p = (uint8 *) e->pbmpn; break;
        case 5: p = (uint8 *) &e->urg; break;
        case 6: p = (uint8 *) &e->useurg; break;
        case 7: p = (uint8 *) &e->ack; break;
        case 8: p = (uint8 *) &e->useack; break;
        case 9: p = (uint8 *) &e->psh; break;
        case 10: p = (uint8 *) &e->usepsh; break;
        case 11: p = (uint8 *) &e->rst; break;
        case 12: p = (uint8 *) &e->userst; break;
        case 13: p = (uint8 *) &e->syn; break;
        case 14: p = (uint8 *) &e->usesyn; break;
        case 15: p = (uint8 *) &e->fin; break;
        case 16: p = (uint8 *) &e->usefin; break;
        case 17: p = (uint8 *) &e->TC; break;
        case 18: p = (uint8 *) &e->useTC; break;
        case 19: p = (uint8 *) &e->nextheaderhi; break;
        case 20: p = (uint8 *) &e->nextheaderlo; break;
        case 21: p = (uint8 *) &e->sporthi; break;
        case 22: p = (uint8 *) &e->sportlo; break;
        case 23: p = (uint8 *) &e->dporthi; break;
        case 24: p = (uint8 *) &e->dportlo; break;
        case 25: p = (uint8 *) e->sa; break;
        case 26: p = (uint8 *) &e->sawidth; break;
        case 27: p = (uint8 *) e->da; break;
        case 28: p = (uint8 *) &e->dawidth; break;
        case 29: p = (uint8 *) &e->vid; break;
        case 30: p = (uint8 *) &e->usevid; break;
        case 31: p = (uint8 *) &e->enable; break;
        case 32: p = (uint8 *) &e->mirror; break;
        case 33: p = (uint8 *) &e->drop; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for efp_v6 */
int soc_sbx_g2p3_efp_v6_unpack(int unit,
                soc_sbx_g2p3_efp_v6_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EFP_V6_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->dbtype; break;
        case 1: p = (uint8 *) &e->usedbtype; break;
        case 2: p = (uint8 *) &e->port; break;
        case 3: p = (uint8 *) &e->useport; break;
        case 4: p = (uint8 *) e->pbmpn; break;
        case 5: p = (uint8 *) &e->urg; break;
        case 6: p = (uint8 *) &e->useurg; break;
        case 7: p = (uint8 *) &e->ack; break;
        case 8: p = (uint8 *) &e->useack; break;
        case 9: p = (uint8 *) &e->psh; break;
        case 10: p = (uint8 *) &e->usepsh; break;
        case 11: p = (uint8 *) &e->rst; break;
        case 12: p = (uint8 *) &e->userst; break;
        case 13: p = (uint8 *) &e->syn; break;
        case 14: p = (uint8 *) &e->usesyn; break;
        case 15: p = (uint8 *) &e->fin; break;
        case 16: p = (uint8 *) &e->usefin; break;
        case 17: p = (uint8 *) &e->TC; break;
        case 18: p = (uint8 *) &e->useTC; break;
        case 19: p = (uint8 *) &e->nextheaderhi; break;
        case 20: p = (uint8 *) &e->nextheaderlo; break;
        case 21: p = (uint8 *) &e->sporthi; break;
        case 22: p = (uint8 *) &e->sportlo; break;
        case 23: p = (uint8 *) &e->dporthi; break;
        case 24: p = (uint8 *) &e->dportlo; break;
        case 25: p = (uint8 *) e->sa; break;
        case 26: p = (uint8 *) &e->sawidth; break;
        case 27: p = (uint8 *) e->da; break;
        case 28: p = (uint8 *) &e->dawidth; break;
        case 29: p = (uint8 *) &e->vid; break;
        case 30: p = (uint8 *) &e->usevid; break;
        case 31: p = (uint8 *) &e->enable; break;
        case 32: p = (uint8 *) &e->mirror; break;
        case 33: p = (uint8 *) &e->drop; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for efp_v6 */
int soc_sbx_g2p3_efp_v6_index_check(int unit,
                int *vindex,
                int irule)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EFP_V6_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &irule; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for efp_v6 */
int soc_sbx_g2p3_efp_v6_entry_check(int unit,
                soc_sbx_g2p3_efp_v6_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EFP_V6_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->dbtype; break;
        case 1: ev = e->usedbtype; break;
        case 2: ev = e->port; break;
        case 3: ev = e->useport; break;
        case 4: ev = e->pbmpn[0]; break;
        case 5: ev = e->urg; break;
        case 6: ev = e->useurg; break;
        case 7: ev = e->ack; break;
        case 8: ev = e->useack; break;
        case 9: ev = e->psh; break;
        case 10: ev = e->usepsh; break;
        case 11: ev = e->rst; break;
        case 12: ev = e->userst; break;
        case 13: ev = e->syn; break;
        case 14: ev = e->usesyn; break;
        case 15: ev = e->fin; break;
        case 16: ev = e->usefin; break;
        case 17: ev = e->TC; break;
        case 18: ev = e->useTC; break;
        case 19: ev = e->nextheaderhi; break;
        case 20: ev = e->nextheaderlo; break;
        case 21: ev = e->sporthi; break;
        case 22: ev = e->sportlo; break;
        case 23: ev = e->dporthi; break;
        case 24: ev = e->dportlo; break;
        case 25: ev = e->sa[0]; break;
        case 26: ev = e->sawidth; break;
        case 27: ev = e->da[0]; break;
        case 28: ev = e->dawidth; break;
        case 29: ev = e->vid; break;
        case 30: ev = e->usevid; break;
        case 31: ev = e->enable; break;
        case 32: ev = e->mirror; break;
        case 33: ev = e->drop; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for efp_v6 */
int soc_sbx_g2p3_efp_v6_set(int unit,
                int irule,
                soc_sbx_g2p3_efp_v6_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_efp_v6_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_efp_v6_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_efp_v6_update(unit,
                irule,
                e);
    if (s == SOC_E_NOT_FOUND) {
        s = soc_sbx_g2p3_efp_v6_add(unit,
                irule,
                e);
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_efp_v6_commit(unit, 0xffffffff);
    }

    return s;
}

/* entry add accessor implementation for efp_v6 */
int soc_sbx_g2p3_efp_v6_add(int unit,
                int irule,
                soc_sbx_g2p3_efp_v6_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_efp_v6_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_efp_v6_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_efp_v6_add_ext(unit,
                irule,
                e);

    return s;
}

/* entry get accessor implementation for efp_v6 */
int soc_sbx_g2p3_efp_v6_get(int unit,
                int irule,
                soc_sbx_g2p3_efp_v6_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_efp_v6_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_efp_v6_get_ext(unit,
                irule,
                e);

    return s;
}

/* entry update accessor implementation for efp_v6 */
int soc_sbx_g2p3_efp_v6_update(int unit,
                int irule,
                soc_sbx_g2p3_efp_v6_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_efp_v6_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_efp_v6_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_efp_v6_update_ext(unit,
                irule,
                e);

    return s;
}

/* entry delete accessor implementation for efp_v6 */
int soc_sbx_g2p3_efp_v6_delete(int unit,
                int irule)
{
    int s, key[32];

    s = soc_sbx_g2p3_efp_v6_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_efp_v6_remove(unit,
                irule);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_efp_v6_commit(unit, 0xffffffff);

    return s;
}

/* entry remove accessor implementation for efp_v6 */
int soc_sbx_g2p3_efp_v6_remove(int unit,
                int irule)
{
    int s, key[32];

    s = soc_sbx_g2p3_efp_v6_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_efp_v6_remove_ext(unit,
                irule);

    return s;
}

/* Get the first element of efp_v6 */
int soc_sbx_g2p3_efp_v6_first(int unit,
                int *nirule)
{
    return soc_sbx_g2p3_efp_v6_first_ext(unit,
                nirule);
}

/* Get the next element of efp_v6 */
int soc_sbx_g2p3_efp_v6_next(int unit,
                int irule,
                int *nirule)
{
    int key[32], s;

    s = soc_sbx_g2p3_efp_v6_index_check(unit, key,
                irule);
    if (s) {
        return s;
    }

    return soc_sbx_g2p3_efp_v6_next_ext(unit,
                irule,
                nirule);
}

/* Batch commit implementation for efp_v6 */
int soc_sbx_g2p3_efp_v6_commit(int unit, int runlength)
{
    return soc_sbx_g2p3_efp_v6_commit_ext(unit, runlength);
}

/*
 * Entry accessor implementations for oamMultiplier
 */

void soc_sbx_g2p3_oammultiplier_t_init(
    soc_sbx_g2p3_oammultiplier_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_oammultiplier_t));
}

/* entry pack accessor implementation for oamMultiplier */
int soc_sbx_g2p3_oammultiplier_pack(int unit,
    soc_sbx_g2p3_oammultiplier_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMMULTIPLIER_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->frameCount; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for oamMultiplier */
int soc_sbx_g2p3_oammultiplier_unpack(int unit,
                soc_sbx_g2p3_oammultiplier_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMMULTIPLIER_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->frameCount; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for oamMultiplier */
int soc_sbx_g2p3_oammultiplier_index_check(int unit,
                int *vindex,
                int ilosscount,
                int ithreshold)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMMULTIPLIER_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ilosscount; break;
        case 1: p = (uint8 *) &ithreshold; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for oamMultiplier */
int soc_sbx_g2p3_oammultiplier_entry_check(int unit,
                soc_sbx_g2p3_oammultiplier_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMMULTIPLIER_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->frameCount; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* oamMultiplier table size get */
int soc_sbx_g2p3_oammultiplier_entry_table_size_get(int unit,
                int *tsize,
                int ilosscount,
                int ithreshold)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMMULTIPLIER_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ilosscount; break;
        case 1: v = ithreshold; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for oamMultiplier */
int soc_sbx_g2p3_oammultiplier_set(int unit,
                int ilosscount,
                int ithreshold,
                soc_sbx_g2p3_oammultiplier_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMMULTIPLIER_ID];

    s = soc_sbx_g2p3_oammultiplier_index_check(unit, key,
                ilosscount,
                ithreshold);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_oammultiplier_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_oammultiplier_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for oamMultiplier */
int soc_sbx_g2p3_oammultiplier_get(int unit,
                int ilosscount,
                int ithreshold,
                soc_sbx_g2p3_oammultiplier_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMMULTIPLIER_ID];

    s = soc_sbx_g2p3_oammultiplier_index_check(unit, key,
                ilosscount,
                ithreshold);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_oammultiplier_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for oamEpRemap
 */

void soc_sbx_g2p3_oamepremap_t_init(
    soc_sbx_g2p3_oamepremap_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_oamepremap_t));
}

/* entry pack accessor implementation for oamEpRemap */
int soc_sbx_g2p3_oamepremap_pack(int unit,
    soc_sbx_g2p3_oamepremap_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMEPREMAP_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->epIdx; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for oamEpRemap */
int soc_sbx_g2p3_oamepremap_unpack(int unit,
                soc_sbx_g2p3_oamepremap_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMEPREMAP_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->epIdx; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for oamEpRemap */
int soc_sbx_g2p3_oamepremap_index_check(int unit,
                int *vindex,
                int iendpoint,
                int imdlevel,
                int itype)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMEPREMAP_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iendpoint; break;
        case 1: p = (uint8 *) &imdlevel; break;
        case 2: p = (uint8 *) &itype; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for oamEpRemap */
int soc_sbx_g2p3_oamepremap_entry_check(int unit,
                soc_sbx_g2p3_oamepremap_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMEPREMAP_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->epIdx; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* oamEpRemap table size get */
int soc_sbx_g2p3_oamepremap_entry_table_size_get(int unit,
                int *tsize,
                int iendpoint,
                int imdlevel,
                int itype)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMEPREMAP_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = iendpoint; break;
        case 1: v = imdlevel; break;
        case 2: v = itype; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for oamEpRemap */
int soc_sbx_g2p3_oamepremap_set(int unit,
                int iendpoint,
                int imdlevel,
                int itype,
                soc_sbx_g2p3_oamepremap_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMEPREMAP_ID];

    s = soc_sbx_g2p3_oamepremap_index_check(unit, key,
                iendpoint,
                imdlevel,
                itype);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_oamepremap_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_oamepremap_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for oamEpRemap */
int soc_sbx_g2p3_oamepremap_get(int unit,
                int iendpoint,
                int imdlevel,
                int itype,
                soc_sbx_g2p3_oamepremap_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMEPREMAP_ID];

    s = soc_sbx_g2p3_oamepremap_index_check(unit, key,
                iendpoint,
                imdlevel,
                itype);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_oamepremap_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for ipv6da
 */

void soc_sbx_g2p3_ipv6da_t_init(
    soc_sbx_g2p3_ipv6da_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ipv6da_t));
}

/* entry pack accessor implementation for ipv6da */
int soc_sbx_g2p3_ipv6da_pack(int unit,
    soc_sbx_g2p3_ipv6da_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DA_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->ftidx; break;
        case 1: p = (uint8 *) &e->ecmpmask; break;
        case 2: p = (uint8 *) &e->vid; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ipv6da */
int soc_sbx_g2p3_ipv6da_unpack(int unit,
                soc_sbx_g2p3_ipv6da_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DA_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->ftidx; break;
        case 1: p = (uint8 *) &e->ecmpmask; break;
        case 2: p = (uint8 *) &e->vid; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ipv6da */
int soc_sbx_g2p3_ipv6da_index_check(int unit,
                int *vindex,
                int iprefixbits,
                soc_sbx_g2p3_8_byte_t iip)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DA_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iprefixbits; break;
        case 1: p = (uint8 *) iip; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!i) continue;
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry index unpack for ipv6da */
int soc_sbx_g2p3_ipv6da_index_unpack(int unit,
                int *vindex,
                int *iprefixbits,
                soc_sbx_g2p3_8_byte_t iip)
{
    int i, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DA_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int be = tm->behost;
    int pkbe = be;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    iprefixbits = iprefixbits;

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 1; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
	fmt = id->format;
        switch (i) {
        case 1: p = (uint8 *) iip; break;
        default: return SOC_E_INTERNAL;
        }
        sal_memset(p, 0, width <= 32 ? (int) sizeof(int) : (width + 7) / 8);
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe =
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT 
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_extract(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ipv6da */
int soc_sbx_g2p3_ipv6da_entry_check(int unit,
                soc_sbx_g2p3_ipv6da_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DA_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->ftidx; break;
        case 1: ev = e->ecmpmask; break;
        case 2: ev = e->vid; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for ipv6da */
int soc_sbx_g2p3_ipv6da_set(int unit,
                int iprefixbits,
                soc_sbx_g2p3_8_byte_t iip,
                soc_sbx_g2p3_ipv6da_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_ipv6da_index_check(unit, key,
                iprefixbits,
                iip);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv6da_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv6da_update(unit,
                iprefixbits,
                iip,
                e);
    if (s == SOC_E_NOT_FOUND) {
        s = soc_sbx_g2p3_ipv6da_add(unit,
                iprefixbits,
                iip,
                e);
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ipv6da_commit(unit, 0xffffffff);
    }

    return s;
}

/* entry add accessor implementation for ipv6da */
int soc_sbx_g2p3_ipv6da_add(int unit,
                int iprefixbits,
                soc_sbx_g2p3_8_byte_t iip,
                soc_sbx_g2p3_ipv6da_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DA_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_ipv6da_index_check(unit, key,
                iprefixbits,
                iip);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv6da_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_lpm_add_ext(unit, cs,
                iprefixbits,
                (uint8 *) key,
                e);

    return s;
}

/* entry get accessor implementation for ipv6da */
int soc_sbx_g2p3_ipv6da_get(int unit,
                int iprefixbits,
                soc_sbx_g2p3_8_byte_t iip,
                soc_sbx_g2p3_ipv6da_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DA_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_ipv6da_index_check(unit, key,
                iprefixbits,
                iip);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_lpm_get_ext(unit, cs,
                iprefixbits,
                (uint8 *) key,
                e);

    return s;
}

/* entry update accessor implementation for ipv6da */
int soc_sbx_g2p3_ipv6da_update(int unit,
                int iprefixbits,
                soc_sbx_g2p3_8_byte_t iip,
                soc_sbx_g2p3_ipv6da_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_ipv6da_index_check(unit, key,
                iprefixbits,
                iip);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv6da_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv6da_renew(unit,
                iprefixbits,
                iip,
                e);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv6da_commit(unit, 0xffffffff);

    return s;
}

/* entry renew accessor implementation for ipv6da */
int soc_sbx_g2p3_ipv6da_renew(int unit,
                int iprefixbits,
                soc_sbx_g2p3_8_byte_t iip,
                soc_sbx_g2p3_ipv6da_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DA_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_ipv6da_index_check(unit, key,
                iprefixbits,
                iip);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv6da_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_lpm_renew_ext(unit, cs,
                iprefixbits,
                (uint8 *) key,
                e);

    return s;
}

/* entry delete accessor implementation for ipv6da */
int soc_sbx_g2p3_ipv6da_delete(int unit,
                int iprefixbits,
                soc_sbx_g2p3_8_byte_t iip)
{
    int s, key[32];

    s = soc_sbx_g2p3_ipv6da_index_check(unit, key,
                iprefixbits,
                iip);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv6da_remove(unit,
                iprefixbits,
                iip);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv6da_commit(unit, 0xffffffff);

    return s;
}

/* entry remove accessor implementation for ipv6da */
int soc_sbx_g2p3_ipv6da_remove(int unit,
                int iprefixbits,
                soc_sbx_g2p3_8_byte_t iip)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DA_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_ipv6da_index_check(unit, key,
                iprefixbits,
                iip);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_lpm_remove_ext(unit, cs,
                iprefixbits,
                (uint8 *) key);

    return s;
}

/* Get the first element of ipv6da */
int soc_sbx_g2p3_ipv6da_first(int unit,
                int *niprefixbits,
                soc_sbx_g2p3_8_byte_t niip)
{
    int s;
    int nkey[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DA_ID];
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    void *cs = td->cstate;

    s = soc_sbx_g2p3_lpm_first_ext(unit, cs,
                niprefixbits,
                (uint8 *) nkey);
    if (!s) {
        soc_sbx_g2p3_ipv6da_index_unpack(unit, nkey,
                niprefixbits,
                niip);
    }
    return s;
}

/* Get the next element of ipv6da */
int soc_sbx_g2p3_ipv6da_next(int unit,
                int iprefixbits,
                soc_sbx_g2p3_8_byte_t iip,
                int *niprefixbits,
                soc_sbx_g2p3_8_byte_t niip)
{
    int key[32], s;
    int nkey[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DA_ID];
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    void *cs = td->cstate;

    s = soc_sbx_g2p3_ipv6da_index_check(unit, key,
                iprefixbits,
                iip);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_lpm_next_ext(unit, cs,
                iprefixbits,
                (uint8 *) key,
                niprefixbits,
                (uint8 *) nkey);
    if (!s) {
        soc_sbx_g2p3_ipv6da_index_unpack(unit, nkey,
                niprefixbits,
                niip);
    }
    return s;
}

/* Batch commit implementation for ipv6da */
int soc_sbx_g2p3_ipv6da_commit(int unit, int runlength)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DA_ID];
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    void *cs = td->cstate;

    return soc_sbx_g2p3_lpm_commit_ext(unit, cs, runlength);
}

/*
 * Entry accessor implementations for ipv6dal0
 */

void soc_sbx_g2p3_ipv6dal0_t_init(
    soc_sbx_g2p3_ipv6dal0_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ipv6dal0_t));
}

/* entry pack accessor implementation for ipv6dal0 */
int soc_sbx_g2p3_ipv6dal0_pack(int unit,
    soc_sbx_g2p3_ipv6dal0_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DAL0_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->pattern; break;
        case 1: p = (uint8 *) &e->singleton; break;
        case 2: p = (uint8 *) &e->pointer; break;
        case 3: p = (uint8 *) &e->leaf; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ipv6dal0 */
int soc_sbx_g2p3_ipv6dal0_unpack(int unit,
                soc_sbx_g2p3_ipv6dal0_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DAL0_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->pattern; break;
        case 1: p = (uint8 *) &e->singleton; break;
        case 2: p = (uint8 *) &e->pointer; break;
        case 3: p = (uint8 *) &e->leaf; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ipv6dal0 */
int soc_sbx_g2p3_ipv6dal0_index_check(int unit,
                int *vindex,
                int iaddr)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DAL0_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iaddr; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ipv6dal0 */
int soc_sbx_g2p3_ipv6dal0_entry_check(int unit,
                soc_sbx_g2p3_ipv6dal0_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DAL0_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->pattern; break;
        case 1: ev = e->singleton; break;
        case 2: ev = e->pointer; break;
        case 3: ev = e->leaf; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* ipv6dal0 table size get */
int soc_sbx_g2p3_ipv6dal0_entry_table_size_get(int unit,
                int *tsize,
                int iaddr)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DAL0_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = iaddr; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for ipv6dal0 */
int soc_sbx_g2p3_ipv6dal0_set(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv6dal0_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DAL0_ID];

    s = soc_sbx_g2p3_ipv6dal0_index_check(unit, key,
                iaddr);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv6dal0_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_ipv6dal0_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for ipv6dal0 */
int soc_sbx_g2p3_ipv6dal0_get(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv6dal0_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DAL0_ID];

    s = soc_sbx_g2p3_ipv6dal0_index_check(unit, key,
                iaddr);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_ipv6dal0_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for ipv6daodd
 */

void soc_sbx_g2p3_ipv6daodd_t_init(
    soc_sbx_g2p3_ipv6daodd_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ipv6daodd_t));
}

/* entry pack accessor implementation for ipv6daodd */
int soc_sbx_g2p3_ipv6daodd_pack(int unit,
    soc_sbx_g2p3_ipv6daodd_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DAODD_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->pattern; break;
        case 1: p = (uint8 *) &e->singleton; break;
        case 2: p = (uint8 *) &e->pointer; break;
        case 3: p = (uint8 *) &e->leaf; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ipv6daodd */
int soc_sbx_g2p3_ipv6daodd_unpack(int unit,
                soc_sbx_g2p3_ipv6daodd_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DAODD_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->pattern; break;
        case 1: p = (uint8 *) &e->singleton; break;
        case 2: p = (uint8 *) &e->pointer; break;
        case 3: p = (uint8 *) &e->leaf; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ipv6daodd */
int soc_sbx_g2p3_ipv6daodd_index_check(int unit,
                int *vindex,
                int iaddr)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DAODD_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iaddr; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ipv6daodd */
int soc_sbx_g2p3_ipv6daodd_entry_check(int unit,
                soc_sbx_g2p3_ipv6daodd_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DAODD_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->pattern; break;
        case 1: ev = e->singleton; break;
        case 2: ev = e->pointer; break;
        case 3: ev = e->leaf; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* ipv6daodd table size get */
int soc_sbx_g2p3_ipv6daodd_entry_table_size_get(int unit,
                int *tsize,
                int iaddr)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DAODD_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = iaddr; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for ipv6daodd */
int soc_sbx_g2p3_ipv6daodd_set(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv6daodd_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DAODD_ID];

    s = soc_sbx_g2p3_ipv6daodd_index_check(unit, key,
                iaddr);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv6daodd_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_ipv6daodd_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for ipv6daodd */
int soc_sbx_g2p3_ipv6daodd_get(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv6daodd_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DAODD_ID];

    s = soc_sbx_g2p3_ipv6daodd_index_check(unit, key,
                iaddr);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_ipv6daodd_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for ipv6daeven
 */

void soc_sbx_g2p3_ipv6daeven_t_init(
    soc_sbx_g2p3_ipv6daeven_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ipv6daeven_t));
}

/* entry pack accessor implementation for ipv6daeven */
int soc_sbx_g2p3_ipv6daeven_pack(int unit,
    soc_sbx_g2p3_ipv6daeven_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DAEVEN_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->pattern; break;
        case 1: p = (uint8 *) &e->singleton; break;
        case 2: p = (uint8 *) &e->pointer; break;
        case 3: p = (uint8 *) &e->leaf; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ipv6daeven */
int soc_sbx_g2p3_ipv6daeven_unpack(int unit,
                soc_sbx_g2p3_ipv6daeven_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DAEVEN_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->pattern; break;
        case 1: p = (uint8 *) &e->singleton; break;
        case 2: p = (uint8 *) &e->pointer; break;
        case 3: p = (uint8 *) &e->leaf; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ipv6daeven */
int soc_sbx_g2p3_ipv6daeven_index_check(int unit,
                int *vindex,
                int iaddr)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DAEVEN_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iaddr; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ipv6daeven */
int soc_sbx_g2p3_ipv6daeven_entry_check(int unit,
                soc_sbx_g2p3_ipv6daeven_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DAEVEN_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->pattern; break;
        case 1: ev = e->singleton; break;
        case 2: ev = e->pointer; break;
        case 3: ev = e->leaf; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* ipv6daeven table size get */
int soc_sbx_g2p3_ipv6daeven_entry_table_size_get(int unit,
                int *tsize,
                int iaddr)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DAEVEN_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = iaddr; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for ipv6daeven */
int soc_sbx_g2p3_ipv6daeven_set(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv6daeven_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DAEVEN_ID];

    s = soc_sbx_g2p3_ipv6daeven_index_check(unit, key,
                iaddr);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv6daeven_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_ipv6daeven_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for ipv6daeven */
int soc_sbx_g2p3_ipv6daeven_get(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv6daeven_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DAEVEN_ID];

    s = soc_sbx_g2p3_ipv6daeven_index_check(unit, key,
                iaddr);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_ipv6daeven_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for ipv6dapayload
 */

void soc_sbx_g2p3_ipv6dapayload_t_init(
    soc_sbx_g2p3_ipv6dapayload_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ipv6dapayload_t));
}

/* entry pack accessor implementation for ipv6dapayload */
int soc_sbx_g2p3_ipv6dapayload_pack(int unit,
    soc_sbx_g2p3_ipv6dapayload_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DAPAYLOAD_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->ftidx; break;
        case 1: p = (uint8 *) &e->ecmpmask; break;
        case 2: p = (uint8 *) &e->vid; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ipv6dapayload */
int soc_sbx_g2p3_ipv6dapayload_unpack(int unit,
                soc_sbx_g2p3_ipv6dapayload_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DAPAYLOAD_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->ftidx; break;
        case 1: p = (uint8 *) &e->ecmpmask; break;
        case 2: p = (uint8 *) &e->vid; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ipv6dapayload */
int soc_sbx_g2p3_ipv6dapayload_index_check(int unit,
                int *vindex,
                int iaddr)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DAPAYLOAD_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iaddr; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ipv6dapayload */
int soc_sbx_g2p3_ipv6dapayload_entry_check(int unit,
                soc_sbx_g2p3_ipv6dapayload_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DAPAYLOAD_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->ftidx; break;
        case 1: ev = e->ecmpmask; break;
        case 2: ev = e->vid; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* ipv6dapayload table size get */
int soc_sbx_g2p3_ipv6dapayload_entry_table_size_get(int unit,
                int *tsize,
                int iaddr)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DAPAYLOAD_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = iaddr; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for ipv6dapayload */
int soc_sbx_g2p3_ipv6dapayload_set(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv6dapayload_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DAPAYLOAD_ID];

    s = soc_sbx_g2p3_ipv6dapayload_index_check(unit, key,
                iaddr);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv6dapayload_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_ipv6dapayload_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for ipv6dapayload */
int soc_sbx_g2p3_ipv6dapayload_get(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv6dapayload_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DAPAYLOAD_ID];

    s = soc_sbx_g2p3_ipv6dapayload_index_check(unit, key,
                iaddr);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_ipv6dapayload_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for ipv6sa
 */

void soc_sbx_g2p3_ipv6sa_t_init(
    soc_sbx_g2p3_ipv6sa_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ipv6sa_t));
    e->poe = 0x3fff;
}

/* entry pack accessor implementation for ipv6sa */
int soc_sbx_g2p3_ipv6sa_pack(int unit,
    soc_sbx_g2p3_ipv6sa_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SA_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->poe; break;
        case 1: p = (uint8 *) &e->rpfmode; break;
        case 2: p = (uint8 *) &e->srcdrop; break;
        case 3: p = (uint8 *) &e->srccnt; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ipv6sa */
int soc_sbx_g2p3_ipv6sa_unpack(int unit,
                soc_sbx_g2p3_ipv6sa_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SA_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->poe; break;
        case 1: p = (uint8 *) &e->rpfmode; break;
        case 2: p = (uint8 *) &e->srcdrop; break;
        case 3: p = (uint8 *) &e->srccnt; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ipv6sa */
int soc_sbx_g2p3_ipv6sa_index_check(int unit,
                int *vindex,
                int iprefixbits,
                soc_sbx_g2p3_8_byte_t iip)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SA_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iprefixbits; break;
        case 1: p = (uint8 *) iip; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!i) continue;
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry index unpack for ipv6sa */
int soc_sbx_g2p3_ipv6sa_index_unpack(int unit,
                int *vindex,
                int *iprefixbits,
                soc_sbx_g2p3_8_byte_t iip)
{
    int i, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SA_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int be = tm->behost;
    int pkbe = be;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    iprefixbits = iprefixbits;

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 1; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
	fmt = id->format;
        switch (i) {
        case 1: p = (uint8 *) iip; break;
        default: return SOC_E_INTERNAL;
        }
        sal_memset(p, 0, width <= 32 ? (int) sizeof(int) : (width + 7) / 8);
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe =
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT 
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_extract(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ipv6sa */
int soc_sbx_g2p3_ipv6sa_entry_check(int unit,
                soc_sbx_g2p3_ipv6sa_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SA_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->poe; break;
        case 1: ev = e->rpfmode; break;
        case 2: ev = e->srcdrop; break;
        case 3: ev = e->srccnt; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for ipv6sa */
int soc_sbx_g2p3_ipv6sa_set(int unit,
                int iprefixbits,
                soc_sbx_g2p3_8_byte_t iip,
                soc_sbx_g2p3_ipv6sa_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_ipv6sa_index_check(unit, key,
                iprefixbits,
                iip);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv6sa_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv6sa_update(unit,
                iprefixbits,
                iip,
                e);
    if (s == SOC_E_NOT_FOUND) {
        s = soc_sbx_g2p3_ipv6sa_add(unit,
                iprefixbits,
                iip,
                e);
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ipv6sa_commit(unit, 0xffffffff);
    }

    return s;
}

/* entry add accessor implementation for ipv6sa */
int soc_sbx_g2p3_ipv6sa_add(int unit,
                int iprefixbits,
                soc_sbx_g2p3_8_byte_t iip,
                soc_sbx_g2p3_ipv6sa_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SA_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_ipv6sa_index_check(unit, key,
                iprefixbits,
                iip);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv6sa_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_lpm_add_ext(unit, cs,
                iprefixbits,
                (uint8 *) key,
                e);

    return s;
}

/* entry get accessor implementation for ipv6sa */
int soc_sbx_g2p3_ipv6sa_get(int unit,
                int iprefixbits,
                soc_sbx_g2p3_8_byte_t iip,
                soc_sbx_g2p3_ipv6sa_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SA_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_ipv6sa_index_check(unit, key,
                iprefixbits,
                iip);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_lpm_get_ext(unit, cs,
                iprefixbits,
                (uint8 *) key,
                e);

    return s;
}

/* entry update accessor implementation for ipv6sa */
int soc_sbx_g2p3_ipv6sa_update(int unit,
                int iprefixbits,
                soc_sbx_g2p3_8_byte_t iip,
                soc_sbx_g2p3_ipv6sa_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_ipv6sa_index_check(unit, key,
                iprefixbits,
                iip);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv6sa_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv6sa_renew(unit,
                iprefixbits,
                iip,
                e);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv6sa_commit(unit, 0xffffffff);

    return s;
}

/* entry renew accessor implementation for ipv6sa */
int soc_sbx_g2p3_ipv6sa_renew(int unit,
                int iprefixbits,
                soc_sbx_g2p3_8_byte_t iip,
                soc_sbx_g2p3_ipv6sa_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SA_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_ipv6sa_index_check(unit, key,
                iprefixbits,
                iip);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv6sa_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_lpm_renew_ext(unit, cs,
                iprefixbits,
                (uint8 *) key,
                e);

    return s;
}

/* entry delete accessor implementation for ipv6sa */
int soc_sbx_g2p3_ipv6sa_delete(int unit,
                int iprefixbits,
                soc_sbx_g2p3_8_byte_t iip)
{
    int s, key[32];

    s = soc_sbx_g2p3_ipv6sa_index_check(unit, key,
                iprefixbits,
                iip);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv6sa_remove(unit,
                iprefixbits,
                iip);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv6sa_commit(unit, 0xffffffff);

    return s;
}

/* entry remove accessor implementation for ipv6sa */
int soc_sbx_g2p3_ipv6sa_remove(int unit,
                int iprefixbits,
                soc_sbx_g2p3_8_byte_t iip)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SA_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_ipv6sa_index_check(unit, key,
                iprefixbits,
                iip);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_lpm_remove_ext(unit, cs,
                iprefixbits,
                (uint8 *) key);

    return s;
}

/* Get the first element of ipv6sa */
int soc_sbx_g2p3_ipv6sa_first(int unit,
                int *niprefixbits,
                soc_sbx_g2p3_8_byte_t niip)
{
    int s;
    int nkey[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SA_ID];
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    void *cs = td->cstate;

    s = soc_sbx_g2p3_lpm_first_ext(unit, cs,
                niprefixbits,
                (uint8 *) nkey);
    if (!s) {
        soc_sbx_g2p3_ipv6sa_index_unpack(unit, nkey,
                niprefixbits,
                niip);
    }
    return s;
}

/* Get the next element of ipv6sa */
int soc_sbx_g2p3_ipv6sa_next(int unit,
                int iprefixbits,
                soc_sbx_g2p3_8_byte_t iip,
                int *niprefixbits,
                soc_sbx_g2p3_8_byte_t niip)
{
    int key[32], s;
    int nkey[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SA_ID];
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    void *cs = td->cstate;

    s = soc_sbx_g2p3_ipv6sa_index_check(unit, key,
                iprefixbits,
                iip);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_lpm_next_ext(unit, cs,
                iprefixbits,
                (uint8 *) key,
                niprefixbits,
                (uint8 *) nkey);
    if (!s) {
        soc_sbx_g2p3_ipv6sa_index_unpack(unit, nkey,
                niprefixbits,
                niip);
    }
    return s;
}

/* Batch commit implementation for ipv6sa */
int soc_sbx_g2p3_ipv6sa_commit(int unit, int runlength)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SA_ID];
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    void *cs = td->cstate;

    return soc_sbx_g2p3_lpm_commit_ext(unit, cs, runlength);
}

/*
 * Entry accessor implementations for ipv6sal0
 */

void soc_sbx_g2p3_ipv6sal0_t_init(
    soc_sbx_g2p3_ipv6sal0_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ipv6sal0_t));
}

/* entry pack accessor implementation for ipv6sal0 */
int soc_sbx_g2p3_ipv6sal0_pack(int unit,
    soc_sbx_g2p3_ipv6sal0_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SAL0_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->pattern; break;
        case 1: p = (uint8 *) &e->singleton; break;
        case 2: p = (uint8 *) &e->pointer; break;
        case 3: p = (uint8 *) &e->leaf; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ipv6sal0 */
int soc_sbx_g2p3_ipv6sal0_unpack(int unit,
                soc_sbx_g2p3_ipv6sal0_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SAL0_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->pattern; break;
        case 1: p = (uint8 *) &e->singleton; break;
        case 2: p = (uint8 *) &e->pointer; break;
        case 3: p = (uint8 *) &e->leaf; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ipv6sal0 */
int soc_sbx_g2p3_ipv6sal0_index_check(int unit,
                int *vindex,
                int iaddr)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SAL0_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iaddr; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ipv6sal0 */
int soc_sbx_g2p3_ipv6sal0_entry_check(int unit,
                soc_sbx_g2p3_ipv6sal0_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SAL0_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->pattern; break;
        case 1: ev = e->singleton; break;
        case 2: ev = e->pointer; break;
        case 3: ev = e->leaf; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* ipv6sal0 table size get */
int soc_sbx_g2p3_ipv6sal0_entry_table_size_get(int unit,
                int *tsize,
                int iaddr)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SAL0_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = iaddr; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for ipv6sal0 */
int soc_sbx_g2p3_ipv6sal0_set(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv6sal0_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SAL0_ID];

    s = soc_sbx_g2p3_ipv6sal0_index_check(unit, key,
                iaddr);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv6sal0_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_ipv6sal0_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for ipv6sal0 */
int soc_sbx_g2p3_ipv6sal0_get(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv6sal0_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SAL0_ID];

    s = soc_sbx_g2p3_ipv6sal0_index_check(unit, key,
                iaddr);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_ipv6sal0_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for ipv6saodd
 */

void soc_sbx_g2p3_ipv6saodd_t_init(
    soc_sbx_g2p3_ipv6saodd_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ipv6saodd_t));
}

/* entry pack accessor implementation for ipv6saodd */
int soc_sbx_g2p3_ipv6saodd_pack(int unit,
    soc_sbx_g2p3_ipv6saodd_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SAODD_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->pattern; break;
        case 1: p = (uint8 *) &e->singleton; break;
        case 2: p = (uint8 *) &e->pointer; break;
        case 3: p = (uint8 *) &e->leaf; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ipv6saodd */
int soc_sbx_g2p3_ipv6saodd_unpack(int unit,
                soc_sbx_g2p3_ipv6saodd_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SAODD_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->pattern; break;
        case 1: p = (uint8 *) &e->singleton; break;
        case 2: p = (uint8 *) &e->pointer; break;
        case 3: p = (uint8 *) &e->leaf; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ipv6saodd */
int soc_sbx_g2p3_ipv6saodd_index_check(int unit,
                int *vindex,
                int iaddr)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SAODD_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iaddr; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ipv6saodd */
int soc_sbx_g2p3_ipv6saodd_entry_check(int unit,
                soc_sbx_g2p3_ipv6saodd_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SAODD_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->pattern; break;
        case 1: ev = e->singleton; break;
        case 2: ev = e->pointer; break;
        case 3: ev = e->leaf; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* ipv6saodd table size get */
int soc_sbx_g2p3_ipv6saodd_entry_table_size_get(int unit,
                int *tsize,
                int iaddr)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SAODD_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = iaddr; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for ipv6saodd */
int soc_sbx_g2p3_ipv6saodd_set(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv6saodd_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SAODD_ID];

    s = soc_sbx_g2p3_ipv6saodd_index_check(unit, key,
                iaddr);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv6saodd_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_ipv6saodd_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for ipv6saodd */
int soc_sbx_g2p3_ipv6saodd_get(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv6saodd_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SAODD_ID];

    s = soc_sbx_g2p3_ipv6saodd_index_check(unit, key,
                iaddr);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_ipv6saodd_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for ipv6saeven
 */

void soc_sbx_g2p3_ipv6saeven_t_init(
    soc_sbx_g2p3_ipv6saeven_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ipv6saeven_t));
}

/* entry pack accessor implementation for ipv6saeven */
int soc_sbx_g2p3_ipv6saeven_pack(int unit,
    soc_sbx_g2p3_ipv6saeven_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SAEVEN_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->pattern; break;
        case 1: p = (uint8 *) &e->singleton; break;
        case 2: p = (uint8 *) &e->pointer; break;
        case 3: p = (uint8 *) &e->leaf; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ipv6saeven */
int soc_sbx_g2p3_ipv6saeven_unpack(int unit,
                soc_sbx_g2p3_ipv6saeven_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SAEVEN_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->pattern; break;
        case 1: p = (uint8 *) &e->singleton; break;
        case 2: p = (uint8 *) &e->pointer; break;
        case 3: p = (uint8 *) &e->leaf; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ipv6saeven */
int soc_sbx_g2p3_ipv6saeven_index_check(int unit,
                int *vindex,
                int iaddr)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SAEVEN_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iaddr; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ipv6saeven */
int soc_sbx_g2p3_ipv6saeven_entry_check(int unit,
                soc_sbx_g2p3_ipv6saeven_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SAEVEN_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->pattern; break;
        case 1: ev = e->singleton; break;
        case 2: ev = e->pointer; break;
        case 3: ev = e->leaf; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* ipv6saeven table size get */
int soc_sbx_g2p3_ipv6saeven_entry_table_size_get(int unit,
                int *tsize,
                int iaddr)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SAEVEN_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = iaddr; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for ipv6saeven */
int soc_sbx_g2p3_ipv6saeven_set(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv6saeven_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SAEVEN_ID];

    s = soc_sbx_g2p3_ipv6saeven_index_check(unit, key,
                iaddr);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv6saeven_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_ipv6saeven_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for ipv6saeven */
int soc_sbx_g2p3_ipv6saeven_get(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv6saeven_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SAEVEN_ID];

    s = soc_sbx_g2p3_ipv6saeven_index_check(unit, key,
                iaddr);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_ipv6saeven_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for ipv6sapayload
 */

void soc_sbx_g2p3_ipv6sapayload_t_init(
    soc_sbx_g2p3_ipv6sapayload_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ipv6sapayload_t));
    e->poe = 0x3fff;
}

/* entry pack accessor implementation for ipv6sapayload */
int soc_sbx_g2p3_ipv6sapayload_pack(int unit,
    soc_sbx_g2p3_ipv6sapayload_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SAPAYLOAD_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->poe; break;
        case 1: p = (uint8 *) &e->rpfmode; break;
        case 2: p = (uint8 *) &e->srcdrop; break;
        case 3: p = (uint8 *) &e->srccnt; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ipv6sapayload */
int soc_sbx_g2p3_ipv6sapayload_unpack(int unit,
                soc_sbx_g2p3_ipv6sapayload_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SAPAYLOAD_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->poe; break;
        case 1: p = (uint8 *) &e->rpfmode; break;
        case 2: p = (uint8 *) &e->srcdrop; break;
        case 3: p = (uint8 *) &e->srccnt; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ipv6sapayload */
int soc_sbx_g2p3_ipv6sapayload_index_check(int unit,
                int *vindex,
                int iaddr)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SAPAYLOAD_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iaddr; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ipv6sapayload */
int soc_sbx_g2p3_ipv6sapayload_entry_check(int unit,
                soc_sbx_g2p3_ipv6sapayload_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SAPAYLOAD_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->poe; break;
        case 1: ev = e->rpfmode; break;
        case 2: ev = e->srcdrop; break;
        case 3: ev = e->srccnt; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* ipv6sapayload table size get */
int soc_sbx_g2p3_ipv6sapayload_entry_table_size_get(int unit,
                int *tsize,
                int iaddr)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SAPAYLOAD_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = iaddr; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for ipv6sapayload */
int soc_sbx_g2p3_ipv6sapayload_set(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv6sapayload_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SAPAYLOAD_ID];

    s = soc_sbx_g2p3_ipv6sapayload_index_check(unit, key,
                iaddr);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv6sapayload_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_ipv6sapayload_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for ipv6sapayload */
int soc_sbx_g2p3_ipv6sapayload_get(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv6sapayload_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SAPAYLOAD_ID];

    s = soc_sbx_g2p3_ipv6sapayload_index_check(unit, key,
                iaddr);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_ipv6sapayload_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for ipv4da
 */

void soc_sbx_g2p3_ipv4da_t_init(
    soc_sbx_g2p3_ipv4da_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ipv4da_t));
}

/* entry pack accessor implementation for ipv4da */
int soc_sbx_g2p3_ipv4da_pack(int unit,
    soc_sbx_g2p3_ipv4da_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DA_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->ftidx; break;
        case 1: p = (uint8 *) &e->ecmpmask; break;
        case 2: p = (uint8 *) &e->vid; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ipv4da */
int soc_sbx_g2p3_ipv4da_unpack(int unit,
                soc_sbx_g2p3_ipv4da_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DA_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->ftidx; break;
        case 1: p = (uint8 *) &e->ecmpmask; break;
        case 2: p = (uint8 *) &e->vid; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ipv4da */
int soc_sbx_g2p3_ipv4da_index_check(int unit,
                int *vindex,
                int iprefixbits,
                int iip,
                int iipcxt)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DA_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iprefixbits; break;
        case 1: p = (uint8 *) &iip; break;
        case 2: p = (uint8 *) &iipcxt; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!i) continue;
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry index unpack for ipv4da */
int soc_sbx_g2p3_ipv4da_index_unpack(int unit,
                int *vindex,
                int *iprefixbits,
                int *iip,
                int *iipcxt)
{
    int i, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DA_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int be = tm->behost;
    int pkbe = be;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    iprefixbits = iprefixbits;

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 1; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
	fmt = id->format;
        switch (i) {
        case 1: p = (uint8 *) iip; break;
        case 2: p = (uint8 *) iipcxt; break;
        default: return SOC_E_INTERNAL;
        }
        sal_memset(p, 0, width <= 32 ? (int) sizeof(int) : (width + 7) / 8);
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe =
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT 
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_extract(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ipv4da */
int soc_sbx_g2p3_ipv4da_entry_check(int unit,
                soc_sbx_g2p3_ipv4da_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DA_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->ftidx; break;
        case 1: ev = e->ecmpmask; break;
        case 2: ev = e->vid; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for ipv4da */
int soc_sbx_g2p3_ipv4da_set(int unit,
                int iprefixbits,
                int iip,
                int iipcxt,
                soc_sbx_g2p3_ipv4da_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_ipv4da_index_check(unit, key,
                iprefixbits,
                iip,
                iipcxt);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv4da_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv4da_update(unit,
                iprefixbits,
                iip,
                iipcxt,
                e);
    if (s == SOC_E_NOT_FOUND) {
        s = soc_sbx_g2p3_ipv4da_add(unit,
                iprefixbits,
                iip,
                iipcxt,
                e);
        if (s) {
            return s;
        }
        s = soc_sbx_g2p3_ipv4da_commit(unit, 0xffffffff);
    }

    return s;
}

/* entry add accessor implementation for ipv4da */
int soc_sbx_g2p3_ipv4da_add(int unit,
                int iprefixbits,
                int iip,
                int iipcxt,
                soc_sbx_g2p3_ipv4da_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DA_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_ipv4da_index_check(unit, key,
                iprefixbits,
                iip,
                iipcxt);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv4da_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_lpm_add_ext(unit, cs,
                iprefixbits,
                (uint8 *) key,
                e);

    return s;
}

/* entry get accessor implementation for ipv4da */
int soc_sbx_g2p3_ipv4da_get(int unit,
                int iprefixbits,
                int iip,
                int iipcxt,
                soc_sbx_g2p3_ipv4da_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DA_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_ipv4da_index_check(unit, key,
                iprefixbits,
                iip,
                iipcxt);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_lpm_get_ext(unit, cs,
                iprefixbits,
                (uint8 *) key,
                e);

    return s;
}

/* entry update accessor implementation for ipv4da */
int soc_sbx_g2p3_ipv4da_update(int unit,
                int iprefixbits,
                int iip,
                int iipcxt,
                soc_sbx_g2p3_ipv4da_t *e)
{
    int s, key[32];

    s = soc_sbx_g2p3_ipv4da_index_check(unit, key,
                iprefixbits,
                iip,
                iipcxt);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv4da_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv4da_renew(unit,
                iprefixbits,
                iip,
                iipcxt,
                e);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv4da_commit(unit, 0xffffffff);

    return s;
}

/* entry renew accessor implementation for ipv4da */
int soc_sbx_g2p3_ipv4da_renew(int unit,
                int iprefixbits,
                int iip,
                int iipcxt,
                soc_sbx_g2p3_ipv4da_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DA_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_ipv4da_index_check(unit, key,
                iprefixbits,
                iip,
                iipcxt);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv4da_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_lpm_renew_ext(unit, cs,
                iprefixbits,
                (uint8 *) key,
                e);

    return s;
}

/* entry delete accessor implementation for ipv4da */
int soc_sbx_g2p3_ipv4da_delete(int unit,
                int iprefixbits,
                int iip,
                int iipcxt)
{
    int s, key[32];

    s = soc_sbx_g2p3_ipv4da_index_check(unit, key,
                iprefixbits,
                iip,
                iipcxt);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv4da_remove(unit,
                iprefixbits,
                iip,
                iipcxt);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_ipv4da_commit(unit, 0xffffffff);

    return s;
}

/* entry remove accessor implementation for ipv4da */
int soc_sbx_g2p3_ipv4da_remove(int unit,
                int iprefixbits,
                int iip,
                int iipcxt)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DA_ID];
    void *cs = tm->tables[ed->table].cstate;

    s = soc_sbx_g2p3_ipv4da_index_check(unit, key,
                iprefixbits,
                iip,
                iipcxt);
    if (s) {
        return s;
    }
    s = soc_sbx_g2p3_lpm_remove_ext(unit, cs,
                iprefixbits,
                (uint8 *) key);

    return s;
}

/* Get the first element of ipv4da */
int soc_sbx_g2p3_ipv4da_first(int unit,
                int *niprefixbits,
                int *niip,
                int *niipcxt)
{
    int s;
    int nkey[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DA_ID];
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    void *cs = td->cstate;

    s = soc_sbx_g2p3_lpm_first_ext(unit, cs,
                niprefixbits,
                (uint8 *) nkey);
    if (!s) {
        soc_sbx_g2p3_ipv4da_index_unpack(unit, nkey,
                niprefixbits,
                niip,
                niipcxt);
    }
    return s;
}

/* Get the next element of ipv4da */
int soc_sbx_g2p3_ipv4da_next(int unit,
                int iprefixbits,
                int iip,
                int iipcxt,
                int *niprefixbits,
                int *niip,
                int *niipcxt)
{
    int key[32], s;
    int nkey[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DA_ID];
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    void *cs = td->cstate;

    s = soc_sbx_g2p3_ipv4da_index_check(unit, key,
                iprefixbits,
                iip,
                iipcxt);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_lpm_next_ext(unit, cs,
                iprefixbits,
                (uint8 *) key,
                niprefixbits,
                (uint8 *) nkey);
    if (!s) {
        soc_sbx_g2p3_ipv4da_index_unpack(unit, nkey,
                niprefixbits,
                niip,
                niipcxt);
    }
    return s;
}

/* Batch commit implementation for ipv4da */
int soc_sbx_g2p3_ipv4da_commit(int unit, int runlength)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DA_ID];
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    void *cs = td->cstate;

    return soc_sbx_g2p3_lpm_commit_ext(unit, cs, runlength);
}

/*
 * Entry accessor implementations for ipv4dal0
 */

void soc_sbx_g2p3_ipv4dal0_t_init(
    soc_sbx_g2p3_ipv4dal0_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ipv4dal0_t));
}

/* entry pack accessor implementation for ipv4dal0 */
int soc_sbx_g2p3_ipv4dal0_pack(int unit,
    soc_sbx_g2p3_ipv4dal0_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DAL0_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->pattern; break;
        case 1: p = (uint8 *) &e->singleton; break;
        case 2: p = (uint8 *) &e->pointer; break;
        case 3: p = (uint8 *) &e->leaf; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ipv4dal0 */
int soc_sbx_g2p3_ipv4dal0_unpack(int unit,
                soc_sbx_g2p3_ipv4dal0_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DAL0_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->pattern; break;
        case 1: p = (uint8 *) &e->singleton; break;
        case 2: p = (uint8 *) &e->pointer; break;
        case 3: p = (uint8 *) &e->leaf; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ipv4dal0 */
int soc_sbx_g2p3_ipv4dal0_index_check(int unit,
                int *vindex,
                int iaddr)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DAL0_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iaddr; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ipv4dal0 */
int soc_sbx_g2p3_ipv4dal0_entry_check(int unit,
                soc_sbx_g2p3_ipv4dal0_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DAL0_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->pattern; break;
        case 1: ev = e->singleton; break;
        case 2: ev = e->pointer; break;
        case 3: ev = e->leaf; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* ipv4dal0 table size get */
int soc_sbx_g2p3_ipv4dal0_entry_table_size_get(int unit,
                int *tsize,
                int iaddr)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DAL0_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = iaddr; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for ipv4dal0 */
int soc_sbx_g2p3_ipv4dal0_set(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv4dal0_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DAL0_ID];

    s = soc_sbx_g2p3_ipv4dal0_index_check(unit, key,
                iaddr);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv4dal0_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_ipv4dal0_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for ipv4dal0 */
int soc_sbx_g2p3_ipv4dal0_get(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv4dal0_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DAL0_ID];

    s = soc_sbx_g2p3_ipv4dal0_index_check(unit, key,
                iaddr);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_ipv4dal0_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for ipv4daodd
 */

void soc_sbx_g2p3_ipv4daodd_t_init(
    soc_sbx_g2p3_ipv4daodd_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ipv4daodd_t));
}

/* entry pack accessor implementation for ipv4daodd */
int soc_sbx_g2p3_ipv4daodd_pack(int unit,
    soc_sbx_g2p3_ipv4daodd_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DAODD_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->pattern; break;
        case 1: p = (uint8 *) &e->singleton; break;
        case 2: p = (uint8 *) &e->pointer; break;
        case 3: p = (uint8 *) &e->leaf; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ipv4daodd */
int soc_sbx_g2p3_ipv4daodd_unpack(int unit,
                soc_sbx_g2p3_ipv4daodd_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DAODD_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->pattern; break;
        case 1: p = (uint8 *) &e->singleton; break;
        case 2: p = (uint8 *) &e->pointer; break;
        case 3: p = (uint8 *) &e->leaf; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ipv4daodd */
int soc_sbx_g2p3_ipv4daodd_index_check(int unit,
                int *vindex,
                int iaddr)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DAODD_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iaddr; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ipv4daodd */
int soc_sbx_g2p3_ipv4daodd_entry_check(int unit,
                soc_sbx_g2p3_ipv4daodd_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DAODD_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->pattern; break;
        case 1: ev = e->singleton; break;
        case 2: ev = e->pointer; break;
        case 3: ev = e->leaf; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* ipv4daodd table size get */
int soc_sbx_g2p3_ipv4daodd_entry_table_size_get(int unit,
                int *tsize,
                int iaddr)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DAODD_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = iaddr; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for ipv4daodd */
int soc_sbx_g2p3_ipv4daodd_set(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv4daodd_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DAODD_ID];

    s = soc_sbx_g2p3_ipv4daodd_index_check(unit, key,
                iaddr);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv4daodd_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_ipv4daodd_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for ipv4daodd */
int soc_sbx_g2p3_ipv4daodd_get(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv4daodd_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DAODD_ID];

    s = soc_sbx_g2p3_ipv4daodd_index_check(unit, key,
                iaddr);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_ipv4daodd_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for ipv4daeven
 */

void soc_sbx_g2p3_ipv4daeven_t_init(
    soc_sbx_g2p3_ipv4daeven_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ipv4daeven_t));
}

/* entry pack accessor implementation for ipv4daeven */
int soc_sbx_g2p3_ipv4daeven_pack(int unit,
    soc_sbx_g2p3_ipv4daeven_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DAEVEN_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->pattern; break;
        case 1: p = (uint8 *) &e->singleton; break;
        case 2: p = (uint8 *) &e->pointer; break;
        case 3: p = (uint8 *) &e->leaf; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ipv4daeven */
int soc_sbx_g2p3_ipv4daeven_unpack(int unit,
                soc_sbx_g2p3_ipv4daeven_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DAEVEN_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->pattern; break;
        case 1: p = (uint8 *) &e->singleton; break;
        case 2: p = (uint8 *) &e->pointer; break;
        case 3: p = (uint8 *) &e->leaf; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ipv4daeven */
int soc_sbx_g2p3_ipv4daeven_index_check(int unit,
                int *vindex,
                int iaddr)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DAEVEN_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iaddr; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ipv4daeven */
int soc_sbx_g2p3_ipv4daeven_entry_check(int unit,
                soc_sbx_g2p3_ipv4daeven_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DAEVEN_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->pattern; break;
        case 1: ev = e->singleton; break;
        case 2: ev = e->pointer; break;
        case 3: ev = e->leaf; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* ipv4daeven table size get */
int soc_sbx_g2p3_ipv4daeven_entry_table_size_get(int unit,
                int *tsize,
                int iaddr)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DAEVEN_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = iaddr; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for ipv4daeven */
int soc_sbx_g2p3_ipv4daeven_set(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv4daeven_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DAEVEN_ID];

    s = soc_sbx_g2p3_ipv4daeven_index_check(unit, key,
                iaddr);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv4daeven_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_ipv4daeven_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for ipv4daeven */
int soc_sbx_g2p3_ipv4daeven_get(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv4daeven_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DAEVEN_ID];

    s = soc_sbx_g2p3_ipv4daeven_index_check(unit, key,
                iaddr);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_ipv4daeven_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for ipv4dapayload
 */

void soc_sbx_g2p3_ipv4dapayload_t_init(
    soc_sbx_g2p3_ipv4dapayload_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_ipv4dapayload_t));
}

/* entry pack accessor implementation for ipv4dapayload */
int soc_sbx_g2p3_ipv4dapayload_pack(int unit,
    soc_sbx_g2p3_ipv4dapayload_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DAPAYLOAD_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->ftidx; break;
        case 1: p = (uint8 *) &e->ecmpmask; break;
        case 2: p = (uint8 *) &e->vid; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ipv4dapayload */
int soc_sbx_g2p3_ipv4dapayload_unpack(int unit,
                soc_sbx_g2p3_ipv4dapayload_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DAPAYLOAD_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->ftidx; break;
        case 1: p = (uint8 *) &e->ecmpmask; break;
        case 2: p = (uint8 *) &e->vid; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ipv4dapayload */
int soc_sbx_g2p3_ipv4dapayload_index_check(int unit,
                int *vindex,
                int iaddr)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DAPAYLOAD_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iaddr; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ipv4dapayload */
int soc_sbx_g2p3_ipv4dapayload_entry_check(int unit,
                soc_sbx_g2p3_ipv4dapayload_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DAPAYLOAD_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->ftidx; break;
        case 1: ev = e->ecmpmask; break;
        case 2: ev = e->vid; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* ipv4dapayload table size get */
int soc_sbx_g2p3_ipv4dapayload_entry_table_size_get(int unit,
                int *tsize,
                int iaddr)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DAPAYLOAD_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = iaddr; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for ipv4dapayload */
int soc_sbx_g2p3_ipv4dapayload_set(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv4dapayload_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DAPAYLOAD_ID];

    s = soc_sbx_g2p3_ipv4dapayload_index_check(unit, key,
                iaddr);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_ipv4dapayload_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_ipv4dapayload_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for ipv4dapayload */
int soc_sbx_g2p3_ipv4dapayload_get(int unit,
                int iaddr,
                soc_sbx_g2p3_ipv4dapayload_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DAPAYLOAD_ID];

    s = soc_sbx_g2p3_ipv4dapayload_index_check(unit, key,
                iaddr);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_ipv4dapayload_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for P2FTI
 */

void soc_sbx_g2p3_p2fti_t_init(
    soc_sbx_g2p3_p2fti_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_p2fti_t));
}

/* entry pack accessor implementation for P2FTI */
int soc_sbx_g2p3_p2fti_pack(int unit,
    soc_sbx_g2p3_p2fti_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2FTI_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->ftidx; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for P2FTI */
int soc_sbx_g2p3_p2fti_unpack(int unit,
                soc_sbx_g2p3_p2fti_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2FTI_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->ftidx; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for P2FTI */
int soc_sbx_g2p3_p2fti_index_check(int unit,
                int *vindex,
                int iport,
                int idmac)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2FTI_ID];
    soc_sbx_g2p3_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iport; break;
        case 1: p = (uint8 *) &idmac; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2P3_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2P3_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2p3_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for P2FTI */
int soc_sbx_g2p3_p2fti_entry_check(int unit,
                soc_sbx_g2p3_p2fti_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2FTI_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->ftidx; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2p3_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* P2FTI table size get */
int soc_sbx_g2p3_p2fti_entry_table_size_get(int unit,
                int *tsize,
                int iport,
                int idmac)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2FTI_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2p3_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2p3_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = iport; break;
        case 1: v = idmac; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2p3_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for P2FTI */
int soc_sbx_g2p3_p2fti_set(int unit,
                int iport,
                int idmac,
                soc_sbx_g2p3_p2fti_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2FTI_ID];

    s = soc_sbx_g2p3_p2fti_index_check(unit, key,
                iport,
                idmac);
    if (s) {
        return s;
    }

    s = soc_sbx_g2p3_p2fti_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2p3_p2fti_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for P2FTI */
int soc_sbx_g2p3_p2fti_get(int unit,
                int iport,
                int idmac,
                soc_sbx_g2p3_p2fti_t *e)
{
    int s, key[32];
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2FTI_ID];

    s = soc_sbx_g2p3_p2fti_index_check(unit, key,
                iport,
                idmac);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2p3_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2p3_p2fti_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for policer
 */

void soc_sbx_g2p3_policer_t_init(
    soc_sbx_g2p3_policer_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_policer_t));
}

/* entry size function for policer */
int soc_sbx_g2p3_policer_size(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_POLICER_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];

    return (eb->width + (eb->stridebits - 1)) / eb->stridebits;
}

/* entry pack accessor implementation for policer */
int soc_sbx_g2p3_policer_pack(int unit,
    soc_sbx_g2p3_policer_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_POLICER_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->cbsbytes; break;
        case 1: p = (uint8 *) &e->cirkbps; break;
        case 2: p = (uint8 *) &e->ebsbytes; break;
        case 3: p = (uint8 *) &e->eirkbps; break;
        case 4: p = (uint8 *) &e->mode; break;
        case 5: p = (uint8 *) &e->lenshift; break;
        case 6: p = (uint8 *) &e->colorblind; break;
        case 7: p = (uint8 *) &e->dropred; break;
        case 8: p = (uint8 *) &e->coupling; break;
        case 9: p = (uint8 *) &e->nodebit; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for policer */
int soc_sbx_g2p3_policer_unpack(int unit,
                soc_sbx_g2p3_policer_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_POLICER_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->cbsbytes; break;
        case 1: p = (uint8 *) &e->cirkbps; break;
        case 2: p = (uint8 *) &e->ebsbytes; break;
        case 3: p = (uint8 *) &e->eirkbps; break;
        case 4: p = (uint8 *) &e->mode; break;
        case 5: p = (uint8 *) &e->lenshift; break;
        case 6: p = (uint8 *) &e->colorblind; break;
        case 7: p = (uint8 *) &e->dropred; break;
        case 8: p = (uint8 *) &e->coupling; break;
        case 9: p = (uint8 *) &e->nodebit; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/*
 * Entry accessor implementations for timer
 */

void soc_sbx_g2p3_timer_t_init(
    soc_sbx_g2p3_timer_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_timer_t));
}

/* entry size function for timer */
int soc_sbx_g2p3_timer_size(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_TIMER_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];

    return (eb->width + (eb->stridebits - 1)) / eb->stridebits;
}

/* entry pack accessor implementation for timer */
int soc_sbx_g2p3_timer_pack(int unit,
    soc_sbx_g2p3_timer_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_TIMER_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->ms; break;
        case 1: p = (uint8 *) &e->started; break;
        case 2: p = (uint8 *) &e->ucodereset; break;
        case 3: p = (uint8 *) &e->interrupt; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for timer */
int soc_sbx_g2p3_timer_unpack(int unit,
                soc_sbx_g2p3_timer_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_TIMER_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->ms; break;
        case 1: p = (uint8 *) &e->started; break;
        case 2: p = (uint8 *) &e->ucodereset; break;
        case 3: p = (uint8 *) &e->interrupt; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/*
 * Entry accessor implementations for sequence
 */

void soc_sbx_g2p3_sequence_t_init(
    soc_sbx_g2p3_sequence_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2p3_sequence_t));
}

/* entry size function for sequence */
int soc_sbx_g2p3_sequence_size(int unit)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_SEQUENCE_ID];
    soc_sbx_g2p3_entry_bank_t *eb = &ed->banks[0];

    return (eb->width + (eb->stridebits - 1)) / eb->stridebits;
}

/* entry pack accessor implementation for sequence */
int soc_sbx_g2p3_sequence_pack(int unit,
    soc_sbx_g2p3_sequence_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_SEQUENCE_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->seqnum; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for sequence */
int soc_sbx_g2p3_sequence_unpack(int unit,
                soc_sbx_g2p3_sequence_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_SEQUENCE_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->seqnum; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2p3_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* Get counter bank description implementation */
int soc_sbx_g2p3_counter_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_counter_bank_params_t *p)
{
    int size, i;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;

    if (bank >= SOC_SBX_G2P3_COUNTER_BANKS_MAX) {
        return SOC_E_PARAM;
    }
    
    if (tm->counterbanks[bank].base < 0) {
        return SOC_E_NOT_FOUND;
    }

    p->memory = tm->counterbanks[bank].memory;
    p->base = tm->counterbanks[bank].base;

    size = 0;
    for (i = 0; i < SOC_SBX_G2P3_COUNTER_MAX_ID; i++) {
        if (tm->counters[i].bank == bank) {
            size += tm->counters[i].size;
        }
    }
    p->size = size;

    return SOC_E_NONE;
}
  
/* Get counter parameter implementation for pdctr */
int soc_sbx_g2p3_pdctr_counter_params_get(int unit,
                soc_sbx_g2p3_counter_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;

    p->bank = tm->counters
        [SOC_SBX_G2P3_PDCTR_ID].bank;
    p->size = tm->counters
        [SOC_SBX_G2P3_PDCTR_ID].size;
    p->base = tm->counters
        [SOC_SBX_G2P3_PDCTR_ID].base;

    return SOC_E_NONE;
}
  
/* Set the size of the counter set implementation for pdctr */
int soc_sbx_g2p3_pdctr_counter_size_set(int unit, int size)
{
    int s;

    s = soc_sbx_g2p3_generic_counter_size_set(unit, SOC_SBX_G2P3_PDCTR_ID, size, 1);
    return s;
}
  
/* Get counter implementation for pdctr */
int soc_sbx_g2p3_pdctr_get(int unit,
                int clear, int cnum,
                soc_sbx_g2p3_counter_value_t *v)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm   = fe->tableinfo;
    soc_sbx_g2p3_counter_desc_t *cd   = &tm->counters[SOC_SBX_G2P3_PDCTR_ID];
    sbStatus_t s;

    if (0 <= cd->size && cd->size <= cnum) {
        return SOC_E_PARAM;
    }

    s = sbFe2000CmuCounterRead(fe->pCmuMgr, cd->bank, cd->base + cnum, 1,
                               (void *) v, 1, clear);
      
    return soc_sbx_translate_status(s);
}
  
/* Get counter parameter implementation for rtctr */
int soc_sbx_g2p3_rtctr_counter_params_get(int unit,
                soc_sbx_g2p3_counter_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;

    p->bank = tm->counters
        [SOC_SBX_G2P3_RTCTR_ID].bank;
    p->size = tm->counters
        [SOC_SBX_G2P3_RTCTR_ID].size;
    p->base = tm->counters
        [SOC_SBX_G2P3_RTCTR_ID].base;

    return SOC_E_NONE;
}
  
/* Set the size of the counter set implementation for rtctr */
int soc_sbx_g2p3_rtctr_counter_size_set(int unit, int size)
{
    int s;

    s = soc_sbx_g2p3_generic_counter_size_set(unit, SOC_SBX_G2P3_RTCTR_ID, size, 1);
    return s;
}
  
/* Get counter implementation for rtctr */
int soc_sbx_g2p3_rtctr_get(int unit,
                int clear, int cnum,
                soc_sbx_g2p3_counter_value_t *v)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm   = fe->tableinfo;
    soc_sbx_g2p3_counter_desc_t *cd   = &tm->counters[SOC_SBX_G2P3_RTCTR_ID];
    sbStatus_t s;

    if (0 <= cd->size && cd->size <= cnum) {
        return SOC_E_PARAM;
    }

    s = sbFe2000CmuCounterRead(fe->pCmuMgr, cd->bank, cd->base + cnum, 1,
                               (void *) v, 1, clear);
      
    return soc_sbx_translate_status(s);
}
  
/* Get counter parameter implementation for irtctr */
int soc_sbx_g2p3_irtctr_counter_params_get(int unit,
                soc_sbx_g2p3_counter_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;

    p->bank = tm->counters
        [SOC_SBX_G2P3_IRTCTR_ID].bank;
    p->size = tm->counters
        [SOC_SBX_G2P3_IRTCTR_ID].size;
    p->base = tm->counters
        [SOC_SBX_G2P3_IRTCTR_ID].base;

    return SOC_E_NONE;
}
  
/* Set the size of the counter set implementation for irtctr */
int soc_sbx_g2p3_irtctr_counter_size_set(int unit, int size)
{
    int s;

    s = soc_sbx_g2p3_generic_counter_size_set(unit, SOC_SBX_G2P3_IRTCTR_ID, size, 1);
    return s;
}
  
/* Get counter implementation for irtctr */
int soc_sbx_g2p3_irtctr_get(int unit,
                int clear, int cnum,
                soc_sbx_g2p3_counter_value_t *v)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm   = fe->tableinfo;
    soc_sbx_g2p3_counter_desc_t *cd   = &tm->counters[SOC_SBX_G2P3_IRTCTR_ID];
    sbStatus_t s;

    if (0 <= cd->size && cd->size <= cnum) {
        return SOC_E_PARAM;
    }

    s = sbFe2000CmuCounterRead(fe->pCmuMgr, cd->bank, cd->base + cnum, 1,
                               (void *) v, 1, clear);
      
    return soc_sbx_translate_status(s);
}
  
/* Get counter parameter implementation for ifpctr */
int soc_sbx_g2p3_ifpctr_counter_params_get(int unit,
                soc_sbx_g2p3_counter_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;

    p->bank = tm->counters
        [SOC_SBX_G2P3_IFPCTR_ID].bank;
    p->size = tm->counters
        [SOC_SBX_G2P3_IFPCTR_ID].size;
    p->base = tm->counters
        [SOC_SBX_G2P3_IFPCTR_ID].base;

    return SOC_E_NONE;
}
  
/* Set the size of the counter set implementation for ifpctr */
int soc_sbx_g2p3_ifpctr_counter_size_set(int unit, int size)
{
    int s;

    s = soc_sbx_g2p3_generic_counter_size_set(unit, SOC_SBX_G2P3_IFPCTR_ID, size, 1);
    return s;
}
  
/* Get counter implementation for ifpctr */
int soc_sbx_g2p3_ifpctr_get(int unit,
                int clear, int cnum,
                soc_sbx_g2p3_counter_value_t *v)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm   = fe->tableinfo;
    soc_sbx_g2p3_counter_desc_t *cd   = &tm->counters[SOC_SBX_G2P3_IFPCTR_ID];

    if (0 <= cd->size && cd->size <= cnum) {
        return SOC_E_PARAM;
    }

    return soc_sbx_g2p3_ifpctr_get_ext(unit, clear, cnum, v);
}
  
/* Get counter parameter implementation for ifp_v6ctr */
int soc_sbx_g2p3_ifp_v6ctr_counter_params_get(int unit,
                soc_sbx_g2p3_counter_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;

    p->bank = tm->counters
        [SOC_SBX_G2P3_IFP_V6CTR_ID].bank;
    p->size = tm->counters
        [SOC_SBX_G2P3_IFP_V6CTR_ID].size;
    p->base = tm->counters
        [SOC_SBX_G2P3_IFP_V6CTR_ID].base;

    return SOC_E_NONE;
}
  
/* Set the size of the counter set implementation for ifp_v6ctr */
int soc_sbx_g2p3_ifp_v6ctr_counter_size_set(int unit, int size)
{
    int s;

    s = soc_sbx_g2p3_generic_counter_size_set(unit, SOC_SBX_G2P3_IFP_V6CTR_ID, size, 1);
    return s;
}
  
/* Get counter implementation for ifp_v6ctr */
int soc_sbx_g2p3_ifp_v6ctr_get(int unit,
                int clear, int cnum,
                soc_sbx_g2p3_counter_value_t *v)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm   = fe->tableinfo;
    soc_sbx_g2p3_counter_desc_t *cd   = &tm->counters[SOC_SBX_G2P3_IFP_V6CTR_ID];

    if (0 <= cd->size && cd->size <= cnum) {
        return SOC_E_PARAM;
    }

    return soc_sbx_g2p3_ifp_v6ctr_get_ext(unit, clear, cnum, v);
}
  
/* Get counter parameter implementation for ertctr */
int soc_sbx_g2p3_ertctr_counter_params_get(int unit,
                soc_sbx_g2p3_counter_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;

    p->bank = tm->counters
        [SOC_SBX_G2P3_ERTCTR_ID].bank;
    p->size = tm->counters
        [SOC_SBX_G2P3_ERTCTR_ID].size;
    p->base = tm->counters
        [SOC_SBX_G2P3_ERTCTR_ID].base;

    return SOC_E_NONE;
}
  
/* Set the size of the counter set implementation for ertctr */
int soc_sbx_g2p3_ertctr_counter_size_set(int unit, int size)
{
    int s;

    s = soc_sbx_g2p3_generic_counter_size_set(unit, SOC_SBX_G2P3_ERTCTR_ID, size, 1);
    return s;
}
  
/* Get counter implementation for ertctr */
int soc_sbx_g2p3_ertctr_get(int unit,
                int clear, int cnum,
                soc_sbx_g2p3_counter_value_t *v)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm   = fe->tableinfo;
    soc_sbx_g2p3_counter_desc_t *cd   = &tm->counters[SOC_SBX_G2P3_ERTCTR_ID];
    sbStatus_t s;

    if (0 <= cd->size && cd->size <= cnum) {
        return SOC_E_PARAM;
    }

    s = sbFe2000CmuCounterRead(fe->pCmuMgr, cd->bank, cd->base + cnum, 1,
                               (void *) v, 1, clear);
      
    return soc_sbx_translate_status(s);
}
  
/* Get counter parameter implementation for efpctr */
int soc_sbx_g2p3_efpctr_counter_params_get(int unit,
                soc_sbx_g2p3_counter_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;

    p->bank = tm->counters
        [SOC_SBX_G2P3_EFPCTR_ID].bank;
    p->size = tm->counters
        [SOC_SBX_G2P3_EFPCTR_ID].size;
    p->base = tm->counters
        [SOC_SBX_G2P3_EFPCTR_ID].base;

    return SOC_E_NONE;
}
  
/* Set the size of the counter set implementation for efpctr */
int soc_sbx_g2p3_efpctr_counter_size_set(int unit, int size)
{
    int s;

    s = soc_sbx_g2p3_generic_counter_size_set(unit, SOC_SBX_G2P3_EFPCTR_ID, size, 1);
    return s;
}
  
/* Get counter implementation for efpctr */
int soc_sbx_g2p3_efpctr_get(int unit,
                int clear, int cnum,
                soc_sbx_g2p3_counter_value_t *v)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm   = fe->tableinfo;
    soc_sbx_g2p3_counter_desc_t *cd   = &tm->counters[SOC_SBX_G2P3_EFPCTR_ID];

    if (0 <= cd->size && cd->size <= cnum) {
        return SOC_E_PARAM;
    }

    return soc_sbx_g2p3_efpctr_get_ext(unit, clear, cnum, v);
}
  
/* Get counter parameter implementation for efp_v6ctr */
int soc_sbx_g2p3_efp_v6ctr_counter_params_get(int unit,
                soc_sbx_g2p3_counter_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;

    p->bank = tm->counters
        [SOC_SBX_G2P3_EFP_V6CTR_ID].bank;
    p->size = tm->counters
        [SOC_SBX_G2P3_EFP_V6CTR_ID].size;
    p->base = tm->counters
        [SOC_SBX_G2P3_EFP_V6CTR_ID].base;

    return SOC_E_NONE;
}
  
/* Set the size of the counter set implementation for efp_v6ctr */
int soc_sbx_g2p3_efp_v6ctr_counter_size_set(int unit, int size)
{
    int s;

    s = soc_sbx_g2p3_generic_counter_size_set(unit, SOC_SBX_G2P3_EFP_V6CTR_ID, size, 1);
    return s;
}
  
/* Get counter implementation for efp_v6ctr */
int soc_sbx_g2p3_efp_v6ctr_get(int unit,
                int clear, int cnum,
                soc_sbx_g2p3_counter_value_t *v)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm   = fe->tableinfo;
    soc_sbx_g2p3_counter_desc_t *cd   = &tm->counters[SOC_SBX_G2P3_EFP_V6CTR_ID];

    if (0 <= cd->size && cd->size <= cnum) {
        return SOC_E_PARAM;
    }

    return soc_sbx_g2p3_efp_v6ctr_get_ext(unit, clear, cnum, v);
}
  
/* Get counter parameter implementation for excctr */
int soc_sbx_g2p3_excctr_counter_params_get(int unit,
                soc_sbx_g2p3_counter_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;

    p->bank = tm->counters
        [SOC_SBX_G2P3_EXCCTR_ID].bank;
    p->size = tm->counters
        [SOC_SBX_G2P3_EXCCTR_ID].size;
    p->base = tm->counters
        [SOC_SBX_G2P3_EXCCTR_ID].base;

    return SOC_E_NONE;
}
  
/* Set the size of the counter set implementation for excctr */
int soc_sbx_g2p3_excctr_counter_size_set(int unit, int size)
{
    int s;

    s = soc_sbx_g2p3_generic_counter_size_set(unit, SOC_SBX_G2P3_EXCCTR_ID, size, 1);
    return s;
}
  
/* Get counter implementation for excctr */
int soc_sbx_g2p3_excctr_get(int unit,
                int clear, int cnum,
                soc_sbx_g2p3_counter_value_t *v)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm   = fe->tableinfo;
    soc_sbx_g2p3_counter_desc_t *cd   = &tm->counters[SOC_SBX_G2P3_EXCCTR_ID];
    sbStatus_t s;

    if (0 <= cd->size && cd->size <= cnum) {
        return SOC_E_PARAM;
    }

    s = sbFe2000CmuCounterRead(fe->pCmuMgr, cd->bank, cd->base + cnum, 1,
                               (void *) v, 1, clear);
      
    return soc_sbx_translate_status(s);
}
  
/* Get counter parameter implementation for ingctr */
int soc_sbx_g2p3_ingctr_counter_params_get(int unit,
                soc_sbx_g2p3_counter_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;

    p->bank = tm->counters
        [SOC_SBX_G2P3_INGCTR_ID].bank;
    p->size = tm->counters
        [SOC_SBX_G2P3_INGCTR_ID].size;
    p->base = tm->counters
        [SOC_SBX_G2P3_INGCTR_ID].base;

    return SOC_E_NONE;
}
  
/* Set the size of the counter set implementation for ingctr */
int soc_sbx_g2p3_ingctr_counter_size_set(int unit, int size)
{
    int s;

    s = soc_sbx_g2p3_generic_counter_size_set(unit, SOC_SBX_G2P3_INGCTR_ID, size, 1);
    return s;
}
  
/* Get counter implementation for ingctr */
int soc_sbx_g2p3_ingctr_get(int unit,
                int clear, int cnum,
                soc_sbx_g2p3_counter_value_t *v)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm   = fe->tableinfo;
    soc_sbx_g2p3_counter_desc_t *cd   = &tm->counters[SOC_SBX_G2P3_INGCTR_ID];
    sbStatus_t s;

    if (0 <= cd->size && cd->size <= cnum) {
        return SOC_E_PARAM;
    }

    s = sbFe2000CmuCounterRead(fe->pCmuMgr, cd->bank, cd->base + cnum, 1,
                               (void *) v, 1, clear);
      
    return soc_sbx_translate_status(s);
}
  
/* Get counter parameter implementation for egrctr */
int soc_sbx_g2p3_egrctr_counter_params_get(int unit,
                soc_sbx_g2p3_counter_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;

    p->bank = tm->counters
        [SOC_SBX_G2P3_EGRCTR_ID].bank;
    p->size = tm->counters
        [SOC_SBX_G2P3_EGRCTR_ID].size;
    p->base = tm->counters
        [SOC_SBX_G2P3_EGRCTR_ID].base;

    return SOC_E_NONE;
}
  
/* Set the size of the counter set implementation for egrctr */
int soc_sbx_g2p3_egrctr_counter_size_set(int unit, int size)
{
    int s;

    s = soc_sbx_g2p3_generic_counter_size_set(unit, SOC_SBX_G2P3_EGRCTR_ID, size, 1);
    return s;
}
  
/* Get counter implementation for egrctr */
int soc_sbx_g2p3_egrctr_get(int unit,
                int clear, int cnum,
                soc_sbx_g2p3_counter_value_t *v)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm   = fe->tableinfo;
    soc_sbx_g2p3_counter_desc_t *cd   = &tm->counters[SOC_SBX_G2P3_EGRCTR_ID];
    sbStatus_t s;

    if (0 <= cd->size && cd->size <= cnum) {
        return SOC_E_PARAM;
    }

    s = sbFe2000CmuCounterRead(fe->pCmuMgr, cd->bank, cd->base + cnum, 1,
                               (void *) v, 1, clear);
      
    return soc_sbx_translate_status(s);
}

/* Get policer bank description implementation */
int soc_sbx_g2p3_policer_bank_params_get(int unit, int bank,
                soc_sbx_g2p3_policer_bank_params_t *p)
{
    int size, i;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;

    if (bank >= SOC_SBX_G2P3_POLICER_BANKS_MAX) {
        return SOC_E_PARAM;
    }
    
    if (tm->policerbanks[bank].base < 0) {
        return SOC_E_NOT_FOUND;
    }

    p->memory = tm->policerbanks[bank].memory;
    p->base = tm->policerbanks[bank].base;
    p->kbps = tm->policerbanks[bank].kbps;
    p->type = tm->policerbanks[bank].type;

    size = 0;
    for (i = 0; i < SOC_SBX_G2P3_POLICER_MAX_ID; i++) {
        if (tm->policers[i].bank == bank) {
            size += tm->policers[i].size;
        }
    }
    p->size = size;

    return SOC_E_NONE;
}

/* Policer parameter get implementation for xtpol */
int soc_sbx_g2p3_xtpol_policer_params_get(int unit,
                soc_sbx_g2p3_policer_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;

    p->bank = tm->policers
        [SOC_SBX_G2P3_XTPOL_ID].bank;
    p->size = tm->policers
        [SOC_SBX_G2P3_XTPOL_ID].size;
    p->base = tm->policers
        [SOC_SBX_G2P3_XTPOL_ID].base;

    return SOC_E_NONE;
}
  
/* Set the size of the policer set implementation for xtpol */
int soc_sbx_g2p3_xtpol_policer_size_set(int unit, int size)
{
    int s;

    s = soc_sbx_g2p3_generic_policer_size_set(unit, SOC_SBX_G2P3_XTPOL_ID, size, 1);
    return s;
}

/* policer set implementation for xtpol */
int soc_sbx_g2p3_xtpol_set(int unit,
                  int policer, soc_sbx_g2p3_policer_t *p)
{
    return soc_sbx_g2p3_generic_policer_set(unit,
                    SOC_SBX_G2P3_XTPOL_ID,
                    policer, p);
}

/* policer get implementation for xtpol */
int soc_sbx_g2p3_xtpol_get(int unit,
                  int policer, soc_sbx_g2p3_policer_t *p)
{
    return soc_sbx_g2p3_generic_policer_get(unit,
                    SOC_SBX_G2P3_XTPOL_ID,
                    policer, p);
}

/* policer delete implementation for xtpol */
int soc_sbx_g2p3_xtpol_delete(int unit, int policer)
{
    return soc_sbx_g2p3_generic_policer_delete(unit,
                    SOC_SBX_G2P3_XTPOL_ID,
                    policer);
}

/* Policer parameter get implementation for ingegrpol */
int soc_sbx_g2p3_ingegrpol_policer_params_get(int unit,
                soc_sbx_g2p3_policer_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;

    p->bank = tm->policers
        [SOC_SBX_G2P3_INGEGRPOL_ID].bank;
    p->size = tm->policers
        [SOC_SBX_G2P3_INGEGRPOL_ID].size;
    p->base = tm->policers
        [SOC_SBX_G2P3_INGEGRPOL_ID].base;

    return SOC_E_NONE;
}
  
/* Set the size of the policer set implementation for ingegrpol */
int soc_sbx_g2p3_ingegrpol_policer_size_set(int unit, int size)
{
    int s;

    s = soc_sbx_g2p3_generic_policer_size_set(unit, SOC_SBX_G2P3_INGEGRPOL_ID, size, 1);
    return s;
}

/* policer set implementation for ingegrpol */
int soc_sbx_g2p3_ingegrpol_set(int unit,
                  int policer, soc_sbx_g2p3_policer_t *p)
{
    return soc_sbx_g2p3_generic_policer_set(unit,
                    SOC_SBX_G2P3_INGEGRPOL_ID,
                    policer, p);
}

/* policer get implementation for ingegrpol */
int soc_sbx_g2p3_ingegrpol_get(int unit,
                  int policer, soc_sbx_g2p3_policer_t *p)
{
    return soc_sbx_g2p3_generic_policer_get(unit,
                    SOC_SBX_G2P3_INGEGRPOL_ID,
                    policer, p);
}

/* policer delete implementation for ingegrpol */
int soc_sbx_g2p3_ingegrpol_delete(int unit, int policer)
{
    return soc_sbx_g2p3_generic_policer_delete(unit,
                    SOC_SBX_G2P3_INGEGRPOL_ID,
                    policer);
}

/* Policer parameter get implementation for oamtimer */
int soc_sbx_g2p3_oamtimer_policer_params_get(int unit,
                soc_sbx_g2p3_policer_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;

    p->bank = tm->policers
        [SOC_SBX_G2P3_OAMTIMER_ID].bank;
    p->size = tm->policers
        [SOC_SBX_G2P3_OAMTIMER_ID].size;
    p->base = tm->policers
        [SOC_SBX_G2P3_OAMTIMER_ID].base;

    return SOC_E_NONE;
}
  
/* Set the size of the policer set implementation for oamtimer */
int soc_sbx_g2p3_oamtimer_policer_size_set(int unit, int size)
{
    int s;

    s = soc_sbx_g2p3_generic_policer_size_set(unit, SOC_SBX_G2P3_OAMTIMER_ID, size, 1);
    return s;
}

/* timer set implementation for oamtimer */
int soc_sbx_g2p3_oamtimer_set(int unit,
                  int policer, soc_sbx_g2p3_timer_t *p)
{
    return soc_sbx_g2p3_generic_timer_set(unit,
                    SOC_SBX_G2P3_OAMTIMER_ID,
                    policer, p);
}

/* timer get implementation for oamtimer */
int soc_sbx_g2p3_oamtimer_get(int unit,
                  int policer, soc_sbx_g2p3_timer_t *p)
{
    return soc_sbx_g2p3_generic_timer_get(unit,
                    SOC_SBX_G2P3_OAMTIMER_ID,
                    policer, p);
}

/* timer delete implementation for oamtimer */
int soc_sbx_g2p3_oamtimer_delete(int unit, int policer)
{
    return soc_sbx_g2p3_generic_timer_delete(unit,
                    SOC_SBX_G2P3_OAMTIMER_ID,
                    policer);
}

/* Policer parameter get implementation for oamseq */
int soc_sbx_g2p3_oamseq_policer_params_get(int unit,
                soc_sbx_g2p3_policer_params_t *p)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;

    p->bank = tm->policers
        [SOC_SBX_G2P3_OAMSEQ_ID].bank;
    p->size = tm->policers
        [SOC_SBX_G2P3_OAMSEQ_ID].size;
    p->base = tm->policers
        [SOC_SBX_G2P3_OAMSEQ_ID].base;

    return SOC_E_NONE;
}
  
/* Set the size of the policer set implementation for oamseq */
int soc_sbx_g2p3_oamseq_policer_size_set(int unit, int size)
{
    int s;

    s = soc_sbx_g2p3_generic_policer_size_set(unit, SOC_SBX_G2P3_OAMSEQ_ID, size, 1);
    return s;
}

/* sequence set implementation for oamseq */
int soc_sbx_g2p3_oamseq_set(int unit,
                  int policer, soc_sbx_g2p3_sequence_t *p)
{
    return soc_sbx_g2p3_generic_sequence_set(unit,
                    SOC_SBX_G2P3_OAMSEQ_ID,
                    policer, p);
}

/* sequence get implementation for oamseq */
int soc_sbx_g2p3_oamseq_get(int unit,
                  int policer, soc_sbx_g2p3_sequence_t *p)
{
    return soc_sbx_g2p3_generic_sequence_get(unit,
                    SOC_SBX_G2P3_OAMSEQ_ID,
                    policer, p);
}

/* sequence delete implementation for oamseq */
int soc_sbx_g2p3_oamseq_delete(int unit, int policer)
{
    return soc_sbx_g2p3_generic_sequence_delete(unit,
                    SOC_SBX_G2P3_OAMSEQ_ID,
                    policer);
}

/*
 * Diag shell constant value print
 */
int soc_sbx_g2p3_constant_shell_print(int unit, int cid);
int
soc_sbx_g2p3_constant_shell_print(int unit, int cid)
{
    uint32 v;
    int rv = SOC_E_INTERNAL;

    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;

    switch (cid) {
    case SOC_SBX_G2P3_MAX_PORTS_ID:
        rv = soc_sbx_g2p3_max_ports_get(unit, &v); break;
    case SOC_SBX_G2P3_IPV4_VRF_BITS_ID:
        rv = soc_sbx_g2p3_ipv4_vrf_bits_get(unit, &v); break;
    case SOC_SBX_G2P3_EXC_IP_CHECKSUM_IDX_ID:
        rv = soc_sbx_g2p3_exc_ip_checksum_idx_get(unit, &v); break;
    case SOC_SBX_G2P3_EXC_STP_BLOCKED_IDX_ID:
        rv = soc_sbx_g2p3_exc_stp_blocked_idx_get(unit, &v); break;
    case SOC_SBX_G2P3_EXC_SMAC_DROP_IDX_ID:
        rv = soc_sbx_g2p3_exc_smac_drop_idx_get(unit, &v); break;
    case SOC_SBX_G2P3_EXC_SMAC_UNKNOWN_IDX_ID:
        rv = soc_sbx_g2p3_exc_smac_unknown_idx_get(unit, &v); break;
    case SOC_SBX_G2P3_EXC_MAC_HAIRPIN_IDX_ID:
        rv = soc_sbx_g2p3_exc_mac_hairpin_idx_get(unit, &v); break;
    case SOC_SBX_G2P3_EXC_DMAC_DROP_IDX_ID:
        rv = soc_sbx_g2p3_exc_dmac_drop_idx_get(unit, &v); break;
    case SOC_SBX_G2P3_EXC_TTL_EXPIRED_IDX_ID:
        rv = soc_sbx_g2p3_exc_ttl_expired_idx_get(unit, &v); break;
    case SOC_SBX_G2P3_EXC_EGR_STP_BLOCKED_IDX_ID:
        rv = soc_sbx_g2p3_exc_egr_stp_blocked_idx_get(unit, &v); break;
    case SOC_SBX_G2P3_EXC_SPLIT_IDX_ID:
        rv = soc_sbx_g2p3_exc_split_idx_get(unit, &v); break;
    case SOC_SBX_G2P3_EXC_MTU_IDX_ID:
        rv = soc_sbx_g2p3_exc_mtu_idx_get(unit, &v); break;
    case SOC_SBX_G2P3_EXC_OAM_MISMATCH_ID:
        rv = soc_sbx_g2p3_exc_oam_mismatch_get(unit, &v); break;
    case SOC_SBX_G2P3_EXC_OAM_LEARN_ID:
        rv = soc_sbx_g2p3_exc_oam_learn_get(unit, &v); break;
    case SOC_SBX_G2P3_EXC_OAM_NO_ENDPOINT_ID:
        rv = soc_sbx_g2p3_exc_oam_no_endpoint_get(unit, &v); break;
    case SOC_SBX_G2P3_EXC_OAM_TYPE_ID:
        rv = soc_sbx_g2p3_exc_oam_type_get(unit, &v); break;
    case SOC_SBX_G2P3_EXC_OAM_RDI_ID:
        rv = soc_sbx_g2p3_exc_oam_rdi_get(unit, &v); break;
    case SOC_SBX_G2P3_EXC_VLAN_DROP_IDX_ID:
        rv = soc_sbx_g2p3_exc_vlan_drop_idx_get(unit, &v); break;
    case SOC_SBX_G2P3_EXC_V4MC_RPF_CHECK_IDX_ID:
        rv = soc_sbx_g2p3_exc_v4mc_rpf_check_idx_get(unit, &v); break;
    case SOC_SBX_G2P3_EXC_URPF_DROP_IDX_ID:
        rv = soc_sbx_g2p3_exc_urpf_drop_idx_get(unit, &v); break;
    case SOC_SBX_G2P3_EXC_IP_SA_DROP_IDX_ID:
        rv = soc_sbx_g2p3_exc_ip_sa_drop_idx_get(unit, &v); break;
    case SOC_SBX_G2P3_EXC_MIM_BAD_FORMAT_IDX_ID:
        rv = soc_sbx_g2p3_exc_mim_bad_format_idx_get(unit, &v); break;
    case SOC_SBX_G2P3_EXC_ISID2E_MISS_IDX_ID:
        rv = soc_sbx_g2p3_exc_isid2e_miss_idx_get(unit, &v); break;
    case SOC_SBX_G2P3_EXC_OAM_THRESHOLD_EXCEEDED_ID:
        rv = soc_sbx_g2p3_exc_oam_threshold_exceeded_get(unit, &v); break;
    case SOC_SBX_G2P3_EXC_OAM_COPY_TO_HOST_ID:
        rv = soc_sbx_g2p3_exc_oam_copy_to_host_get(unit, &v); break;
    case SOC_SBX_G2P3_EXC_OAM_PARAM_CHANGE_ID:
        rv = soc_sbx_g2p3_exc_oam_param_change_get(unit, &v); break;
    case SOC_SBX_G2P3_EXC_BAD_OUTER_LABEL_IDX_ID:
        rv = soc_sbx_g2p3_exc_bad_outer_label_idx_get(unit, &v); break;
    case SOC_SBX_G2P3_EXC_BAD_INNER_LABEL_IDX_ID:
        rv = soc_sbx_g2p3_exc_bad_inner_label_idx_get(unit, &v); break;
    case SOC_SBX_G2P3_EXC_LSP_PING_IDX_ID:
        rv = soc_sbx_g2p3_exc_lsp_ping_idx_get(unit, &v); break;
    case SOC_SBX_G2P3_EXC_TOO_MANY_LABELS_IDX_ID:
        rv = soc_sbx_g2p3_exc_too_many_labels_idx_get(unit, &v); break;
    case SOC_SBX_G2P3_EXC_EGR_DROP_TAGGED_IDX_ID:
        rv = soc_sbx_g2p3_exc_egr_drop_tagged_idx_get(unit, &v); break;
    case SOC_SBX_G2P3_EXC_EGR_DROP_UNTAGGED_IDX_ID:
        rv = soc_sbx_g2p3_exc_egr_drop_untagged_idx_get(unit, &v); break;
    case SOC_SBX_G2P3_EXC_EGR_OAM_LINK_IDX_ID:
        rv = soc_sbx_g2p3_exc_egr_oam_link_idx_get(unit, &v); break;
    case SOC_SBX_G2P3_EXC_OAM_EP_INVALID_IDX_ID:
        rv = soc_sbx_g2p3_exc_oam_ep_invalid_idx_get(unit, &v); break;
    case SOC_SBX_G2P3_EXC_DCN_IDX_ID:
        rv = soc_sbx_g2p3_exc_dcn_idx_get(unit, &v); break;
    case SOC_SBX_G2P3_EXC_MPLS_FILTER_IDX_ID:
        rv = soc_sbx_g2p3_exc_mpls_filter_idx_get(unit, &v); break;
    case SOC_SBX_G2P3_EXC_MIN_FREE_EXCEPTION_ID:
        rv = soc_sbx_g2p3_exc_min_free_exception_get(unit, &v); break;
    case SOC_SBX_G2P3_MAX_FREE_EXCEPTION_ID:
        rv = soc_sbx_g2p3_max_free_exception_get(unit, &v); break;
    case SOC_SBX_G2P3_EXC_SMAC_LEARN_IDX_ID:
        rv = soc_sbx_g2p3_exc_smac_learn_idx_get(unit, &v); break;
    case SOC_SBX_G2P3_EXC_PIM_IDX_ID:
        rv = soc_sbx_g2p3_exc_pim_idx_get(unit, &v); break;
    case SOC_SBX_G2P3_EXC_IGMP_IDX_ID:
        rv = soc_sbx_g2p3_exc_igmp_idx_get(unit, &v); break;
    case SOC_SBX_G2P3_EXC_RT_COPY_IDX_ID:
        rv = soc_sbx_g2p3_exc_rt_copy_idx_get(unit, &v); break;
    case SOC_SBX_G2P3_EXC_L2CP_COPY_IDX_ID:
        rv = soc_sbx_g2p3_exc_l2cp_copy_idx_get(unit, &v); break;
    case SOC_SBX_G2P3_EXC_DMAC_COPY_IDX_ID:
        rv = soc_sbx_g2p3_exc_dmac_copy_idx_get(unit, &v); break;
    case SOC_SBX_G2P3_EXC_IPREDIRECT_IDX_ID:
        rv = soc_sbx_g2p3_exc_ipredirect_idx_get(unit, &v); break;
    case SOC_SBX_G2P3_EXC_BMAC_LEARN_IDX_ID:
        rv = soc_sbx_g2p3_exc_bmac_learn_idx_get(unit, &v); break;
    case SOC_SBX_G2P3_EXC_COPY_MAX_IDX_ID:
        rv = soc_sbx_g2p3_exc_copy_max_idx_get(unit, &v); break;
    case SOC_SBX_G2P3_HTYPE_ERH_ID:
        rv = soc_sbx_g2p3_htype_erh_get(unit, &v); break;
    case SOC_SBX_G2P3_HTYPE_ETYPE_ID:
        rv = soc_sbx_g2p3_htype_etype_get(unit, &v); break;
    case SOC_SBX_G2P3_HTYPE_ETH_ID:
        rv = soc_sbx_g2p3_htype_eth_get(unit, &v); break;
    case SOC_SBX_G2P3_HTYPE_IETH_ID:
        rv = soc_sbx_g2p3_htype_ieth_get(unit, &v); break;
    case SOC_SBX_G2P3_HTYPE_LLC_ID:
        rv = soc_sbx_g2p3_htype_llc_get(unit, &v); break;
    case SOC_SBX_G2P3_HTYPE_SNAP_ID:
        rv = soc_sbx_g2p3_htype_snap_get(unit, &v); break;
    case SOC_SBX_G2P3_HTYPE_VTAG_ID:
        rv = soc_sbx_g2p3_htype_vtag_get(unit, &v); break;
    case SOC_SBX_G2P3_HTYPE_DVTAG_ID:
        rv = soc_sbx_g2p3_htype_dvtag_get(unit, &v); break;
    case SOC_SBX_G2P3_HTYPE_MPLS_ID:
        rv = soc_sbx_g2p3_htype_mpls_get(unit, &v); break;
    case SOC_SBX_G2P3_HTYPE_IPV4_ID:
        rv = soc_sbx_g2p3_htype_ipv4_get(unit, &v); break;
    case SOC_SBX_G2P3_HTYPE_IPV6_ID:
        rv = soc_sbx_g2p3_htype_ipv6_get(unit, &v); break;
    case SOC_SBX_G2P3_HTYPE_ACH_ID:
        rv = soc_sbx_g2p3_htype_ach_get(unit, &v); break;
    case SOC_SBX_G2P3_HTYPE_MIM_ID:
        rv = soc_sbx_g2p3_htype_mim_get(unit, &v); break;
    case SOC_SBX_G2P3_HTYPE_ELEN_ID:
        rv = soc_sbx_g2p3_htype_elen_get(unit, &v); break;
    case SOC_SBX_G2P3_HTYPE_UNKN_ID:
        rv = soc_sbx_g2p3_htype_unkn_get(unit, &v); break;
    case SOC_SBX_G2P3_TRAP_OAMLABELPRESENT_ID:
        rv = soc_sbx_g2p3_trap_oamlabelpresent_get(unit, &v); break;
    case SOC_SBX_G2P3_TRAP_LINKLOOPBACK_ID:
        rv = soc_sbx_g2p3_trap_linkloopback_get(unit, &v); break;
    case SOC_SBX_G2P3_LSMAC_TABLE_SIZE_ID:
        rv = soc_sbx_g2p3_lsmac_table_size_get(unit, &v); break;
    case SOC_SBX_G2P3_L2CPMAC_TABLE_SIZE_ID:
        rv = soc_sbx_g2p3_l2cpmac_table_size_get(unit, &v); break;
    case SOC_SBX_G2P3_OAMUPMAC_TABLE_SIZE_ID:
        rv = soc_sbx_g2p3_oamupmac_table_size_get(unit, &v); break;
    case SOC_SBX_G2P3_OAMEPREMAP_C2_TABLE_SIZE_ID:
        rv = soc_sbx_g2p3_oamepremap_c2_table_size_get(unit, &v); break;
    case SOC_SBX_G2P3_OAMMULTIPLIER_C2_TABLE_SIZE_ID:
        rv = soc_sbx_g2p3_oammultiplier_c2_table_size_get(unit, &v); break;
    case SOC_SBX_G2P3_EGRCTR_CA_COUNTER_SIZE_ID:
        rv = soc_sbx_g2p3_egrctr_ca_counter_size_get(unit, &v); break;
    case SOC_SBX_G2P3_MAC_CA_TABLE_SIZE_ID:
        rv = soc_sbx_g2p3_mac_ca_table_size_get(unit, &v); break;
    case SOC_SBX_G2P3_PTYPE_UNKNOWN_UNICAST_ID:
        rv = soc_sbx_g2p3_ptype_unknown_unicast_get(unit, &v); break;
    case SOC_SBX_G2P3_PTYPE_KNOWN_UNICAST_ID:
        rv = soc_sbx_g2p3_ptype_known_unicast_get(unit, &v); break;
    case SOC_SBX_G2P3_PTYPE_MULTICAST_ID:
        rv = soc_sbx_g2p3_ptype_multicast_get(unit, &v); break;
    case SOC_SBX_G2P3_PTYPE_BROADCAST_ID:
        rv = soc_sbx_g2p3_ptype_broadcast_get(unit, &v); break;
    case SOC_SBX_G2P3_PTYPE_LAST_ID:
        rv = soc_sbx_g2p3_ptype_last_get(unit, &v); break;
    case SOC_SBX_G2P3_CUCKOO_TYPE_PVV_ID:
        rv = soc_sbx_g2p3_cuckoo_type_pvv_get(unit, &v); break;
    case SOC_SBX_G2P3_CUCKOO_TYPE_ISID_ID:
        rv = soc_sbx_g2p3_cuckoo_type_isid_get(unit, &v); break;
    case SOC_SBX_G2P3_CUCKOO_TYPE_PVD_ID:
        rv = soc_sbx_g2p3_cuckoo_type_pvd_get(unit, &v); break;
    case SOC_SBX_G2P3_CUCKOO_TYPE_MAIDMEP_ID:
        rv = soc_sbx_g2p3_cuckoo_type_maidmep_get(unit, &v); break;
    case SOC_SBX_G2P3_CUCKOO_TYPE_SHIFT_ID:
        rv = soc_sbx_g2p3_cuckoo_type_shift_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_EP_SUBTYPE_CCM_ID:
        rv = soc_sbx_g2p3_oam_ep_subtype_ccm_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_EP_SUBTYPE_LM_ID:
        rv = soc_sbx_g2p3_oam_ep_subtype_lm_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_EP_SUBTYPE_DM_ID:
        rv = soc_sbx_g2p3_oam_ep_subtype_dm_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_EP_SUBTYPE_SHIFT_ID:
        rv = soc_sbx_g2p3_oam_ep_subtype_shift_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_TYPE_INVALID_ID:
        rv = soc_sbx_g2p3_oam_type_invalid_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_TYPE_ENET_ID:
        rv = soc_sbx_g2p3_oam_type_enet_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_TYPE_MPLS_PWE_ID:
        rv = soc_sbx_g2p3_oam_type_mpls_pwe_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_TYPE_MPLS_LSP_ID:
        rv = soc_sbx_g2p3_oam_type_mpls_lsp_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_FUNCTION_UNUSED_ID:
        rv = soc_sbx_g2p3_oam_function_unused_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_FUNCTION_BFD_ID:
        rv = soc_sbx_g2p3_oam_function_bfd_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_FUNCTION_LM_ID:
        rv = soc_sbx_g2p3_oam_function_lm_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_FUNCTION_DM_ID:
        rv = soc_sbx_g2p3_oam_function_dm_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_FUNCTION_CCM_FIRST_ID:
        rv = soc_sbx_g2p3_oam_function_ccm_first_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_FUNCTION_CCM_SECOND_ID:
        rv = soc_sbx_g2p3_oam_function_ccm_second_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_FUNCTION_CCM_PEER_ID:
        rv = soc_sbx_g2p3_oam_function_ccm_peer_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_FUNCTION_PSC_ID:
        rv = soc_sbx_g2p3_oam_function_psc_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_FUNCTION_PM_ID:
        rv = soc_sbx_g2p3_oam_function_pm_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_FUNCTION_CCM_LOCAL_ID:
        rv = soc_sbx_g2p3_oam_function_ccm_local_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_NUM_ENDPOINTS_ID:
        rv = soc_sbx_g2p3_oam_num_endpoints_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_MAX_CALENDAR_ID:
        rv = soc_sbx_g2p3_oam_max_calendar_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_BUBBLE_TIMEOUT_ID:
        rv = soc_sbx_g2p3_oam_bubble_timeout_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_LIST_MGR_SIZE_ID:
        rv = soc_sbx_g2p3_oam_list_mgr_size_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_LIST_MGR_SIZE_CA_ID:
        rv = soc_sbx_g2p3_oam_list_mgr_size_ca_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_BUBBLE_TIMER_ADDR_ID:
        rv = soc_sbx_g2p3_oam_bubble_timer_addr_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_LIST_MGR_ADDR_ID:
        rv = soc_sbx_g2p3_oam_list_mgr_addr_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_INTERVAL1_ID:
        rv = soc_sbx_g2p3_oam_interval1_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_INTERVAL2_ID:
        rv = soc_sbx_g2p3_oam_interval2_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_INTERVAL3_ID:
        rv = soc_sbx_g2p3_oam_interval3_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_INTERVAL4_ID:
        rv = soc_sbx_g2p3_oam_interval4_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_INTERVAL5_ID:
        rv = soc_sbx_g2p3_oam_interval5_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_INTERVAL6_ID:
        rv = soc_sbx_g2p3_oam_interval6_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_INTERVAL7_ID:
        rv = soc_sbx_g2p3_oam_interval7_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_REMOTE_EP_BASE_ID:
        rv = soc_sbx_g2p3_oam_remote_ep_base_get(unit, &v); break;
    case SOC_SBX_G2P3_MAX_QOS_PROFILE_INDEX_ID:
        rv = soc_sbx_g2p3_max_qos_profile_index_get(unit, &v); break;
    case SOC_SBX_G2P3_MAX_QOS_MAP_TABLE_ID:
        rv = soc_sbx_g2p3_max_qos_map_table_get(unit, &v); break;
    case SOC_SBX_G2P3_MAX_QOS_REMARK_TABLE_ID:
        rv = soc_sbx_g2p3_max_qos_remark_table_get(unit, &v); break;
    case SOC_SBX_G2P3_MAX_L2CP_TYPES_ID:
        rv = soc_sbx_g2p3_max_l2cp_types_get(unit, &v); break;
    case SOC_SBX_G2P3_MAX_L2CP_SUBTYPES_ID:
        rv = soc_sbx_g2p3_max_l2cp_subtypes_get(unit, &v); break;
    case SOC_SBX_G2P3_URPF_DEFAULT_PID_ID:
        rv = soc_sbx_g2p3_urpf_default_pid_get(unit, &v); break;
    case SOC_SBX_G2P3_STPSTATE_FORWARD_ID:
        rv = soc_sbx_g2p3_stpstate_forward_get(unit, &v); break;
    case SOC_SBX_G2P3_STPSTATE_BLOCK_ID:
        rv = soc_sbx_g2p3_stpstate_block_get(unit, &v); break;
    case SOC_SBX_G2P3_STPSTATE_LEARN_ID:
        rv = soc_sbx_g2p3_stpstate_learn_get(unit, &v); break;
    case SOC_SBX_G2P3_MPLSTP_LOOPBACK_OAM_ID:
        rv = soc_sbx_g2p3_mplstp_loopback_oam_get(unit, &v); break;
    case SOC_SBX_G2P3_MPLSTP_LOOPBACK_FULL_ID:
        rv = soc_sbx_g2p3_mplstp_loopback_full_get(unit, &v); break;
    case SOC_SBX_G2P3_MPLSTP_LOOPBACK_NONE_ID:
        rv = soc_sbx_g2p3_mplstp_loopback_none_get(unit, &v); break;
    case SOC_SBX_G2P3_LABEL_LSR_ID:
        rv = soc_sbx_g2p3_label_lsr_get(unit, &v); break;
    case SOC_SBX_G2P3_LABEL_ETH_PWE3_ID:
        rv = soc_sbx_g2p3_label_eth_pwe3_get(unit, &v); break;
    case SOC_SBX_G2P3_LABEL_LER_ID:
        rv = soc_sbx_g2p3_label_ler_get(unit, &v); break;
    case SOC_SBX_G2P3_LABEL_CES_PWE3_ID:
        rv = soc_sbx_g2p3_label_ces_pwe3_get(unit, &v); break;
    }
    if (rv) {
        soc_cm_print("constant %s get timeout\n",
                tm->constants[cid].name);
        return rv;
    }

    soc_cm_print("%s=", tm->constants[cid].name);
    soc_sbx_g2p3_print(-1, v);
    soc_cm_print("\n");
    return SOC_E_NONE;
}

/*
 * Diag shell global value print
 */
int soc_sbx_g2p3_global_shell_print(int unit, int gid);
int
soc_sbx_g2p3_global_shell_print(int unit, int gid)
{
    uint32 v;
    int rv = SOC_E_INTERNAL;

    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;

    switch (gid) {
    case SOC_SBX_G2P3_CONTEXTS_ID:
        rv = soc_sbx_g2p3_contexts_get(unit, &v); break;
    case SOC_SBX_G2P3_TPID0_ID:
        rv = soc_sbx_g2p3_tpid0_get(unit, &v); break;
    case SOC_SBX_G2P3_TPID1_ID:
        rv = soc_sbx_g2p3_tpid1_get(unit, &v); break;
    case SOC_SBX_G2P3_TPID2_ID:
        rv = soc_sbx_g2p3_tpid2_get(unit, &v); break;
    case SOC_SBX_G2P3_DEFITAG_ID:
        rv = soc_sbx_g2p3_defitag_get(unit, &v); break;
    case SOC_SBX_G2P3_AGE_ID:
        rv = soc_sbx_g2p3_age_get(unit, &v); break;
    case SOC_SBX_G2P3_LABELCUCKOO_ABSEED_ID:
        rv = soc_sbx_g2p3_labelcuckoo_abseed_get(unit, &v); break;
    case SOC_SBX_G2P3_CUCKOO_ABSEED_ID:
        rv = soc_sbx_g2p3_cuckoo_abseed_get(unit, &v); break;
    case SOC_SBX_G2P3_NODE_ID:
        rv = soc_sbx_g2p3_node_get(unit, &v); break;
    case SOC_SBX_G2P3_VLAN_FT_BASE_ID:
        rv = soc_sbx_g2p3_vlan_ft_base_get(unit, &v); break;
    case SOC_SBX_G2P3_VPWS_VLAN_ID:
        rv = soc_sbx_g2p3_vpws_vlan_get(unit, &v); break;
    case SOC_SBX_G2P3_VPWS_FT_OFFSET_ID:
        rv = soc_sbx_g2p3_vpws_ft_offset_get(unit, &v); break;
    case SOC_SBX_G2P3_EEX_MIRROR0_ID:
        rv = soc_sbx_g2p3_eex_mirror0_get(unit, &v); break;
    case SOC_SBX_G2P3_EEX_MIRROR1_ID:
        rv = soc_sbx_g2p3_eex_mirror1_get(unit, &v); break;
    case SOC_SBX_G2P3_MAX_PIDS_ID:
        rv = soc_sbx_g2p3_max_pids_get(unit, &v); break;
    case SOC_SBX_G2P3_MC_FT_OFFSET_ID:
        rv = soc_sbx_g2p3_mc_ft_offset_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_DROP_BIT_ID:
        rv = soc_sbx_g2p3_oam_drop_bit_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_ENET_CONTINUE_BYTE_ID:
        rv = soc_sbx_g2p3_oam_enet_continue_byte_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_MPLS_CONTINUE_BYTE_ID:
        rv = soc_sbx_g2p3_oam_mpls_continue_byte_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_ENET_FRAME_LEN_ID:
        rv = soc_sbx_g2p3_oam_enet_frame_len_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_MPLS_FRAME_LEN_ID:
        rv = soc_sbx_g2p3_oam_mpls_frame_len_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_SOURCE_QUEUE_ID:
        rv = soc_sbx_g2p3_oam_source_queue_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_DEST_QUEUE_ID:
        rv = soc_sbx_g2p3_oam_dest_queue_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_SOURCE_BUFFER_ID:
        rv = soc_sbx_g2p3_oam_source_buffer_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_BUBBLE_TIMER_OFFSET_ID:
        rv = soc_sbx_g2p3_oam_bubble_timer_offset_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_SA_LM_ID:
        rv = soc_sbx_g2p3_oam_sa_lm_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_SA_DM_ID:
        rv = soc_sbx_g2p3_oam_sa_dm_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_MPLS_SA_LM_ID:
        rv = soc_sbx_g2p3_oam_mpls_sa_lm_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_MPLS_SA_DM_ID:
        rv = soc_sbx_g2p3_oam_mpls_sa_dm_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_PWE_IP_SA_ID:
        rv = soc_sbx_g2p3_oam_pwe_ip_sa_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_PWE_UDP_DEST_PORT_ID:
        rv = soc_sbx_g2p3_oam_pwe_udp_dest_port_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_MIRROR_INDEX_ID:
        rv = soc_sbx_g2p3_oam_mirror_index_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_LOOPBACK_QID_ID:
        rv = soc_sbx_g2p3_oam_loopback_qid_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_SA_4LO_ID:
        rv = soc_sbx_g2p3_oam_sa_4lo_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_SA_2HI_ID:
        rv = soc_sbx_g2p3_oam_sa_2hi_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_SA_4LO_AUX_ID:
        rv = soc_sbx_g2p3_oam_sa_4lo_aux_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_SA_2HI_AUX_ID:
        rv = soc_sbx_g2p3_oam_sa_2hi_aux_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_BFD_STATE_TABLE_ID:
        rv = soc_sbx_g2p3_oam_bfd_state_table_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_BFD_RDI_DIAG_CODE_ID:
        rv = soc_sbx_g2p3_oam_bfd_rdi_diag_code_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_TX_PACKETS_PER_BUBBLE_ID:
        rv = soc_sbx_g2p3_oam_tx_packets_per_bubble_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_TX_PACKETS_PER_BUBBLE_CA_ID:
        rv = soc_sbx_g2p3_oam_tx_packets_per_bubble_ca_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_PSC_RX_FILTER_ID:
        rv = soc_sbx_g2p3_oam_psc_rx_filter_get(unit, &v); break;
    case SOC_SBX_G2P3_OAM_LOCAL_FE_QID_ID:
        rv = soc_sbx_g2p3_oam_local_fe_qid_get(unit, &v); break;
    case SOC_SBX_G2P3_BLACKHOLE_VLAN_ID:
        rv = soc_sbx_g2p3_blackhole_vlan_get(unit, &v); break;
    case SOC_SBX_G2P3_IGMP_PROXY_MODE_ID:
        rv = soc_sbx_g2p3_igmp_proxy_mode_get(unit, &v); break;
    case SOC_SBX_G2P3_STATIC_LAG_ID:
        rv = soc_sbx_g2p3_static_lag_get(unit, &v); break;
    case SOC_SBX_G2P3_IPV4_CHECKSUM_MODE_ID:
        rv = soc_sbx_g2p3_ipv4_checksum_mode_get(unit, &v); break;
    case SOC_SBX_G2P3_EXIT_FILTER_ON_BTAG_ID:
        rv = soc_sbx_g2p3_exit_filter_on_btag_get(unit, &v); break;
    case SOC_SBX_G2P3_SWITCH_METER_ADJUST_ID:
        rv = soc_sbx_g2p3_switch_meter_adjust_get(unit, &v); break;
    case SOC_SBX_G2P3_RC1_RULE_STARTIDX_ID:
        rv = soc_sbx_g2p3_rc1_rule_startidx_get(unit, &v); break;
    case SOC_SBX_G2P3_IPV6_ACL_ENABLE_ID:
        rv = soc_sbx_g2p3_ipv6_acl_enable_get(unit, &v); break;
    case SOC_SBX_G2P3_OI2EOFF_ID:
        rv = soc_sbx_g2p3_oi2eoff_get(unit, &v); break;
    case SOC_SBX_G2P3_ETE0PLUS1_ID:
        rv = soc_sbx_g2p3_ete0plus1_get(unit, &v); break;
    case SOC_SBX_G2P3_ETE1PLUS1_ID:
        rv = soc_sbx_g2p3_ete1plus1_get(unit, &v); break;
    }
    if (rv) {
        soc_cm_print("global %s get timeout\n",
                tm->globals[gid].name);
        return rv;
    }

    soc_cm_print("%s=", tm->globals[gid].name);
    soc_sbx_g2p3_print(tm->globals[gid].range, v);
    soc_cm_print("\n");
    return SOC_E_NONE;
}


/*
 * Diag shell global value set
 */
int soc_sbx_g2p3_global_shell_set(int unit,
             int gid, int argc, char **argv);
int
soc_sbx_g2p3_global_shell_set(int unit, 
         int gid, int argc, char **argv)
{
    int rv;
    uint32 v;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;

    if (argc == 0) {
        soc_cm_print("missing value\n");
        return SOC_E_PARAM;
    }
    rv = soc_sbx_g2p3_read(argv[0], tm->globals[gid].range, &v);
    if (rv) {
        soc_cm_print("illegal value '%s'\n", argv[0]);
        return SOC_E_PARAM;
    }
    switch (gid) {
    case SOC_SBX_G2P3_CONTEXTS_ID:
        rv = soc_sbx_g2p3_contexts_set(unit, v); break;
    case SOC_SBX_G2P3_TPID0_ID:
        rv = soc_sbx_g2p3_tpid0_set(unit, v); break;
    case SOC_SBX_G2P3_TPID1_ID:
        rv = soc_sbx_g2p3_tpid1_set(unit, v); break;
    case SOC_SBX_G2P3_TPID2_ID:
        rv = soc_sbx_g2p3_tpid2_set(unit, v); break;
    case SOC_SBX_G2P3_DEFITAG_ID:
        rv = soc_sbx_g2p3_defitag_set(unit, v); break;
    case SOC_SBX_G2P3_AGE_ID:
        rv = soc_sbx_g2p3_age_set(unit, v); break;
    case SOC_SBX_G2P3_LABELCUCKOO_ABSEED_ID:
        rv = soc_sbx_g2p3_labelcuckoo_abseed_set(unit, v); break;
    case SOC_SBX_G2P3_CUCKOO_ABSEED_ID:
        rv = soc_sbx_g2p3_cuckoo_abseed_set(unit, v); break;
    case SOC_SBX_G2P3_NODE_ID:
        rv = soc_sbx_g2p3_node_set(unit, v); break;
    case SOC_SBX_G2P3_VLAN_FT_BASE_ID:
        rv = soc_sbx_g2p3_vlan_ft_base_set(unit, v); break;
    case SOC_SBX_G2P3_VPWS_VLAN_ID:
        rv = soc_sbx_g2p3_vpws_vlan_set(unit, v); break;
    case SOC_SBX_G2P3_VPWS_FT_OFFSET_ID:
        rv = soc_sbx_g2p3_vpws_ft_offset_set(unit, v); break;
    case SOC_SBX_G2P3_EEX_MIRROR0_ID:
        rv = soc_sbx_g2p3_eex_mirror0_set(unit, v); break;
    case SOC_SBX_G2P3_EEX_MIRROR1_ID:
        rv = soc_sbx_g2p3_eex_mirror1_set(unit, v); break;
    case SOC_SBX_G2P3_MAX_PIDS_ID:
        rv = soc_sbx_g2p3_max_pids_set(unit, v); break;
    case SOC_SBX_G2P3_MC_FT_OFFSET_ID:
        rv = soc_sbx_g2p3_mc_ft_offset_set(unit, v); break;
    case SOC_SBX_G2P3_OAM_DROP_BIT_ID:
        rv = soc_sbx_g2p3_oam_drop_bit_set(unit, v); break;
    case SOC_SBX_G2P3_OAM_ENET_CONTINUE_BYTE_ID:
        rv = soc_sbx_g2p3_oam_enet_continue_byte_set(unit, v); break;
    case SOC_SBX_G2P3_OAM_MPLS_CONTINUE_BYTE_ID:
        rv = soc_sbx_g2p3_oam_mpls_continue_byte_set(unit, v); break;
    case SOC_SBX_G2P3_OAM_ENET_FRAME_LEN_ID:
        rv = soc_sbx_g2p3_oam_enet_frame_len_set(unit, v); break;
    case SOC_SBX_G2P3_OAM_MPLS_FRAME_LEN_ID:
        rv = soc_sbx_g2p3_oam_mpls_frame_len_set(unit, v); break;
    case SOC_SBX_G2P3_OAM_SOURCE_QUEUE_ID:
        rv = soc_sbx_g2p3_oam_source_queue_set(unit, v); break;
    case SOC_SBX_G2P3_OAM_DEST_QUEUE_ID:
        rv = soc_sbx_g2p3_oam_dest_queue_set(unit, v); break;
    case SOC_SBX_G2P3_OAM_SOURCE_BUFFER_ID:
        rv = soc_sbx_g2p3_oam_source_buffer_set(unit, v); break;
    case SOC_SBX_G2P3_OAM_BUBBLE_TIMER_OFFSET_ID:
        rv = soc_sbx_g2p3_oam_bubble_timer_offset_set(unit, v); break;
    case SOC_SBX_G2P3_OAM_SA_LM_ID:
        rv = soc_sbx_g2p3_oam_sa_lm_set(unit, v); break;
    case SOC_SBX_G2P3_OAM_SA_DM_ID:
        rv = soc_sbx_g2p3_oam_sa_dm_set(unit, v); break;
    case SOC_SBX_G2P3_OAM_MPLS_SA_LM_ID:
        rv = soc_sbx_g2p3_oam_mpls_sa_lm_set(unit, v); break;
    case SOC_SBX_G2P3_OAM_MPLS_SA_DM_ID:
        rv = soc_sbx_g2p3_oam_mpls_sa_dm_set(unit, v); break;
    case SOC_SBX_G2P3_OAM_PWE_IP_SA_ID:
        rv = soc_sbx_g2p3_oam_pwe_ip_sa_set(unit, v); break;
    case SOC_SBX_G2P3_OAM_PWE_UDP_DEST_PORT_ID:
        rv = soc_sbx_g2p3_oam_pwe_udp_dest_port_set(unit, v); break;
    case SOC_SBX_G2P3_OAM_MIRROR_INDEX_ID:
        rv = soc_sbx_g2p3_oam_mirror_index_set(unit, v); break;
    case SOC_SBX_G2P3_OAM_LOOPBACK_QID_ID:
        rv = soc_sbx_g2p3_oam_loopback_qid_set(unit, v); break;
    case SOC_SBX_G2P3_OAM_SA_4LO_ID:
        rv = soc_sbx_g2p3_oam_sa_4lo_set(unit, v); break;
    case SOC_SBX_G2P3_OAM_SA_2HI_ID:
        rv = soc_sbx_g2p3_oam_sa_2hi_set(unit, v); break;
    case SOC_SBX_G2P3_OAM_SA_4LO_AUX_ID:
        rv = soc_sbx_g2p3_oam_sa_4lo_aux_set(unit, v); break;
    case SOC_SBX_G2P3_OAM_SA_2HI_AUX_ID:
        rv = soc_sbx_g2p3_oam_sa_2hi_aux_set(unit, v); break;
    case SOC_SBX_G2P3_OAM_BFD_STATE_TABLE_ID:
        rv = soc_sbx_g2p3_oam_bfd_state_table_set(unit, v); break;
    case SOC_SBX_G2P3_OAM_BFD_RDI_DIAG_CODE_ID:
        rv = soc_sbx_g2p3_oam_bfd_rdi_diag_code_set(unit, v); break;
    case SOC_SBX_G2P3_OAM_TX_PACKETS_PER_BUBBLE_ID:
        rv = soc_sbx_g2p3_oam_tx_packets_per_bubble_set(unit, v); break;
    case SOC_SBX_G2P3_OAM_TX_PACKETS_PER_BUBBLE_CA_ID:
        rv = soc_sbx_g2p3_oam_tx_packets_per_bubble_ca_set(unit, v); break;
    case SOC_SBX_G2P3_OAM_PSC_RX_FILTER_ID:
        rv = soc_sbx_g2p3_oam_psc_rx_filter_set(unit, v); break;
    case SOC_SBX_G2P3_OAM_LOCAL_FE_QID_ID:
        rv = soc_sbx_g2p3_oam_local_fe_qid_set(unit, v); break;
    case SOC_SBX_G2P3_BLACKHOLE_VLAN_ID:
        rv = soc_sbx_g2p3_blackhole_vlan_set(unit, v); break;
    case SOC_SBX_G2P3_IGMP_PROXY_MODE_ID:
        rv = soc_sbx_g2p3_igmp_proxy_mode_set(unit, v); break;
    case SOC_SBX_G2P3_STATIC_LAG_ID:
        rv = soc_sbx_g2p3_static_lag_set(unit, v); break;
    case SOC_SBX_G2P3_IPV4_CHECKSUM_MODE_ID:
        rv = soc_sbx_g2p3_ipv4_checksum_mode_set(unit, v); break;
    case SOC_SBX_G2P3_EXIT_FILTER_ON_BTAG_ID:
        rv = soc_sbx_g2p3_exit_filter_on_btag_set(unit, v); break;
    case SOC_SBX_G2P3_SWITCH_METER_ADJUST_ID:
        rv = soc_sbx_g2p3_switch_meter_adjust_set(unit, v); break;
    case SOC_SBX_G2P3_RC1_RULE_STARTIDX_ID:
        rv = soc_sbx_g2p3_rc1_rule_startidx_set(unit, v); break;
    case SOC_SBX_G2P3_IPV6_ACL_ENABLE_ID:
        rv = soc_sbx_g2p3_ipv6_acl_enable_set(unit, v); break;
    case SOC_SBX_G2P3_OI2EOFF_ID:
        rv = soc_sbx_g2p3_oi2eoff_set(unit, v); break;
    case SOC_SBX_G2P3_ETE0PLUS1_ID:
        rv = soc_sbx_g2p3_ete0plus1_set(unit, v); break;
    case SOC_SBX_G2P3_ETE1PLUS1_ID:
        rv = soc_sbx_g2p3_ete1plus1_set(unit, v); break;
    }
    if (rv) {
        soc_cm_print("global %s set timeout\n",
                tm->globals[gid].name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for p2e */
void soc_sbx_g2p3_p2e_print(int unit, 
    soc_sbx_g2p3_p2e_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2E_ID];

    int j, digits;
    uint8 *s;
    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->port; w = 4;  break;
        case 1: v = e->nativevid; w = 9;  break;
        case 2: v = e->defcfi; w = 6;  break;
        case 3: v = e->defpri; w = 6;  break;
        case 4: v = e->defstrip; w = 8;  break;
        case 5: v = e->pstrip; w = 6;  break;
        case 6: v = e->mim; w = 3;  break;
        case 7: v = e->mplstp; w = 6;  break;
        case 8: s = e->mask; w = 4; goto bigfield;
        case 9: v = e->customer; w = 8;  break;
        case 10: v = e->provider; w = 8;  break;
        case 11: v = e->oamloop; w = 7;  break;
        case 12: v = e->stpid1; w = 6;  break;
        case 13: v = e->twintpid; w = 8;  break;
        case 14: v = e->pbb; w = 3;  break;
        case 15: v = e->ipv4mc; w = 6;  break;
        case 16: v = e->state; w = 5;  break;
        case 17: v = e->pport; w = 5;  break;
        case 18: v = e->htype; w = 5;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
        continue;

    bigfield:
        digits = (width + 7) / 8;
        if ((col + w + 1 + 5 * digits) > 72) {
            soc_cm_print("\n  ");
            col=2;
        }
        soc_cm_print("%s=", fd->name);
        col += w + 1;
        for (j = 0; j < digits; j++) {
            soc_cm_print("0x%02x ", s[digits - j - 1]);
            col += 5;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for p2e */
int soc_sbx_g2p3_p2e_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_p2e_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_p2e_t e0;
    soc_sbx_g2p3_p2e_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2E_ID];
    int iport;
    void *indexpointers[1];

    indexpointers[0] = &iport;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_p2e_get(unit,
                iport,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_p2e_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for p2e */
int soc_sbx_g2p3_p2e_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_p2e_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_p2e_t e0;
    soc_sbx_g2p3_p2e_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2E_ID];
    int iport;
    void *indexpointers[1];

    indexpointers[0] = &iport;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_p2e_t_init(e);

    rv = soc_sbx_g2p3_p2e_get(unit,
                iport,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->port,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->nativevid,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->defcfi,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->defpri,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2p3_value_read(&e->defstrip,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g2p3_value_read(&e->pstrip,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g2p3_value_read(&e->mim,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g2p3_value_read(&e->mplstp,
                                ed->fields[7].range, 0, argc, argv);
                 break;
        case 8: rv = soc_sbx_g2p3_big_value_read(e->mask,
                                ed->fields[8].width, 0, argc, argv);
                 break;
        case 9: rv = soc_sbx_g2p3_value_read(&e->customer,
                                ed->fields[9].range, 0, argc, argv);
                 break;
        case 10: rv = soc_sbx_g2p3_value_read(&e->provider,
                                ed->fields[10].range, 0, argc, argv);
                 break;
        case 11: rv = soc_sbx_g2p3_value_read(&e->oamloop,
                                ed->fields[11].range, 0, argc, argv);
                 break;
        case 12: rv = soc_sbx_g2p3_value_read(&e->stpid1,
                                ed->fields[12].range, 0, argc, argv);
                 break;
        case 13: rv = soc_sbx_g2p3_value_read(&e->twintpid,
                                ed->fields[13].range, 0, argc, argv);
                 break;
        case 14: rv = soc_sbx_g2p3_value_read(&e->pbb,
                                ed->fields[14].range, 0, argc, argv);
                 break;
        case 15: rv = soc_sbx_g2p3_value_read(&e->ipv4mc,
                                ed->fields[15].range, 0, argc, argv);
                 break;
        case 16: rv = soc_sbx_g2p3_value_read(&e->state,
                                ed->fields[16].range, 0, argc, argv);
                 break;
        case 17: rv = soc_sbx_g2p3_value_read(&e->pport,
                                ed->fields[17].range, 0, argc, argv);
                 break;
        case 18: rv = soc_sbx_g2p3_value_read(&e->htype,
                                ed->fields[18].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_p2e_set(unit,
                iport,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for ep2e */
void soc_sbx_g2p3_ep2e_print(int unit, 
    soc_sbx_g2p3_ep2e_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EP2E_ID];

    int j, digits;
    uint8 *s;
    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->mim; w = 3;  break;
        case 1: v = e->pid; w = 3;  break;
        case 2: v = e->stpid0; w = 6;  break;
        case 3: v = e->stpid1; w = 6;  break;
        case 4: v = e->customer; w = 8;  break;
        case 5: v = e->keeperh; w = 7;  break;
        case 6: v = e->port; w = 4;  break;
        case 7: v = e->mirroridx; w = 9;  break;
        case 8: s = e->mask; w = 4; goto bigfield;
        case 9: v = e->oamloop; w = 7;  break;
        case 10: v = e->pbb; w = 3;  break;
        case 11: v = e->state; w = 5;  break;
        case 12: v = e->htype; w = 5;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
        continue;

    bigfield:
        digits = (width + 7) / 8;
        if ((col + w + 1 + 5 * digits) > 72) {
            soc_cm_print("\n  ");
            col=2;
        }
        soc_cm_print("%s=", fd->name);
        col += w + 1;
        for (j = 0; j < digits; j++) {
            soc_cm_print("0x%02x ", s[digits - j - 1]);
            col += 5;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ep2e */
int soc_sbx_g2p3_ep2e_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ep2e_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ep2e_t e0;
    soc_sbx_g2p3_ep2e_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EP2E_ID];
    int iport;
    void *indexpointers[1];

    indexpointers[0] = &iport;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ep2e_get(unit,
                iport,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ep2e_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ep2e */
int soc_sbx_g2p3_ep2e_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ep2e_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ep2e_t e0;
    soc_sbx_g2p3_ep2e_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EP2E_ID];
    int iport;
    void *indexpointers[1];

    indexpointers[0] = &iport;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ep2e_t_init(e);

    rv = soc_sbx_g2p3_ep2e_get(unit,
                iport,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->mim,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->pid,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->stpid0,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->stpid1,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2p3_value_read(&e->customer,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g2p3_value_read(&e->keeperh,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g2p3_value_read(&e->port,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g2p3_value_read(&e->mirroridx,
                                ed->fields[7].range, 0, argc, argv);
                 break;
        case 8: rv = soc_sbx_g2p3_big_value_read(e->mask,
                                ed->fields[8].width, 0, argc, argv);
                 break;
        case 9: rv = soc_sbx_g2p3_value_read(&e->oamloop,
                                ed->fields[9].range, 0, argc, argv);
                 break;
        case 10: rv = soc_sbx_g2p3_value_read(&e->pbb,
                                ed->fields[10].range, 0, argc, argv);
                 break;
        case 11: rv = soc_sbx_g2p3_value_read(&e->state,
                                ed->fields[11].range, 0, argc, argv);
                 break;
        case 12: rv = soc_sbx_g2p3_value_read(&e->htype,
                                ed->fields[12].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ep2e_set(unit,
                iport,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for p2e20 */
void soc_sbx_g2p3_p2e20_print(int unit, 
    soc_sbx_g2p3_p2e20_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2E20_ID];

    int j, digits;
    uint8 *s;
    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->port; w = 4;  break;
        case 1: v = e->nativevid; w = 9;  break;
        case 2: v = e->defcfi; w = 6;  break;
        case 3: v = e->defpri; w = 6;  break;
        case 4: v = e->defstrip; w = 8;  break;
        case 5: v = e->pstrip; w = 6;  break;
        case 6: v = e->mim; w = 3;  break;
        case 7: v = e->mplstp; w = 6;  break;
        case 8: s = e->mask; w = 4; goto bigfield;
        case 9: v = e->customer; w = 8;  break;
        case 10: v = e->provider; w = 8;  break;
        case 11: v = e->oamloop; w = 7;  break;
        case 12: v = e->stpid1; w = 6;  break;
        case 13: v = e->twintpid; w = 8;  break;
        case 14: v = e->pbb; w = 3;  break;
        case 15: v = e->ipv4mc; w = 6;  break;
        case 16: v = e->state; w = 5;  break;
        case 17: v = e->pport; w = 5;  break;
        case 18: v = e->htype; w = 5;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
        continue;

    bigfield:
        digits = (width + 7) / 8;
        if ((col + w + 1 + 5 * digits) > 72) {
            soc_cm_print("\n  ");
            col=2;
        }
        soc_cm_print("%s=", fd->name);
        col += w + 1;
        for (j = 0; j < digits; j++) {
            soc_cm_print("0x%02x ", s[digits - j - 1]);
            col += 5;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for p2e20 */
int soc_sbx_g2p3_p2e20_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_p2e20_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_p2e20_t e0;
    soc_sbx_g2p3_p2e20_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2E20_ID];
    int iport;
    void *indexpointers[1];

    indexpointers[0] = &iport;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_p2e20_get(unit,
                iport,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_p2e20_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for p2e20 */
int soc_sbx_g2p3_p2e20_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_p2e20_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_p2e20_t e0;
    soc_sbx_g2p3_p2e20_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2E20_ID];
    int iport;
    void *indexpointers[1];

    indexpointers[0] = &iport;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_p2e20_t_init(e);

    rv = soc_sbx_g2p3_p2e20_get(unit,
                iport,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->port,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->nativevid,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->defcfi,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->defpri,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2p3_value_read(&e->defstrip,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g2p3_value_read(&e->pstrip,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g2p3_value_read(&e->mim,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g2p3_value_read(&e->mplstp,
                                ed->fields[7].range, 0, argc, argv);
                 break;
        case 8: rv = soc_sbx_g2p3_big_value_read(e->mask,
                                ed->fields[8].width, 0, argc, argv);
                 break;
        case 9: rv = soc_sbx_g2p3_value_read(&e->customer,
                                ed->fields[9].range, 0, argc, argv);
                 break;
        case 10: rv = soc_sbx_g2p3_value_read(&e->provider,
                                ed->fields[10].range, 0, argc, argv);
                 break;
        case 11: rv = soc_sbx_g2p3_value_read(&e->oamloop,
                                ed->fields[11].range, 0, argc, argv);
                 break;
        case 12: rv = soc_sbx_g2p3_value_read(&e->stpid1,
                                ed->fields[12].range, 0, argc, argv);
                 break;
        case 13: rv = soc_sbx_g2p3_value_read(&e->twintpid,
                                ed->fields[13].range, 0, argc, argv);
                 break;
        case 14: rv = soc_sbx_g2p3_value_read(&e->pbb,
                                ed->fields[14].range, 0, argc, argv);
                 break;
        case 15: rv = soc_sbx_g2p3_value_read(&e->ipv4mc,
                                ed->fields[15].range, 0, argc, argv);
                 break;
        case 16: rv = soc_sbx_g2p3_value_read(&e->state,
                                ed->fields[16].range, 0, argc, argv);
                 break;
        case 17: rv = soc_sbx_g2p3_value_read(&e->pport,
                                ed->fields[17].range, 0, argc, argv);
                 break;
        case 18: rv = soc_sbx_g2p3_value_read(&e->htype,
                                ed->fields[18].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_p2e20_set(unit,
                iport,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for ep2e20 */
void soc_sbx_g2p3_ep2e20_print(int unit, 
    soc_sbx_g2p3_ep2e20_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EP2E20_ID];

    int j, digits;
    uint8 *s;
    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->mim; w = 3;  break;
        case 1: v = e->pid; w = 3;  break;
        case 2: v = e->stpid0; w = 6;  break;
        case 3: v = e->stpid1; w = 6;  break;
        case 4: v = e->customer; w = 8;  break;
        case 5: v = e->keeperh; w = 7;  break;
        case 6: v = e->port; w = 4;  break;
        case 7: v = e->mirroridx; w = 9;  break;
        case 8: s = e->mask; w = 4; goto bigfield;
        case 9: v = e->oamloop; w = 7;  break;
        case 10: v = e->pbb; w = 3;  break;
        case 11: v = e->state; w = 5;  break;
        case 12: v = e->htype; w = 5;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
        continue;

    bigfield:
        digits = (width + 7) / 8;
        if ((col + w + 1 + 5 * digits) > 72) {
            soc_cm_print("\n  ");
            col=2;
        }
        soc_cm_print("%s=", fd->name);
        col += w + 1;
        for (j = 0; j < digits; j++) {
            soc_cm_print("0x%02x ", s[digits - j - 1]);
            col += 5;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ep2e20 */
int soc_sbx_g2p3_ep2e20_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ep2e20_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ep2e20_t e0;
    soc_sbx_g2p3_ep2e20_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EP2E20_ID];
    int iport;
    void *indexpointers[1];

    indexpointers[0] = &iport;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ep2e20_get(unit,
                iport,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ep2e20_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ep2e20 */
int soc_sbx_g2p3_ep2e20_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ep2e20_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ep2e20_t e0;
    soc_sbx_g2p3_ep2e20_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EP2E20_ID];
    int iport;
    void *indexpointers[1];

    indexpointers[0] = &iport;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ep2e20_t_init(e);

    rv = soc_sbx_g2p3_ep2e20_get(unit,
                iport,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->mim,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->pid,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->stpid0,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->stpid1,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2p3_value_read(&e->customer,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g2p3_value_read(&e->keeperh,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g2p3_value_read(&e->port,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g2p3_value_read(&e->mirroridx,
                                ed->fields[7].range, 0, argc, argv);
                 break;
        case 8: rv = soc_sbx_g2p3_big_value_read(e->mask,
                                ed->fields[8].width, 0, argc, argv);
                 break;
        case 9: rv = soc_sbx_g2p3_value_read(&e->oamloop,
                                ed->fields[9].range, 0, argc, argv);
                 break;
        case 10: rv = soc_sbx_g2p3_value_read(&e->pbb,
                                ed->fields[10].range, 0, argc, argv);
                 break;
        case 11: rv = soc_sbx_g2p3_value_read(&e->state,
                                ed->fields[11].range, 0, argc, argv);
                 break;
        case 12: rv = soc_sbx_g2p3_value_read(&e->htype,
                                ed->fields[12].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ep2e20_set(unit,
                iport,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for p2e25 */
void soc_sbx_g2p3_p2e25_print(int unit, 
    soc_sbx_g2p3_p2e25_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2E25_ID];

    int j, digits;
    uint8 *s;
    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->port; w = 4;  break;
        case 1: v = e->nativevid; w = 9;  break;
        case 2: v = e->defcfi; w = 6;  break;
        case 3: v = e->defpri; w = 6;  break;
        case 4: v = e->defstrip; w = 8;  break;
        case 5: v = e->pstrip; w = 6;  break;
        case 6: v = e->mim; w = 3;  break;
        case 7: v = e->mplstp; w = 6;  break;
        case 8: s = e->mask; w = 4; goto bigfield;
        case 9: v = e->customer; w = 8;  break;
        case 10: v = e->provider; w = 8;  break;
        case 11: v = e->oamloop; w = 7;  break;
        case 12: v = e->stpid1; w = 6;  break;
        case 13: v = e->twintpid; w = 8;  break;
        case 14: v = e->pbb; w = 3;  break;
        case 15: v = e->ipv4mc; w = 6;  break;
        case 16: v = e->state; w = 5;  break;
        case 17: v = e->pport; w = 5;  break;
        case 18: v = e->htype; w = 5;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
        continue;

    bigfield:
        digits = (width + 7) / 8;
        if ((col + w + 1 + 5 * digits) > 72) {
            soc_cm_print("\n  ");
            col=2;
        }
        soc_cm_print("%s=", fd->name);
        col += w + 1;
        for (j = 0; j < digits; j++) {
            soc_cm_print("0x%02x ", s[digits - j - 1]);
            col += 5;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for p2e25 */
int soc_sbx_g2p3_p2e25_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_p2e25_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_p2e25_t e0;
    soc_sbx_g2p3_p2e25_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2E25_ID];
    int iport;
    void *indexpointers[1];

    indexpointers[0] = &iport;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_p2e25_get(unit,
                iport,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_p2e25_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for p2e25 */
int soc_sbx_g2p3_p2e25_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_p2e25_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_p2e25_t e0;
    soc_sbx_g2p3_p2e25_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2E25_ID];
    int iport;
    void *indexpointers[1];

    indexpointers[0] = &iport;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_p2e25_t_init(e);

    rv = soc_sbx_g2p3_p2e25_get(unit,
                iport,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->port,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->nativevid,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->defcfi,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->defpri,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2p3_value_read(&e->defstrip,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g2p3_value_read(&e->pstrip,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g2p3_value_read(&e->mim,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g2p3_value_read(&e->mplstp,
                                ed->fields[7].range, 0, argc, argv);
                 break;
        case 8: rv = soc_sbx_g2p3_big_value_read(e->mask,
                                ed->fields[8].width, 0, argc, argv);
                 break;
        case 9: rv = soc_sbx_g2p3_value_read(&e->customer,
                                ed->fields[9].range, 0, argc, argv);
                 break;
        case 10: rv = soc_sbx_g2p3_value_read(&e->provider,
                                ed->fields[10].range, 0, argc, argv);
                 break;
        case 11: rv = soc_sbx_g2p3_value_read(&e->oamloop,
                                ed->fields[11].range, 0, argc, argv);
                 break;
        case 12: rv = soc_sbx_g2p3_value_read(&e->stpid1,
                                ed->fields[12].range, 0, argc, argv);
                 break;
        case 13: rv = soc_sbx_g2p3_value_read(&e->twintpid,
                                ed->fields[13].range, 0, argc, argv);
                 break;
        case 14: rv = soc_sbx_g2p3_value_read(&e->pbb,
                                ed->fields[14].range, 0, argc, argv);
                 break;
        case 15: rv = soc_sbx_g2p3_value_read(&e->ipv4mc,
                                ed->fields[15].range, 0, argc, argv);
                 break;
        case 16: rv = soc_sbx_g2p3_value_read(&e->state,
                                ed->fields[16].range, 0, argc, argv);
                 break;
        case 17: rv = soc_sbx_g2p3_value_read(&e->pport,
                                ed->fields[17].range, 0, argc, argv);
                 break;
        case 18: rv = soc_sbx_g2p3_value_read(&e->htype,
                                ed->fields[18].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_p2e25_set(unit,
                iport,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for ep2e25 */
void soc_sbx_g2p3_ep2e25_print(int unit, 
    soc_sbx_g2p3_ep2e25_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EP2E25_ID];

    int j, digits;
    uint8 *s;
    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->mim; w = 3;  break;
        case 1: v = e->pid; w = 3;  break;
        case 2: v = e->stpid0; w = 6;  break;
        case 3: v = e->stpid1; w = 6;  break;
        case 4: v = e->customer; w = 8;  break;
        case 5: v = e->keeperh; w = 7;  break;
        case 6: v = e->port; w = 4;  break;
        case 7: v = e->mirroridx; w = 9;  break;
        case 8: s = e->mask; w = 4; goto bigfield;
        case 9: v = e->oamloop; w = 7;  break;
        case 10: v = e->pbb; w = 3;  break;
        case 11: v = e->state; w = 5;  break;
        case 12: v = e->htype; w = 5;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
        continue;

    bigfield:
        digits = (width + 7) / 8;
        if ((col + w + 1 + 5 * digits) > 72) {
            soc_cm_print("\n  ");
            col=2;
        }
        soc_cm_print("%s=", fd->name);
        col += w + 1;
        for (j = 0; j < digits; j++) {
            soc_cm_print("0x%02x ", s[digits - j - 1]);
            col += 5;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ep2e25 */
int soc_sbx_g2p3_ep2e25_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ep2e25_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ep2e25_t e0;
    soc_sbx_g2p3_ep2e25_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EP2E25_ID];
    int iport;
    void *indexpointers[1];

    indexpointers[0] = &iport;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ep2e25_get(unit,
                iport,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ep2e25_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ep2e25 */
int soc_sbx_g2p3_ep2e25_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ep2e25_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ep2e25_t e0;
    soc_sbx_g2p3_ep2e25_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EP2E25_ID];
    int iport;
    void *indexpointers[1];

    indexpointers[0] = &iport;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ep2e25_t_init(e);

    rv = soc_sbx_g2p3_ep2e25_get(unit,
                iport,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->mim,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->pid,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->stpid0,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->stpid1,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2p3_value_read(&e->customer,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g2p3_value_read(&e->keeperh,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g2p3_value_read(&e->port,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g2p3_value_read(&e->mirroridx,
                                ed->fields[7].range, 0, argc, argv);
                 break;
        case 8: rv = soc_sbx_g2p3_big_value_read(e->mask,
                                ed->fields[8].width, 0, argc, argv);
                 break;
        case 9: rv = soc_sbx_g2p3_value_read(&e->oamloop,
                                ed->fields[9].range, 0, argc, argv);
                 break;
        case 10: rv = soc_sbx_g2p3_value_read(&e->pbb,
                                ed->fields[10].range, 0, argc, argv);
                 break;
        case 11: rv = soc_sbx_g2p3_value_read(&e->state,
                                ed->fields[11].range, 0, argc, argv);
                 break;
        case 12: rv = soc_sbx_g2p3_value_read(&e->htype,
                                ed->fields[12].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ep2e25_set(unit,
                iport,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for tpid */
void soc_sbx_g2p3_tpid_print(int unit, 
    soc_sbx_g2p3_tpid_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_TPID_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->tpid; w = 4;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for tpid */
int soc_sbx_g2p3_tpid_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_tpid_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_tpid_t e0;
    soc_sbx_g2p3_tpid_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_TPID_ID];
    int itpidi;
    void *indexpointers[1];

    indexpointers[0] = &itpidi;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_tpid_get(unit,
                itpidi,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_tpid_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for tpid */
int soc_sbx_g2p3_tpid_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_tpid_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_tpid_t e0;
    soc_sbx_g2p3_tpid_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_TPID_ID];
    int itpidi;
    void *indexpointers[1];

    indexpointers[0] = &itpidi;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_tpid_t_init(e);

    rv = soc_sbx_g2p3_tpid_get(unit,
                itpidi,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->tpid,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_tpid_set(unit,
                itpidi,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for oam_rx */
void soc_sbx_g2p3_oam_rx_print(int unit, 
    soc_sbx_g2p3_oam_rx_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAM_RX_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->valid; w = 5;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for oam_rx */
int soc_sbx_g2p3_oam_rx_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_oam_rx_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_oam_rx_t e0;
    soc_sbx_g2p3_oam_rx_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAM_RX_ID];
    int irule;
    void *indexpointers[1];

    indexpointers[0] = &irule;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_oam_rx_get(unit,
                irule,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_oam_rx_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for oam_rx */
int soc_sbx_g2p3_oam_rx_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_oam_rx_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_oam_rx_t e0;
    soc_sbx_g2p3_oam_rx_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAM_RX_ID];
    int irule;
    void *indexpointers[1];

    indexpointers[0] = &irule;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_oam_rx_t_init(e);

    rv = soc_sbx_g2p3_oam_rx_get(unit,
                irule,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->valid,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_oam_rx_set(unit,
                irule,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for oam_tx */
void soc_sbx_g2p3_oam_tx_print(int unit, 
    soc_sbx_g2p3_oam_tx_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAM_TX_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->valid; w = 5;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for oam_tx */
int soc_sbx_g2p3_oam_tx_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_oam_tx_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_oam_tx_t e0;
    soc_sbx_g2p3_oam_tx_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAM_TX_ID];
    int irule;
    void *indexpointers[1];

    indexpointers[0] = &irule;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_oam_tx_get(unit,
                irule,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_oam_tx_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for oam_tx */
int soc_sbx_g2p3_oam_tx_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_oam_tx_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_oam_tx_t e0;
    soc_sbx_g2p3_oam_tx_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAM_TX_ID];
    int irule;
    void *indexpointers[1];

    indexpointers[0] = &irule;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_oam_tx_t_init(e);

    rv = soc_sbx_g2p3_oam_tx_get(unit,
                irule,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->valid,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_oam_tx_set(unit,
                irule,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for lsmac */
void soc_sbx_g2p3_lsmac_print(int unit, 
    soc_sbx_g2p3_lsmac_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LSMAC_ID];

    int j, digits;
    uint8 *s;
    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->port; w = 4;  break;
        case 1: v = e->useport; w = 7;  break;
        case 2: s = e->mac; w = 3; goto bigfield;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
        continue;

    bigfield:
        digits = (width + 7) / 8;
        if ((col + w + 1 + 5 * digits) > 72) {
            soc_cm_print("\n  ");
            col=2;
        }
        soc_cm_print("%s=", fd->name);
        col += w + 1;
        for (j = 0; j < digits; j++) {
            soc_cm_print("0x%02x ", s[digits - j - 1]);
            col += 5;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for lsmac */
int soc_sbx_g2p3_lsmac_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_lsmac_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_lsmac_t e0;
    soc_sbx_g2p3_lsmac_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LSMAC_ID];
    int ilsi;
    void *indexpointers[1];

    indexpointers[0] = &ilsi;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_lsmac_get(unit,
                ilsi,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_lsmac_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for lsmac */
int soc_sbx_g2p3_lsmac_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_lsmac_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_lsmac_t e0;
    soc_sbx_g2p3_lsmac_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LSMAC_ID];
    int ilsi;
    void *indexpointers[1];

    indexpointers[0] = &ilsi;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_lsmac_t_init(e);

    rv = soc_sbx_g2p3_lsmac_get(unit,
                ilsi,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->port,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->useport,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_big_value_read(e->mac,
                                ed->fields[2].width, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_lsmac_set(unit,
                ilsi,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for l2cpmac */
void soc_sbx_g2p3_l2cpmac_print(int unit, 
    soc_sbx_g2p3_l2cpmac_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2CPMAC_ID];

    int j, digits;
    uint8 *s;
    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->port; w = 4;  break;
        case 1: v = e->useport; w = 7;  break;
        case 2: s = e->mac; w = 3; goto bigfield;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
        continue;

    bigfield:
        digits = (width + 7) / 8;
        if ((col + w + 1 + 5 * digits) > 72) {
            soc_cm_print("\n  ");
            col=2;
        }
        soc_cm_print("%s=", fd->name);
        col += w + 1;
        for (j = 0; j < digits; j++) {
            soc_cm_print("0x%02x ", s[digits - j - 1]);
            col += 5;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for l2cpmac */
int soc_sbx_g2p3_l2cpmac_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_l2cpmac_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_l2cpmac_t e0;
    soc_sbx_g2p3_l2cpmac_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2CPMAC_ID];
    int ilsi;
    void *indexpointers[1];

    indexpointers[0] = &ilsi;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_l2cpmac_get(unit,
                ilsi,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_l2cpmac_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for l2cpmac */
int soc_sbx_g2p3_l2cpmac_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_l2cpmac_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_l2cpmac_t e0;
    soc_sbx_g2p3_l2cpmac_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2CPMAC_ID];
    int ilsi;
    void *indexpointers[1];

    indexpointers[0] = &ilsi;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_l2cpmac_t_init(e);

    rv = soc_sbx_g2p3_l2cpmac_get(unit,
                ilsi,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->port,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->useport,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_big_value_read(e->mac,
                                ed->fields[2].width, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_l2cpmac_set(unit,
                ilsi,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for oamupmac */
void soc_sbx_g2p3_oamupmac_print(int unit, 
    soc_sbx_g2p3_oamupmac_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMUPMAC_ID];

    int j, digits;
    uint8 *s;
    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: s = e->mac; w = 3; goto bigfield;
        case 1: s = e->mask; w = 4; goto bigfield;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
        continue;

    bigfield:
        digits = (width + 7) / 8;
        if ((col + w + 1 + 5 * digits) > 72) {
            soc_cm_print("\n  ");
            col=2;
        }
        soc_cm_print("%s=", fd->name);
        col += w + 1;
        for (j = 0; j < digits; j++) {
            soc_cm_print("0x%02x ", s[digits - j - 1]);
            col += 5;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for oamupmac */
int soc_sbx_g2p3_oamupmac_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_oamupmac_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_oamupmac_t e0;
    soc_sbx_g2p3_oamupmac_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMUPMAC_ID];
    int ilsi;
    void *indexpointers[1];

    indexpointers[0] = &ilsi;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_oamupmac_get(unit,
                ilsi,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_oamupmac_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for oamupmac */
int soc_sbx_g2p3_oamupmac_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_oamupmac_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_oamupmac_t e0;
    soc_sbx_g2p3_oamupmac_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMUPMAC_ID];
    int ilsi;
    void *indexpointers[1];

    indexpointers[0] = &ilsi;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_oamupmac_t_init(e);

    rv = soc_sbx_g2p3_oamupmac_get(unit,
                ilsi,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_big_value_read(e->mac,
                                ed->fields[0].width, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_big_value_read(e->mask,
                                ed->fields[1].width, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_oamupmac_set(unit,
                ilsi,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for qos */
void soc_sbx_g2p3_qos_print(int unit, 
    soc_sbx_g2p3_qos_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_QOS_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->e; w = 1;  break;
        case 1: v = e->dp; w = 2;  break;
        case 2: v = e->cos; w = 3;  break;
        case 3: v = e->fcos; w = 4;  break;
        case 4: v = e->mefcos; w = 6;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for qos */
int soc_sbx_g2p3_qos_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_qos_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_qos_t e0;
    soc_sbx_g2p3_qos_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_QOS_ID];
    int ide;
    int ipri;
    int iprof;
    void *indexpointers[3];

    indexpointers[0] = &ide;
    indexpointers[1] = &ipri;
    indexpointers[2] = &iprof;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_qos_get(unit,
                ide,
                ipri,
                iprof,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_qos_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for qos */
int soc_sbx_g2p3_qos_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_qos_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_qos_t e0;
    soc_sbx_g2p3_qos_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_QOS_ID];
    int ide;
    int ipri;
    int iprof;
    void *indexpointers[3];

    indexpointers[0] = &ide;
    indexpointers[1] = &ipri;
    indexpointers[2] = &iprof;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_qos_t_init(e);

    rv = soc_sbx_g2p3_qos_get(unit,
                ide,
                ipri,
                iprof,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->e,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->dp,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->cos,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->fcos,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2p3_value_read(&e->mefcos,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_qos_set(unit,
                ide,
                ipri,
                iprof,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for dscp_qos */
void soc_sbx_g2p3_dscp_qos_print(int unit, 
    soc_sbx_g2p3_dscp_qos_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_DSCP_QOS_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->e; w = 1;  break;
        case 1: v = e->dp; w = 2;  break;
        case 2: v = e->cos; w = 3;  break;
        case 3: v = e->fcos; w = 4;  break;
        case 4: v = e->mefcos; w = 6;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for dscp_qos */
int soc_sbx_g2p3_dscp_qos_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_dscp_qos_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_dscp_qos_t e0;
    soc_sbx_g2p3_dscp_qos_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_DSCP_QOS_ID];
    int idscp;
    int iprof;
    void *indexpointers[2];

    indexpointers[0] = &idscp;
    indexpointers[1] = &iprof;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_dscp_qos_get(unit,
                idscp,
                iprof,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_dscp_qos_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for dscp_qos */
int soc_sbx_g2p3_dscp_qos_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_dscp_qos_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_dscp_qos_t e0;
    soc_sbx_g2p3_dscp_qos_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_DSCP_QOS_ID];
    int idscp;
    int iprof;
    void *indexpointers[2];

    indexpointers[0] = &idscp;
    indexpointers[1] = &iprof;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_dscp_qos_t_init(e);

    rv = soc_sbx_g2p3_dscp_qos_get(unit,
                idscp,
                iprof,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->e,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->dp,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->cos,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->fcos,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2p3_value_read(&e->mefcos,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_dscp_qos_set(unit,
                idscp,
                iprof,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for irt */
void soc_sbx_g2p3_irt_print(int unit, 
    soc_sbx_g2p3_irt_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IRT_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->vlan; w = 4;  break;
        case 1: v = e->ftidx; w = 5;  break;
        case 2: v = e->mirror; w = 6;  break;
        case 3: v = e->usevlan; w = 7;  break;
        case 4: v = e->useftidx; w = 8;  break;
        case 5: v = e->copy; w = 4;  break;
        case 6: v = e->dp; w = 2;  break;
        case 7: v = e->cos; w = 3;  break;
        case 8: v = e->fcos; w = 4;  break;
        case 9: v = e->usedp; w = 5;  break;
        case 10: v = e->usecos; w = 6;  break;
        case 11: v = e->policer; w = 7;  break;
        case 12: v = e->typedpolice; w = 11;  break;
        case 13: v = e->mefcos; w = 6;  break;
        case 14: v = e->mef; w = 3;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for irt */
int soc_sbx_g2p3_irt_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_irt_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_irt_t e0;
    soc_sbx_g2p3_irt_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IRT_ID];
    int irule;
    void *indexpointers[1];

    indexpointers[0] = &irule;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_irt_get(unit,
                irule,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_irt_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for irt */
int soc_sbx_g2p3_irt_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_irt_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_irt_t e0;
    soc_sbx_g2p3_irt_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IRT_ID];
    int irule;
    void *indexpointers[1];

    indexpointers[0] = &irule;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_irt_t_init(e);

    rv = soc_sbx_g2p3_irt_get(unit,
                irule,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->vlan,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->ftidx,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->mirror,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->usevlan,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2p3_value_read(&e->useftidx,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g2p3_value_read(&e->copy,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g2p3_value_read(&e->dp,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g2p3_value_read(&e->cos,
                                ed->fields[7].range, 0, argc, argv);
                 break;
        case 8: rv = soc_sbx_g2p3_value_read(&e->fcos,
                                ed->fields[8].range, 0, argc, argv);
                 break;
        case 9: rv = soc_sbx_g2p3_value_read(&e->usedp,
                                ed->fields[9].range, 0, argc, argv);
                 break;
        case 10: rv = soc_sbx_g2p3_value_read(&e->usecos,
                                ed->fields[10].range, 0, argc, argv);
                 break;
        case 11: rv = soc_sbx_g2p3_value_read(&e->policer,
                                ed->fields[11].range, 0, argc, argv);
                 break;
        case 12: rv = soc_sbx_g2p3_value_read(&e->typedpolice,
                                ed->fields[12].range, 0, argc, argv);
                 break;
        case 13: rv = soc_sbx_g2p3_value_read(&e->mefcos,
                                ed->fields[13].range, 0, argc, argv);
                 break;
        case 14: rv = soc_sbx_g2p3_value_read(&e->mef,
                                ed->fields[14].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_irt_set(unit,
                irule,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for irt_wrap */
void soc_sbx_g2p3_irt_wrap_print(int unit, 
    soc_sbx_g2p3_irt_wrap_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IRT_WRAP_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->vlan; w = 4;  break;
        case 1: v = e->ftidx; w = 5;  break;
        case 2: v = e->mirror; w = 6;  break;
        case 3: v = e->usevlan; w = 7;  break;
        case 4: v = e->useftidx; w = 8;  break;
        case 5: v = e->copy; w = 4;  break;
        case 6: v = e->dp; w = 2;  break;
        case 7: v = e->cos; w = 3;  break;
        case 8: v = e->fcos; w = 4;  break;
        case 9: v = e->usedp; w = 5;  break;
        case 10: v = e->usecos; w = 6;  break;
        case 11: v = e->policer; w = 7;  break;
        case 12: v = e->typedpolice; w = 11;  break;
        case 13: v = e->mefcos; w = 6;  break;
        case 14: v = e->mef; w = 3;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for irt_wrap */
int soc_sbx_g2p3_irt_wrap_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_irt_wrap_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_irt_wrap_t e0;
    soc_sbx_g2p3_irt_wrap_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IRT_WRAP_ID];
    int irule;
    void *indexpointers[1];

    indexpointers[0] = &irule;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_irt_wrap_get(unit,
                irule,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_irt_wrap_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for irt_wrap */
int soc_sbx_g2p3_irt_wrap_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_irt_wrap_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_irt_wrap_t e0;
    soc_sbx_g2p3_irt_wrap_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IRT_WRAP_ID];
    int irule;
    void *indexpointers[1];

    indexpointers[0] = &irule;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_irt_wrap_t_init(e);

    rv = soc_sbx_g2p3_irt_wrap_get(unit,
                irule,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->vlan,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->ftidx,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->mirror,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->usevlan,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2p3_value_read(&e->useftidx,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g2p3_value_read(&e->copy,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g2p3_value_read(&e->dp,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g2p3_value_read(&e->cos,
                                ed->fields[7].range, 0, argc, argv);
                 break;
        case 8: rv = soc_sbx_g2p3_value_read(&e->fcos,
                                ed->fields[8].range, 0, argc, argv);
                 break;
        case 9: rv = soc_sbx_g2p3_value_read(&e->usedp,
                                ed->fields[9].range, 0, argc, argv);
                 break;
        case 10: rv = soc_sbx_g2p3_value_read(&e->usecos,
                                ed->fields[10].range, 0, argc, argv);
                 break;
        case 11: rv = soc_sbx_g2p3_value_read(&e->policer,
                                ed->fields[11].range, 0, argc, argv);
                 break;
        case 12: rv = soc_sbx_g2p3_value_read(&e->typedpolice,
                                ed->fields[12].range, 0, argc, argv);
                 break;
        case 13: rv = soc_sbx_g2p3_value_read(&e->mefcos,
                                ed->fields[13].range, 0, argc, argv);
                 break;
        case 14: rv = soc_sbx_g2p3_value_read(&e->mef,
                                ed->fields[14].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_irt_wrap_set(unit,
                irule,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for rt_mt */
void soc_sbx_g2p3_rt_mt_print(int unit, 
    soc_sbx_g2p3_rt_mt_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RT_MT_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->policer; w = 7;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for rt_mt */
int soc_sbx_g2p3_rt_mt_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_rt_mt_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_rt_mt_t e0;
    soc_sbx_g2p3_rt_mt_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RT_MT_ID];
    int irule;
    void *indexpointers[1];

    indexpointers[0] = &irule;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_rt_mt_get(unit,
                irule,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_rt_mt_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for rt_mt */
int soc_sbx_g2p3_rt_mt_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_rt_mt_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_rt_mt_t e0;
    soc_sbx_g2p3_rt_mt_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RT_MT_ID];
    int irule;
    void *indexpointers[1];

    indexpointers[0] = &irule;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_rt_mt_t_init(e);

    rv = soc_sbx_g2p3_rt_mt_get(unit,
                irule,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->policer,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_rt_mt_set(unit,
                irule,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for rt_rr0 */
void soc_sbx_g2p3_rt_rr0_print(int unit, 
    soc_sbx_g2p3_rt_rr0_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RT_RR0_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->resv; w = 4;  break;
        case 1: v = e->usevlan; w = 7;  break;
        case 2: v = e->useftidx; w = 8;  break;
        case 3: v = e->vlan; w = 4;  break;
        case 4: v = e->ftidx; w = 5;  break;
        case 5: v = e->copy; w = 4;  break;
        case 6: v = e->dp; w = 2;  break;
        case 7: v = e->usedp; w = 5;  break;
        case 8: v = e->mirror; w = 6;  break;
        case 9: v = e->typedpolice; w = 11;  break;
        case 10: v = e->mefcos; w = 6;  break;
        case 11: v = e->mef; w = 3;  break;
        case 12: v = e->cos; w = 3;  break;
        case 13: v = e->fcos; w = 4;  break;
        case 14: v = e->usecos; w = 6;  break;
        case 15: v = e->emirror; w = 7;  break;
        case 16: v = e->drop; w = 4;  break;
        case 17: v = e->rtidx; w = 5;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for rt_rr0 */
int soc_sbx_g2p3_rt_rr0_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_rt_rr0_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_rt_rr0_t e0;
    soc_sbx_g2p3_rt_rr0_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RT_RR0_ID];
    int irule;
    void *indexpointers[1];

    indexpointers[0] = &irule;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_rt_rr0_get(unit,
                irule,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_rt_rr0_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for rt_rr0 */
int soc_sbx_g2p3_rt_rr0_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_rt_rr0_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_rt_rr0_t e0;
    soc_sbx_g2p3_rt_rr0_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RT_RR0_ID];
    int irule;
    void *indexpointers[1];

    indexpointers[0] = &irule;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_rt_rr0_t_init(e);

    rv = soc_sbx_g2p3_rt_rr0_get(unit,
                irule,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->resv,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->usevlan,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->useftidx,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->vlan,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2p3_value_read(&e->ftidx,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g2p3_value_read(&e->copy,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g2p3_value_read(&e->dp,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g2p3_value_read(&e->usedp,
                                ed->fields[7].range, 0, argc, argv);
                 break;
        case 8: rv = soc_sbx_g2p3_value_read(&e->mirror,
                                ed->fields[8].range, 0, argc, argv);
                 break;
        case 9: rv = soc_sbx_g2p3_value_read(&e->typedpolice,
                                ed->fields[9].range, 0, argc, argv);
                 break;
        case 10: rv = soc_sbx_g2p3_value_read(&e->mefcos,
                                ed->fields[10].range, 0, argc, argv);
                 break;
        case 11: rv = soc_sbx_g2p3_value_read(&e->mef,
                                ed->fields[11].range, 0, argc, argv);
                 break;
        case 12: rv = soc_sbx_g2p3_value_read(&e->cos,
                                ed->fields[12].range, 0, argc, argv);
                 break;
        case 13: rv = soc_sbx_g2p3_value_read(&e->fcos,
                                ed->fields[13].range, 0, argc, argv);
                 break;
        case 14: rv = soc_sbx_g2p3_value_read(&e->usecos,
                                ed->fields[14].range, 0, argc, argv);
                 break;
        case 15: rv = soc_sbx_g2p3_value_read(&e->emirror,
                                ed->fields[15].range, 0, argc, argv);
                 break;
        case 16: rv = soc_sbx_g2p3_value_read(&e->drop,
                                ed->fields[16].range, 0, argc, argv);
                 break;
        case 17: rv = soc_sbx_g2p3_value_read(&e->rtidx,
                                ed->fields[17].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_rt_rr0_set(unit,
                irule,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for rt_rr1 */
void soc_sbx_g2p3_rt_rr1_print(int unit, 
    soc_sbx_g2p3_rt_rr1_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RT_RR1_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->resv; w = 4;  break;
        case 1: v = e->usevlan; w = 7;  break;
        case 2: v = e->useftidx; w = 8;  break;
        case 3: v = e->vlan; w = 4;  break;
        case 4: v = e->ftidx; w = 5;  break;
        case 5: v = e->copy; w = 4;  break;
        case 6: v = e->dp; w = 2;  break;
        case 7: v = e->usedp; w = 5;  break;
        case 8: v = e->mirror; w = 6;  break;
        case 9: v = e->typedpolice; w = 11;  break;
        case 10: v = e->mefcos; w = 6;  break;
        case 11: v = e->mef; w = 3;  break;
        case 12: v = e->cos; w = 3;  break;
        case 13: v = e->fcos; w = 4;  break;
        case 14: v = e->usecos; w = 6;  break;
        case 15: v = e->emirror; w = 7;  break;
        case 16: v = e->drop; w = 4;  break;
        case 17: v = e->rtidx; w = 5;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for rt_rr1 */
int soc_sbx_g2p3_rt_rr1_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_rt_rr1_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_rt_rr1_t e0;
    soc_sbx_g2p3_rt_rr1_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RT_RR1_ID];
    int irule;
    void *indexpointers[1];

    indexpointers[0] = &irule;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_rt_rr1_get(unit,
                irule,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_rt_rr1_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for rt_rr1 */
int soc_sbx_g2p3_rt_rr1_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_rt_rr1_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_rt_rr1_t e0;
    soc_sbx_g2p3_rt_rr1_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RT_RR1_ID];
    int irule;
    void *indexpointers[1];

    indexpointers[0] = &irule;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_rt_rr1_t_init(e);

    rv = soc_sbx_g2p3_rt_rr1_get(unit,
                irule,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->resv,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->usevlan,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->useftidx,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->vlan,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2p3_value_read(&e->ftidx,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g2p3_value_read(&e->copy,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g2p3_value_read(&e->dp,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g2p3_value_read(&e->usedp,
                                ed->fields[7].range, 0, argc, argv);
                 break;
        case 8: rv = soc_sbx_g2p3_value_read(&e->mirror,
                                ed->fields[8].range, 0, argc, argv);
                 break;
        case 9: rv = soc_sbx_g2p3_value_read(&e->typedpolice,
                                ed->fields[9].range, 0, argc, argv);
                 break;
        case 10: rv = soc_sbx_g2p3_value_read(&e->mefcos,
                                ed->fields[10].range, 0, argc, argv);
                 break;
        case 11: rv = soc_sbx_g2p3_value_read(&e->mef,
                                ed->fields[11].range, 0, argc, argv);
                 break;
        case 12: rv = soc_sbx_g2p3_value_read(&e->cos,
                                ed->fields[12].range, 0, argc, argv);
                 break;
        case 13: rv = soc_sbx_g2p3_value_read(&e->fcos,
                                ed->fields[13].range, 0, argc, argv);
                 break;
        case 14: rv = soc_sbx_g2p3_value_read(&e->usecos,
                                ed->fields[14].range, 0, argc, argv);
                 break;
        case 15: rv = soc_sbx_g2p3_value_read(&e->emirror,
                                ed->fields[15].range, 0, argc, argv);
                 break;
        case 16: rv = soc_sbx_g2p3_value_read(&e->drop,
                                ed->fields[16].range, 0, argc, argv);
                 break;
        case 17: rv = soc_sbx_g2p3_value_read(&e->rtidx,
                                ed->fields[17].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_rt_rr1_set(unit,
                irule,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for lag */
void soc_sbx_g2p3_lag_print(int unit, 
    soc_sbx_g2p3_lag_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LAG_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->qid; w = 3;  break;
        case 1: v = e->oi; w = 2;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for lag */
int soc_sbx_g2p3_lag_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_lag_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_lag_t e0;
    soc_sbx_g2p3_lag_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LAG_ID];
    int ilagi;
    void *indexpointers[1];

    indexpointers[0] = &ilagi;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_lag_get(unit,
                ilagi,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_lag_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for lag */
int soc_sbx_g2p3_lag_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_lag_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_lag_t e0;
    soc_sbx_g2p3_lag_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LAG_ID];
    int ilagi;
    void *indexpointers[1];

    indexpointers[0] = &ilagi;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_lag_t_init(e);

    rv = soc_sbx_g2p3_lag_get(unit,
                ilagi,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->qid,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->oi,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_lag_set(unit,
                ilagi,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for rr */
void soc_sbx_g2p3_rr_print(int unit, 
    soc_sbx_g2p3_rr_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RR_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->backup; w = 6;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for rr */
int soc_sbx_g2p3_rr_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_rr_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_rr_t e0;
    soc_sbx_g2p3_rr_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RR_ID];
    int irri;
    void *indexpointers[1];

    indexpointers[0] = &irri;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_rr_get(unit,
                irri,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_rr_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for rr */
int soc_sbx_g2p3_rr_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_rr_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_rr_t e0;
    soc_sbx_g2p3_rr_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RR_ID];
    int irri;
    void *indexpointers[1];

    indexpointers[0] = &irri;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_rr_t_init(e);

    rv = soc_sbx_g2p3_rr_get(unit,
                irri,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->backup,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_rr_set(unit,
                irri,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for xt */
void soc_sbx_g2p3_xt_print(int unit, 
    soc_sbx_g2p3_xt_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_XT_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->forward; w = 7;  break;
        case 1: v = e->dp; w = 2;  break;
        case 2: v = e->qid; w = 3;  break;
        case 3: v = e->trunc; w = 5;  break;
        case 4: v = e->learn; w = 5;  break;
        case 5: v = e->ppspolice; w = 9;  break;
        case 6: v = e->policer; w = 7;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for xt */
int soc_sbx_g2p3_xt_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_xt_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_xt_t e0;
    soc_sbx_g2p3_xt_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_XT_ID];
    int ixi;
    void *indexpointers[1];

    indexpointers[0] = &ixi;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_xt_get(unit,
                ixi,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_xt_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for xt */
int soc_sbx_g2p3_xt_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_xt_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_xt_t e0;
    soc_sbx_g2p3_xt_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_XT_ID];
    int ixi;
    void *indexpointers[1];

    indexpointers[0] = &ixi;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_xt_t_init(e);

    rv = soc_sbx_g2p3_xt_get(unit,
                ixi,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->forward,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->dp,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->qid,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->trunc,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2p3_value_read(&e->learn,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g2p3_value_read(&e->ppspolice,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g2p3_value_read(&e->policer,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_xt_set(unit,
                ixi,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for mirror */
void soc_sbx_g2p3_mirror_print(int unit, 
    soc_sbx_g2p3_mirror_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MIRROR_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->yellow; w = 6;  break;
        case 1: v = e->qid; w = 3;  break;
        case 2: v = e->oi; w = 2;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for mirror */
int soc_sbx_g2p3_mirror_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_mirror_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_mirror_t e0;
    soc_sbx_g2p3_mirror_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MIRROR_ID];
    int imi;
    void *indexpointers[1];

    indexpointers[0] = &imi;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_mirror_get(unit,
                imi,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_mirror_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for mirror */
int soc_sbx_g2p3_mirror_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_mirror_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_mirror_t e0;
    soc_sbx_g2p3_mirror_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MIRROR_ID];
    int imi;
    void *indexpointers[1];

    indexpointers[0] = &imi;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_mirror_t_init(e);

    rv = soc_sbx_g2p3_mirror_get(unit,
                imi,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->yellow,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->qid,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->oi,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_mirror_set(unit,
                imi,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for emirror */
void soc_sbx_g2p3_emirror_print(int unit, 
    soc_sbx_g2p3_emirror_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EMIRROR_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->local; w = 5;  break;
        case 1: v = e->port; w = 4;  break;
        case 2: v = e->qid; w = 3;  break;
        case 3: v = e->oi; w = 2;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for emirror */
int soc_sbx_g2p3_emirror_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_emirror_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_emirror_t e0;
    soc_sbx_g2p3_emirror_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EMIRROR_ID];
    int imirror;
    void *indexpointers[1];

    indexpointers[0] = &imirror;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_emirror_get(unit,
                imirror,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_emirror_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for emirror */
int soc_sbx_g2p3_emirror_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_emirror_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_emirror_t e0;
    soc_sbx_g2p3_emirror_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EMIRROR_ID];
    int imirror;
    void *indexpointers[1];

    indexpointers[0] = &imirror;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_emirror_t_init(e);

    rv = soc_sbx_g2p3_emirror_get(unit,
                imirror,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->local,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->port,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->qid,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->oi,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_emirror_set(unit,
                imirror,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for emirror20 */
void soc_sbx_g2p3_emirror20_print(int unit, 
    soc_sbx_g2p3_emirror20_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EMIRROR20_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->queue; w = 5;  break;
        case 1: v = e->hdrpresent; w = 10;  break;
        case 2: v = e->dropsrcpkt; w = 10;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for emirror20 */
int soc_sbx_g2p3_emirror20_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_emirror20_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_emirror20_t e0;
    soc_sbx_g2p3_emirror20_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EMIRROR20_ID];
    int imirror;
    void *indexpointers[1];

    indexpointers[0] = &imirror;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_emirror20_get(unit,
                imirror,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_emirror20_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for emirror20 */
int soc_sbx_g2p3_emirror20_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_emirror20_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_emirror20_t e0;
    soc_sbx_g2p3_emirror20_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EMIRROR20_ID];
    int imirror;
    void *indexpointers[1];

    indexpointers[0] = &imirror;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_emirror20_t_init(e);

    rv = soc_sbx_g2p3_emirror20_get(unit,
                imirror,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->queue,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->hdrpresent,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->dropsrcpkt,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_emirror20_set(unit,
                imirror,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for emirror25 */
void soc_sbx_g2p3_emirror25_print(int unit, 
    soc_sbx_g2p3_emirror25_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EMIRROR25_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->queue; w = 5;  break;
        case 1: v = e->hdrpresent; w = 10;  break;
        case 2: v = e->dropsrcpkt; w = 10;  break;
        case 3: v = e->higighdr; w = 8;  break;
        case 4: v = e->overwritehdr; w = 12;  break;
        case 5: v = e->hdrdata0; w = 8;  break;
        case 6: v = e->hdrdata1; w = 8;  break;
        case 7: v = e->hdrdata2; w = 8;  break;
        case 8: v = e->hdrdata3; w = 8;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for emirror25 */
int soc_sbx_g2p3_emirror25_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_emirror25_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_emirror25_t e0;
    soc_sbx_g2p3_emirror25_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EMIRROR25_ID];
    int imirror;
    void *indexpointers[1];

    indexpointers[0] = &imirror;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_emirror25_get(unit,
                imirror,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_emirror25_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for emirror25 */
int soc_sbx_g2p3_emirror25_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_emirror25_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_emirror25_t e0;
    soc_sbx_g2p3_emirror25_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EMIRROR25_ID];
    int imirror;
    void *indexpointers[1];

    indexpointers[0] = &imirror;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_emirror25_t_init(e);

    rv = soc_sbx_g2p3_emirror25_get(unit,
                imirror,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->queue,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->hdrpresent,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->dropsrcpkt,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->higighdr,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2p3_value_read(&e->overwritehdr,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g2p3_value_read(&e->hdrdata0,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g2p3_value_read(&e->hdrdata1,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g2p3_value_read(&e->hdrdata2,
                                ed->fields[7].range, 0, argc, argv);
                 break;
        case 8: rv = soc_sbx_g2p3_value_read(&e->hdrdata3,
                                ed->fields[8].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_emirror25_set(unit,
                imirror,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for emll1 */
void soc_sbx_g2p3_emll1_print(int unit, 
    soc_sbx_g2p3_emll1_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EMLL1_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->usemap; w = 6;  break;
        case 1: v = e->pointer; w = 7;  break;
        case 2: v = e->salt; w = 4;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry print accessor implementation for mac */
void soc_sbx_g2p3_mac_print(int unit, 
    soc_sbx_g2p3_mac_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MAC_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->age; w = 3;  break;
        case 1: v = e->pid; w = 3;  break;
        case 2: v = e->dcopy; w = 5;  break;
        case 3: v = e->dcopycos; w = 8;  break;
        case 4: v = e->ddrop; w = 5;  break;
        case 5: v = e->sdrop; w = 5;  break;
        case 6: v = e->dontage; w = 7;  break;
        case 7: v = e->bsdrop; w = 6;  break;
        case 8: v = e->bpid; w = 4;  break;
        case 9: v = e->btid; w = 4;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for mac */
int soc_sbx_g2p3_mac_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_mac_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_mac_t e0;
    soc_sbx_g2p3_mac_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MAC_ID];
    int all = 0;
    soc_sbx_g2p3_6_byte_t imac;
    int ivlan;
    int ibmac;
    void *indexpointers[3];

    indexpointers[0] = &imac;
    indexpointers[1] = &ivlan;
    indexpointers[2] = &ibmac;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_mac_first(unit,
                imac,
                &ivlan,
                &ibmac);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("unexpected error in iterator first function\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all)
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_mac_get(unit,
                imac,
                ivlan,
                ibmac,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_mac_print(unit, e);

        if (all) {
            rv = soc_sbx_g2p3_mac_next(unit,
                imac,
                ivlan,
                ibmac,
                imac,
                &ivlan,
                &ibmac);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for mac */
int soc_sbx_g2p3_mac_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_mac_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_mac_t e0;
    soc_sbx_g2p3_mac_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MAC_ID];
    soc_sbx_g2p3_6_byte_t imac;
    int ivlan;
    int ibmac;
    void *indexpointers[3];

    indexpointers[0] = &imac;
    indexpointers[1] = &ivlan;
    indexpointers[2] = &ibmac;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_mac_t_init(e);

    rv = soc_sbx_g2p3_mac_get(unit,
                imac,
                ivlan,
                ibmac,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->age,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->pid,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->dcopy,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->dcopycos,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2p3_value_read(&e->ddrop,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g2p3_value_read(&e->sdrop,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g2p3_value_read(&e->dontage,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g2p3_value_read(&e->bsdrop,
                                ed->fields[7].range, 0, argc, argv);
                 break;
        case 8: rv = soc_sbx_g2p3_value_read(&e->bpid,
                                ed->fields[8].range, 0, argc, argv);
                 break;
        case 9: rv = soc_sbx_g2p3_value_read(&e->btid,
                                ed->fields[9].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_mac_set(unit,
                imac,
                ivlan,
                ibmac,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry diag shell delete implementation for mac */
int soc_sbx_g2p3_mac_shell_delete(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_mac_shell_delete(int unit,
         int argc, char **argv)
{
    int rv = 0, rv0;
    int all = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MAC_ID];
    soc_sbx_g2p3_6_byte_t imac, nimac;
    int ivlan, nivlan;
    int ibmac, nibmac;
    void *indexpointers[3];

    indexpointers[0] = &imac;
    indexpointers[1] = &ivlan;
    indexpointers[2] = &ibmac;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_mac_first(unit,
                nimac,
                &nivlan,
                &nibmac);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("iterator first function failed\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all) {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        if (all) {
            sal_memcpy(imac, nimac, 6);
            ivlan = nivlan;
            ibmac = nibmac;

            rv = soc_sbx_g2p3_mac_next(unit,
                imac,
                ivlan,
                ibmac,
                nimac,
                &nivlan,
                &nibmac);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
        rv0 = soc_sbx_g2p3_mac_delete(unit,
                imac,
                ivlan,
                ibmac);
        if (rv0) {
            soc_cm_print("delete of %s failed\n", ed->name);
            return rv0;
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry print accessor implementation for macl1 */
void soc_sbx_g2p3_macl1_print(int unit, 
    soc_sbx_g2p3_macl1_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MACL1_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->usemap; w = 6;  break;
        case 1: v = e->pointer; w = 7;  break;
        case 2: v = e->salt; w = 4;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for macl1 */
int soc_sbx_g2p3_macl1_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_macl1_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_macl1_t e0;
    soc_sbx_g2p3_macl1_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MACL1_ID];
    int il1i;
    void *indexpointers[1];

    indexpointers[0] = &il1i;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_macl1_get(unit,
                il1i,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_macl1_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for macl1 */
int soc_sbx_g2p3_macl1_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_macl1_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_macl1_t e0;
    soc_sbx_g2p3_macl1_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MACL1_ID];
    int il1i;
    void *indexpointers[1];

    indexpointers[0] = &il1i;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_macl1_t_init(e);

    rv = soc_sbx_g2p3_macl1_get(unit,
                il1i,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->usemap,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->pointer,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->salt,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_macl1_set(unit,
                il1i,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for macl2 */
void soc_sbx_g2p3_macl2_print(int unit, 
    soc_sbx_g2p3_macl2_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MACL2_ID];

    int j, digits;
    uint8 *s;
    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: s = e->mac; w = 3; goto bigfield;
        case 1: v = e->vlan; w = 4;  break;
        case 2: v = e->bmac; w = 4;  break;
        case 3: v = e->age; w = 3;  break;
        case 4: v = e->pid; w = 3;  break;
        case 5: v = e->dcopy; w = 5;  break;
        case 6: v = e->dcopycos; w = 8;  break;
        case 7: v = e->ddrop; w = 5;  break;
        case 8: v = e->sdrop; w = 5;  break;
        case 9: v = e->dontage; w = 7;  break;
        case 10: v = e->notage; w = 6;  break;
        case 11: v = e->bsdrop; w = 6;  break;
        case 12: v = e->bpid; w = 4;  break;
        case 13: v = e->btid; w = 4;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
        continue;

    bigfield:
        digits = (width + 7) / 8;
        if ((col + w + 1 + 5 * digits) > 72) {
            soc_cm_print("\n  ");
            col=2;
        }
        soc_cm_print("%s=", fd->name);
        col += w + 1;
        for (j = 0; j < digits; j++) {
            soc_cm_print("0x%02x ", s[digits - j - 1]);
            col += 5;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for macl2 */
int soc_sbx_g2p3_macl2_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_macl2_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_macl2_t e0;
    soc_sbx_g2p3_macl2_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MACL2_ID];
    int imaci;
    void *indexpointers[1];

    indexpointers[0] = &imaci;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_macl2_get(unit,
                imaci,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_macl2_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for macl2 */
int soc_sbx_g2p3_macl2_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_macl2_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_macl2_t e0;
    soc_sbx_g2p3_macl2_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MACL2_ID];
    int imaci;
    void *indexpointers[1];

    indexpointers[0] = &imaci;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_macl2_t_init(e);

    rv = soc_sbx_g2p3_macl2_get(unit,
                imaci,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_big_value_read(e->mac,
                                ed->fields[0].width, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->vlan,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->bmac,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->age,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2p3_value_read(&e->pid,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g2p3_value_read(&e->dcopy,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g2p3_value_read(&e->dcopycos,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g2p3_value_read(&e->ddrop,
                                ed->fields[7].range, 0, argc, argv);
                 break;
        case 8: rv = soc_sbx_g2p3_value_read(&e->sdrop,
                                ed->fields[8].range, 0, argc, argv);
                 break;
        case 9: rv = soc_sbx_g2p3_value_read(&e->dontage,
                                ed->fields[9].range, 0, argc, argv);
                 break;
        case 10: rv = soc_sbx_g2p3_value_read(&e->notage,
                                ed->fields[10].range, 0, argc, argv);
                 break;
        case 11: rv = soc_sbx_g2p3_value_read(&e->bsdrop,
                                ed->fields[11].range, 0, argc, argv);
                 break;
        case 12: rv = soc_sbx_g2p3_value_read(&e->bpid,
                                ed->fields[12].range, 0, argc, argv);
                 break;
        case 13: rv = soc_sbx_g2p3_value_read(&e->btid,
                                ed->fields[13].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_macl2_set(unit,
                imaci,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for ipv6dhost */
void soc_sbx_g2p3_ipv6dhost_print(int unit, 
    soc_sbx_g2p3_ipv6dhost_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DHOST_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->ftidx; w = 5;  break;
        case 1: v = e->ecmpmask; w = 8;  break;
        case 2: v = e->vid; w = 3;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ipv6dhost */
int soc_sbx_g2p3_ipv6dhost_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv6dhost_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ipv6dhost_t e0;
    soc_sbx_g2p3_ipv6dhost_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DHOST_ID];
    int all = 0;
    soc_sbx_g2p3_16_byte_t iip;
    void *indexpointers[1];

    indexpointers[0] = &iip;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_ipv6dhost_first(unit,
                iip);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("unexpected error in iterator first function\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all)
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ipv6dhost_get(unit,
                iip,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ipv6dhost_print(unit, e);

        if (all) {
            rv = soc_sbx_g2p3_ipv6dhost_next(unit,
                iip,
                iip);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ipv6dhost */
int soc_sbx_g2p3_ipv6dhost_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ipv6dhost_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ipv6dhost_t e0;
    soc_sbx_g2p3_ipv6dhost_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DHOST_ID];
    soc_sbx_g2p3_16_byte_t iip;
    void *indexpointers[1];

    indexpointers[0] = &iip;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ipv6dhost_t_init(e);

    rv = soc_sbx_g2p3_ipv6dhost_get(unit,
                iip,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->ftidx,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->ecmpmask,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->vid,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ipv6dhost_set(unit,
                iip,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry diag shell delete implementation for ipv6dhost */
int soc_sbx_g2p3_ipv6dhost_shell_delete(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv6dhost_shell_delete(int unit,
         int argc, char **argv)
{
    int rv = 0, rv0;
    int all = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DHOST_ID];
    soc_sbx_g2p3_16_byte_t iip, niip;
    void *indexpointers[1];

    indexpointers[0] = &iip;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_ipv6dhost_first(unit,
                niip);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("iterator first function failed\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all) {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        if (all) {
            sal_memcpy(iip, niip, 16);

            rv = soc_sbx_g2p3_ipv6dhost_next(unit,
                iip,
                niip);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
        rv0 = soc_sbx_g2p3_ipv6dhost_delete(unit,
                iip);
        if (rv0) {
            soc_cm_print("delete of %s failed\n", ed->name);
            return rv0;
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry print accessor implementation for ipv6dhostl1 */
void soc_sbx_g2p3_ipv6dhostl1_print(int unit, 
    soc_sbx_g2p3_ipv6dhostl1_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DHOSTL1_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->usemap; w = 6;  break;
        case 1: v = e->pointer; w = 7;  break;
        case 2: v = e->salt; w = 4;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ipv6dhostl1 */
int soc_sbx_g2p3_ipv6dhostl1_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv6dhostl1_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ipv6dhostl1_t e0;
    soc_sbx_g2p3_ipv6dhostl1_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DHOSTL1_ID];
    int il1i;
    void *indexpointers[1];

    indexpointers[0] = &il1i;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ipv6dhostl1_get(unit,
                il1i,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ipv6dhostl1_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ipv6dhostl1 */
int soc_sbx_g2p3_ipv6dhostl1_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ipv6dhostl1_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ipv6dhostl1_t e0;
    soc_sbx_g2p3_ipv6dhostl1_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DHOSTL1_ID];
    int il1i;
    void *indexpointers[1];

    indexpointers[0] = &il1i;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ipv6dhostl1_t_init(e);

    rv = soc_sbx_g2p3_ipv6dhostl1_get(unit,
                il1i,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->usemap,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->pointer,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->salt,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ipv6dhostl1_set(unit,
                il1i,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for ipv6dhostl2 */
void soc_sbx_g2p3_ipv6dhostl2_print(int unit, 
    soc_sbx_g2p3_ipv6dhostl2_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DHOSTL2_ID];

    int j, digits;
    uint8 *s;
    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: s = e->key; w = 3; goto bigfield;
        case 1: v = e->ftidx; w = 5;  break;
        case 2: v = e->ecmpmask; w = 8;  break;
        case 3: v = e->vid; w = 3;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
        continue;

    bigfield:
        digits = (width + 7) / 8;
        if ((col + w + 1 + 5 * digits) > 72) {
            soc_cm_print("\n  ");
            col=2;
        }
        soc_cm_print("%s=", fd->name);
        col += w + 1;
        for (j = 0; j < digits; j++) {
            soc_cm_print("0x%02x ", s[digits - j - 1]);
            col += 5;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ipv6dhostl2 */
int soc_sbx_g2p3_ipv6dhostl2_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv6dhostl2_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ipv6dhostl2_t e0;
    soc_sbx_g2p3_ipv6dhostl2_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DHOSTL2_ID];
    int ihosti;
    void *indexpointers[1];

    indexpointers[0] = &ihosti;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ipv6dhostl2_get(unit,
                ihosti,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ipv6dhostl2_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ipv6dhostl2 */
int soc_sbx_g2p3_ipv6dhostl2_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ipv6dhostl2_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ipv6dhostl2_t e0;
    soc_sbx_g2p3_ipv6dhostl2_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DHOSTL2_ID];
    int ihosti;
    void *indexpointers[1];

    indexpointers[0] = &ihosti;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ipv6dhostl2_t_init(e);

    rv = soc_sbx_g2p3_ipv6dhostl2_get(unit,
                ihosti,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_big_value_read(e->key,
                                ed->fields[0].width, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->ftidx,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->ecmpmask,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->vid,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ipv6dhostl2_set(unit,
                ihosti,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for mst */
void soc_sbx_g2p3_mst_print(int unit, 
    soc_sbx_g2p3_mst_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MST_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->learn; w = 5;  break;
        case 1: v = e->pim; w = 3;  break;
        case 2: v = e->igmp; w = 4;  break;
        case 3: v = e->rtcopy; w = 6;  break;
        case 4: v = e->l2cpcopy; w = 8;  break;
        case 5: v = e->dcopy; w = 5;  break;
        case 6: v = e->ipredirect; w = 10;  break;
        case 7: v = e->learn_bmac; w = 10;  break;
        case 8: v = e->mirroridx; w = 9;  break;
        case 9: v = e->vsi; w = 3;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for mst */
int soc_sbx_g2p3_mst_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_mst_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_mst_t e0;
    soc_sbx_g2p3_mst_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MST_ID];
    int imsti;
    void *indexpointers[1];

    indexpointers[0] = &imsti;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_mst_get(unit,
                imsti,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_mst_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for mst */
int soc_sbx_g2p3_mst_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_mst_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_mst_t e0;
    soc_sbx_g2p3_mst_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_MST_ID];
    int imsti;
    void *indexpointers[1];

    indexpointers[0] = &imsti;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_mst_t_init(e);

    rv = soc_sbx_g2p3_mst_get(unit,
                imsti,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->learn,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->pim,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->igmp,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->rtcopy,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2p3_value_read(&e->l2cpcopy,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g2p3_value_read(&e->dcopy,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g2p3_value_read(&e->ipredirect,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g2p3_value_read(&e->learn_bmac,
                                ed->fields[7].range, 0, argc, argv);
                 break;
        case 8: rv = soc_sbx_g2p3_value_read(&e->mirroridx,
                                ed->fields[8].range, 0, argc, argv);
                 break;
        case 9: rv = soc_sbx_g2p3_value_read(&e->vsi,
                                ed->fields[9].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_mst_set(unit,
                imsti,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for pv2e */
void soc_sbx_g2p3_pv2e_print(int unit, 
    soc_sbx_g2p3_pv2e_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PV2E_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->lpi; w = 3;  break;
        case 1: v = e->vlan; w = 4;  break;
        case 2: v = e->stpstate; w = 8;  break;
        case 3: v = e->untagged_strip; w = 14;  break;
        case 4: v = e->vpws; w = 4;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for pv2e */
int soc_sbx_g2p3_pv2e_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_pv2e_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_pv2e_t e0;
    soc_sbx_g2p3_pv2e_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PV2E_ID];
    int ivid;
    int iport;
    void *indexpointers[2];

    indexpointers[0] = &ivid;
    indexpointers[1] = &iport;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_pv2e_get(unit,
                ivid,
                iport,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_pv2e_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for pv2e */
int soc_sbx_g2p3_pv2e_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_pv2e_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_pv2e_t e0;
    soc_sbx_g2p3_pv2e_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PV2E_ID];
    int ivid;
    int iport;
    void *indexpointers[2];

    indexpointers[0] = &ivid;
    indexpointers[1] = &iport;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_pv2e_t_init(e);

    rv = soc_sbx_g2p3_pv2e_get(unit,
                ivid,
                iport,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->lpi,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->vlan,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->stpstate,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->untagged_strip,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2p3_value_read(&e->vpws,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_pv2e_set(unit,
                ivid,
                iport,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for p2appdata */
void soc_sbx_g2p3_p2appdata_print(int unit, 
    soc_sbx_g2p3_p2appdata_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2APPDATA_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->ifilteren; w = 9;  break;
        case 1: v = e->efilteren; w = 9;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for p2appdata */
int soc_sbx_g2p3_p2appdata_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_p2appdata_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_p2appdata_t e0;
    soc_sbx_g2p3_p2appdata_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2APPDATA_ID];
    int iport;
    void *indexpointers[1];

    indexpointers[0] = &iport;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_p2appdata_get(unit,
                iport,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_p2appdata_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for p2appdata */
int soc_sbx_g2p3_p2appdata_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_p2appdata_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_p2appdata_t e0;
    soc_sbx_g2p3_p2appdata_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2APPDATA_ID];
    int iport;
    void *indexpointers[1];

    indexpointers[0] = &iport;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_p2appdata_t_init(e);

    rv = soc_sbx_g2p3_p2appdata_get(unit,
                iport,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->ifilteren,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->efilteren,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_p2appdata_set(unit,
                iport,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for pv2appdata */
void soc_sbx_g2p3_pv2appdata_print(int unit, 
    soc_sbx_g2p3_pv2appdata_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PV2APPDATA_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->member; w = 6;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for pv2appdata */
int soc_sbx_g2p3_pv2appdata_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_pv2appdata_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_pv2appdata_t e0;
    soc_sbx_g2p3_pv2appdata_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PV2APPDATA_ID];
    int ivid;
    int iport;
    void *indexpointers[2];

    indexpointers[0] = &ivid;
    indexpointers[1] = &iport;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_pv2appdata_get(unit,
                ivid,
                iport,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_pv2appdata_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for pv2appdata */
int soc_sbx_g2p3_pv2appdata_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_pv2appdata_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_pv2appdata_t e0;
    soc_sbx_g2p3_pv2appdata_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PV2APPDATA_ID];
    int ivid;
    int iport;
    void *indexpointers[2];

    indexpointers[0] = &ivid;
    indexpointers[1] = &iport;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_pv2appdata_t_init(e);

    rv = soc_sbx_g2p3_pv2appdata_get(unit,
                ivid,
                iport,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->member,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_pv2appdata_set(unit,
                ivid,
                iport,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for ipv6shost */
void soc_sbx_g2p3_ipv6shost_print(int unit, 
    soc_sbx_g2p3_ipv6shost_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SHOST_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->poe; w = 3;  break;
        case 1: v = e->rpfmode; w = 7;  break;
        case 2: v = e->srcdrop; w = 7;  break;
        case 3: v = e->srccnt; w = 6;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ipv6shost */
int soc_sbx_g2p3_ipv6shost_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv6shost_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ipv6shost_t e0;
    soc_sbx_g2p3_ipv6shost_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SHOST_ID];
    int all = 0;
    soc_sbx_g2p3_16_byte_t iip;
    void *indexpointers[1];

    indexpointers[0] = &iip;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_ipv6shost_first(unit,
                iip);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("unexpected error in iterator first function\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all)
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ipv6shost_get(unit,
                iip,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ipv6shost_print(unit, e);

        if (all) {
            rv = soc_sbx_g2p3_ipv6shost_next(unit,
                iip,
                iip);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ipv6shost */
int soc_sbx_g2p3_ipv6shost_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ipv6shost_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ipv6shost_t e0;
    soc_sbx_g2p3_ipv6shost_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SHOST_ID];
    soc_sbx_g2p3_16_byte_t iip;
    void *indexpointers[1];

    indexpointers[0] = &iip;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ipv6shost_t_init(e);

    rv = soc_sbx_g2p3_ipv6shost_get(unit,
                iip,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->poe,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->rpfmode,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->srcdrop,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->srccnt,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ipv6shost_set(unit,
                iip,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry diag shell delete implementation for ipv6shost */
int soc_sbx_g2p3_ipv6shost_shell_delete(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv6shost_shell_delete(int unit,
         int argc, char **argv)
{
    int rv = 0, rv0;
    int all = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SHOST_ID];
    soc_sbx_g2p3_16_byte_t iip, niip;
    void *indexpointers[1];

    indexpointers[0] = &iip;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_ipv6shost_first(unit,
                niip);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("iterator first function failed\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all) {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        if (all) {
            sal_memcpy(iip, niip, 16);

            rv = soc_sbx_g2p3_ipv6shost_next(unit,
                iip,
                niip);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
        rv0 = soc_sbx_g2p3_ipv6shost_delete(unit,
                iip);
        if (rv0) {
            soc_cm_print("delete of %s failed\n", ed->name);
            return rv0;
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry print accessor implementation for ipv6shostl1 */
void soc_sbx_g2p3_ipv6shostl1_print(int unit, 
    soc_sbx_g2p3_ipv6shostl1_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SHOSTL1_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->usemap; w = 6;  break;
        case 1: v = e->pointer; w = 7;  break;
        case 2: v = e->salt; w = 4;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ipv6shostl1 */
int soc_sbx_g2p3_ipv6shostl1_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv6shostl1_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ipv6shostl1_t e0;
    soc_sbx_g2p3_ipv6shostl1_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SHOSTL1_ID];
    int il1i;
    void *indexpointers[1];

    indexpointers[0] = &il1i;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ipv6shostl1_get(unit,
                il1i,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ipv6shostl1_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ipv6shostl1 */
int soc_sbx_g2p3_ipv6shostl1_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ipv6shostl1_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ipv6shostl1_t e0;
    soc_sbx_g2p3_ipv6shostl1_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SHOSTL1_ID];
    int il1i;
    void *indexpointers[1];

    indexpointers[0] = &il1i;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ipv6shostl1_t_init(e);

    rv = soc_sbx_g2p3_ipv6shostl1_get(unit,
                il1i,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->usemap,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->pointer,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->salt,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ipv6shostl1_set(unit,
                il1i,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for ipv6shostl2 */
void soc_sbx_g2p3_ipv6shostl2_print(int unit, 
    soc_sbx_g2p3_ipv6shostl2_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SHOSTL2_ID];

    int j, digits;
    uint8 *s;
    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: s = e->key; w = 3; goto bigfield;
        case 1: v = e->ftidx; w = 5;  break;
        case 2: v = e->ecmpmask; w = 8;  break;
        case 3: v = e->vid; w = 3;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
        continue;

    bigfield:
        digits = (width + 7) / 8;
        if ((col + w + 1 + 5 * digits) > 72) {
            soc_cm_print("\n  ");
            col=2;
        }
        soc_cm_print("%s=", fd->name);
        col += w + 1;
        for (j = 0; j < digits; j++) {
            soc_cm_print("0x%02x ", s[digits - j - 1]);
            col += 5;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ipv6shostl2 */
int soc_sbx_g2p3_ipv6shostl2_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv6shostl2_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ipv6shostl2_t e0;
    soc_sbx_g2p3_ipv6shostl2_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SHOSTL2_ID];
    int ihosti;
    void *indexpointers[1];

    indexpointers[0] = &ihosti;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ipv6shostl2_get(unit,
                ihosti,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ipv6shostl2_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ipv6shostl2 */
int soc_sbx_g2p3_ipv6shostl2_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ipv6shostl2_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ipv6shostl2_t e0;
    soc_sbx_g2p3_ipv6shostl2_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SHOSTL2_ID];
    int ihosti;
    void *indexpointers[1];

    indexpointers[0] = &ihosti;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ipv6shostl2_t_init(e);

    rv = soc_sbx_g2p3_ipv6shostl2_get(unit,
                ihosti,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_big_value_read(e->key,
                                ed->fields[0].width, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->ftidx,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->ecmpmask,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->vid,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ipv6shostl2_set(unit,
                ihosti,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for pvv2e */
void soc_sbx_g2p3_pvv2e_print(int unit, 
    soc_sbx_g2p3_pvv2e_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PVV2E_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->lpi; w = 3;  break;
        case 1: v = e->vlan; w = 4;  break;
        case 2: v = e->stpstate; w = 8;  break;
        case 3: v = e->untagged_strip; w = 14;  break;
        case 4: v = e->vpws; w = 4;  break;
        case 5: v = e->vid; w = 3;  break;
        case 6: v = e->replace; w = 7;  break;
        case 7: v = e->keeporstrip; w = 11;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for pvv2e */
int soc_sbx_g2p3_pvv2e_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_pvv2e_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_pvv2e_t e0;
    soc_sbx_g2p3_pvv2e_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PVV2E_ID];
    int all = 0;
    int iivid;
    int iovid;
    int iport;
    void *indexpointers[3];

    indexpointers[0] = &iivid;
    indexpointers[1] = &iovid;
    indexpointers[2] = &iport;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_pvv2e_first(unit,
                &iivid,
                &iovid,
                &iport);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("unexpected error in iterator first function\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all)
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_pvv2e_get(unit,
                iivid,
                iovid,
                iport,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_pvv2e_print(unit, e);

        if (all) {
            rv = soc_sbx_g2p3_pvv2e_next(unit,
                iivid,
                iovid,
                iport,
                &iivid,
                &iovid,
                &iport);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for pvv2e */
int soc_sbx_g2p3_pvv2e_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_pvv2e_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_pvv2e_t e0;
    soc_sbx_g2p3_pvv2e_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PVV2E_ID];
    int iivid;
    int iovid;
    int iport;
    void *indexpointers[3];

    indexpointers[0] = &iivid;
    indexpointers[1] = &iovid;
    indexpointers[2] = &iport;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_pvv2e_t_init(e);

    rv = soc_sbx_g2p3_pvv2e_get(unit,
                iivid,
                iovid,
                iport,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->lpi,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->vlan,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->stpstate,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->untagged_strip,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2p3_value_read(&e->vpws,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g2p3_value_read(&e->vid,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g2p3_value_read(&e->replace,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g2p3_value_read(&e->keeporstrip,
                                ed->fields[7].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_pvv2e_set(unit,
                iivid,
                iovid,
                iport,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry diag shell delete implementation for pvv2e */
int soc_sbx_g2p3_pvv2e_shell_delete(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_pvv2e_shell_delete(int unit,
         int argc, char **argv)
{
    int rv = 0, rv0;
    int all = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PVV2E_ID];
    int iivid, niivid;
    int iovid, niovid;
    int iport, niport;
    void *indexpointers[3];

    indexpointers[0] = &iivid;
    indexpointers[1] = &iovid;
    indexpointers[2] = &iport;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_pvv2e_first(unit,
                &niivid,
                &niovid,
                &niport);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("iterator first function failed\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all) {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        if (all) {
            iivid = niivid;
            iovid = niovid;
            iport = niport;

            rv = soc_sbx_g2p3_pvv2e_next(unit,
                iivid,
                iovid,
                iport,
                &niivid,
                &niovid,
                &niport);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
        rv0 = soc_sbx_g2p3_pvv2e_delete(unit,
                iivid,
                iovid,
                iport);
        if (rv0) {
            soc_cm_print("delete of %s failed\n", ed->name);
            return rv0;
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry print accessor implementation for pvv2epack */
void soc_sbx_g2p3_pvv2epack_print(int unit, 
    soc_sbx_g2p3_pvv2epack_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PVV2EPACK_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->lpi; w = 3;  break;
        case 1: v = e->vlan; w = 4;  break;
        case 2: v = e->stpstate; w = 8;  break;
        case 3: v = e->untagged_strip; w = 14;  break;
        case 4: v = e->vpws; w = 4;  break;
        case 5: v = e->vid; w = 3;  break;
        case 6: v = e->replace; w = 7;  break;
        case 7: v = e->keeporstrip; w = 11;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for pvv2epack */
int soc_sbx_g2p3_pvv2epack_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_pvv2epack_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_pvv2epack_t e0;
    soc_sbx_g2p3_pvv2epack_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PVV2EPACK_ID];
    int all = 0;
    int iovid;
    int iport;
    int iivid;
    void *indexpointers[3];

    indexpointers[0] = &iovid;
    indexpointers[1] = &iport;
    indexpointers[2] = &iivid;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_pvv2epack_first(unit,
                &iovid,
                &iport,
                &iivid);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("unexpected error in iterator first function\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all)
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_pvv2epack_get(unit,
                iovid,
                iport,
                iivid,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_pvv2epack_print(unit, e);

        if (all) {
            rv = soc_sbx_g2p3_pvv2epack_next(unit,
                iovid,
                iport,
                iivid,
                &iovid,
                &iport,
                &iivid);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for pvv2epack */
int soc_sbx_g2p3_pvv2epack_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_pvv2epack_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_pvv2epack_t e0;
    soc_sbx_g2p3_pvv2epack_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PVV2EPACK_ID];
    int iovid;
    int iport;
    int iivid;
    void *indexpointers[3];

    indexpointers[0] = &iovid;
    indexpointers[1] = &iport;
    indexpointers[2] = &iivid;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_pvv2epack_t_init(e);

    rv = soc_sbx_g2p3_pvv2epack_get(unit,
                iovid,
                iport,
                iivid,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->lpi,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->vlan,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->stpstate,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->untagged_strip,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2p3_value_read(&e->vpws,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g2p3_value_read(&e->vid,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g2p3_value_read(&e->replace,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g2p3_value_read(&e->keeporstrip,
                                ed->fields[7].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_pvv2epack_set(unit,
                iovid,
                iport,
                iivid,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry diag shell delete implementation for pvv2epack */
int soc_sbx_g2p3_pvv2epack_shell_delete(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_pvv2epack_shell_delete(int unit,
         int argc, char **argv)
{
    int rv = 0, rv0;
    int all = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_PVV2EPACK_ID];
    int iovid, niovid;
    int iport, niport;
    int iivid, niivid;
    void *indexpointers[3];

    indexpointers[0] = &iovid;
    indexpointers[1] = &iport;
    indexpointers[2] = &iivid;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_pvv2epack_first(unit,
                &niovid,
                &niport,
                &niivid);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("iterator first function failed\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all) {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        if (all) {
            iovid = niovid;
            iport = niport;
            iivid = niivid;

            rv = soc_sbx_g2p3_pvv2epack_next(unit,
                iovid,
                iport,
                iivid,
                &niovid,
                &niport,
                &niivid);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
        rv0 = soc_sbx_g2p3_pvv2epack_delete(unit,
                iovid,
                iport,
                iivid);
        if (rv0) {
            soc_cm_print("delete of %s failed\n", ed->name);
            return rv0;
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry print accessor implementation for isid2e */
void soc_sbx_g2p3_isid2e_print(int unit, 
    soc_sbx_g2p3_isid2e_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ISID2E_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->lpi; w = 3;  break;
        case 1: v = e->vlan; w = 4;  break;
        case 2: v = e->stpstate; w = 8;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for isid2e */
int soc_sbx_g2p3_isid2e_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_isid2e_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_isid2e_t e0;
    soc_sbx_g2p3_isid2e_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ISID2E_ID];
    int all = 0;
    int iisid;
    void *indexpointers[1];

    indexpointers[0] = &iisid;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_isid2e_first(unit,
                &iisid);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("unexpected error in iterator first function\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all)
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_isid2e_get(unit,
                iisid,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_isid2e_print(unit, e);

        if (all) {
            rv = soc_sbx_g2p3_isid2e_next(unit,
                iisid,
                &iisid);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for isid2e */
int soc_sbx_g2p3_isid2e_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_isid2e_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_isid2e_t e0;
    soc_sbx_g2p3_isid2e_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ISID2E_ID];
    int iisid;
    void *indexpointers[1];

    indexpointers[0] = &iisid;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_isid2e_t_init(e);

    rv = soc_sbx_g2p3_isid2e_get(unit,
                iisid,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->lpi,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->vlan,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->stpstate,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_isid2e_set(unit,
                iisid,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry diag shell delete implementation for isid2e */
int soc_sbx_g2p3_isid2e_shell_delete(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_isid2e_shell_delete(int unit,
         int argc, char **argv)
{
    int rv = 0, rv0;
    int all = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ISID2E_ID];
    int iisid, niisid;
    void *indexpointers[1];

    indexpointers[0] = &iisid;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_isid2e_first(unit,
                &niisid);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("iterator first function failed\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all) {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        if (all) {
            iisid = niisid;

            rv = soc_sbx_g2p3_isid2e_next(unit,
                iisid,
                &niisid);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
        rv0 = soc_sbx_g2p3_isid2e_delete(unit,
                iisid);
        if (rv0) {
            soc_cm_print("delete of %s failed\n", ed->name);
            return rv0;
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry print accessor implementation for oampvd2e */
void soc_sbx_g2p3_oampvd2e_print(int unit, 
    soc_sbx_g2p3_oampvd2e_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMPVD2E_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->endpointPtr; w = 11;  break;
        case 1: v = e->ftIdx; w = 5;  break;
        case 2: v = e->mdLevelEp; w = 9;  break;
        case 3: v = e->mdLevelFwd; w = 10;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for oampvd2e */
int soc_sbx_g2p3_oampvd2e_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_oampvd2e_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_oampvd2e_t e0;
    soc_sbx_g2p3_oampvd2e_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMPVD2E_ID];
    int all = 0;
    int iport;
    int ivid;
    int idir;
    int itag;
    void *indexpointers[4];

    indexpointers[0] = &iport;
    indexpointers[1] = &ivid;
    indexpointers[2] = &idir;
    indexpointers[3] = &itag;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_oampvd2e_first(unit,
                &iport,
                &ivid,
                &idir,
                &itag);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("unexpected error in iterator first function\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all)
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_oampvd2e_get(unit,
                iport,
                ivid,
                idir,
                itag,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_oampvd2e_print(unit, e);

        if (all) {
            rv = soc_sbx_g2p3_oampvd2e_next(unit,
                iport,
                ivid,
                idir,
                itag,
                &iport,
                &ivid,
                &idir,
                &itag);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for oampvd2e */
int soc_sbx_g2p3_oampvd2e_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_oampvd2e_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_oampvd2e_t e0;
    soc_sbx_g2p3_oampvd2e_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMPVD2E_ID];
    int iport;
    int ivid;
    int idir;
    int itag;
    void *indexpointers[4];

    indexpointers[0] = &iport;
    indexpointers[1] = &ivid;
    indexpointers[2] = &idir;
    indexpointers[3] = &itag;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_oampvd2e_t_init(e);

    rv = soc_sbx_g2p3_oampvd2e_get(unit,
                iport,
                ivid,
                idir,
                itag,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->endpointPtr,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->ftIdx,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->mdLevelEp,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->mdLevelFwd,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_oampvd2e_set(unit,
                iport,
                ivid,
                idir,
                itag,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry diag shell delete implementation for oampvd2e */
int soc_sbx_g2p3_oampvd2e_shell_delete(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_oampvd2e_shell_delete(int unit,
         int argc, char **argv)
{
    int rv = 0, rv0;
    int all = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMPVD2E_ID];
    int iport, niport;
    int ivid, nivid;
    int idir, nidir;
    int itag, nitag;
    void *indexpointers[4];

    indexpointers[0] = &iport;
    indexpointers[1] = &ivid;
    indexpointers[2] = &idir;
    indexpointers[3] = &itag;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_oampvd2e_first(unit,
                &niport,
                &nivid,
                &nidir,
                &nitag);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("iterator first function failed\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all) {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        if (all) {
            iport = niport;
            ivid = nivid;
            idir = nidir;
            itag = nitag;

            rv = soc_sbx_g2p3_oampvd2e_next(unit,
                iport,
                ivid,
                idir,
                itag,
                &niport,
                &nivid,
                &nidir,
                &nitag);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
        rv0 = soc_sbx_g2p3_oampvd2e_delete(unit,
                iport,
                ivid,
                idir,
                itag);
        if (rv0) {
            soc_cm_print("delete of %s failed\n", ed->name);
            return rv0;
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry print accessor implementation for oammaidmep2e */
void soc_sbx_g2p3_oammaidmep2e_print(int unit, 
    soc_sbx_g2p3_oammaidmep2e_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMMAIDMEP2E_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->endpointPtr; w = 11;  break;
        case 1: v = e->epValid; w = 7;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for oammaidmep2e */
int soc_sbx_g2p3_oammaidmep2e_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_oammaidmep2e_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_oammaidmep2e_t e0;
    soc_sbx_g2p3_oammaidmep2e_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMMAIDMEP2E_ID];
    int all = 0;
    int imaid;
    int imepid;
    void *indexpointers[2];

    indexpointers[0] = &imaid;
    indexpointers[1] = &imepid;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_oammaidmep2e_first(unit,
                &imaid,
                &imepid);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("unexpected error in iterator first function\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all)
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_oammaidmep2e_get(unit,
                imaid,
                imepid,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_oammaidmep2e_print(unit, e);

        if (all) {
            rv = soc_sbx_g2p3_oammaidmep2e_next(unit,
                imaid,
                imepid,
                &imaid,
                &imepid);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for oammaidmep2e */
int soc_sbx_g2p3_oammaidmep2e_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_oammaidmep2e_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_oammaidmep2e_t e0;
    soc_sbx_g2p3_oammaidmep2e_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMMAIDMEP2E_ID];
    int imaid;
    int imepid;
    void *indexpointers[2];

    indexpointers[0] = &imaid;
    indexpointers[1] = &imepid;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_oammaidmep2e_t_init(e);

    rv = soc_sbx_g2p3_oammaidmep2e_get(unit,
                imaid,
                imepid,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->endpointPtr,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->epValid,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_oammaidmep2e_set(unit,
                imaid,
                imepid,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry diag shell delete implementation for oammaidmep2e */
int soc_sbx_g2p3_oammaidmep2e_shell_delete(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_oammaidmep2e_shell_delete(int unit,
         int argc, char **argv)
{
    int rv = 0, rv0;
    int all = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMMAIDMEP2E_ID];
    int imaid, nimaid;
    int imepid, nimepid;
    void *indexpointers[2];

    indexpointers[0] = &imaid;
    indexpointers[1] = &imepid;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_oammaidmep2e_first(unit,
                &nimaid,
                &nimepid);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("iterator first function failed\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all) {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        if (all) {
            imaid = nimaid;
            imepid = nimepid;

            rv = soc_sbx_g2p3_oammaidmep2e_next(unit,
                imaid,
                imepid,
                &nimaid,
                &nimepid);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
        rv0 = soc_sbx_g2p3_oammaidmep2e_delete(unit,
                imaid,
                imepid);
        if (rv0) {
            soc_cm_print("delete of %s failed\n", ed->name);
            return rv0;
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry print accessor implementation for cuckoo */
void soc_sbx_g2p3_cuckoo_print(int unit, 
    soc_sbx_g2p3_cuckoo_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_CUCKOO_ID];

    int j, digits;
    uint8 *s;
    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: s = e->pay; w = 3; goto bigfield;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
        continue;

    bigfield:
        digits = (width + 7) / 8;
        if ((col + w + 1 + 5 * digits) > 72) {
            soc_cm_print("\n  ");
            col=2;
        }
        soc_cm_print("%s=", fd->name);
        col += w + 1;
        for (j = 0; j < digits; j++) {
            soc_cm_print("0x%02x ", s[digits - j - 1]);
            col += 5;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for cuckoo */
int soc_sbx_g2p3_cuckoo_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_cuckoo_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_cuckoo_t e0;
    soc_sbx_g2p3_cuckoo_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_CUCKOO_ID];
    int all = 0;
    int ikey;
    int itype;
    void *indexpointers[2];

    indexpointers[0] = &ikey;
    indexpointers[1] = &itype;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_cuckoo_first(unit,
                &ikey,
                &itype);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("unexpected error in iterator first function\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all)
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_cuckoo_get(unit,
                ikey,
                itype,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_cuckoo_print(unit, e);

        if (all) {
            rv = soc_sbx_g2p3_cuckoo_next(unit,
                ikey,
                itype,
                &ikey,
                &itype);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for cuckoo */
int soc_sbx_g2p3_cuckoo_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_cuckoo_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_cuckoo_t e0;
    soc_sbx_g2p3_cuckoo_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_CUCKOO_ID];
    int ikey;
    int itype;
    void *indexpointers[2];

    indexpointers[0] = &ikey;
    indexpointers[1] = &itype;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_cuckoo_t_init(e);

    rv = soc_sbx_g2p3_cuckoo_get(unit,
                ikey,
                itype,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_big_value_read(e->pay,
                                ed->fields[0].width, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_cuckoo_set(unit,
                ikey,
                itype,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry diag shell delete implementation for cuckoo */
int soc_sbx_g2p3_cuckoo_shell_delete(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_cuckoo_shell_delete(int unit,
         int argc, char **argv)
{
    int rv = 0, rv0;
    int all = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_CUCKOO_ID];
    int ikey, nikey;
    int itype, nitype;
    void *indexpointers[2];

    indexpointers[0] = &ikey;
    indexpointers[1] = &itype;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_cuckoo_first(unit,
                &nikey,
                &nitype);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("iterator first function failed\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all) {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        if (all) {
            ikey = nikey;
            itype = nitype;

            rv = soc_sbx_g2p3_cuckoo_next(unit,
                ikey,
                itype,
                &nikey,
                &nitype);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
        rv0 = soc_sbx_g2p3_cuckoo_delete(unit,
                ikey,
                itype);
        if (rv0) {
            soc_cm_print("delete of %s failed\n", ed->name);
            return rv0;
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry print accessor implementation for left */
void soc_sbx_g2p3_left_print(int unit, 
    soc_sbx_g2p3_left_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LEFT_ID];

    int j, digits;
    uint8 *s;
    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: s = e->pay; w = 3; goto bigfield;
        case 1: v = e->key; w = 3;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
        continue;

    bigfield:
        digits = (width + 7) / 8;
        if ((col + w + 1 + 5 * digits) > 72) {
            soc_cm_print("\n  ");
            col=2;
        }
        soc_cm_print("%s=", fd->name);
        col += w + 1;
        for (j = 0; j < digits; j++) {
            soc_cm_print("0x%02x ", s[digits - j - 1]);
            col += 5;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for left */
int soc_sbx_g2p3_left_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_left_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_left_t e0;
    soc_sbx_g2p3_left_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LEFT_ID];
    int ili;
    void *indexpointers[1];

    indexpointers[0] = &ili;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_left_get(unit,
                ili,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_left_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for left */
int soc_sbx_g2p3_left_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_left_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_left_t e0;
    soc_sbx_g2p3_left_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LEFT_ID];
    int ili;
    void *indexpointers[1];

    indexpointers[0] = &ili;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_left_t_init(e);

    rv = soc_sbx_g2p3_left_get(unit,
                ili,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_big_value_read(e->pay,
                                ed->fields[0].width, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->key,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_left_set(unit,
                ili,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for right */
void soc_sbx_g2p3_right_print(int unit, 
    soc_sbx_g2p3_right_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RIGHT_ID];

    int j, digits;
    uint8 *s;
    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: s = e->pay; w = 3; goto bigfield;
        case 1: v = e->key; w = 3;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
        continue;

    bigfield:
        digits = (width + 7) / 8;
        if ((col + w + 1 + 5 * digits) > 72) {
            soc_cm_print("\n  ");
            col=2;
        }
        soc_cm_print("%s=", fd->name);
        col += w + 1;
        for (j = 0; j < digits; j++) {
            soc_cm_print("0x%02x ", s[digits - j - 1]);
            col += 5;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for right */
int soc_sbx_g2p3_right_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_right_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_right_t e0;
    soc_sbx_g2p3_right_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RIGHT_ID];
    int iri;
    void *indexpointers[1];

    indexpointers[0] = &iri;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_right_get(unit,
                iri,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_right_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for right */
int soc_sbx_g2p3_right_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_right_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_right_t e0;
    soc_sbx_g2p3_right_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_RIGHT_ID];
    int iri;
    void *indexpointers[1];

    indexpointers[0] = &iri;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_right_t_init(e);

    rv = soc_sbx_g2p3_right_get(unit,
                iri,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_big_value_read(e->pay,
                                ed->fields[0].width, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->key,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_right_set(unit,
                iri,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for outerlabelcuckoo */
void soc_sbx_g2p3_outerlabelcuckoo_print(int unit, 
    soc_sbx_g2p3_outerlabelcuckoo_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OUTERLABELCUCKOO_ID];

    int j, digits;
    uint8 *s;
    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: s = e->pay; w = 3; goto bigfield;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
        continue;

    bigfield:
        digits = (width + 7) / 8;
        if ((col + w + 1 + 5 * digits) > 72) {
            soc_cm_print("\n  ");
            col=2;
        }
        soc_cm_print("%s=", fd->name);
        col += w + 1;
        for (j = 0; j < digits; j++) {
            soc_cm_print("0x%02x ", s[digits - j - 1]);
            col += 5;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for outerlabelcuckoo */
int soc_sbx_g2p3_outerlabelcuckoo_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_outerlabelcuckoo_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_outerlabelcuckoo_t e0;
    soc_sbx_g2p3_outerlabelcuckoo_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OUTERLABELCUCKOO_ID];
    int all = 0;
    int ikey;
    int itype;
    void *indexpointers[2];

    indexpointers[0] = &ikey;
    indexpointers[1] = &itype;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_outerlabelcuckoo_first(unit,
                &ikey,
                &itype);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("unexpected error in iterator first function\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all)
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_outerlabelcuckoo_get(unit,
                ikey,
                itype,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_outerlabelcuckoo_print(unit, e);

        if (all) {
            rv = soc_sbx_g2p3_outerlabelcuckoo_next(unit,
                ikey,
                itype,
                &ikey,
                &itype);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for outerlabelcuckoo */
int soc_sbx_g2p3_outerlabelcuckoo_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_outerlabelcuckoo_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_outerlabelcuckoo_t e0;
    soc_sbx_g2p3_outerlabelcuckoo_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OUTERLABELCUCKOO_ID];
    int ikey;
    int itype;
    void *indexpointers[2];

    indexpointers[0] = &ikey;
    indexpointers[1] = &itype;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_outerlabelcuckoo_t_init(e);

    rv = soc_sbx_g2p3_outerlabelcuckoo_get(unit,
                ikey,
                itype,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_big_value_read(e->pay,
                                ed->fields[0].width, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_outerlabelcuckoo_set(unit,
                ikey,
                itype,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry diag shell delete implementation for outerlabelcuckoo */
int soc_sbx_g2p3_outerlabelcuckoo_shell_delete(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_outerlabelcuckoo_shell_delete(int unit,
         int argc, char **argv)
{
    int rv = 0, rv0;
    int all = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OUTERLABELCUCKOO_ID];
    int ikey, nikey;
    int itype, nitype;
    void *indexpointers[2];

    indexpointers[0] = &ikey;
    indexpointers[1] = &itype;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_outerlabelcuckoo_first(unit,
                &nikey,
                &nitype);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("iterator first function failed\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all) {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        if (all) {
            ikey = nikey;
            itype = nitype;

            rv = soc_sbx_g2p3_outerlabelcuckoo_next(unit,
                ikey,
                itype,
                &nikey,
                &nitype);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
        rv0 = soc_sbx_g2p3_outerlabelcuckoo_delete(unit,
                ikey,
                itype);
        if (rv0) {
            soc_cm_print("delete of %s failed\n", ed->name);
            return rv0;
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry print accessor implementation for outerlabelleft */
void soc_sbx_g2p3_outerlabelleft_print(int unit, 
    soc_sbx_g2p3_outerlabelleft_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OUTERLABELLEFT_ID];

    int j, digits;
    uint8 *s;
    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: s = e->pay; w = 3; goto bigfield;
        case 1: v = e->key; w = 3;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
        continue;

    bigfield:
        digits = (width + 7) / 8;
        if ((col + w + 1 + 5 * digits) > 72) {
            soc_cm_print("\n  ");
            col=2;
        }
        soc_cm_print("%s=", fd->name);
        col += w + 1;
        for (j = 0; j < digits; j++) {
            soc_cm_print("0x%02x ", s[digits - j - 1]);
            col += 5;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for outerlabelleft */
int soc_sbx_g2p3_outerlabelleft_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_outerlabelleft_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_outerlabelleft_t e0;
    soc_sbx_g2p3_outerlabelleft_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OUTERLABELLEFT_ID];
    int ili;
    void *indexpointers[1];

    indexpointers[0] = &ili;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_outerlabelleft_get(unit,
                ili,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_outerlabelleft_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for outerlabelleft */
int soc_sbx_g2p3_outerlabelleft_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_outerlabelleft_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_outerlabelleft_t e0;
    soc_sbx_g2p3_outerlabelleft_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OUTERLABELLEFT_ID];
    int ili;
    void *indexpointers[1];

    indexpointers[0] = &ili;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_outerlabelleft_t_init(e);

    rv = soc_sbx_g2p3_outerlabelleft_get(unit,
                ili,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_big_value_read(e->pay,
                                ed->fields[0].width, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->key,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_outerlabelleft_set(unit,
                ili,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for outerlabelright */
void soc_sbx_g2p3_outerlabelright_print(int unit, 
    soc_sbx_g2p3_outerlabelright_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OUTERLABELRIGHT_ID];

    int j, digits;
    uint8 *s;
    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: s = e->pay; w = 3; goto bigfield;
        case 1: v = e->key; w = 3;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
        continue;

    bigfield:
        digits = (width + 7) / 8;
        if ((col + w + 1 + 5 * digits) > 72) {
            soc_cm_print("\n  ");
            col=2;
        }
        soc_cm_print("%s=", fd->name);
        col += w + 1;
        for (j = 0; j < digits; j++) {
            soc_cm_print("0x%02x ", s[digits - j - 1]);
            col += 5;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for outerlabelright */
int soc_sbx_g2p3_outerlabelright_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_outerlabelright_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_outerlabelright_t e0;
    soc_sbx_g2p3_outerlabelright_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OUTERLABELRIGHT_ID];
    int iri;
    void *indexpointers[1];

    indexpointers[0] = &iri;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_outerlabelright_get(unit,
                iri,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_outerlabelright_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for outerlabelright */
int soc_sbx_g2p3_outerlabelright_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_outerlabelright_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_outerlabelright_t e0;
    soc_sbx_g2p3_outerlabelright_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OUTERLABELRIGHT_ID];
    int iri;
    void *indexpointers[1];

    indexpointers[0] = &iri;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_outerlabelright_t_init(e);

    rv = soc_sbx_g2p3_outerlabelright_get(unit,
                iri,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_big_value_read(e->pay,
                                ed->fields[0].width, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->key,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_outerlabelright_set(unit,
                iri,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for innerlabelcuckoo */
void soc_sbx_g2p3_innerlabelcuckoo_print(int unit, 
    soc_sbx_g2p3_innerlabelcuckoo_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_INNERLABELCUCKOO_ID];

    int j, digits;
    uint8 *s;
    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: s = e->pay; w = 3; goto bigfield;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
        continue;

    bigfield:
        digits = (width + 7) / 8;
        if ((col + w + 1 + 5 * digits) > 72) {
            soc_cm_print("\n  ");
            col=2;
        }
        soc_cm_print("%s=", fd->name);
        col += w + 1;
        for (j = 0; j < digits; j++) {
            soc_cm_print("0x%02x ", s[digits - j - 1]);
            col += 5;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for innerlabelcuckoo */
int soc_sbx_g2p3_innerlabelcuckoo_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_innerlabelcuckoo_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_innerlabelcuckoo_t e0;
    soc_sbx_g2p3_innerlabelcuckoo_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_INNERLABELCUCKOO_ID];
    int all = 0;
    int ikey;
    int itype;
    void *indexpointers[2];

    indexpointers[0] = &ikey;
    indexpointers[1] = &itype;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_innerlabelcuckoo_first(unit,
                &ikey,
                &itype);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("unexpected error in iterator first function\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all)
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_innerlabelcuckoo_get(unit,
                ikey,
                itype,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_innerlabelcuckoo_print(unit, e);

        if (all) {
            rv = soc_sbx_g2p3_innerlabelcuckoo_next(unit,
                ikey,
                itype,
                &ikey,
                &itype);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for innerlabelcuckoo */
int soc_sbx_g2p3_innerlabelcuckoo_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_innerlabelcuckoo_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_innerlabelcuckoo_t e0;
    soc_sbx_g2p3_innerlabelcuckoo_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_INNERLABELCUCKOO_ID];
    int ikey;
    int itype;
    void *indexpointers[2];

    indexpointers[0] = &ikey;
    indexpointers[1] = &itype;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_innerlabelcuckoo_t_init(e);

    rv = soc_sbx_g2p3_innerlabelcuckoo_get(unit,
                ikey,
                itype,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_big_value_read(e->pay,
                                ed->fields[0].width, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_innerlabelcuckoo_set(unit,
                ikey,
                itype,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry diag shell delete implementation for innerlabelcuckoo */
int soc_sbx_g2p3_innerlabelcuckoo_shell_delete(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_innerlabelcuckoo_shell_delete(int unit,
         int argc, char **argv)
{
    int rv = 0, rv0;
    int all = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_INNERLABELCUCKOO_ID];
    int ikey, nikey;
    int itype, nitype;
    void *indexpointers[2];

    indexpointers[0] = &ikey;
    indexpointers[1] = &itype;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_innerlabelcuckoo_first(unit,
                &nikey,
                &nitype);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("iterator first function failed\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all) {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        if (all) {
            ikey = nikey;
            itype = nitype;

            rv = soc_sbx_g2p3_innerlabelcuckoo_next(unit,
                ikey,
                itype,
                &nikey,
                &nitype);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
        rv0 = soc_sbx_g2p3_innerlabelcuckoo_delete(unit,
                ikey,
                itype);
        if (rv0) {
            soc_cm_print("delete of %s failed\n", ed->name);
            return rv0;
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry print accessor implementation for innerlabelleft */
void soc_sbx_g2p3_innerlabelleft_print(int unit, 
    soc_sbx_g2p3_innerlabelleft_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_INNERLABELLEFT_ID];

    int j, digits;
    uint8 *s;
    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: s = e->pay; w = 3; goto bigfield;
        case 1: v = e->key; w = 3;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
        continue;

    bigfield:
        digits = (width + 7) / 8;
        if ((col + w + 1 + 5 * digits) > 72) {
            soc_cm_print("\n  ");
            col=2;
        }
        soc_cm_print("%s=", fd->name);
        col += w + 1;
        for (j = 0; j < digits; j++) {
            soc_cm_print("0x%02x ", s[digits - j - 1]);
            col += 5;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for innerlabelleft */
int soc_sbx_g2p3_innerlabelleft_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_innerlabelleft_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_innerlabelleft_t e0;
    soc_sbx_g2p3_innerlabelleft_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_INNERLABELLEFT_ID];
    int ili;
    void *indexpointers[1];

    indexpointers[0] = &ili;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_innerlabelleft_get(unit,
                ili,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_innerlabelleft_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for innerlabelleft */
int soc_sbx_g2p3_innerlabelleft_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_innerlabelleft_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_innerlabelleft_t e0;
    soc_sbx_g2p3_innerlabelleft_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_INNERLABELLEFT_ID];
    int ili;
    void *indexpointers[1];

    indexpointers[0] = &ili;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_innerlabelleft_t_init(e);

    rv = soc_sbx_g2p3_innerlabelleft_get(unit,
                ili,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_big_value_read(e->pay,
                                ed->fields[0].width, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->key,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_innerlabelleft_set(unit,
                ili,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for innerlabelright */
void soc_sbx_g2p3_innerlabelright_print(int unit, 
    soc_sbx_g2p3_innerlabelright_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_INNERLABELRIGHT_ID];

    int j, digits;
    uint8 *s;
    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: s = e->pay; w = 3; goto bigfield;
        case 1: v = e->key; w = 3;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
        continue;

    bigfield:
        digits = (width + 7) / 8;
        if ((col + w + 1 + 5 * digits) > 72) {
            soc_cm_print("\n  ");
            col=2;
        }
        soc_cm_print("%s=", fd->name);
        col += w + 1;
        for (j = 0; j < digits; j++) {
            soc_cm_print("0x%02x ", s[digits - j - 1]);
            col += 5;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for innerlabelright */
int soc_sbx_g2p3_innerlabelright_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_innerlabelright_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_innerlabelright_t e0;
    soc_sbx_g2p3_innerlabelright_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_INNERLABELRIGHT_ID];
    int iri;
    void *indexpointers[1];

    indexpointers[0] = &iri;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_innerlabelright_get(unit,
                iri,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_innerlabelright_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for innerlabelright */
int soc_sbx_g2p3_innerlabelright_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_innerlabelright_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_innerlabelright_t e0;
    soc_sbx_g2p3_innerlabelright_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_INNERLABELRIGHT_ID];
    int iri;
    void *indexpointers[1];

    indexpointers[0] = &iri;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_innerlabelright_t_init(e);

    rv = soc_sbx_g2p3_innerlabelright_get(unit,
                iri,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_big_value_read(e->pay,
                                ed->fields[0].width, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->key,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_innerlabelright_set(unit,
                iri,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for label2e */
void soc_sbx_g2p3_label2e_print(int unit, 
    soc_sbx_g2p3_label2e_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LABEL2E_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->vlan; w = 4;  break;
        case 1: v = e->ftidx0; w = 6; iffok = (e->vlan==0);  break;
        case 2: v = e->opcode; w = 6;  break;
        case 3: v = e->lpidx; w = 5;  break;
        case 4: v = e->cos; w = 3;  break;
        case 5: v = e->loopback; w = 8;  break;
        case 6: v = e->vpws; w = 4;  break;
        case 7: v = e->ftidx1; w = 6;  break;
        case 8: v = e->stpstate; w = 8;  break;
        case 9: v = e->elsp; w = 4;  break;
        case 10: v = e->pipe; w = 4;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for label2e */
int soc_sbx_g2p3_label2e_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_label2e_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_label2e_t e0;
    soc_sbx_g2p3_label2e_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LABEL2E_ID];
    int all = 0;
    int ilabel;
    void *indexpointers[1];

    indexpointers[0] = &ilabel;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_label2e_first(unit,
                &ilabel);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("unexpected error in iterator first function\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all)
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_label2e_get(unit,
                ilabel,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_label2e_print(unit, e);

        if (all) {
            rv = soc_sbx_g2p3_label2e_next(unit,
                ilabel,
                &ilabel);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for label2e */
int soc_sbx_g2p3_label2e_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_label2e_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_label2e_t e0;
    soc_sbx_g2p3_label2e_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LABEL2E_ID];
    int ilabel;
    void *indexpointers[1];

    indexpointers[0] = &ilabel;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_label2e_t_init(e);

    rv = soc_sbx_g2p3_label2e_get(unit,
                ilabel,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->vlan,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->ftidx0,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->opcode,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->lpidx,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2p3_value_read(&e->cos,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g2p3_value_read(&e->loopback,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g2p3_value_read(&e->vpws,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g2p3_value_read(&e->ftidx1,
                                ed->fields[7].range, 0, argc, argv);
                 break;
        case 8: rv = soc_sbx_g2p3_value_read(&e->stpstate,
                                ed->fields[8].range, 0, argc, argv);
                 break;
        case 9: rv = soc_sbx_g2p3_value_read(&e->elsp,
                                ed->fields[9].range, 0, argc, argv);
                 break;
        case 10: rv = soc_sbx_g2p3_value_read(&e->pipe,
                                ed->fields[10].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_label2e_set(unit,
                ilabel,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry diag shell delete implementation for label2e */
int soc_sbx_g2p3_label2e_shell_delete(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_label2e_shell_delete(int unit,
         int argc, char **argv)
{
    int rv = 0, rv0;
    int all = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LABEL2E_ID];
    int ilabel, nilabel;
    void *indexpointers[1];

    indexpointers[0] = &ilabel;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_label2e_first(unit,
                &nilabel);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("iterator first function failed\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all) {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        if (all) {
            ilabel = nilabel;

            rv = soc_sbx_g2p3_label2e_next(unit,
                ilabel,
                &nilabel);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
        rv0 = soc_sbx_g2p3_label2e_delete(unit,
                ilabel);
        if (rv0) {
            soc_cm_print("delete of %s failed\n", ed->name);
            return rv0;
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry print accessor implementation for tagged_mpls */
void soc_sbx_g2p3_tagged_mpls_print(int unit, 
    soc_sbx_g2p3_tagged_mpls_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_TAGGED_MPLS_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->valid; w = 5;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for tagged_mpls */
int soc_sbx_g2p3_tagged_mpls_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_tagged_mpls_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_tagged_mpls_t e0;
    soc_sbx_g2p3_tagged_mpls_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_TAGGED_MPLS_ID];
    int irule;
    void *indexpointers[1];

    indexpointers[0] = &irule;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_tagged_mpls_get(unit,
                irule,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_tagged_mpls_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for tagged_mpls */
int soc_sbx_g2p3_tagged_mpls_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_tagged_mpls_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_tagged_mpls_t e0;
    soc_sbx_g2p3_tagged_mpls_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_TAGGED_MPLS_ID];
    int irule;
    void *indexpointers[1];

    indexpointers[0] = &irule;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_tagged_mpls_t_init(e);

    rv = soc_sbx_g2p3_tagged_mpls_get(unit,
                irule,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->valid,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_tagged_mpls_set(unit,
                irule,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for v2e */
void soc_sbx_g2p3_v2e_print(int unit, 
    soc_sbx_g2p3_v2e_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_V2E_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->pim; w = 3;  break;
        case 1: v = e->igmp; w = 4;  break;
        case 2: v = e->forceflood; w = 10;  break;
        case 3: v = e->dropunksmac; w = 11;  break;
        case 4: v = e->dontlearn; w = 9;  break;
        case 5: v = e->vrf; w = 3;  break;
        case 6: v = e->v6mcmode; w = 8;  break;
        case 7: v = e->v4mcmode; w = 8;  break;
        case 8: v = e->laghash; w = 7;  break;
        case 9: v = e->v4route; w = 7;  break;
        case 10: v = e->v6route; w = 7;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for v2e */
int soc_sbx_g2p3_v2e_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_v2e_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_v2e_t e0;
    soc_sbx_g2p3_v2e_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_V2E_ID];
    int ivlan;
    void *indexpointers[1];

    indexpointers[0] = &ivlan;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_v2e_get(unit,
                ivlan,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_v2e_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for v2e */
int soc_sbx_g2p3_v2e_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_v2e_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_v2e_t e0;
    soc_sbx_g2p3_v2e_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_V2E_ID];
    int ivlan;
    void *indexpointers[1];

    indexpointers[0] = &ivlan;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_v2e_t_init(e);

    rv = soc_sbx_g2p3_v2e_get(unit,
                ivlan,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->pim,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->igmp,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->forceflood,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->dropunksmac,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2p3_value_read(&e->dontlearn,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g2p3_value_read(&e->vrf,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g2p3_value_read(&e->v6mcmode,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g2p3_value_read(&e->v4mcmode,
                                ed->fields[7].range, 0, argc, argv);
                 break;
        case 8: rv = soc_sbx_g2p3_value_read(&e->laghash,
                                ed->fields[8].range, 0, argc, argv);
                 break;
        case 9: rv = soc_sbx_g2p3_value_read(&e->v4route,
                                ed->fields[9].range, 0, argc, argv);
                 break;
        case 10: rv = soc_sbx_g2p3_value_read(&e->v6route,
                                ed->fields[10].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_v2e_set(unit,
                ivlan,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for v2e1 */
void soc_sbx_g2p3_v2e1_print(int unit, 
    soc_sbx_g2p3_v2e1_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_V2E1_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->vrid0; w = 5;  break;
        case 1: v = e->vrid1; w = 5;  break;
        case 2: v = e->vrid2; w = 5;  break;
        case 3: v = e->vrid3; w = 5;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for v2e1 */
int soc_sbx_g2p3_v2e1_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_v2e1_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_v2e1_t e0;
    soc_sbx_g2p3_v2e1_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_V2E1_ID];
    int ivlan;
    void *indexpointers[1];

    indexpointers[0] = &ivlan;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_v2e1_get(unit,
                ivlan,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_v2e1_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for v2e1 */
int soc_sbx_g2p3_v2e1_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_v2e1_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_v2e1_t e0;
    soc_sbx_g2p3_v2e1_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_V2E1_ID];
    int ivlan;
    void *indexpointers[1];

    indexpointers[0] = &ivlan;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_v2e1_t_init(e);

    rv = soc_sbx_g2p3_v2e1_get(unit,
                ivlan,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->vrid0,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->vrid1,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->vrid2,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->vrid3,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_v2e1_set(unit,
                ivlan,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for lp */
void soc_sbx_g2p3_lp_print(int unit, 
    soc_sbx_g2p3_lp_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LP_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->pid; w = 3;  break;
        case 1: v = e->qos; w = 3;  break;
        case 2: v = e->useexp; w = 6;  break;
        case 3: v = e->usedscp; w = 7;  break;
        case 4: v = e->updatefdp; w = 9;  break;
        case 5: v = e->mirror; w = 6;  break;
        case 6: v = e->updaterdp; w = 9;  break;
        case 7: v = e->policer; w = 7;  break;
        case 8: v = e->typedpolice; w = 11;  break;
        case 9: v = e->mefcos; w = 6;  break;
        case 10: v = e->mef; w = 3;  break;
        case 11: v = e->cocounter; w = 9;  break;
        case 12: v = e->priclass; w = 8;  break;
        case 13: v = e->allpri; w = 6;  break;
        case 14: v = e->xtpolreplace; w = 12;  break;
        case 15: v = e->counter; w = 7;  break;
        case 16: v = e->typedcount; w = 10;  break;
        case 17: v = e->color; w = 5;  break;
        case 18: v = e->usecolor; w = 8;  break;
        case 19: v = e->oamepi; w = 6;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for lp */
int soc_sbx_g2p3_lp_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_lp_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_lp_t e0;
    soc_sbx_g2p3_lp_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LP_ID];
    int ilpi;
    void *indexpointers[1];

    indexpointers[0] = &ilpi;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_lp_get(unit,
                ilpi,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_lp_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for lp */
int soc_sbx_g2p3_lp_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_lp_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_lp_t e0;
    soc_sbx_g2p3_lp_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LP_ID];
    int ilpi;
    void *indexpointers[1];

    indexpointers[0] = &ilpi;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_lp_t_init(e);

    rv = soc_sbx_g2p3_lp_get(unit,
                ilpi,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->pid,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->qos,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->useexp,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->usedscp,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2p3_value_read(&e->updatefdp,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g2p3_value_read(&e->mirror,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g2p3_value_read(&e->updaterdp,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g2p3_value_read(&e->policer,
                                ed->fields[7].range, 0, argc, argv);
                 break;
        case 8: rv = soc_sbx_g2p3_value_read(&e->typedpolice,
                                ed->fields[8].range, 0, argc, argv);
                 break;
        case 9: rv = soc_sbx_g2p3_value_read(&e->mefcos,
                                ed->fields[9].range, 0, argc, argv);
                 break;
        case 10: rv = soc_sbx_g2p3_value_read(&e->mef,
                                ed->fields[10].range, 0, argc, argv);
                 break;
        case 11: rv = soc_sbx_g2p3_value_read(&e->cocounter,
                                ed->fields[11].range, 0, argc, argv);
                 break;
        case 12: rv = soc_sbx_g2p3_value_read(&e->priclass,
                                ed->fields[12].range, 0, argc, argv);
                 break;
        case 13: rv = soc_sbx_g2p3_value_read(&e->allpri,
                                ed->fields[13].range, 0, argc, argv);
                 break;
        case 14: rv = soc_sbx_g2p3_value_read(&e->xtpolreplace,
                                ed->fields[14].range, 0, argc, argv);
                 break;
        case 15: rv = soc_sbx_g2p3_value_read(&e->counter,
                                ed->fields[15].range, 0, argc, argv);
                 break;
        case 16: rv = soc_sbx_g2p3_value_read(&e->typedcount,
                                ed->fields[16].range, 0, argc, argv);
                 break;
        case 17: rv = soc_sbx_g2p3_value_read(&e->color,
                                ed->fields[17].range, 0, argc, argv);
                 break;
        case 18: rv = soc_sbx_g2p3_value_read(&e->usecolor,
                                ed->fields[18].range, 0, argc, argv);
                 break;
        case 19: rv = soc_sbx_g2p3_value_read(&e->oamepi,
                                ed->fields[19].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_lp_set(unit,
                ilpi,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for l2e */
void soc_sbx_g2p3_l2e_print(int unit, 
    soc_sbx_g2p3_l2e_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2E_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->vlan; w = 4;  break;
        case 1: v = e->stpstate; w = 8;  break;
        case 2: v = e->elsp; w = 4;  break;
        case 3: v = e->pipe; w = 4;  break;
        case 4: v = e->ftidx; w = 5;  break;
        case 5: v = e->oamen; w = 5;  break;
        case 6: v = e->leren; w = 5;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for l2e */
int soc_sbx_g2p3_l2e_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_l2e_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_l2e_t e0;
    soc_sbx_g2p3_l2e_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2E_ID];
    int ilabel;
    void *indexpointers[1];

    indexpointers[0] = &ilabel;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_l2e_get(unit,
                ilabel,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_l2e_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for l2e */
int soc_sbx_g2p3_l2e_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_l2e_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_l2e_t e0;
    soc_sbx_g2p3_l2e_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2E_ID];
    int ilabel;
    void *indexpointers[1];

    indexpointers[0] = &ilabel;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_l2e_t_init(e);

    rv = soc_sbx_g2p3_l2e_get(unit,
                ilabel,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->vlan,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->stpstate,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->elsp,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->pipe,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2p3_value_read(&e->ftidx,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g2p3_value_read(&e->oamen,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g2p3_value_read(&e->leren,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_l2e_set(unit,
                ilabel,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for l2cp */
void soc_sbx_g2p3_l2cp_print(int unit, 
    soc_sbx_g2p3_l2cp_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2CP_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->ftidx; w = 5;  break;
        case 1: v = e->forward; w = 7;  break;
        case 2: v = e->passstp; w = 7;  break;
        case 3: v = e->copy; w = 4;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for l2cp */
int soc_sbx_g2p3_l2cp_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_l2cp_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_l2cp_t e0;
    soc_sbx_g2p3_l2cp_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2CP_ID];
    int ilsb;
    int iport;
    void *indexpointers[2];

    indexpointers[0] = &ilsb;
    indexpointers[1] = &iport;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_l2cp_get(unit,
                ilsb,
                iport,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_l2cp_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for l2cp */
int soc_sbx_g2p3_l2cp_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_l2cp_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_l2cp_t e0;
    soc_sbx_g2p3_l2cp_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2CP_ID];
    int ilsb;
    int iport;
    void *indexpointers[2];

    indexpointers[0] = &ilsb;
    indexpointers[1] = &iport;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_l2cp_t_init(e);

    rv = soc_sbx_g2p3_l2cp_get(unit,
                ilsb,
                iport,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->ftidx,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->forward,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->passstp,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->copy,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_l2cp_set(unit,
                ilsb,
                iport,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for l2cpslow */
void soc_sbx_g2p3_l2cpslow_print(int unit, 
    soc_sbx_g2p3_l2cpslow_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2CPSLOW_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->ftidx; w = 5;  break;
        case 1: v = e->forward; w = 7;  break;
        case 2: v = e->passstp; w = 7;  break;
        case 3: v = e->copy; w = 4;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for l2cpslow */
int soc_sbx_g2p3_l2cpslow_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_l2cpslow_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_l2cpslow_t e0;
    soc_sbx_g2p3_l2cpslow_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2CPSLOW_ID];
    int isubcode;
    int iport;
    void *indexpointers[2];

    indexpointers[0] = &isubcode;
    indexpointers[1] = &iport;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_l2cpslow_get(unit,
                isubcode,
                iport,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_l2cpslow_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for l2cpslow */
int soc_sbx_g2p3_l2cpslow_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_l2cpslow_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_l2cpslow_t e0;
    soc_sbx_g2p3_l2cpslow_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2CPSLOW_ID];
    int isubcode;
    int iport;
    void *indexpointers[2];

    indexpointers[0] = &isubcode;
    indexpointers[1] = &iport;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_l2cpslow_t_init(e);

    rv = soc_sbx_g2p3_l2cpslow_get(unit,
                isubcode,
                iport,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->ftidx,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->forward,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->passstp,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->copy,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_l2cpslow_set(unit,
                isubcode,
                iport,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for l2cpnop */
void soc_sbx_g2p3_l2cpnop_print(int unit, 
    soc_sbx_g2p3_l2cpnop_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2CPNOP_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->ftidx; w = 5;  break;
        case 1: v = e->forward; w = 7;  break;
        case 2: v = e->passstp; w = 7;  break;
        case 3: v = e->copy; w = 4;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for l2cpnop */
int soc_sbx_g2p3_l2cpnop_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_l2cpnop_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_l2cpnop_t e0;
    soc_sbx_g2p3_l2cpnop_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2CPNOP_ID];
    int ii;
    void *indexpointers[1];

    indexpointers[0] = &ii;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_l2cpnop_get(unit,
                ii,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_l2cpnop_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for l2cpnop */
int soc_sbx_g2p3_l2cpnop_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_l2cpnop_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_l2cpnop_t e0;
    soc_sbx_g2p3_l2cpnop_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_L2CPNOP_ID];
    int ii;
    void *indexpointers[1];

    indexpointers[0] = &ii;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_l2cpnop_t_init(e);

    rv = soc_sbx_g2p3_l2cpnop_get(unit,
                ii,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->ftidx,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->forward,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->passstp,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->copy,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_l2cpnop_set(unit,
                ii,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for ft */
void soc_sbx_g2p3_ft_print(int unit, 
    soc_sbx_g2p3_ft_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_FT_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->rridx; w = 5;  break;
        case 1: v = e->excidx; w = 6;  break;
        case 2: v = e->lenadj; w = 6;  break;
        case 3: v = e->mc; w = 2;  break;
        case 4: v = e->t; w = 1;  break;
        case 5: v = e->hc; w = 2;  break;
        case 6: v = e->oi; w = 2;  break;
        case 7: v = e->qid; w = 3; iffok = (e->lag==0);  break;
        case 8: v = e->lagbase; w = 7; iffok = (e->lag==1);  break;
        case 9: v = e->lagsize; w = 7; iffok = (e->lag==1);  break;
        case 10: v = e->lag; w = 3;  break;
        case 11: v = e->oib; w = 3;  break;
        case 12: v = e->qidb; w = 4; iffok = (e->lagb==0);  break;
        case 13: v = e->lagbaseb; w = 8; iffok = (e->lagb==1);  break;
        case 14: v = e->lagsizeb; w = 8; iffok = (e->lagb==1);  break;
        case 15: v = e->lagb; w = 4;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ft */
int soc_sbx_g2p3_ft_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ft_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ft_t e0;
    soc_sbx_g2p3_ft_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_FT_ID];
    int ifti;
    void *indexpointers[1];

    indexpointers[0] = &ifti;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ft_get(unit,
                ifti,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ft_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ft */
int soc_sbx_g2p3_ft_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ft_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ft_t e0;
    soc_sbx_g2p3_ft_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_FT_ID];
    int ifti;
    void *indexpointers[1];

    indexpointers[0] = &ifti;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ft_t_init(e);

    rv = soc_sbx_g2p3_ft_get(unit,
                ifti,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->rridx,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->excidx,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->lenadj,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->mc,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2p3_value_read(&e->t,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g2p3_value_read(&e->hc,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g2p3_value_read(&e->oi,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g2p3_value_read(&e->qid,
                                ed->fields[7].range, 0, argc, argv);
                 break;
        case 8: rv = soc_sbx_g2p3_value_read(&e->lagbase,
                                ed->fields[8].range, 0, argc, argv);
                 break;
        case 9: rv = soc_sbx_g2p3_value_read(&e->lagsize,
                                ed->fields[9].range, 0, argc, argv);
                 break;
        case 10: rv = soc_sbx_g2p3_value_read(&e->lag,
                                ed->fields[10].range, 0, argc, argv);
                 break;
        case 11: rv = soc_sbx_g2p3_value_read(&e->oib,
                                ed->fields[11].range, 0, argc, argv);
                 break;
        case 12: rv = soc_sbx_g2p3_value_read(&e->qidb,
                                ed->fields[12].range, 0, argc, argv);
                 break;
        case 13: rv = soc_sbx_g2p3_value_read(&e->lagbaseb,
                                ed->fields[13].range, 0, argc, argv);
                 break;
        case 14: rv = soc_sbx_g2p3_value_read(&e->lagsizeb,
                                ed->fields[14].range, 0, argc, argv);
                 break;
        case 15: rv = soc_sbx_g2p3_value_read(&e->lagb,
                                ed->fields[15].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ft_set(unit,
                ifti,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for OamTimerCalendar */
void soc_sbx_g2p3_oamtimercalendar_print(int unit, 
    soc_sbx_g2p3_oamtimercalendar_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMTIMERCALENDAR_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->endpointPtr; w = 11;  break;
        case 1: v = e->xmitPeriod; w = 10;  break;
        case 2: v = e->xmitCount; w = 9;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for OamTimerCalendar */
int soc_sbx_g2p3_oamtimercalendar_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_oamtimercalendar_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_oamtimercalendar_t e0;
    soc_sbx_g2p3_oamtimercalendar_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMTIMERCALENDAR_ID];
    int ilistmgrindex;
    void *indexpointers[1];

    indexpointers[0] = &ilistmgrindex;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_oamtimercalendar_get(unit,
                ilistmgrindex,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_oamtimercalendar_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for OamTimerCalendar */
int soc_sbx_g2p3_oamtimercalendar_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_oamtimercalendar_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_oamtimercalendar_t e0;
    soc_sbx_g2p3_oamtimercalendar_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMTIMERCALENDAR_ID];
    int ilistmgrindex;
    void *indexpointers[1];

    indexpointers[0] = &ilistmgrindex;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_oamtimercalendar_t_init(e);

    rv = soc_sbx_g2p3_oamtimercalendar_get(unit,
                ilistmgrindex,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->endpointPtr,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->xmitPeriod,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->xmitCount,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_oamtimercalendar_set(unit,
                ilistmgrindex,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for OamPortMdLevel2Etc */
void soc_sbx_g2p3_oamportmdlevel2etc_print(int unit, 
    soc_sbx_g2p3_oamportmdlevel2etc_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMPORTMDLEVEL2ETC_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->valid; w = 5;  break;
        case 1: v = e->fwd; w = 3;  break;
        case 2: v = e->epIdx; w = 5;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for OamPortMdLevel2Etc */
int soc_sbx_g2p3_oamportmdlevel2etc_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_oamportmdlevel2etc_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_oamportmdlevel2etc_t e0;
    soc_sbx_g2p3_oamportmdlevel2etc_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMPORTMDLEVEL2ETC_ID];
    int iportmd;
    void *indexpointers[1];

    indexpointers[0] = &iportmd;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_oamportmdlevel2etc_get(unit,
                iportmd,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_oamportmdlevel2etc_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for OamPortMdLevel2Etc */
int soc_sbx_g2p3_oamportmdlevel2etc_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_oamportmdlevel2etc_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_oamportmdlevel2etc_t e0;
    soc_sbx_g2p3_oamportmdlevel2etc_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMPORTMDLEVEL2ETC_ID];
    int iportmd;
    void *indexpointers[1];

    indexpointers[0] = &iportmd;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_oamportmdlevel2etc_t_init(e);

    rv = soc_sbx_g2p3_oamportmdlevel2etc_get(unit,
                iportmd,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->valid,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->fwd,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->epIdx,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_oamportmdlevel2etc_set(unit,
                iportmd,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for v4uc_str_sel */
void soc_sbx_g2p3_v4uc_str_sel_print(int unit, 
    soc_sbx_g2p3_v4uc_str_sel_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_V4UC_STR_SEL_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->valid; w = 5;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for v4uc_str_sel */
int soc_sbx_g2p3_v4uc_str_sel_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_v4uc_str_sel_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_v4uc_str_sel_t e0;
    soc_sbx_g2p3_v4uc_str_sel_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_V4UC_STR_SEL_ID];
    int irule;
    void *indexpointers[1];

    indexpointers[0] = &irule;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_v4uc_str_sel_get(unit,
                irule,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_v4uc_str_sel_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for v4uc_str_sel */
int soc_sbx_g2p3_v4uc_str_sel_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_v4uc_str_sel_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_v4uc_str_sel_t e0;
    soc_sbx_g2p3_v4uc_str_sel_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_V4UC_STR_SEL_ID];
    int irule;
    void *indexpointers[1];

    indexpointers[0] = &irule;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_v4uc_str_sel_t_init(e);

    rv = soc_sbx_g2p3_v4uc_str_sel_get(unit,
                irule,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->valid,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_v4uc_str_sel_set(unit,
                irule,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for cmac */
void soc_sbx_g2p3_cmac_print(int unit, 
    soc_sbx_g2p3_cmac_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_CMAC_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->age; w = 3;  break;
        case 1: v = e->pid; w = 3;  break;
        case 2: v = e->dcopy; w = 5;  break;
        case 3: v = e->dcopycos; w = 8;  break;
        case 4: v = e->ddrop; w = 5;  break;
        case 5: v = e->sdrop; w = 5;  break;
        case 6: v = e->dontage; w = 7;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for cmac */
int soc_sbx_g2p3_cmac_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_cmac_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_cmac_t e0;
    soc_sbx_g2p3_cmac_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_CMAC_ID];
    int all = 0;
    soc_sbx_g2p3_6_byte_t imac;
    int ivlan;
    void *indexpointers[2];

    indexpointers[0] = &imac;
    indexpointers[1] = &ivlan;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_cmac_first(unit,
                imac,
                &ivlan);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("unexpected error in iterator first function\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all)
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_cmac_get(unit,
                imac,
                ivlan,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_cmac_print(unit, e);

        if (all) {
            rv = soc_sbx_g2p3_cmac_next(unit,
                imac,
                ivlan,
                imac,
                &ivlan);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for cmac */
int soc_sbx_g2p3_cmac_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_cmac_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_cmac_t e0;
    soc_sbx_g2p3_cmac_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_CMAC_ID];
    soc_sbx_g2p3_6_byte_t imac;
    int ivlan;
    void *indexpointers[2];

    indexpointers[0] = &imac;
    indexpointers[1] = &ivlan;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_cmac_t_init(e);

    rv = soc_sbx_g2p3_cmac_get(unit,
                imac,
                ivlan,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->age,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->pid,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->dcopy,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->dcopycos,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2p3_value_read(&e->ddrop,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g2p3_value_read(&e->sdrop,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g2p3_value_read(&e->dontage,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_cmac_set(unit,
                imac,
                ivlan,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry diag shell delete implementation for cmac */
int soc_sbx_g2p3_cmac_shell_delete(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_cmac_shell_delete(int unit,
         int argc, char **argv)
{
    int rv = 0, rv0;
    int all = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_CMAC_ID];
    soc_sbx_g2p3_6_byte_t imac, nimac;
    int ivlan, nivlan;
    void *indexpointers[2];

    indexpointers[0] = &imac;
    indexpointers[1] = &ivlan;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_cmac_first(unit,
                nimac,
                &nivlan);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("iterator first function failed\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all) {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        if (all) {
            sal_memcpy(imac, nimac, 6);
            ivlan = nivlan;

            rv = soc_sbx_g2p3_cmac_next(unit,
                imac,
                ivlan,
                nimac,
                &nivlan);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
        rv0 = soc_sbx_g2p3_cmac_delete(unit,
                imac,
                ivlan);
        if (rv0) {
            soc_cm_print("delete of %s failed\n", ed->name);
            return rv0;
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry print accessor implementation for bmac */
void soc_sbx_g2p3_bmac_print(int unit, 
    soc_sbx_g2p3_bmac_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_BMAC_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->bsdrop; w = 6;  break;
        case 1: v = e->bpid; w = 4;  break;
        case 2: v = e->btid; w = 4;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for bmac */
int soc_sbx_g2p3_bmac_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_bmac_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_bmac_t e0;
    soc_sbx_g2p3_bmac_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_BMAC_ID];
    int all = 0;
    soc_sbx_g2p3_6_byte_t imac;
    int ivlan;
    void *indexpointers[2];

    indexpointers[0] = &imac;
    indexpointers[1] = &ivlan;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_bmac_first(unit,
                imac,
                &ivlan);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("unexpected error in iterator first function\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all)
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_bmac_get(unit,
                imac,
                ivlan,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_bmac_print(unit, e);

        if (all) {
            rv = soc_sbx_g2p3_bmac_next(unit,
                imac,
                ivlan,
                imac,
                &ivlan);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for bmac */
int soc_sbx_g2p3_bmac_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_bmac_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_bmac_t e0;
    soc_sbx_g2p3_bmac_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_BMAC_ID];
    soc_sbx_g2p3_6_byte_t imac;
    int ivlan;
    void *indexpointers[2];

    indexpointers[0] = &imac;
    indexpointers[1] = &ivlan;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_bmac_t_init(e);

    rv = soc_sbx_g2p3_bmac_get(unit,
                imac,
                ivlan,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->bsdrop,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->bpid,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->btid,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_bmac_set(unit,
                imac,
                ivlan,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry diag shell delete implementation for bmac */
int soc_sbx_g2p3_bmac_shell_delete(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_bmac_shell_delete(int unit,
         int argc, char **argv)
{
    int rv = 0, rv0;
    int all = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_BMAC_ID];
    soc_sbx_g2p3_6_byte_t imac, nimac;
    int ivlan, nivlan;
    void *indexpointers[2];

    indexpointers[0] = &imac;
    indexpointers[1] = &ivlan;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_bmac_first(unit,
                nimac,
                &nivlan);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("iterator first function failed\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all) {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        if (all) {
            sal_memcpy(imac, nimac, 6);
            ivlan = nivlan;

            rv = soc_sbx_g2p3_bmac_next(unit,
                imac,
                ivlan,
                nimac,
                &nivlan);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
        rv0 = soc_sbx_g2p3_bmac_delete(unit,
                imac,
                ivlan);
        if (rv0) {
            soc_cm_print("delete of %s failed\n", ed->name);
            return rv0;
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry print accessor implementation for ipv6mcsg */
void soc_sbx_g2p3_ipv6mcsg_print(int unit, 
    soc_sbx_g2p3_ipv6mcsg_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCSG_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->ftidx; w = 5;  break;
        case 1: v = e->rpfunion; w = 8;  break;
        case 2: v = e->proccopy; w = 8;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ipv6mcsg */
int soc_sbx_g2p3_ipv6mcsg_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv6mcsg_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ipv6mcsg_t e0;
    soc_sbx_g2p3_ipv6mcsg_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCSG_ID];
    int all = 0;
    soc_sbx_g2p3_16_byte_t ig;
    soc_sbx_g2p3_16_byte_t is;
    int ivlan;
    void *indexpointers[3];

    indexpointers[0] = &ig;
    indexpointers[1] = &is;
    indexpointers[2] = &ivlan;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_ipv6mcsg_first(unit,
                ig,
                is,
                &ivlan);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("unexpected error in iterator first function\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all)
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ipv6mcsg_get(unit,
                ig,
                is,
                ivlan,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ipv6mcsg_print(unit, e);

        if (all) {
            rv = soc_sbx_g2p3_ipv6mcsg_next(unit,
                ig,
                is,
                ivlan,
                ig,
                is,
                &ivlan);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ipv6mcsg */
int soc_sbx_g2p3_ipv6mcsg_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ipv6mcsg_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ipv6mcsg_t e0;
    soc_sbx_g2p3_ipv6mcsg_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCSG_ID];
    soc_sbx_g2p3_16_byte_t ig;
    soc_sbx_g2p3_16_byte_t is;
    int ivlan;
    void *indexpointers[3];

    indexpointers[0] = &ig;
    indexpointers[1] = &is;
    indexpointers[2] = &ivlan;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ipv6mcsg_t_init(e);

    rv = soc_sbx_g2p3_ipv6mcsg_get(unit,
                ig,
                is,
                ivlan,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->ftidx,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->rpfunion,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->proccopy,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ipv6mcsg_set(unit,
                ig,
                is,
                ivlan,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry diag shell delete implementation for ipv6mcsg */
int soc_sbx_g2p3_ipv6mcsg_shell_delete(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv6mcsg_shell_delete(int unit,
         int argc, char **argv)
{
    int rv = 0, rv0;
    int all = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCSG_ID];
    soc_sbx_g2p3_16_byte_t ig, nig;
    soc_sbx_g2p3_16_byte_t is, nis;
    int ivlan, nivlan;
    void *indexpointers[3];

    indexpointers[0] = &ig;
    indexpointers[1] = &is;
    indexpointers[2] = &ivlan;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_ipv6mcsg_first(unit,
                nig,
                nis,
                &nivlan);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("iterator first function failed\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all) {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        if (all) {
            sal_memcpy(ig, nig, 16);
            sal_memcpy(is, nis, 16);
            ivlan = nivlan;

            rv = soc_sbx_g2p3_ipv6mcsg_next(unit,
                ig,
                is,
                ivlan,
                nig,
                nis,
                &nivlan);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
        rv0 = soc_sbx_g2p3_ipv6mcsg_delete(unit,
                ig,
                is,
                ivlan);
        if (rv0) {
            soc_cm_print("delete of %s failed\n", ed->name);
            return rv0;
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry print accessor implementation for ipv6mcsgl1 */
void soc_sbx_g2p3_ipv6mcsgl1_print(int unit, 
    soc_sbx_g2p3_ipv6mcsgl1_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCSGL1_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->usemap; w = 6;  break;
        case 1: v = e->pointer; w = 7;  break;
        case 2: v = e->salt; w = 4;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ipv6mcsgl1 */
int soc_sbx_g2p3_ipv6mcsgl1_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv6mcsgl1_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ipv6mcsgl1_t e0;
    soc_sbx_g2p3_ipv6mcsgl1_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCSGL1_ID];
    int il1i;
    void *indexpointers[1];

    indexpointers[0] = &il1i;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ipv6mcsgl1_get(unit,
                il1i,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ipv6mcsgl1_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ipv6mcsgl1 */
int soc_sbx_g2p3_ipv6mcsgl1_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ipv6mcsgl1_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ipv6mcsgl1_t e0;
    soc_sbx_g2p3_ipv6mcsgl1_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCSGL1_ID];
    int il1i;
    void *indexpointers[1];

    indexpointers[0] = &il1i;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ipv6mcsgl1_t_init(e);

    rv = soc_sbx_g2p3_ipv6mcsgl1_get(unit,
                il1i,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->usemap,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->pointer,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->salt,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ipv6mcsgl1_set(unit,
                il1i,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for ipv6mcsgl2 */
void soc_sbx_g2p3_ipv6mcsgl2_print(int unit, 
    soc_sbx_g2p3_ipv6mcsgl2_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCSGL2_ID];

    int j, digits;
    uint8 *s;
    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: s = e->g; w = 1; goto bigfield;
        case 1: s = e->s; w = 1; goto bigfield;
        case 2: v = e->vlan; w = 4;  break;
        case 3: v = e->proccopy; w = 8;  break;
        case 4: v = e->ftidx; w = 5;  break;
        case 5: v = e->rpfunion; w = 8;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
        continue;

    bigfield:
        digits = (width + 7) / 8;
        if ((col + w + 1 + 5 * digits) > 72) {
            soc_cm_print("\n  ");
            col=2;
        }
        soc_cm_print("%s=", fd->name);
        col += w + 1;
        for (j = 0; j < digits; j++) {
            soc_cm_print("0x%02x ", s[digits - j - 1]);
            col += 5;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ipv6mcsgl2 */
int soc_sbx_g2p3_ipv6mcsgl2_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv6mcsgl2_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ipv6mcsgl2_t e0;
    soc_sbx_g2p3_ipv6mcsgl2_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCSGL2_ID];
    int imcgi;
    void *indexpointers[1];

    indexpointers[0] = &imcgi;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ipv6mcsgl2_get(unit,
                imcgi,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ipv6mcsgl2_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ipv6mcsgl2 */
int soc_sbx_g2p3_ipv6mcsgl2_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ipv6mcsgl2_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ipv6mcsgl2_t e0;
    soc_sbx_g2p3_ipv6mcsgl2_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCSGL2_ID];
    int imcgi;
    void *indexpointers[1];

    indexpointers[0] = &imcgi;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ipv6mcsgl2_t_init(e);

    rv = soc_sbx_g2p3_ipv6mcsgl2_get(unit,
                imcgi,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_big_value_read(e->g,
                                ed->fields[0].width, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_big_value_read(e->s,
                                ed->fields[1].width, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->vlan,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->proccopy,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2p3_value_read(&e->ftidx,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g2p3_value_read(&e->rpfunion,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ipv6mcsgl2_set(unit,
                imcgi,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for ipv6mcg */
void soc_sbx_g2p3_ipv6mcg_print(int unit, 
    soc_sbx_g2p3_ipv6mcg_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCG_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->ftidx; w = 5;  break;
        case 1: v = e->rpfunion; w = 8;  break;
        case 2: v = e->proccopy; w = 8;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ipv6mcg */
int soc_sbx_g2p3_ipv6mcg_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv6mcg_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ipv6mcg_t e0;
    soc_sbx_g2p3_ipv6mcg_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCG_ID];
    int all = 0;
    soc_sbx_g2p3_16_byte_t ig;
    int ivlan;
    void *indexpointers[2];

    indexpointers[0] = &ig;
    indexpointers[1] = &ivlan;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_ipv6mcg_first(unit,
                ig,
                &ivlan);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("unexpected error in iterator first function\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all)
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ipv6mcg_get(unit,
                ig,
                ivlan,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ipv6mcg_print(unit, e);

        if (all) {
            rv = soc_sbx_g2p3_ipv6mcg_next(unit,
                ig,
                ivlan,
                ig,
                &ivlan);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ipv6mcg */
int soc_sbx_g2p3_ipv6mcg_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ipv6mcg_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ipv6mcg_t e0;
    soc_sbx_g2p3_ipv6mcg_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCG_ID];
    soc_sbx_g2p3_16_byte_t ig;
    int ivlan;
    void *indexpointers[2];

    indexpointers[0] = &ig;
    indexpointers[1] = &ivlan;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ipv6mcg_t_init(e);

    rv = soc_sbx_g2p3_ipv6mcg_get(unit,
                ig,
                ivlan,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->ftidx,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->rpfunion,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->proccopy,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ipv6mcg_set(unit,
                ig,
                ivlan,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry diag shell delete implementation for ipv6mcg */
int soc_sbx_g2p3_ipv6mcg_shell_delete(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv6mcg_shell_delete(int unit,
         int argc, char **argv)
{
    int rv = 0, rv0;
    int all = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCG_ID];
    soc_sbx_g2p3_16_byte_t ig, nig;
    int ivlan, nivlan;
    void *indexpointers[2];

    indexpointers[0] = &ig;
    indexpointers[1] = &ivlan;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_ipv6mcg_first(unit,
                nig,
                &nivlan);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("iterator first function failed\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all) {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        if (all) {
            sal_memcpy(ig, nig, 16);
            ivlan = nivlan;

            rv = soc_sbx_g2p3_ipv6mcg_next(unit,
                ig,
                ivlan,
                nig,
                &nivlan);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
        rv0 = soc_sbx_g2p3_ipv6mcg_delete(unit,
                ig,
                ivlan);
        if (rv0) {
            soc_cm_print("delete of %s failed\n", ed->name);
            return rv0;
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry print accessor implementation for ipv6mcgl1 */
void soc_sbx_g2p3_ipv6mcgl1_print(int unit, 
    soc_sbx_g2p3_ipv6mcgl1_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCGL1_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->usemap; w = 6;  break;
        case 1: v = e->pointer; w = 7;  break;
        case 2: v = e->salt; w = 4;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ipv6mcgl1 */
int soc_sbx_g2p3_ipv6mcgl1_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv6mcgl1_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ipv6mcgl1_t e0;
    soc_sbx_g2p3_ipv6mcgl1_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCGL1_ID];
    int il1i;
    void *indexpointers[1];

    indexpointers[0] = &il1i;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ipv6mcgl1_get(unit,
                il1i,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ipv6mcgl1_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ipv6mcgl1 */
int soc_sbx_g2p3_ipv6mcgl1_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ipv6mcgl1_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ipv6mcgl1_t e0;
    soc_sbx_g2p3_ipv6mcgl1_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCGL1_ID];
    int il1i;
    void *indexpointers[1];

    indexpointers[0] = &il1i;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ipv6mcgl1_t_init(e);

    rv = soc_sbx_g2p3_ipv6mcgl1_get(unit,
                il1i,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->usemap,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->pointer,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->salt,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ipv6mcgl1_set(unit,
                il1i,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for ipv6mcgl2 */
void soc_sbx_g2p3_ipv6mcgl2_print(int unit, 
    soc_sbx_g2p3_ipv6mcgl2_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCGL2_ID];

    int j, digits;
    uint8 *s;
    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: s = e->g; w = 1; goto bigfield;
        case 1: v = e->ftidx; w = 5;  break;
        case 2: v = e->rpfunion; w = 8;  break;
        case 3: v = e->vlan; w = 4;  break;
        case 4: v = e->proccopy; w = 8;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
        continue;

    bigfield:
        digits = (width + 7) / 8;
        if ((col + w + 1 + 5 * digits) > 72) {
            soc_cm_print("\n  ");
            col=2;
        }
        soc_cm_print("%s=", fd->name);
        col += w + 1;
        for (j = 0; j < digits; j++) {
            soc_cm_print("0x%02x ", s[digits - j - 1]);
            col += 5;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ipv6mcgl2 */
int soc_sbx_g2p3_ipv6mcgl2_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv6mcgl2_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ipv6mcgl2_t e0;
    soc_sbx_g2p3_ipv6mcgl2_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCGL2_ID];
    int imcgi;
    void *indexpointers[1];

    indexpointers[0] = &imcgi;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ipv6mcgl2_get(unit,
                imcgi,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ipv6mcgl2_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ipv6mcgl2 */
int soc_sbx_g2p3_ipv6mcgl2_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ipv6mcgl2_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ipv6mcgl2_t e0;
    soc_sbx_g2p3_ipv6mcgl2_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6MCGL2_ID];
    int imcgi;
    void *indexpointers[1];

    indexpointers[0] = &imcgi;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ipv6mcgl2_t_init(e);

    rv = soc_sbx_g2p3_ipv6mcgl2_get(unit,
                imcgi,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_big_value_read(e->g,
                                ed->fields[0].width, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->ftidx,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->rpfunion,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->vlan,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2p3_value_read(&e->proccopy,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ipv6mcgl2_set(unit,
                imcgi,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for ipv4mcg */
void soc_sbx_g2p3_ipv4mcg_print(int unit, 
    soc_sbx_g2p3_ipv4mcg_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCG_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->ftidx; w = 5;  break;
        case 1: v = e->rpfunion; w = 8;  break;
        case 2: v = e->proccopy; w = 8;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ipv4mcg */
int soc_sbx_g2p3_ipv4mcg_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv4mcg_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ipv4mcg_t e0;
    soc_sbx_g2p3_ipv4mcg_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCG_ID];
    int all = 0;
    int ig;
    int ivlan;
    void *indexpointers[2];

    indexpointers[0] = &ig;
    indexpointers[1] = &ivlan;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_ipv4mcg_first(unit,
                &ig,
                &ivlan);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("unexpected error in iterator first function\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all)
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ipv4mcg_get(unit,
                ig,
                ivlan,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ipv4mcg_print(unit, e);

        if (all) {
            rv = soc_sbx_g2p3_ipv4mcg_next(unit,
                ig,
                ivlan,
                &ig,
                &ivlan);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ipv4mcg */
int soc_sbx_g2p3_ipv4mcg_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ipv4mcg_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ipv4mcg_t e0;
    soc_sbx_g2p3_ipv4mcg_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCG_ID];
    int ig;
    int ivlan;
    void *indexpointers[2];

    indexpointers[0] = &ig;
    indexpointers[1] = &ivlan;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ipv4mcg_t_init(e);

    rv = soc_sbx_g2p3_ipv4mcg_get(unit,
                ig,
                ivlan,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->ftidx,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->rpfunion,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->proccopy,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ipv4mcg_set(unit,
                ig,
                ivlan,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry diag shell delete implementation for ipv4mcg */
int soc_sbx_g2p3_ipv4mcg_shell_delete(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv4mcg_shell_delete(int unit,
         int argc, char **argv)
{
    int rv = 0, rv0;
    int all = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCG_ID];
    int ig, nig;
    int ivlan, nivlan;
    void *indexpointers[2];

    indexpointers[0] = &ig;
    indexpointers[1] = &ivlan;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_ipv4mcg_first(unit,
                &nig,
                &nivlan);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("iterator first function failed\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all) {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        if (all) {
            ig = nig;
            ivlan = nivlan;

            rv = soc_sbx_g2p3_ipv4mcg_next(unit,
                ig,
                ivlan,
                &nig,
                &nivlan);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
        rv0 = soc_sbx_g2p3_ipv4mcg_delete(unit,
                ig,
                ivlan);
        if (rv0) {
            soc_cm_print("delete of %s failed\n", ed->name);
            return rv0;
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry print accessor implementation for ipv4mcgl1 */
void soc_sbx_g2p3_ipv4mcgl1_print(int unit, 
    soc_sbx_g2p3_ipv4mcgl1_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCGL1_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->usemap; w = 6;  break;
        case 1: v = e->pointer; w = 7;  break;
        case 2: v = e->salt; w = 4;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ipv4mcgl1 */
int soc_sbx_g2p3_ipv4mcgl1_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv4mcgl1_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ipv4mcgl1_t e0;
    soc_sbx_g2p3_ipv4mcgl1_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCGL1_ID];
    int il1i;
    void *indexpointers[1];

    indexpointers[0] = &il1i;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ipv4mcgl1_get(unit,
                il1i,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ipv4mcgl1_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ipv4mcgl1 */
int soc_sbx_g2p3_ipv4mcgl1_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ipv4mcgl1_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ipv4mcgl1_t e0;
    soc_sbx_g2p3_ipv4mcgl1_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCGL1_ID];
    int il1i;
    void *indexpointers[1];

    indexpointers[0] = &il1i;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ipv4mcgl1_t_init(e);

    rv = soc_sbx_g2p3_ipv4mcgl1_get(unit,
                il1i,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->usemap,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->pointer,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->salt,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ipv4mcgl1_set(unit,
                il1i,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for ipv4mcgl2 */
void soc_sbx_g2p3_ipv4mcgl2_print(int unit, 
    soc_sbx_g2p3_ipv4mcgl2_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCGL2_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->g; w = 1;  break;
        case 1: v = e->ftidx; w = 5;  break;
        case 2: v = e->rpfunion; w = 8;  break;
        case 3: v = e->vlan; w = 4;  break;
        case 4: v = e->proccopy; w = 8;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ipv4mcgl2 */
int soc_sbx_g2p3_ipv4mcgl2_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv4mcgl2_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ipv4mcgl2_t e0;
    soc_sbx_g2p3_ipv4mcgl2_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCGL2_ID];
    int imcgi;
    void *indexpointers[1];

    indexpointers[0] = &imcgi;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ipv4mcgl2_get(unit,
                imcgi,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ipv4mcgl2_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ipv4mcgl2 */
int soc_sbx_g2p3_ipv4mcgl2_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ipv4mcgl2_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ipv4mcgl2_t e0;
    soc_sbx_g2p3_ipv4mcgl2_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCGL2_ID];
    int imcgi;
    void *indexpointers[1];

    indexpointers[0] = &imcgi;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ipv4mcgl2_t_init(e);

    rv = soc_sbx_g2p3_ipv4mcgl2_get(unit,
                imcgi,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->g,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->ftidx,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->rpfunion,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->vlan,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2p3_value_read(&e->proccopy,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ipv4mcgl2_set(unit,
                imcgi,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for ipv4mcsg */
void soc_sbx_g2p3_ipv4mcsg_print(int unit, 
    soc_sbx_g2p3_ipv4mcsg_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCSG_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->ftidx; w = 5;  break;
        case 1: v = e->rpfunion; w = 8;  break;
        case 2: v = e->proccopy; w = 8;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ipv4mcsg */
int soc_sbx_g2p3_ipv4mcsg_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv4mcsg_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ipv4mcsg_t e0;
    soc_sbx_g2p3_ipv4mcsg_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCSG_ID];
    int all = 0;
    int ig;
    int is;
    int ivlan;
    void *indexpointers[3];

    indexpointers[0] = &ig;
    indexpointers[1] = &is;
    indexpointers[2] = &ivlan;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_ipv4mcsg_first(unit,
                &ig,
                &is,
                &ivlan);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("unexpected error in iterator first function\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all)
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ipv4mcsg_get(unit,
                ig,
                is,
                ivlan,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ipv4mcsg_print(unit, e);

        if (all) {
            rv = soc_sbx_g2p3_ipv4mcsg_next(unit,
                ig,
                is,
                ivlan,
                &ig,
                &is,
                &ivlan);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ipv4mcsg */
int soc_sbx_g2p3_ipv4mcsg_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ipv4mcsg_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ipv4mcsg_t e0;
    soc_sbx_g2p3_ipv4mcsg_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCSG_ID];
    int ig;
    int is;
    int ivlan;
    void *indexpointers[3];

    indexpointers[0] = &ig;
    indexpointers[1] = &is;
    indexpointers[2] = &ivlan;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ipv4mcsg_t_init(e);

    rv = soc_sbx_g2p3_ipv4mcsg_get(unit,
                ig,
                is,
                ivlan,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->ftidx,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->rpfunion,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->proccopy,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ipv4mcsg_set(unit,
                ig,
                is,
                ivlan,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry diag shell delete implementation for ipv4mcsg */
int soc_sbx_g2p3_ipv4mcsg_shell_delete(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv4mcsg_shell_delete(int unit,
         int argc, char **argv)
{
    int rv = 0, rv0;
    int all = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCSG_ID];
    int ig, nig;
    int is, nis;
    int ivlan, nivlan;
    void *indexpointers[3];

    indexpointers[0] = &ig;
    indexpointers[1] = &is;
    indexpointers[2] = &ivlan;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_ipv4mcsg_first(unit,
                &nig,
                &nis,
                &nivlan);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("iterator first function failed\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all) {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        if (all) {
            ig = nig;
            is = nis;
            ivlan = nivlan;

            rv = soc_sbx_g2p3_ipv4mcsg_next(unit,
                ig,
                is,
                ivlan,
                &nig,
                &nis,
                &nivlan);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
        rv0 = soc_sbx_g2p3_ipv4mcsg_delete(unit,
                ig,
                is,
                ivlan);
        if (rv0) {
            soc_cm_print("delete of %s failed\n", ed->name);
            return rv0;
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry print accessor implementation for ipv4mcsgl1 */
void soc_sbx_g2p3_ipv4mcsgl1_print(int unit, 
    soc_sbx_g2p3_ipv4mcsgl1_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCSGL1_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->usemap; w = 6;  break;
        case 1: v = e->pointer; w = 7;  break;
        case 2: v = e->salt; w = 4;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ipv4mcsgl1 */
int soc_sbx_g2p3_ipv4mcsgl1_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv4mcsgl1_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ipv4mcsgl1_t e0;
    soc_sbx_g2p3_ipv4mcsgl1_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCSGL1_ID];
    int il1i;
    void *indexpointers[1];

    indexpointers[0] = &il1i;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ipv4mcsgl1_get(unit,
                il1i,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ipv4mcsgl1_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ipv4mcsgl1 */
int soc_sbx_g2p3_ipv4mcsgl1_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ipv4mcsgl1_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ipv4mcsgl1_t e0;
    soc_sbx_g2p3_ipv4mcsgl1_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCSGL1_ID];
    int il1i;
    void *indexpointers[1];

    indexpointers[0] = &il1i;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ipv4mcsgl1_t_init(e);

    rv = soc_sbx_g2p3_ipv4mcsgl1_get(unit,
                il1i,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->usemap,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->pointer,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->salt,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ipv4mcsgl1_set(unit,
                il1i,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for ipv4mcsgl2 */
void soc_sbx_g2p3_ipv4mcsgl2_print(int unit, 
    soc_sbx_g2p3_ipv4mcsgl2_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCSGL2_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->g; w = 1;  break;
        case 1: v = e->s; w = 1;  break;
        case 2: v = e->ftidx; w = 5;  break;
        case 3: v = e->rpfunion; w = 8;  break;
        case 4: v = e->vlan; w = 4;  break;
        case 5: v = e->proccopy; w = 8;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ipv4mcsgl2 */
int soc_sbx_g2p3_ipv4mcsgl2_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv4mcsgl2_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ipv4mcsgl2_t e0;
    soc_sbx_g2p3_ipv4mcsgl2_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCSGL2_ID];
    int imcgi;
    void *indexpointers[1];

    indexpointers[0] = &imcgi;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ipv4mcsgl2_get(unit,
                imcgi,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ipv4mcsgl2_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ipv4mcsgl2 */
int soc_sbx_g2p3_ipv4mcsgl2_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ipv4mcsgl2_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ipv4mcsgl2_t e0;
    soc_sbx_g2p3_ipv4mcsgl2_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4MCSGL2_ID];
    int imcgi;
    void *indexpointers[1];

    indexpointers[0] = &imcgi;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ipv4mcsgl2_t_init(e);

    rv = soc_sbx_g2p3_ipv4mcsgl2_get(unit,
                imcgi,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->g,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->s,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->ftidx,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->rpfunion,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2p3_value_read(&e->vlan,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g2p3_value_read(&e->proccopy,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ipv4mcsgl2_set(unit,
                imcgi,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for lpmnode */
void soc_sbx_g2p3_lpmnode_print(int unit, 
    soc_sbx_g2p3_lpmnode_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_LPMNODE_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->pattern; w = 7;  break;
        case 1: v = e->singleton; w = 9;  break;
        case 2: v = e->pointer; w = 7;  break;
        case 3: v = e->leaf; w = 4;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry print accessor implementation for ipv4sa */
void soc_sbx_g2p3_ipv4sa_print(int unit, 
    soc_sbx_g2p3_ipv4sa_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SA_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->poe; w = 3;  break;
        case 1: v = e->rpfmode; w = 7;  break;
        case 2: v = e->srcdrop; w = 7;  break;
        case 3: v = e->srccnt; w = 6;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ipv4sa */
int soc_sbx_g2p3_ipv4sa_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv4sa_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ipv4sa_t e0;
    soc_sbx_g2p3_ipv4sa_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SA_ID];
    int all = 0;
    int iprefixbits;
    int iip;
    int iipcxt;
    void *indexpointers[3];

    indexpointers[0] = &iprefixbits;
    indexpointers[1] = &iip;
    indexpointers[2] = &iipcxt;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_ipv4sa_first(unit,
                &iprefixbits,
                &iip,
                &iipcxt);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("unexpected error in iterator first function\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all)
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ipv4sa_get(unit,
                iprefixbits,
                iip,
                iipcxt,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ipv4sa_print(unit, e);

        if (all) {
            rv = soc_sbx_g2p3_ipv4sa_next(unit,
                iprefixbits,
                iip,
                iipcxt,
                &iprefixbits,
                &iip,
                &iipcxt);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ipv4sa */
int soc_sbx_g2p3_ipv4sa_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ipv4sa_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ipv4sa_t e0;
    soc_sbx_g2p3_ipv4sa_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SA_ID];
    int iprefixbits;
    int iip;
    int iipcxt;
    void *indexpointers[3];

    indexpointers[0] = &iprefixbits;
    indexpointers[1] = &iip;
    indexpointers[2] = &iipcxt;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ipv4sa_t_init(e);

    rv = soc_sbx_g2p3_ipv4sa_get(unit,
                iprefixbits,
                iip,
                iipcxt,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->poe,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->rpfmode,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->srcdrop,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->srccnt,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ipv4sa_set(unit,
                iprefixbits,
                iip,
                iipcxt,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry diag shell delete implementation for ipv4sa */
int soc_sbx_g2p3_ipv4sa_shell_delete(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv4sa_shell_delete(int unit,
         int argc, char **argv)
{
    int rv = 0, rv0;
    int all = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SA_ID];
    int iprefixbits, niprefixbits;
    int iip, niip;
    int iipcxt, niipcxt;
    void *indexpointers[3];

    indexpointers[0] = &iprefixbits;
    indexpointers[1] = &iip;
    indexpointers[2] = &iipcxt;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_ipv4sa_first(unit,
                &niprefixbits,
                &niip,
                &niipcxt);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("iterator first function failed\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all) {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        if (all) {
            iprefixbits = niprefixbits;
            iip = niip;
            iipcxt = niipcxt;

            rv = soc_sbx_g2p3_ipv4sa_next(unit,
                iprefixbits,
                iip,
                iipcxt,
                &niprefixbits,
                &niip,
                &niipcxt);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
        rv0 = soc_sbx_g2p3_ipv4sa_delete(unit,
                iprefixbits,
                iip,
                iipcxt);
        if (rv0) {
            soc_cm_print("delete of %s failed\n", ed->name);
            return rv0;
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry print accessor implementation for ipv4sal0 */
void soc_sbx_g2p3_ipv4sal0_print(int unit, 
    soc_sbx_g2p3_ipv4sal0_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SAL0_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->pattern; w = 7;  break;
        case 1: v = e->singleton; w = 9;  break;
        case 2: v = e->pointer; w = 7;  break;
        case 3: v = e->leaf; w = 4;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ipv4sal0 */
int soc_sbx_g2p3_ipv4sal0_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv4sal0_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ipv4sal0_t e0;
    soc_sbx_g2p3_ipv4sal0_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SAL0_ID];
    int iaddr;
    void *indexpointers[1];

    indexpointers[0] = &iaddr;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ipv4sal0_get(unit,
                iaddr,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ipv4sal0_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ipv4sal0 */
int soc_sbx_g2p3_ipv4sal0_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ipv4sal0_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ipv4sal0_t e0;
    soc_sbx_g2p3_ipv4sal0_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SAL0_ID];
    int iaddr;
    void *indexpointers[1];

    indexpointers[0] = &iaddr;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ipv4sal0_t_init(e);

    rv = soc_sbx_g2p3_ipv4sal0_get(unit,
                iaddr,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->pattern,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->singleton,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->pointer,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->leaf,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ipv4sal0_set(unit,
                iaddr,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for ipv4saodd */
void soc_sbx_g2p3_ipv4saodd_print(int unit, 
    soc_sbx_g2p3_ipv4saodd_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SAODD_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->pattern; w = 7;  break;
        case 1: v = e->singleton; w = 9;  break;
        case 2: v = e->pointer; w = 7;  break;
        case 3: v = e->leaf; w = 4;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ipv4saodd */
int soc_sbx_g2p3_ipv4saodd_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv4saodd_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ipv4saodd_t e0;
    soc_sbx_g2p3_ipv4saodd_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SAODD_ID];
    int iaddr;
    void *indexpointers[1];

    indexpointers[0] = &iaddr;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ipv4saodd_get(unit,
                iaddr,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ipv4saodd_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ipv4saodd */
int soc_sbx_g2p3_ipv4saodd_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ipv4saodd_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ipv4saodd_t e0;
    soc_sbx_g2p3_ipv4saodd_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SAODD_ID];
    int iaddr;
    void *indexpointers[1];

    indexpointers[0] = &iaddr;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ipv4saodd_t_init(e);

    rv = soc_sbx_g2p3_ipv4saodd_get(unit,
                iaddr,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->pattern,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->singleton,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->pointer,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->leaf,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ipv4saodd_set(unit,
                iaddr,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for ipv4saeven */
void soc_sbx_g2p3_ipv4saeven_print(int unit, 
    soc_sbx_g2p3_ipv4saeven_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SAEVEN_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->pattern; w = 7;  break;
        case 1: v = e->singleton; w = 9;  break;
        case 2: v = e->pointer; w = 7;  break;
        case 3: v = e->leaf; w = 4;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ipv4saeven */
int soc_sbx_g2p3_ipv4saeven_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv4saeven_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ipv4saeven_t e0;
    soc_sbx_g2p3_ipv4saeven_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SAEVEN_ID];
    int iaddr;
    void *indexpointers[1];

    indexpointers[0] = &iaddr;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ipv4saeven_get(unit,
                iaddr,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ipv4saeven_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ipv4saeven */
int soc_sbx_g2p3_ipv4saeven_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ipv4saeven_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ipv4saeven_t e0;
    soc_sbx_g2p3_ipv4saeven_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SAEVEN_ID];
    int iaddr;
    void *indexpointers[1];

    indexpointers[0] = &iaddr;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ipv4saeven_t_init(e);

    rv = soc_sbx_g2p3_ipv4saeven_get(unit,
                iaddr,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->pattern,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->singleton,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->pointer,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->leaf,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ipv4saeven_set(unit,
                iaddr,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for ipv4sapayload */
void soc_sbx_g2p3_ipv4sapayload_print(int unit, 
    soc_sbx_g2p3_ipv4sapayload_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SAPAYLOAD_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->poe; w = 3;  break;
        case 1: v = e->rpfmode; w = 7;  break;
        case 2: v = e->srcdrop; w = 7;  break;
        case 3: v = e->srccnt; w = 6;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ipv4sapayload */
int soc_sbx_g2p3_ipv4sapayload_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv4sapayload_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ipv4sapayload_t e0;
    soc_sbx_g2p3_ipv4sapayload_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SAPAYLOAD_ID];
    int iaddr;
    void *indexpointers[1];

    indexpointers[0] = &iaddr;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ipv4sapayload_get(unit,
                iaddr,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ipv4sapayload_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ipv4sapayload */
int soc_sbx_g2p3_ipv4sapayload_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ipv4sapayload_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ipv4sapayload_t e0;
    soc_sbx_g2p3_ipv4sapayload_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4SAPAYLOAD_ID];
    int iaddr;
    void *indexpointers[1];

    indexpointers[0] = &iaddr;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ipv4sapayload_t_init(e);

    rv = soc_sbx_g2p3_ipv4sapayload_get(unit,
                iaddr,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->poe,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->rpfmode,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->srcdrop,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->srccnt,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ipv4sapayload_set(unit,
                iaddr,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for ifp */
void soc_sbx_g2p3_ifp_print(int unit, 
    soc_sbx_g2p3_ifp_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IFP_ID];

    int j, digits;
    uint8 *s;
    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->dbtype; w = 6;  break;
        case 1: v = e->usedbtype; w = 9;  break;
        case 2: v = e->port; w = 4;  break;
        case 3: v = e->useport; w = 7;  break;
        case 4: s = e->pbmpn; w = 5; goto bigfield;
        case 5: v = e->pri; w = 3;  break;
        case 6: v = e->usepri; w = 6;  break;
        case 7: v = e->fragment; w = 8;  break;
        case 8: v = e->usefragment; w = 11;  break;
        case 9: v = e->urg; w = 3;  break;
        case 10: v = e->useurg; w = 6;  break;
        case 11: v = e->ack; w = 3;  break;
        case 12: v = e->useack; w = 6;  break;
        case 13: v = e->psh; w = 3;  break;
        case 14: v = e->usepsh; w = 6;  break;
        case 15: v = e->rst; w = 3;  break;
        case 16: v = e->userst; w = 6;  break;
        case 17: v = e->syn; w = 3;  break;
        case 18: v = e->usesyn; w = 6;  break;
        case 19: v = e->fin; w = 3;  break;
        case 20: v = e->usefin; w = 6;  break;
        case 21: v = e->dscp; w = 4;  break;
        case 22: v = e->usedscp; w = 7;  break;
        case 23: v = e->ecn; w = 3;  break;
        case 24: v = e->useecn; w = 6;  break;
        case 25: v = e->proto; w = 5;  break;
        case 26: v = e->useproto; w = 8;  break;
        case 27: v = e->sporthi; w = 7;  break;
        case 28: v = e->sportlo; w = 7;  break;
        case 29: v = e->dporthi; w = 7;  break;
        case 30: v = e->dportlo; w = 7;  break;
        case 31: v = e->sa; w = 2;  break;
        case 32: v = e->sawidth; w = 7;  break;
        case 33: v = e->da; w = 2;  break;
        case 34: v = e->dawidth; w = 7;  break;
        case 35: v = e->etype; w = 5;  break;
        case 36: v = e->useetype; w = 8;  break;
        case 37: s = e->smac; w = 4; goto bigfield;
        case 38: v = e->smacwidth; w = 9;  break;
        case 39: s = e->dmac; w = 4; goto bigfield;
        case 40: v = e->dmacwidth; w = 9;  break;
        case 41: v = e->vid; w = 3;  break;
        case 42: v = e->usevid; w = 6;  break;
        case 43: v = e->ssaphi; w = 6;  break;
        case 44: v = e->ssaplo; w = 6;  break;
        case 45: v = e->usessap; w = 7;  break;
        case 46: v = e->dsaphi; w = 6;  break;
        case 47: v = e->dsaplo; w = 6;  break;
        case 48: v = e->usedsap; w = 7;  break;
        case 49: v = e->llcctrlhi; w = 9;  break;
        case 50: v = e->llcctrllo; w = 9;  break;
        case 51: v = e->usellcctrl; w = 10;  break;
        case 52: v = e->enable; w = 6;  break;
        case 53: v = e->vlan; w = 4;  break;
        case 54: v = e->ftidx; w = 5;  break;
        case 55: v = e->mirror; w = 6;  break;
        case 56: v = e->usevlan; w = 7;  break;
        case 57: v = e->useftidx; w = 8;  break;
        case 58: v = e->copy; w = 4;  break;
        case 59: v = e->dp; w = 2;  break;
        case 60: v = e->cos; w = 3;  break;
        case 61: v = e->fcos; w = 4;  break;
        case 62: v = e->usedp; w = 5;  break;
        case 63: v = e->usecos; w = 6;  break;
        case 64: v = e->policer; w = 7;  break;
        case 65: v = e->typedpolice; w = 11;  break;
        case 66: v = e->mefcos; w = 6;  break;
        case 67: v = e->mef; w = 3;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
        continue;

    bigfield:
        digits = (width + 7) / 8;
        if ((col + w + 1 + 5 * digits) > 72) {
            soc_cm_print("\n  ");
            col=2;
        }
        soc_cm_print("%s=", fd->name);
        col += w + 1;
        for (j = 0; j < digits; j++) {
            soc_cm_print("0x%02x ", s[digits - j - 1]);
            col += 5;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ifp */
int soc_sbx_g2p3_ifp_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ifp_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ifp_t e0;
    soc_sbx_g2p3_ifp_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IFP_ID];
    int all = 0;
    int irule;
    void *indexpointers[1];

    indexpointers[0] = &irule;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_ifp_first(unit,
                &irule);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("unexpected error in iterator first function\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all)
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ifp_get(unit,
                irule,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ifp_print(unit, e);

        if (all) {
            rv = soc_sbx_g2p3_ifp_next(unit,
                irule,
                &irule);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ifp */
int soc_sbx_g2p3_ifp_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ifp_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ifp_t e0;
    soc_sbx_g2p3_ifp_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IFP_ID];
    int irule;
    void *indexpointers[1];

    indexpointers[0] = &irule;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ifp_t_init(e);

    rv = soc_sbx_g2p3_ifp_get(unit,
                irule,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->dbtype,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->usedbtype,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->port,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->useport,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2p3_big_value_read(e->pbmpn,
                                ed->fields[4].width, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g2p3_value_read(&e->pri,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g2p3_value_read(&e->usepri,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g2p3_value_read(&e->fragment,
                                ed->fields[7].range, 0, argc, argv);
                 break;
        case 8: rv = soc_sbx_g2p3_value_read(&e->usefragment,
                                ed->fields[8].range, 0, argc, argv);
                 break;
        case 9: rv = soc_sbx_g2p3_value_read(&e->urg,
                                ed->fields[9].range, 0, argc, argv);
                 break;
        case 10: rv = soc_sbx_g2p3_value_read(&e->useurg,
                                ed->fields[10].range, 0, argc, argv);
                 break;
        case 11: rv = soc_sbx_g2p3_value_read(&e->ack,
                                ed->fields[11].range, 0, argc, argv);
                 break;
        case 12: rv = soc_sbx_g2p3_value_read(&e->useack,
                                ed->fields[12].range, 0, argc, argv);
                 break;
        case 13: rv = soc_sbx_g2p3_value_read(&e->psh,
                                ed->fields[13].range, 0, argc, argv);
                 break;
        case 14: rv = soc_sbx_g2p3_value_read(&e->usepsh,
                                ed->fields[14].range, 0, argc, argv);
                 break;
        case 15: rv = soc_sbx_g2p3_value_read(&e->rst,
                                ed->fields[15].range, 0, argc, argv);
                 break;
        case 16: rv = soc_sbx_g2p3_value_read(&e->userst,
                                ed->fields[16].range, 0, argc, argv);
                 break;
        case 17: rv = soc_sbx_g2p3_value_read(&e->syn,
                                ed->fields[17].range, 0, argc, argv);
                 break;
        case 18: rv = soc_sbx_g2p3_value_read(&e->usesyn,
                                ed->fields[18].range, 0, argc, argv);
                 break;
        case 19: rv = soc_sbx_g2p3_value_read(&e->fin,
                                ed->fields[19].range, 0, argc, argv);
                 break;
        case 20: rv = soc_sbx_g2p3_value_read(&e->usefin,
                                ed->fields[20].range, 0, argc, argv);
                 break;
        case 21: rv = soc_sbx_g2p3_value_read(&e->dscp,
                                ed->fields[21].range, 0, argc, argv);
                 break;
        case 22: rv = soc_sbx_g2p3_value_read(&e->usedscp,
                                ed->fields[22].range, 0, argc, argv);
                 break;
        case 23: rv = soc_sbx_g2p3_value_read(&e->ecn,
                                ed->fields[23].range, 0, argc, argv);
                 break;
        case 24: rv = soc_sbx_g2p3_value_read(&e->useecn,
                                ed->fields[24].range, 0, argc, argv);
                 break;
        case 25: rv = soc_sbx_g2p3_value_read(&e->proto,
                                ed->fields[25].range, 0, argc, argv);
                 break;
        case 26: rv = soc_sbx_g2p3_value_read(&e->useproto,
                                ed->fields[26].range, 0, argc, argv);
                 break;
        case 27: rv = soc_sbx_g2p3_value_read(&e->sporthi,
                                ed->fields[27].range, 0, argc, argv);
                 break;
        case 28: rv = soc_sbx_g2p3_value_read(&e->sportlo,
                                ed->fields[28].range, 0, argc, argv);
                 break;
        case 29: rv = soc_sbx_g2p3_value_read(&e->dporthi,
                                ed->fields[29].range, 0, argc, argv);
                 break;
        case 30: rv = soc_sbx_g2p3_value_read(&e->dportlo,
                                ed->fields[30].range, 0, argc, argv);
                 break;
        case 31: rv = soc_sbx_g2p3_value_read(&e->sa,
                                ed->fields[31].range, 0, argc, argv);
                 break;
        case 32: rv = soc_sbx_g2p3_value_read(&e->sawidth,
                                ed->fields[32].range, 0, argc, argv);
                 break;
        case 33: rv = soc_sbx_g2p3_value_read(&e->da,
                                ed->fields[33].range, 0, argc, argv);
                 break;
        case 34: rv = soc_sbx_g2p3_value_read(&e->dawidth,
                                ed->fields[34].range, 0, argc, argv);
                 break;
        case 35: rv = soc_sbx_g2p3_value_read(&e->etype,
                                ed->fields[35].range, 0, argc, argv);
                 break;
        case 36: rv = soc_sbx_g2p3_value_read(&e->useetype,
                                ed->fields[36].range, 0, argc, argv);
                 break;
        case 37: rv = soc_sbx_g2p3_big_value_read(e->smac,
                                ed->fields[37].width, 0, argc, argv);
                 break;
        case 38: rv = soc_sbx_g2p3_value_read(&e->smacwidth,
                                ed->fields[38].range, 0, argc, argv);
                 break;
        case 39: rv = soc_sbx_g2p3_big_value_read(e->dmac,
                                ed->fields[39].width, 0, argc, argv);
                 break;
        case 40: rv = soc_sbx_g2p3_value_read(&e->dmacwidth,
                                ed->fields[40].range, 0, argc, argv);
                 break;
        case 41: rv = soc_sbx_g2p3_value_read(&e->vid,
                                ed->fields[41].range, 0, argc, argv);
                 break;
        case 42: rv = soc_sbx_g2p3_value_read(&e->usevid,
                                ed->fields[42].range, 0, argc, argv);
                 break;
        case 43: rv = soc_sbx_g2p3_value_read(&e->ssaphi,
                                ed->fields[43].range, 0, argc, argv);
                 break;
        case 44: rv = soc_sbx_g2p3_value_read(&e->ssaplo,
                                ed->fields[44].range, 0, argc, argv);
                 break;
        case 45: rv = soc_sbx_g2p3_value_read(&e->usessap,
                                ed->fields[45].range, 0, argc, argv);
                 break;
        case 46: rv = soc_sbx_g2p3_value_read(&e->dsaphi,
                                ed->fields[46].range, 0, argc, argv);
                 break;
        case 47: rv = soc_sbx_g2p3_value_read(&e->dsaplo,
                                ed->fields[47].range, 0, argc, argv);
                 break;
        case 48: rv = soc_sbx_g2p3_value_read(&e->usedsap,
                                ed->fields[48].range, 0, argc, argv);
                 break;
        case 49: rv = soc_sbx_g2p3_value_read(&e->llcctrlhi,
                                ed->fields[49].range, 0, argc, argv);
                 break;
        case 50: rv = soc_sbx_g2p3_value_read(&e->llcctrllo,
                                ed->fields[50].range, 0, argc, argv);
                 break;
        case 51: rv = soc_sbx_g2p3_value_read(&e->usellcctrl,
                                ed->fields[51].range, 0, argc, argv);
                 break;
        case 52: rv = soc_sbx_g2p3_value_read(&e->enable,
                                ed->fields[52].range, 0, argc, argv);
                 break;
        case 53: rv = soc_sbx_g2p3_value_read(&e->vlan,
                                ed->fields[53].range, 0, argc, argv);
                 break;
        case 54: rv = soc_sbx_g2p3_value_read(&e->ftidx,
                                ed->fields[54].range, 0, argc, argv);
                 break;
        case 55: rv = soc_sbx_g2p3_value_read(&e->mirror,
                                ed->fields[55].range, 0, argc, argv);
                 break;
        case 56: rv = soc_sbx_g2p3_value_read(&e->usevlan,
                                ed->fields[56].range, 0, argc, argv);
                 break;
        case 57: rv = soc_sbx_g2p3_value_read(&e->useftidx,
                                ed->fields[57].range, 0, argc, argv);
                 break;
        case 58: rv = soc_sbx_g2p3_value_read(&e->copy,
                                ed->fields[58].range, 0, argc, argv);
                 break;
        case 59: rv = soc_sbx_g2p3_value_read(&e->dp,
                                ed->fields[59].range, 0, argc, argv);
                 break;
        case 60: rv = soc_sbx_g2p3_value_read(&e->cos,
                                ed->fields[60].range, 0, argc, argv);
                 break;
        case 61: rv = soc_sbx_g2p3_value_read(&e->fcos,
                                ed->fields[61].range, 0, argc, argv);
                 break;
        case 62: rv = soc_sbx_g2p3_value_read(&e->usedp,
                                ed->fields[62].range, 0, argc, argv);
                 break;
        case 63: rv = soc_sbx_g2p3_value_read(&e->usecos,
                                ed->fields[63].range, 0, argc, argv);
                 break;
        case 64: rv = soc_sbx_g2p3_value_read(&e->policer,
                                ed->fields[64].range, 0, argc, argv);
                 break;
        case 65: rv = soc_sbx_g2p3_value_read(&e->typedpolice,
                                ed->fields[65].range, 0, argc, argv);
                 break;
        case 66: rv = soc_sbx_g2p3_value_read(&e->mefcos,
                                ed->fields[66].range, 0, argc, argv);
                 break;
        case 67: rv = soc_sbx_g2p3_value_read(&e->mef,
                                ed->fields[67].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ifp_set(unit,
                irule,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry diag shell delete implementation for ifp */
int soc_sbx_g2p3_ifp_shell_delete(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ifp_shell_delete(int unit,
         int argc, char **argv)
{
    int rv = 0, rv0;
    int all = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IFP_ID];
    int irule, nirule;
    void *indexpointers[1];

    indexpointers[0] = &irule;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_ifp_first(unit,
                &nirule);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("iterator first function failed\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all) {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        if (all) {
            irule = nirule;

            rv = soc_sbx_g2p3_ifp_next(unit,
                irule,
                &nirule);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
        rv0 = soc_sbx_g2p3_ifp_delete(unit,
                irule);
        if (rv0) {
            soc_cm_print("delete of %s failed\n", ed->name);
            return rv0;
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry print accessor implementation for ifp_v6 */
void soc_sbx_g2p3_ifp_v6_print(int unit, 
    soc_sbx_g2p3_ifp_v6_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IFP_V6_ID];

    int j, digits;
    uint8 *s;
    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->dbtype; w = 6;  break;
        case 1: v = e->usedbtype; w = 9;  break;
        case 2: v = e->port; w = 4;  break;
        case 3: v = e->useport; w = 7;  break;
        case 4: s = e->pbmpn; w = 5; goto bigfield;
        case 5: v = e->urg; w = 3;  break;
        case 6: v = e->useurg; w = 6;  break;
        case 7: v = e->ack; w = 3;  break;
        case 8: v = e->useack; w = 6;  break;
        case 9: v = e->psh; w = 3;  break;
        case 10: v = e->usepsh; w = 6;  break;
        case 11: v = e->rst; w = 3;  break;
        case 12: v = e->userst; w = 6;  break;
        case 13: v = e->syn; w = 3;  break;
        case 14: v = e->usesyn; w = 6;  break;
        case 15: v = e->fin; w = 3;  break;
        case 16: v = e->usefin; w = 6;  break;
        case 17: v = e->TC; w = 2;  break;
        case 18: v = e->useTC; w = 5;  break;
        case 19: v = e->nextheaderhi; w = 12;  break;
        case 20: v = e->nextheaderlo; w = 12;  break;
        case 21: v = e->sporthi; w = 7;  break;
        case 22: v = e->sportlo; w = 7;  break;
        case 23: v = e->dporthi; w = 7;  break;
        case 24: v = e->dportlo; w = 7;  break;
        case 25: s = e->sa; w = 2; goto bigfield;
        case 26: v = e->sawidth; w = 7;  break;
        case 27: s = e->da; w = 2; goto bigfield;
        case 28: v = e->dawidth; w = 7;  break;
        case 29: v = e->vid; w = 3;  break;
        case 30: v = e->usevid; w = 6;  break;
        case 31: v = e->enable; w = 6;  break;
        case 32: v = e->vlan; w = 4;  break;
        case 33: v = e->ftidx; w = 5;  break;
        case 34: v = e->mirror; w = 6;  break;
        case 35: v = e->usevlan; w = 7;  break;
        case 36: v = e->useftidx; w = 8;  break;
        case 37: v = e->copy; w = 4;  break;
        case 38: v = e->dp; w = 2;  break;
        case 39: v = e->cos; w = 3;  break;
        case 40: v = e->fcos; w = 4;  break;
        case 41: v = e->usedp; w = 5;  break;
        case 42: v = e->usecos; w = 6;  break;
        case 43: v = e->policer; w = 7;  break;
        case 44: v = e->typedpolice; w = 11;  break;
        case 45: v = e->mefcos; w = 6;  break;
        case 46: v = e->mef; w = 3;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
        continue;

    bigfield:
        digits = (width + 7) / 8;
        if ((col + w + 1 + 5 * digits) > 72) {
            soc_cm_print("\n  ");
            col=2;
        }
        soc_cm_print("%s=", fd->name);
        col += w + 1;
        for (j = 0; j < digits; j++) {
            soc_cm_print("0x%02x ", s[digits - j - 1]);
            col += 5;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ifp_v6 */
int soc_sbx_g2p3_ifp_v6_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ifp_v6_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ifp_v6_t e0;
    soc_sbx_g2p3_ifp_v6_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IFP_V6_ID];
    int all = 0;
    int irule;
    void *indexpointers[1];

    indexpointers[0] = &irule;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_ifp_v6_first(unit,
                &irule);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("unexpected error in iterator first function\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all)
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ifp_v6_get(unit,
                irule,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ifp_v6_print(unit, e);

        if (all) {
            rv = soc_sbx_g2p3_ifp_v6_next(unit,
                irule,
                &irule);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ifp_v6 */
int soc_sbx_g2p3_ifp_v6_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ifp_v6_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ifp_v6_t e0;
    soc_sbx_g2p3_ifp_v6_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IFP_V6_ID];
    int irule;
    void *indexpointers[1];

    indexpointers[0] = &irule;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ifp_v6_t_init(e);

    rv = soc_sbx_g2p3_ifp_v6_get(unit,
                irule,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->dbtype,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->usedbtype,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->port,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->useport,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2p3_big_value_read(e->pbmpn,
                                ed->fields[4].width, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g2p3_value_read(&e->urg,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g2p3_value_read(&e->useurg,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g2p3_value_read(&e->ack,
                                ed->fields[7].range, 0, argc, argv);
                 break;
        case 8: rv = soc_sbx_g2p3_value_read(&e->useack,
                                ed->fields[8].range, 0, argc, argv);
                 break;
        case 9: rv = soc_sbx_g2p3_value_read(&e->psh,
                                ed->fields[9].range, 0, argc, argv);
                 break;
        case 10: rv = soc_sbx_g2p3_value_read(&e->usepsh,
                                ed->fields[10].range, 0, argc, argv);
                 break;
        case 11: rv = soc_sbx_g2p3_value_read(&e->rst,
                                ed->fields[11].range, 0, argc, argv);
                 break;
        case 12: rv = soc_sbx_g2p3_value_read(&e->userst,
                                ed->fields[12].range, 0, argc, argv);
                 break;
        case 13: rv = soc_sbx_g2p3_value_read(&e->syn,
                                ed->fields[13].range, 0, argc, argv);
                 break;
        case 14: rv = soc_sbx_g2p3_value_read(&e->usesyn,
                                ed->fields[14].range, 0, argc, argv);
                 break;
        case 15: rv = soc_sbx_g2p3_value_read(&e->fin,
                                ed->fields[15].range, 0, argc, argv);
                 break;
        case 16: rv = soc_sbx_g2p3_value_read(&e->usefin,
                                ed->fields[16].range, 0, argc, argv);
                 break;
        case 17: rv = soc_sbx_g2p3_value_read(&e->TC,
                                ed->fields[17].range, 0, argc, argv);
                 break;
        case 18: rv = soc_sbx_g2p3_value_read(&e->useTC,
                                ed->fields[18].range, 0, argc, argv);
                 break;
        case 19: rv = soc_sbx_g2p3_value_read(&e->nextheaderhi,
                                ed->fields[19].range, 0, argc, argv);
                 break;
        case 20: rv = soc_sbx_g2p3_value_read(&e->nextheaderlo,
                                ed->fields[20].range, 0, argc, argv);
                 break;
        case 21: rv = soc_sbx_g2p3_value_read(&e->sporthi,
                                ed->fields[21].range, 0, argc, argv);
                 break;
        case 22: rv = soc_sbx_g2p3_value_read(&e->sportlo,
                                ed->fields[22].range, 0, argc, argv);
                 break;
        case 23: rv = soc_sbx_g2p3_value_read(&e->dporthi,
                                ed->fields[23].range, 0, argc, argv);
                 break;
        case 24: rv = soc_sbx_g2p3_value_read(&e->dportlo,
                                ed->fields[24].range, 0, argc, argv);
                 break;
        case 25: rv = soc_sbx_g2p3_big_value_read(e->sa,
                                ed->fields[25].width, 0, argc, argv);
                 break;
        case 26: rv = soc_sbx_g2p3_value_read(&e->sawidth,
                                ed->fields[26].range, 0, argc, argv);
                 break;
        case 27: rv = soc_sbx_g2p3_big_value_read(e->da,
                                ed->fields[27].width, 0, argc, argv);
                 break;
        case 28: rv = soc_sbx_g2p3_value_read(&e->dawidth,
                                ed->fields[28].range, 0, argc, argv);
                 break;
        case 29: rv = soc_sbx_g2p3_value_read(&e->vid,
                                ed->fields[29].range, 0, argc, argv);
                 break;
        case 30: rv = soc_sbx_g2p3_value_read(&e->usevid,
                                ed->fields[30].range, 0, argc, argv);
                 break;
        case 31: rv = soc_sbx_g2p3_value_read(&e->enable,
                                ed->fields[31].range, 0, argc, argv);
                 break;
        case 32: rv = soc_sbx_g2p3_value_read(&e->vlan,
                                ed->fields[32].range, 0, argc, argv);
                 break;
        case 33: rv = soc_sbx_g2p3_value_read(&e->ftidx,
                                ed->fields[33].range, 0, argc, argv);
                 break;
        case 34: rv = soc_sbx_g2p3_value_read(&e->mirror,
                                ed->fields[34].range, 0, argc, argv);
                 break;
        case 35: rv = soc_sbx_g2p3_value_read(&e->usevlan,
                                ed->fields[35].range, 0, argc, argv);
                 break;
        case 36: rv = soc_sbx_g2p3_value_read(&e->useftidx,
                                ed->fields[36].range, 0, argc, argv);
                 break;
        case 37: rv = soc_sbx_g2p3_value_read(&e->copy,
                                ed->fields[37].range, 0, argc, argv);
                 break;
        case 38: rv = soc_sbx_g2p3_value_read(&e->dp,
                                ed->fields[38].range, 0, argc, argv);
                 break;
        case 39: rv = soc_sbx_g2p3_value_read(&e->cos,
                                ed->fields[39].range, 0, argc, argv);
                 break;
        case 40: rv = soc_sbx_g2p3_value_read(&e->fcos,
                                ed->fields[40].range, 0, argc, argv);
                 break;
        case 41: rv = soc_sbx_g2p3_value_read(&e->usedp,
                                ed->fields[41].range, 0, argc, argv);
                 break;
        case 42: rv = soc_sbx_g2p3_value_read(&e->usecos,
                                ed->fields[42].range, 0, argc, argv);
                 break;
        case 43: rv = soc_sbx_g2p3_value_read(&e->policer,
                                ed->fields[43].range, 0, argc, argv);
                 break;
        case 44: rv = soc_sbx_g2p3_value_read(&e->typedpolice,
                                ed->fields[44].range, 0, argc, argv);
                 break;
        case 45: rv = soc_sbx_g2p3_value_read(&e->mefcos,
                                ed->fields[45].range, 0, argc, argv);
                 break;
        case 46: rv = soc_sbx_g2p3_value_read(&e->mef,
                                ed->fields[46].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ifp_v6_set(unit,
                irule,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry diag shell delete implementation for ifp_v6 */
int soc_sbx_g2p3_ifp_v6_shell_delete(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ifp_v6_shell_delete(int unit,
         int argc, char **argv)
{
    int rv = 0, rv0;
    int all = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IFP_V6_ID];
    int irule, nirule;
    void *indexpointers[1];

    indexpointers[0] = &irule;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_ifp_v6_first(unit,
                &nirule);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("iterator first function failed\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all) {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        if (all) {
            irule = nirule;

            rv = soc_sbx_g2p3_ifp_v6_next(unit,
                irule,
                &nirule);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
        rv0 = soc_sbx_g2p3_ifp_v6_delete(unit,
                irule);
        if (rv0) {
            soc_cm_print("delete of %s failed\n", ed->name);
            return rv0;
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry print accessor implementation for evp2e */
void soc_sbx_g2p3_evp2e_print(int unit, 
    soc_sbx_g2p3_evp2e_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EVP2E_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->eteptr; w = 6;  break;
        case 1: v = e->counter; w = 7;  break;
        case 2: v = e->cocounter; w = 9;  break;
        case 3: v = e->priclass; w = 8;  break;
        case 4: v = e->allpri; w = 6;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for evp2e */
int soc_sbx_g2p3_evp2e_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_evp2e_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_evp2e_t e0;
    soc_sbx_g2p3_evp2e_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EVP2E_ID];
    int ivlan;
    int iport;
    void *indexpointers[2];

    indexpointers[0] = &ivlan;
    indexpointers[1] = &iport;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_evp2e_get(unit,
                ivlan,
                iport,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_evp2e_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for evp2e */
int soc_sbx_g2p3_evp2e_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_evp2e_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_evp2e_t e0;
    soc_sbx_g2p3_evp2e_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EVP2E_ID];
    int ivlan;
    int iport;
    void *indexpointers[2];

    indexpointers[0] = &ivlan;
    indexpointers[1] = &iport;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_evp2e_t_init(e);

    rv = soc_sbx_g2p3_evp2e_get(unit,
                ivlan,
                iport,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->eteptr,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->counter,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->cocounter,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->priclass,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2p3_value_read(&e->allpri,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_evp2e_set(unit,
                ivlan,
                iport,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for oi2e */
void soc_sbx_g2p3_oi2e_print(int unit, 
    soc_sbx_g2p3_oi2e_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OI2E_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->eteptr; w = 6;  break;
        case 1: v = e->counter; w = 7;  break;
        case 2: v = e->cocounter; w = 9;  break;
        case 3: v = e->priclass; w = 8;  break;
        case 4: v = e->allpri; w = 6;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for oi2e */
int soc_sbx_g2p3_oi2e_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_oi2e_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_oi2e_t e0;
    soc_sbx_g2p3_oi2e_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OI2E_ID];
    int ioi;
    void *indexpointers[1];

    indexpointers[0] = &ioi;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_oi2e_get(unit,
                ioi,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_oi2e_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for oi2e */
int soc_sbx_g2p3_oi2e_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_oi2e_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_oi2e_t e0;
    soc_sbx_g2p3_oi2e_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OI2E_ID];
    int ioi;
    void *indexpointers[1];

    indexpointers[0] = &ioi;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_oi2e_t_init(e);

    rv = soc_sbx_g2p3_oi2e_get(unit,
                ioi,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->eteptr,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->counter,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->cocounter,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->priclass,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2p3_value_read(&e->allpri,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_oi2e_set(unit,
                ioi,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for eteencap */
void soc_sbx_g2p3_eteencap_print(int unit, 
    soc_sbx_g2p3_eteencap_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ETEENCAP_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->l2ete; w = 5;  break;
        case 1: v = e->dmacset; w = 7;  break;
        case 2: v = e->dmacsetlsb; w = 10;  break;
        case 3: v = e->dscpremark; w = 10;  break;
        case 4: v = e->remark; w = 6;  break;
        case 5: v = e->mplsttldec; w = 10;  break;
        case 6: v = e->encaplen; w = 8;  break;
        case 7: v = e->encapmac; w = 8;  break;
        case 8: v = e->nostrip; w = 7;  break;
        case 9: v = e->noclass; w = 7;  break;
        case 10: v = e->etepid; w = 6;  break;
        case 11: v = e->tunnelenter; w = 11;  break;
        case 12: v = e->exp0remark; w = 10;  break;
        case 13: v = e->exp1remark; w = 10;  break;
        case 14: v = e->exp2remark; w = 10;  break;
        case 15: v = e->ttl0dec; w = 7;  break;
        case 16: v = e->ttl1dec; w = 7;  break;
        case 17: v = e->ttl2dec; w = 7;  break;
        case 18: v = e->smacset; w = 7;  break;
        case 19: v = e->nosplitcheck; w = 12;  break;
        case 20: v = e->ttlcheck; w = 8;  break;
        case 21: v = e->ipttldec; w = 8;  break;
        case 22: v = e->add_pwcw; w = 8;  break;
        case 23: v = e->dmac5; w = 5;  break;
        case 24: v = e->dmac4; w = 5;  break;
        case 25: v = e->dmac3; w = 5;  break;
        case 26: v = e->dmac2; w = 5;  break;
        case 27: v = e->dmac1; w = 5;  break;
        case 28: v = e->dmac0; w = 5;  break;
        case 29: v = e->vlan; w = 4;  break;
        case 30: v = e->vid; w = 3;  break;
        case 31: v = e->pricfi; w = 6;  break;
        case 32: v = e->tpid; w = 4;  break;
        case 33: v = e->mimtype; w = 7;  break;
        case 34: v = e->btag_vid; w = 8;  break;
        case 35: v = e->btag_pricfi; w = 11;  break;
        case 36: v = e->btag_tpid; w = 9;  break;
        case 37: v = e->ttl2; w = 4;  break;
        case 38: v = e->s2; w = 2;  break;
        case 39: v = e->exp2; w = 4;  break;
        case 40: v = e->label2; w = 6;  break;
        case 41: v = e->etype; w = 5;  break;
        case 42: v = e->pid; w = 3;  break;
        case 43: v = e->isid; w = 4;  break;
        case 44: v = e->rsvd; w = 4;  break;
        case 45: v = e->ucm; w = 3;  break;
        case 46: v = e->dei; w = 3;  break;
        case 47: v = e->pcp; w = 3;  break;
        case 48: v = e->ttl0; w = 4;  break;
        case 49: v = e->s0; w = 2;  break;
        case 50: v = e->exp0; w = 4;  break;
        case 51: v = e->label0; w = 6;  break;
        case 52: v = e->ttl1; w = 4;  break;
        case 53: v = e->s1; w = 2;  break;
        case 54: v = e->exp1; w = 4;  break;
        case 55: v = e->label1; w = 6;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for eteencap */
int soc_sbx_g2p3_eteencap_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_eteencap_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_eteencap_t e0;
    soc_sbx_g2p3_eteencap_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ETEENCAP_ID];
    int ietei;
    void *indexpointers[1];

    indexpointers[0] = &ietei;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_eteencap_get(unit,
                ietei,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_eteencap_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for eteencap */
int soc_sbx_g2p3_eteencap_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_eteencap_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_eteencap_t e0;
    soc_sbx_g2p3_eteencap_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ETEENCAP_ID];
    int ietei;
    void *indexpointers[1];

    indexpointers[0] = &ietei;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_eteencap_t_init(e);

    rv = soc_sbx_g2p3_eteencap_get(unit,
                ietei,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->l2ete,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->dmacset,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->dmacsetlsb,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->dscpremark,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2p3_value_read(&e->remark,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g2p3_value_read(&e->mplsttldec,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g2p3_value_read(&e->encaplen,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g2p3_value_read(&e->encapmac,
                                ed->fields[7].range, 0, argc, argv);
                 break;
        case 8: rv = soc_sbx_g2p3_value_read(&e->nostrip,
                                ed->fields[8].range, 0, argc, argv);
                 break;
        case 9: rv = soc_sbx_g2p3_value_read(&e->noclass,
                                ed->fields[9].range, 0, argc, argv);
                 break;
        case 10: rv = soc_sbx_g2p3_value_read(&e->etepid,
                                ed->fields[10].range, 0, argc, argv);
                 break;
        case 11: rv = soc_sbx_g2p3_value_read(&e->tunnelenter,
                                ed->fields[11].range, 0, argc, argv);
                 break;
        case 12: rv = soc_sbx_g2p3_value_read(&e->exp0remark,
                                ed->fields[12].range, 0, argc, argv);
                 break;
        case 13: rv = soc_sbx_g2p3_value_read(&e->exp1remark,
                                ed->fields[13].range, 0, argc, argv);
                 break;
        case 14: rv = soc_sbx_g2p3_value_read(&e->exp2remark,
                                ed->fields[14].range, 0, argc, argv);
                 break;
        case 15: rv = soc_sbx_g2p3_value_read(&e->ttl0dec,
                                ed->fields[15].range, 0, argc, argv);
                 break;
        case 16: rv = soc_sbx_g2p3_value_read(&e->ttl1dec,
                                ed->fields[16].range, 0, argc, argv);
                 break;
        case 17: rv = soc_sbx_g2p3_value_read(&e->ttl2dec,
                                ed->fields[17].range, 0, argc, argv);
                 break;
        case 18: rv = soc_sbx_g2p3_value_read(&e->smacset,
                                ed->fields[18].range, 0, argc, argv);
                 break;
        case 19: rv = soc_sbx_g2p3_value_read(&e->nosplitcheck,
                                ed->fields[19].range, 0, argc, argv);
                 break;
        case 20: rv = soc_sbx_g2p3_value_read(&e->ttlcheck,
                                ed->fields[20].range, 0, argc, argv);
                 break;
        case 21: rv = soc_sbx_g2p3_value_read(&e->ipttldec,
                                ed->fields[21].range, 0, argc, argv);
                 break;
        case 22: rv = soc_sbx_g2p3_value_read(&e->add_pwcw,
                                ed->fields[22].range, 0, argc, argv);
                 break;
        case 23: rv = soc_sbx_g2p3_value_read(&e->dmac5,
                                ed->fields[23].range, 0, argc, argv);
                 break;
        case 24: rv = soc_sbx_g2p3_value_read(&e->dmac4,
                                ed->fields[24].range, 0, argc, argv);
                 break;
        case 25: rv = soc_sbx_g2p3_value_read(&e->dmac3,
                                ed->fields[25].range, 0, argc, argv);
                 break;
        case 26: rv = soc_sbx_g2p3_value_read(&e->dmac2,
                                ed->fields[26].range, 0, argc, argv);
                 break;
        case 27: rv = soc_sbx_g2p3_value_read(&e->dmac1,
                                ed->fields[27].range, 0, argc, argv);
                 break;
        case 28: rv = soc_sbx_g2p3_value_read(&e->dmac0,
                                ed->fields[28].range, 0, argc, argv);
                 break;
        case 29: rv = soc_sbx_g2p3_value_read(&e->vlan,
                                ed->fields[29].range, 0, argc, argv);
                 break;
        case 30: rv = soc_sbx_g2p3_value_read(&e->vid,
                                ed->fields[30].range, 0, argc, argv);
                 break;
        case 31: rv = soc_sbx_g2p3_value_read(&e->pricfi,
                                ed->fields[31].range, 0, argc, argv);
                 break;
        case 32: rv = soc_sbx_g2p3_value_read(&e->tpid,
                                ed->fields[32].range, 0, argc, argv);
                 break;
        case 33: rv = soc_sbx_g2p3_value_read(&e->mimtype,
                                ed->fields[33].range, 0, argc, argv);
                 break;
        case 34: rv = soc_sbx_g2p3_value_read(&e->btag_vid,
                                ed->fields[34].range, 0, argc, argv);
                 break;
        case 35: rv = soc_sbx_g2p3_value_read(&e->btag_pricfi,
                                ed->fields[35].range, 0, argc, argv);
                 break;
        case 36: rv = soc_sbx_g2p3_value_read(&e->btag_tpid,
                                ed->fields[36].range, 0, argc, argv);
                 break;
        case 37: rv = soc_sbx_g2p3_value_read(&e->ttl2,
                                ed->fields[37].range, 0, argc, argv);
                 break;
        case 38: rv = soc_sbx_g2p3_value_read(&e->s2,
                                ed->fields[38].range, 0, argc, argv);
                 break;
        case 39: rv = soc_sbx_g2p3_value_read(&e->exp2,
                                ed->fields[39].range, 0, argc, argv);
                 break;
        case 40: rv = soc_sbx_g2p3_value_read(&e->label2,
                                ed->fields[40].range, 0, argc, argv);
                 break;
        case 41: rv = soc_sbx_g2p3_value_read(&e->etype,
                                ed->fields[41].range, 0, argc, argv);
                 break;
        case 42: rv = soc_sbx_g2p3_value_read(&e->pid,
                                ed->fields[42].range, 0, argc, argv);
                 break;
        case 43: rv = soc_sbx_g2p3_value_read(&e->isid,
                                ed->fields[43].range, 0, argc, argv);
                 break;
        case 44: rv = soc_sbx_g2p3_value_read(&e->rsvd,
                                ed->fields[44].range, 0, argc, argv);
                 break;
        case 45: rv = soc_sbx_g2p3_value_read(&e->ucm,
                                ed->fields[45].range, 0, argc, argv);
                 break;
        case 46: rv = soc_sbx_g2p3_value_read(&e->dei,
                                ed->fields[46].range, 0, argc, argv);
                 break;
        case 47: rv = soc_sbx_g2p3_value_read(&e->pcp,
                                ed->fields[47].range, 0, argc, argv);
                 break;
        case 48: rv = soc_sbx_g2p3_value_read(&e->ttl0,
                                ed->fields[48].range, 0, argc, argv);
                 break;
        case 49: rv = soc_sbx_g2p3_value_read(&e->s0,
                                ed->fields[49].range, 0, argc, argv);
                 break;
        case 50: rv = soc_sbx_g2p3_value_read(&e->exp0,
                                ed->fields[50].range, 0, argc, argv);
                 break;
        case 51: rv = soc_sbx_g2p3_value_read(&e->label0,
                                ed->fields[51].range, 0, argc, argv);
                 break;
        case 52: rv = soc_sbx_g2p3_value_read(&e->ttl1,
                                ed->fields[52].range, 0, argc, argv);
                 break;
        case 53: rv = soc_sbx_g2p3_value_read(&e->s1,
                                ed->fields[53].range, 0, argc, argv);
                 break;
        case 54: rv = soc_sbx_g2p3_value_read(&e->exp1,
                                ed->fields[54].range, 0, argc, argv);
                 break;
        case 55: rv = soc_sbx_g2p3_value_read(&e->label1,
                                ed->fields[55].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_eteencap_set(unit,
                ietei,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for etel2 */
void soc_sbx_g2p3_etel2_print(int unit, 
    soc_sbx_g2p3_etel2_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ETEL2_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->dscpremark; w = 10;  break;
        case 1: v = e->encaplen; w = 8;  break;
        case 2: v = e->nostrip; w = 7;  break;
        case 3: v = e->noclass; w = 7;  break;
        case 4: v = e->remark; w = 6;  break;
        case 5: v = e->nosplitcheck; w = 12;  break;
        case 6: v = e->usetag; w = 6;  break;
        case 7: v = e->dropuntagged; w = 12;  break;
        case 8: v = e->droptagged; w = 10;  break;
        case 9: v = e->smacindex; w = 9;  break;
        case 10: v = e->stpcheck; w = 8;  break;
        case 11: v = e->vid; w = 3;  break;
        case 12: v = e->defpricfi; w = 9;  break;
        case 13: v = e->mtu; w = 3;  break;
        case 14: v = e->usevid; w = 6;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for etel2 */
int soc_sbx_g2p3_etel2_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_etel2_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_etel2_t e0;
    soc_sbx_g2p3_etel2_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ETEL2_ID];
    int ietei;
    void *indexpointers[1];

    indexpointers[0] = &ietei;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_etel2_get(unit,
                ietei,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_etel2_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for etel2 */
int soc_sbx_g2p3_etel2_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_etel2_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_etel2_t e0;
    soc_sbx_g2p3_etel2_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ETEL2_ID];
    int ietei;
    void *indexpointers[1];

    indexpointers[0] = &ietei;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_etel2_t_init(e);

    rv = soc_sbx_g2p3_etel2_get(unit,
                ietei,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->dscpremark,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->encaplen,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->nostrip,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->noclass,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2p3_value_read(&e->remark,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g2p3_value_read(&e->nosplitcheck,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g2p3_value_read(&e->usetag,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g2p3_value_read(&e->dropuntagged,
                                ed->fields[7].range, 0, argc, argv);
                 break;
        case 8: rv = soc_sbx_g2p3_value_read(&e->droptagged,
                                ed->fields[8].range, 0, argc, argv);
                 break;
        case 9: rv = soc_sbx_g2p3_value_read(&e->smacindex,
                                ed->fields[9].range, 0, argc, argv);
                 break;
        case 10: rv = soc_sbx_g2p3_value_read(&e->stpcheck,
                                ed->fields[10].range, 0, argc, argv);
                 break;
        case 11: rv = soc_sbx_g2p3_value_read(&e->vid,
                                ed->fields[11].range, 0, argc, argv);
                 break;
        case 12: rv = soc_sbx_g2p3_value_read(&e->defpricfi,
                                ed->fields[12].range, 0, argc, argv);
                 break;
        case 13: rv = soc_sbx_g2p3_value_read(&e->mtu,
                                ed->fields[13].range, 0, argc, argv);
                 break;
        case 14: rv = soc_sbx_g2p3_value_read(&e->usevid,
                                ed->fields[14].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_etel2_set(unit,
                ietei,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for oamEp */
void soc_sbx_g2p3_oamep_print(int unit, 
    soc_sbx_g2p3_oamep_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMEP_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->nextentry; w = 9; iffok = ((e->function==1) || (e->function==3) || (e->function==4) ||
                    (e->function==5) || (e->function==6) || (e->function==7));  break;
        case 1: v = e->function; w = 8;  break;
        case 2: v = e->type; w = 4;  break;
        case 3: v = e->interval; w = 8; iffok = ((e->function==1) || (e->function==4));  break;
        case 4: v = e->mdlevel; w = 7; iffok = ((e->function==2) || (e->function==3) || (e->function==4));  break;
        case 5: v = e->singletx; w = 8; iffok = ((e->function==2) || (e->function==3));  break;
        case 6: v = e->mode; w = 4; iffok = ((e->function==1) || (e->function==2) || (e->function==3));  break;
        case 7: v = e->dir; w = 3; iffok = ((e->function==2) || (e->function==3) || (e->function==4));  break;
        case 8: v = e->conttohost; w = 10; iffok = ((e->function==1) || (e->function==2) || (e->function==3) ||
                    (e->function==4));  break;
        case 9: v = e->singletohost; w = 12; iffok = ((e->function==1) || (e->function==2) || (e->function==3) ||
                    (e->function==4));  break;
        case 10: v = e->ftidx; w = 5; iffok = ((e->function==0) || (e->function==1) ||
                    (e->function==3) || (e->function==5) || (e->function==7));  break;
        case 11: v = e->m; w = 1; iffok = (e->function==1);  break;
        case 12: v = e->d; w = 1; iffok = (e->function==1);  break;
        case 13: v = e->a; w = 1; iffok = (e->function==1);  break;
        case 14: v = e->c; w = 1; iffok = (e->function==1);  break;
        case 15: v = e->unibi; w = 5; iffok = (e->function==1);  break;
        case 16: v = e->cv; w = 2; iffok = (e->function==1);  break;
        case 17: v = e->fbit; w = 4; iffok = (e->function==1);  break;
        case 18: v = e->counteridx; w = 10; iffok = (e->function==2);  break;
        case 19: v = e->multiplieridx; w = 13; iffok = (e->function==2);  break;
        case 20: v = e->rxfc; w = 4; iffok = (e->function==2);  break;
        case 21: v = e->rdi; w = 3; iffok = (e->function==4);  break;
        case 22: v = e->mip; w = 3; iffok = (e->function==4);  break;
        case 23: v = e->lm; w = 2; iffok = (e->function==4);  break;
        case 24: v = e->notlm; w = 5; iffok = (e->function==4);  break;
        case 25: v = e->mepid; w = 5; iffok = (e->function==4);  break;
        case 26: v = e->intpri; w = 6; iffok = (e->function==4);  break;
        case 27: v = e->smacaux; w = 7; iffok = (e->function==5);  break;
        case 28: v = e->smacadd; w = 7; iffok = (e->function==5);  break;
        case 29: v = e->smacoffset; w = 10; iffok = (e->function==5);  break;
        case 30: v = e->sid; w = 3; iffok = (e->function==5);  break;
        case 31: v = e->tx; w = 2; iffok = (e->function==7);  break;
        case 32: v = e->yourdiscrim; w = 11; iffok = (e->function==1);  break;
        case 33: v = e->mydiscrim; w = 9; iffok = (e->function==1);  break;
        case 34: v = e->rxfcl; w = 5; iffok = (e->function==2);  break;
        case 35: v = e->nextentry_store; w = 15; iffok = (e->function==2);  break;
        case 36: v = e->ftidx_store; w = 11; iffok = (e->function==2);  break;
        case 37: v = e->delaysec; w = 8; iffok = (e->function==3);  break;
        case 38: v = e->remotesec; w = 9; iffok = (e->function==3);  break;
        case 39: v = e->maidw3; w = 6; iffok = (e->function==4);  break;
        case 40: v = e->maidw2; w = 6; iffok = (e->function==4);  break;
        case 41: v = e->maidw9; w = 6; iffok = (e->function==5);  break;
        case 42: v = e->maidw8; w = 6; iffok = (e->function==5);  break;
        case 43: v = e->maidcrc; w = 7; iffok = (e->function==6);  break;
        case 44: v = e->path; w = 4; iffok = (e->function==7);  break;
        case 45: v = e->fpath; w = 5; iffok = (e->function==7);  break;
        case 46: v = e->reserved; w = 8; iffok = (e->function==7);  break;
        case 47: v = e->revertive; w = 9; iffok = (e->function==7);  break;
        case 48: v = e->pt; w = 2; iffok = (e->function==7);  break;
        case 49: v = e->request; w = 7; iffok = (e->function==7);  break;
        case 50: v = e->version; w = 7; iffok = (e->function==7);  break;
        case 51: v = e->pschdr; w = 6; iffok = (e->function==7);  break;
        case 52: v = e->slowrate; w = 8; iffok = (e->function==7);  break;
        case 53: v = e->filter; w = 6; iffok = (e->function==7);  break;
        case 54: v = e->burst; w = 5; iffok = (e->function==7);  break;
        case 55: v = e->pscentry; w = 8; iffok = (e->function==1);  break;
        case 56: v = e->ipda; w = 4; iffok = (e->function==1);  break;
        case 57: v = e->txfcf; w = 5; iffok = (e->function==2);  break;
        case 58: v = e->txfcb; w = 5; iffok = (e->function==2);  break;
        case 59: v = e->maidw1; w = 6; iffok = (e->function==4);  break;
        case 60: v = e->maidw0; w = 6; iffok = (e->function==4);  break;
        case 61: v = e->maidw7; w = 6; iffok = (e->function==5);  break;
        case 62: v = e->maidw6; w = 6; iffok = (e->function==5);  break;
        case 63: v = e->maxslowrate; w = 11; iffok = (e->function==7);  break;
        case 64: v = e->peerrdi; w = 7; iffok = ((e->function==1) || (e->function==6));  break;
        case 65: v = e->ackrdi; w = 6; iffok = ((e->function==1) || (e->function==6));  break;
        case 66: v = e->ackrdi_rdi; w = 10; iffok = ((e->function==1) || (e->function==6));  break;
        case 67: v = e->policerid; w = 9; iffok = ((e->function==1) || (e->function==6));  break;
        case 68: v = e->udpsourceport; w = 13; iffok = (e->function==1);  break;
        case 69: v = e->multipoint; w = 10; iffok = (e->function==1);  break;
        case 70: v = e->peerstate; w = 9; iffok = (e->function==1);  break;
        case 71: v = e->final; w = 5; iffok = (e->function==1);  break;
        case 72: v = e->poll; w = 4; iffok = (e->function==1);  break;
        case 73: v = e->localstate; w = 10; iffok = (e->function==1);  break;
        case 74: v = e->diag; w = 4; iffok = (e->function==1);  break;
        case 75: v = e->peerdetectmulti; w = 15; iffok = (e->function==1);  break;
        case 76: v = e->localdetectmulti; w = 16; iffok = (e->function==1);  break;
        case 77: v = e->framelossfar; w = 12; iffok = (e->function==2);  break;
        case 78: v = e->framelossnear; w = 13; iffok = (e->function==2);  break;
        case 79: v = e->delaynanosec; w = 12; iffok = (e->function==3);  break;
        case 80: v = e->remotenanosec; w = 13; iffok = (e->function==3);  break;
        case 81: v = e->maidw5; w = 6; iffok = (e->function==4);  break;
        case 82: v = e->maidw4; w = 6; iffok = (e->function==4);  break;
        case 83: v = e->maidw11; w = 7; iffok = (e->function==5);  break;
        case 84: v = e->maidw10; w = 7; iffok = (e->function==5);  break;
        case 85: v = e->maxfilter; w = 9; iffok = (e->function==7);  break;
        case 86: v = e->tlvlength; w = 9; iffok = (e->function==7);  break;
        case 87: v = e->tlv0_3; w = 6; iffok = (e->function==7);  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for oamEp */
int soc_sbx_g2p3_oamep_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_oamep_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_oamep_t e0;
    soc_sbx_g2p3_oamep_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMEP_ID];
    int iepidx;
    void *indexpointers[1];

    indexpointers[0] = &iepidx;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_oamep_get(unit,
                iepidx,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_oamep_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for oamEp */
int soc_sbx_g2p3_oamep_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_oamep_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_oamep_t e0;
    soc_sbx_g2p3_oamep_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMEP_ID];
    int iepidx;
    void *indexpointers[1];

    indexpointers[0] = &iepidx;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_oamep_t_init(e);

    rv = soc_sbx_g2p3_oamep_get(unit,
                iepidx,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->nextentry,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->function,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->type,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->interval,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2p3_value_read(&e->mdlevel,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g2p3_value_read(&e->singletx,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g2p3_value_read(&e->mode,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g2p3_value_read(&e->dir,
                                ed->fields[7].range, 0, argc, argv);
                 break;
        case 8: rv = soc_sbx_g2p3_value_read(&e->conttohost,
                                ed->fields[8].range, 0, argc, argv);
                 break;
        case 9: rv = soc_sbx_g2p3_value_read(&e->singletohost,
                                ed->fields[9].range, 0, argc, argv);
                 break;
        case 10: rv = soc_sbx_g2p3_value_read(&e->ftidx,
                                ed->fields[10].range, 0, argc, argv);
                 break;
        case 11: rv = soc_sbx_g2p3_value_read(&e->m,
                                ed->fields[11].range, 0, argc, argv);
                 break;
        case 12: rv = soc_sbx_g2p3_value_read(&e->d,
                                ed->fields[12].range, 0, argc, argv);
                 break;
        case 13: rv = soc_sbx_g2p3_value_read(&e->a,
                                ed->fields[13].range, 0, argc, argv);
                 break;
        case 14: rv = soc_sbx_g2p3_value_read(&e->c,
                                ed->fields[14].range, 0, argc, argv);
                 break;
        case 15: rv = soc_sbx_g2p3_value_read(&e->unibi,
                                ed->fields[15].range, 0, argc, argv);
                 break;
        case 16: rv = soc_sbx_g2p3_value_read(&e->cv,
                                ed->fields[16].range, 0, argc, argv);
                 break;
        case 17: rv = soc_sbx_g2p3_value_read(&e->fbit,
                                ed->fields[17].range, 0, argc, argv);
                 break;
        case 18: rv = soc_sbx_g2p3_value_read(&e->counteridx,
                                ed->fields[18].range, 0, argc, argv);
                 break;
        case 19: rv = soc_sbx_g2p3_value_read(&e->multiplieridx,
                                ed->fields[19].range, 0, argc, argv);
                 break;
        case 20: rv = soc_sbx_g2p3_value_read(&e->rxfc,
                                ed->fields[20].range, 0, argc, argv);
                 break;
        case 21: rv = soc_sbx_g2p3_value_read(&e->rdi,
                                ed->fields[21].range, 0, argc, argv);
                 break;
        case 22: rv = soc_sbx_g2p3_value_read(&e->mip,
                                ed->fields[22].range, 0, argc, argv);
                 break;
        case 23: rv = soc_sbx_g2p3_value_read(&e->lm,
                                ed->fields[23].range, 0, argc, argv);
                 break;
        case 24: rv = soc_sbx_g2p3_value_read(&e->notlm,
                                ed->fields[24].range, 0, argc, argv);
                 break;
        case 25: rv = soc_sbx_g2p3_value_read(&e->mepid,
                                ed->fields[25].range, 0, argc, argv);
                 break;
        case 26: rv = soc_sbx_g2p3_value_read(&e->intpri,
                                ed->fields[26].range, 0, argc, argv);
                 break;
        case 27: rv = soc_sbx_g2p3_value_read(&e->smacaux,
                                ed->fields[27].range, 0, argc, argv);
                 break;
        case 28: rv = soc_sbx_g2p3_value_read(&e->smacadd,
                                ed->fields[28].range, 0, argc, argv);
                 break;
        case 29: rv = soc_sbx_g2p3_value_read(&e->smacoffset,
                                ed->fields[29].range, 0, argc, argv);
                 break;
        case 30: rv = soc_sbx_g2p3_value_read(&e->sid,
                                ed->fields[30].range, 0, argc, argv);
                 break;
        case 31: rv = soc_sbx_g2p3_value_read(&e->tx,
                                ed->fields[31].range, 0, argc, argv);
                 break;
        case 32: rv = soc_sbx_g2p3_value_read(&e->yourdiscrim,
                                ed->fields[32].range, 0, argc, argv);
                 break;
        case 33: rv = soc_sbx_g2p3_value_read(&e->mydiscrim,
                                ed->fields[33].range, 0, argc, argv);
                 break;
        case 34: rv = soc_sbx_g2p3_value_read(&e->rxfcl,
                                ed->fields[34].range, 0, argc, argv);
                 break;
        case 35: rv = soc_sbx_g2p3_value_read(&e->nextentry_store,
                                ed->fields[35].range, 0, argc, argv);
                 break;
        case 36: rv = soc_sbx_g2p3_value_read(&e->ftidx_store,
                                ed->fields[36].range, 0, argc, argv);
                 break;
        case 37: rv = soc_sbx_g2p3_value_read(&e->delaysec,
                                ed->fields[37].range, 0, argc, argv);
                 break;
        case 38: rv = soc_sbx_g2p3_value_read(&e->remotesec,
                                ed->fields[38].range, 0, argc, argv);
                 break;
        case 39: rv = soc_sbx_g2p3_value_read(&e->maidw3,
                                ed->fields[39].range, 0, argc, argv);
                 break;
        case 40: rv = soc_sbx_g2p3_value_read(&e->maidw2,
                                ed->fields[40].range, 0, argc, argv);
                 break;
        case 41: rv = soc_sbx_g2p3_value_read(&e->maidw9,
                                ed->fields[41].range, 0, argc, argv);
                 break;
        case 42: rv = soc_sbx_g2p3_value_read(&e->maidw8,
                                ed->fields[42].range, 0, argc, argv);
                 break;
        case 43: rv = soc_sbx_g2p3_value_read(&e->maidcrc,
                                ed->fields[43].range, 0, argc, argv);
                 break;
        case 44: rv = soc_sbx_g2p3_value_read(&e->path,
                                ed->fields[44].range, 0, argc, argv);
                 break;
        case 45: rv = soc_sbx_g2p3_value_read(&e->fpath,
                                ed->fields[45].range, 0, argc, argv);
                 break;
        case 46: rv = soc_sbx_g2p3_value_read(&e->reserved,
                                ed->fields[46].range, 0, argc, argv);
                 break;
        case 47: rv = soc_sbx_g2p3_value_read(&e->revertive,
                                ed->fields[47].range, 0, argc, argv);
                 break;
        case 48: rv = soc_sbx_g2p3_value_read(&e->pt,
                                ed->fields[48].range, 0, argc, argv);
                 break;
        case 49: rv = soc_sbx_g2p3_value_read(&e->request,
                                ed->fields[49].range, 0, argc, argv);
                 break;
        case 50: rv = soc_sbx_g2p3_value_read(&e->version,
                                ed->fields[50].range, 0, argc, argv);
                 break;
        case 51: rv = soc_sbx_g2p3_value_read(&e->pschdr,
                                ed->fields[51].range, 0, argc, argv);
                 break;
        case 52: rv = soc_sbx_g2p3_value_read(&e->slowrate,
                                ed->fields[52].range, 0, argc, argv);
                 break;
        case 53: rv = soc_sbx_g2p3_value_read(&e->filter,
                                ed->fields[53].range, 0, argc, argv);
                 break;
        case 54: rv = soc_sbx_g2p3_value_read(&e->burst,
                                ed->fields[54].range, 0, argc, argv);
                 break;
        case 55: rv = soc_sbx_g2p3_value_read(&e->pscentry,
                                ed->fields[55].range, 0, argc, argv);
                 break;
        case 56: rv = soc_sbx_g2p3_value_read(&e->ipda,
                                ed->fields[56].range, 0, argc, argv);
                 break;
        case 57: rv = soc_sbx_g2p3_value_read(&e->txfcf,
                                ed->fields[57].range, 0, argc, argv);
                 break;
        case 58: rv = soc_sbx_g2p3_value_read(&e->txfcb,
                                ed->fields[58].range, 0, argc, argv);
                 break;
        case 59: rv = soc_sbx_g2p3_value_read(&e->maidw1,
                                ed->fields[59].range, 0, argc, argv);
                 break;
        case 60: rv = soc_sbx_g2p3_value_read(&e->maidw0,
                                ed->fields[60].range, 0, argc, argv);
                 break;
        case 61: rv = soc_sbx_g2p3_value_read(&e->maidw7,
                                ed->fields[61].range, 0, argc, argv);
                 break;
        case 62: rv = soc_sbx_g2p3_value_read(&e->maidw6,
                                ed->fields[62].range, 0, argc, argv);
                 break;
        case 63: rv = soc_sbx_g2p3_value_read(&e->maxslowrate,
                                ed->fields[63].range, 0, argc, argv);
                 break;
        case 64: rv = soc_sbx_g2p3_value_read(&e->peerrdi,
                                ed->fields[64].range, 0, argc, argv);
                 break;
        case 65: rv = soc_sbx_g2p3_value_read(&e->ackrdi,
                                ed->fields[65].range, 0, argc, argv);
                 break;
        case 66: rv = soc_sbx_g2p3_value_read(&e->ackrdi_rdi,
                                ed->fields[66].range, 0, argc, argv);
                 break;
        case 67: rv = soc_sbx_g2p3_value_read(&e->policerid,
                                ed->fields[67].range, 0, argc, argv);
                 break;
        case 68: rv = soc_sbx_g2p3_value_read(&e->udpsourceport,
                                ed->fields[68].range, 0, argc, argv);
                 break;
        case 69: rv = soc_sbx_g2p3_value_read(&e->multipoint,
                                ed->fields[69].range, 0, argc, argv);
                 break;
        case 70: rv = soc_sbx_g2p3_value_read(&e->peerstate,
                                ed->fields[70].range, 0, argc, argv);
                 break;
        case 71: rv = soc_sbx_g2p3_value_read(&e->final,
                                ed->fields[71].range, 0, argc, argv);
                 break;
        case 72: rv = soc_sbx_g2p3_value_read(&e->poll,
                                ed->fields[72].range, 0, argc, argv);
                 break;
        case 73: rv = soc_sbx_g2p3_value_read(&e->localstate,
                                ed->fields[73].range, 0, argc, argv);
                 break;
        case 74: rv = soc_sbx_g2p3_value_read(&e->diag,
                                ed->fields[74].range, 0, argc, argv);
                 break;
        case 75: rv = soc_sbx_g2p3_value_read(&e->peerdetectmulti,
                                ed->fields[75].range, 0, argc, argv);
                 break;
        case 76: rv = soc_sbx_g2p3_value_read(&e->localdetectmulti,
                                ed->fields[76].range, 0, argc, argv);
                 break;
        case 77: rv = soc_sbx_g2p3_value_read(&e->framelossfar,
                                ed->fields[77].range, 0, argc, argv);
                 break;
        case 78: rv = soc_sbx_g2p3_value_read(&e->framelossnear,
                                ed->fields[78].range, 0, argc, argv);
                 break;
        case 79: rv = soc_sbx_g2p3_value_read(&e->delaynanosec,
                                ed->fields[79].range, 0, argc, argv);
                 break;
        case 80: rv = soc_sbx_g2p3_value_read(&e->remotenanosec,
                                ed->fields[80].range, 0, argc, argv);
                 break;
        case 81: rv = soc_sbx_g2p3_value_read(&e->maidw5,
                                ed->fields[81].range, 0, argc, argv);
                 break;
        case 82: rv = soc_sbx_g2p3_value_read(&e->maidw4,
                                ed->fields[82].range, 0, argc, argv);
                 break;
        case 83: rv = soc_sbx_g2p3_value_read(&e->maidw11,
                                ed->fields[83].range, 0, argc, argv);
                 break;
        case 84: rv = soc_sbx_g2p3_value_read(&e->maidw10,
                                ed->fields[84].range, 0, argc, argv);
                 break;
        case 85: rv = soc_sbx_g2p3_value_read(&e->maxfilter,
                                ed->fields[85].range, 0, argc, argv);
                 break;
        case 86: rv = soc_sbx_g2p3_value_read(&e->tlvlength,
                                ed->fields[86].range, 0, argc, argv);
                 break;
        case 87: rv = soc_sbx_g2p3_value_read(&e->tlv0_3,
                                ed->fields[87].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_oamep_set(unit,
                iepidx,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for remark */
void soc_sbx_g2p3_remark_print(int unit, 
    soc_sbx_g2p3_remark_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_REMARK_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->cfi; w = 3;  break;
        case 1: v = e->pri; w = 3;  break;
        case 2: v = e->exp; w = 3;  break;
        case 3: v = e->dscp; w = 4;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for remark */
int soc_sbx_g2p3_remark_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_remark_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_remark_t e0;
    soc_sbx_g2p3_remark_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_REMARK_ID];
    int ie;
    int idp;
    int icos;
    int iprof;
    void *indexpointers[4];

    indexpointers[0] = &ie;
    indexpointers[1] = &idp;
    indexpointers[2] = &icos;
    indexpointers[3] = &iprof;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_remark_get(unit,
                ie,
                idp,
                icos,
                iprof,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_remark_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for remark */
int soc_sbx_g2p3_remark_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_remark_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_remark_t e0;
    soc_sbx_g2p3_remark_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_REMARK_ID];
    int ie;
    int idp;
    int icos;
    int iprof;
    void *indexpointers[4];

    indexpointers[0] = &ie;
    indexpointers[1] = &idp;
    indexpointers[2] = &icos;
    indexpointers[3] = &iprof;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_remark_t_init(e);

    rv = soc_sbx_g2p3_remark_get(unit,
                ie,
                idp,
                icos,
                iprof,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->cfi,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->pri,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->exp,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->dscp,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_remark_set(unit,
                ie,
                idp,
                icos,
                iprof,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for epv2e */
void soc_sbx_g2p3_epv2e_print(int unit, 
    soc_sbx_g2p3_epv2e_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EPV2E_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->drop; w = 4;  break;
        case 1: v = e->strip; w = 5;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for epv2e */
int soc_sbx_g2p3_epv2e_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_epv2e_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_epv2e_t e0;
    soc_sbx_g2p3_epv2e_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EPV2E_ID];
    int ivid;
    int iport;
    void *indexpointers[2];

    indexpointers[0] = &ivid;
    indexpointers[1] = &iport;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_epv2e_get(unit,
                ivid,
                iport,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_epv2e_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for epv2e */
int soc_sbx_g2p3_epv2e_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_epv2e_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_epv2e_t e0;
    soc_sbx_g2p3_epv2e_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EPV2E_ID];
    int ivid;
    int iport;
    void *indexpointers[2];

    indexpointers[0] = &ivid;
    indexpointers[1] = &iport;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_epv2e_t_init(e);

    rv = soc_sbx_g2p3_epv2e_get(unit,
                ivid,
                iport,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->drop,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->strip,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_epv2e_set(unit,
                ivid,
                iport,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for esmac */
void soc_sbx_g2p3_esmac_print(int unit, 
    soc_sbx_g2p3_esmac_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ESMAC_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->smac5; w = 5;  break;
        case 1: v = e->smac4; w = 5;  break;
        case 2: v = e->smac3; w = 5;  break;
        case 3: v = e->smac2; w = 5;  break;
        case 4: v = e->smac1; w = 5;  break;
        case 5: v = e->smac0; w = 5;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for esmac */
int soc_sbx_g2p3_esmac_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_esmac_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_esmac_t e0;
    soc_sbx_g2p3_esmac_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ESMAC_ID];
    int ismaci;
    void *indexpointers[1];

    indexpointers[0] = &ismaci;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_esmac_get(unit,
                ismaci,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_esmac_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for esmac */
int soc_sbx_g2p3_esmac_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_esmac_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_esmac_t e0;
    soc_sbx_g2p3_esmac_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ESMAC_ID];
    int ismaci;
    void *indexpointers[1];

    indexpointers[0] = &ismaci;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_esmac_t_init(e);

    rv = soc_sbx_g2p3_esmac_get(unit,
                ismaci,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->smac5,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->smac4,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->smac3,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->smac2,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2p3_value_read(&e->smac1,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g2p3_value_read(&e->smac0,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_esmac_set(unit,
                ismaci,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for ert */
void soc_sbx_g2p3_ert_print(int unit, 
    soc_sbx_g2p3_ert_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ERT_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->mirror; w = 6;  break;
        case 1: v = e->drop; w = 4;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ert */
int soc_sbx_g2p3_ert_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ert_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ert_t e0;
    soc_sbx_g2p3_ert_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ERT_ID];
    int irule;
    void *indexpointers[1];

    indexpointers[0] = &irule;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ert_get(unit,
                irule,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ert_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ert */
int soc_sbx_g2p3_ert_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ert_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ert_t e0;
    soc_sbx_g2p3_ert_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ERT_ID];
    int irule;
    void *indexpointers[1];

    indexpointers[0] = &irule;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ert_t_init(e);

    rv = soc_sbx_g2p3_ert_get(unit,
                irule,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->mirror,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->drop,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ert_set(unit,
                irule,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for ert_wrap */
void soc_sbx_g2p3_ert_wrap_print(int unit, 
    soc_sbx_g2p3_ert_wrap_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ERT_WRAP_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->mirror; w = 6;  break;
        case 1: v = e->drop; w = 4;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ert_wrap */
int soc_sbx_g2p3_ert_wrap_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ert_wrap_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ert_wrap_t e0;
    soc_sbx_g2p3_ert_wrap_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ERT_WRAP_ID];
    int irule;
    void *indexpointers[1];

    indexpointers[0] = &irule;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ert_wrap_get(unit,
                irule,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ert_wrap_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ert_wrap */
int soc_sbx_g2p3_ert_wrap_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ert_wrap_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ert_wrap_t e0;
    soc_sbx_g2p3_ert_wrap_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_ERT_WRAP_ID];
    int irule;
    void *indexpointers[1];

    indexpointers[0] = &irule;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ert_wrap_t_init(e);

    rv = soc_sbx_g2p3_ert_wrap_get(unit,
                irule,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->mirror,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->drop,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ert_wrap_set(unit,
                irule,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for v4mc_str_sel */
void soc_sbx_g2p3_v4mc_str_sel_print(int unit, 
    soc_sbx_g2p3_v4mc_str_sel_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_V4MC_STR_SEL_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->valid; w = 5;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for v4mc_str_sel */
int soc_sbx_g2p3_v4mc_str_sel_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_v4mc_str_sel_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_v4mc_str_sel_t e0;
    soc_sbx_g2p3_v4mc_str_sel_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_V4MC_STR_SEL_ID];
    int irule;
    void *indexpointers[1];

    indexpointers[0] = &irule;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_v4mc_str_sel_get(unit,
                irule,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_v4mc_str_sel_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for v4mc_str_sel */
int soc_sbx_g2p3_v4mc_str_sel_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_v4mc_str_sel_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_v4mc_str_sel_t e0;
    soc_sbx_g2p3_v4mc_str_sel_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_V4MC_STR_SEL_ID];
    int irule;
    void *indexpointers[1];

    indexpointers[0] = &irule;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_v4mc_str_sel_t_init(e);

    rv = soc_sbx_g2p3_v4mc_str_sel_get(unit,
                irule,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->valid,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_v4mc_str_sel_set(unit,
                irule,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for efp */
void soc_sbx_g2p3_efp_print(int unit, 
    soc_sbx_g2p3_efp_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EFP_ID];

    int j, digits;
    uint8 *s;
    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->dbtype; w = 6;  break;
        case 1: v = e->usedbtype; w = 9;  break;
        case 2: v = e->port; w = 4;  break;
        case 3: v = e->useport; w = 7;  break;
        case 4: s = e->pbmpn; w = 5; goto bigfield;
        case 5: v = e->pri; w = 3;  break;
        case 6: v = e->usepri; w = 6;  break;
        case 7: v = e->fragment; w = 8;  break;
        case 8: v = e->usefragment; w = 11;  break;
        case 9: v = e->urg; w = 3;  break;
        case 10: v = e->useurg; w = 6;  break;
        case 11: v = e->ack; w = 3;  break;
        case 12: v = e->useack; w = 6;  break;
        case 13: v = e->psh; w = 3;  break;
        case 14: v = e->usepsh; w = 6;  break;
        case 15: v = e->rst; w = 3;  break;
        case 16: v = e->userst; w = 6;  break;
        case 17: v = e->syn; w = 3;  break;
        case 18: v = e->usesyn; w = 6;  break;
        case 19: v = e->fin; w = 3;  break;
        case 20: v = e->usefin; w = 6;  break;
        case 21: v = e->dscp; w = 4;  break;
        case 22: v = e->usedscp; w = 7;  break;
        case 23: v = e->ecn; w = 3;  break;
        case 24: v = e->useecn; w = 6;  break;
        case 25: v = e->proto; w = 5;  break;
        case 26: v = e->useproto; w = 8;  break;
        case 27: v = e->sporthi; w = 7;  break;
        case 28: v = e->sportlo; w = 7;  break;
        case 29: v = e->dporthi; w = 7;  break;
        case 30: v = e->dportlo; w = 7;  break;
        case 31: v = e->sa; w = 2;  break;
        case 32: v = e->sawidth; w = 7;  break;
        case 33: v = e->da; w = 2;  break;
        case 34: v = e->dawidth; w = 7;  break;
        case 35: v = e->etype; w = 5;  break;
        case 36: v = e->useetype; w = 8;  break;
        case 37: s = e->smac; w = 4; goto bigfield;
        case 38: v = e->smacwidth; w = 9;  break;
        case 39: s = e->dmac; w = 4; goto bigfield;
        case 40: v = e->dmacwidth; w = 9;  break;
        case 41: v = e->pvlan; w = 5;  break;
        case 42: v = e->usepvlan; w = 8;  break;
        case 43: v = e->ssaphi; w = 6;  break;
        case 44: v = e->ssaplo; w = 6;  break;
        case 45: v = e->usessap; w = 7;  break;
        case 46: v = e->dsaphi; w = 6;  break;
        case 47: v = e->dsaplo; w = 6;  break;
        case 48: v = e->usedsap; w = 7;  break;
        case 49: v = e->llcctrlhi; w = 9;  break;
        case 50: v = e->llcctrllo; w = 9;  break;
        case 51: v = e->usellcctrl; w = 10;  break;
        case 52: v = e->enable; w = 6;  break;
        case 53: v = e->mirror; w = 6;  break;
        case 54: v = e->drop; w = 4;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
        continue;

    bigfield:
        digits = (width + 7) / 8;
        if ((col + w + 1 + 5 * digits) > 72) {
            soc_cm_print("\n  ");
            col=2;
        }
        soc_cm_print("%s=", fd->name);
        col += w + 1;
        for (j = 0; j < digits; j++) {
            soc_cm_print("0x%02x ", s[digits - j - 1]);
            col += 5;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for efp */
int soc_sbx_g2p3_efp_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_efp_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_efp_t e0;
    soc_sbx_g2p3_efp_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EFP_ID];
    int all = 0;
    int irule;
    void *indexpointers[1];

    indexpointers[0] = &irule;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_efp_first(unit,
                &irule);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("unexpected error in iterator first function\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all)
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_efp_get(unit,
                irule,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_efp_print(unit, e);

        if (all) {
            rv = soc_sbx_g2p3_efp_next(unit,
                irule,
                &irule);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for efp */
int soc_sbx_g2p3_efp_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_efp_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_efp_t e0;
    soc_sbx_g2p3_efp_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EFP_ID];
    int irule;
    void *indexpointers[1];

    indexpointers[0] = &irule;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_efp_t_init(e);

    rv = soc_sbx_g2p3_efp_get(unit,
                irule,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->dbtype,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->usedbtype,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->port,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->useport,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2p3_big_value_read(e->pbmpn,
                                ed->fields[4].width, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g2p3_value_read(&e->pri,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g2p3_value_read(&e->usepri,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g2p3_value_read(&e->fragment,
                                ed->fields[7].range, 0, argc, argv);
                 break;
        case 8: rv = soc_sbx_g2p3_value_read(&e->usefragment,
                                ed->fields[8].range, 0, argc, argv);
                 break;
        case 9: rv = soc_sbx_g2p3_value_read(&e->urg,
                                ed->fields[9].range, 0, argc, argv);
                 break;
        case 10: rv = soc_sbx_g2p3_value_read(&e->useurg,
                                ed->fields[10].range, 0, argc, argv);
                 break;
        case 11: rv = soc_sbx_g2p3_value_read(&e->ack,
                                ed->fields[11].range, 0, argc, argv);
                 break;
        case 12: rv = soc_sbx_g2p3_value_read(&e->useack,
                                ed->fields[12].range, 0, argc, argv);
                 break;
        case 13: rv = soc_sbx_g2p3_value_read(&e->psh,
                                ed->fields[13].range, 0, argc, argv);
                 break;
        case 14: rv = soc_sbx_g2p3_value_read(&e->usepsh,
                                ed->fields[14].range, 0, argc, argv);
                 break;
        case 15: rv = soc_sbx_g2p3_value_read(&e->rst,
                                ed->fields[15].range, 0, argc, argv);
                 break;
        case 16: rv = soc_sbx_g2p3_value_read(&e->userst,
                                ed->fields[16].range, 0, argc, argv);
                 break;
        case 17: rv = soc_sbx_g2p3_value_read(&e->syn,
                                ed->fields[17].range, 0, argc, argv);
                 break;
        case 18: rv = soc_sbx_g2p3_value_read(&e->usesyn,
                                ed->fields[18].range, 0, argc, argv);
                 break;
        case 19: rv = soc_sbx_g2p3_value_read(&e->fin,
                                ed->fields[19].range, 0, argc, argv);
                 break;
        case 20: rv = soc_sbx_g2p3_value_read(&e->usefin,
                                ed->fields[20].range, 0, argc, argv);
                 break;
        case 21: rv = soc_sbx_g2p3_value_read(&e->dscp,
                                ed->fields[21].range, 0, argc, argv);
                 break;
        case 22: rv = soc_sbx_g2p3_value_read(&e->usedscp,
                                ed->fields[22].range, 0, argc, argv);
                 break;
        case 23: rv = soc_sbx_g2p3_value_read(&e->ecn,
                                ed->fields[23].range, 0, argc, argv);
                 break;
        case 24: rv = soc_sbx_g2p3_value_read(&e->useecn,
                                ed->fields[24].range, 0, argc, argv);
                 break;
        case 25: rv = soc_sbx_g2p3_value_read(&e->proto,
                                ed->fields[25].range, 0, argc, argv);
                 break;
        case 26: rv = soc_sbx_g2p3_value_read(&e->useproto,
                                ed->fields[26].range, 0, argc, argv);
                 break;
        case 27: rv = soc_sbx_g2p3_value_read(&e->sporthi,
                                ed->fields[27].range, 0, argc, argv);
                 break;
        case 28: rv = soc_sbx_g2p3_value_read(&e->sportlo,
                                ed->fields[28].range, 0, argc, argv);
                 break;
        case 29: rv = soc_sbx_g2p3_value_read(&e->dporthi,
                                ed->fields[29].range, 0, argc, argv);
                 break;
        case 30: rv = soc_sbx_g2p3_value_read(&e->dportlo,
                                ed->fields[30].range, 0, argc, argv);
                 break;
        case 31: rv = soc_sbx_g2p3_value_read(&e->sa,
                                ed->fields[31].range, 0, argc, argv);
                 break;
        case 32: rv = soc_sbx_g2p3_value_read(&e->sawidth,
                                ed->fields[32].range, 0, argc, argv);
                 break;
        case 33: rv = soc_sbx_g2p3_value_read(&e->da,
                                ed->fields[33].range, 0, argc, argv);
                 break;
        case 34: rv = soc_sbx_g2p3_value_read(&e->dawidth,
                                ed->fields[34].range, 0, argc, argv);
                 break;
        case 35: rv = soc_sbx_g2p3_value_read(&e->etype,
                                ed->fields[35].range, 0, argc, argv);
                 break;
        case 36: rv = soc_sbx_g2p3_value_read(&e->useetype,
                                ed->fields[36].range, 0, argc, argv);
                 break;
        case 37: rv = soc_sbx_g2p3_big_value_read(e->smac,
                                ed->fields[37].width, 0, argc, argv);
                 break;
        case 38: rv = soc_sbx_g2p3_value_read(&e->smacwidth,
                                ed->fields[38].range, 0, argc, argv);
                 break;
        case 39: rv = soc_sbx_g2p3_big_value_read(e->dmac,
                                ed->fields[39].width, 0, argc, argv);
                 break;
        case 40: rv = soc_sbx_g2p3_value_read(&e->dmacwidth,
                                ed->fields[40].range, 0, argc, argv);
                 break;
        case 41: rv = soc_sbx_g2p3_value_read(&e->pvlan,
                                ed->fields[41].range, 0, argc, argv);
                 break;
        case 42: rv = soc_sbx_g2p3_value_read(&e->usepvlan,
                                ed->fields[42].range, 0, argc, argv);
                 break;
        case 43: rv = soc_sbx_g2p3_value_read(&e->ssaphi,
                                ed->fields[43].range, 0, argc, argv);
                 break;
        case 44: rv = soc_sbx_g2p3_value_read(&e->ssaplo,
                                ed->fields[44].range, 0, argc, argv);
                 break;
        case 45: rv = soc_sbx_g2p3_value_read(&e->usessap,
                                ed->fields[45].range, 0, argc, argv);
                 break;
        case 46: rv = soc_sbx_g2p3_value_read(&e->dsaphi,
                                ed->fields[46].range, 0, argc, argv);
                 break;
        case 47: rv = soc_sbx_g2p3_value_read(&e->dsaplo,
                                ed->fields[47].range, 0, argc, argv);
                 break;
        case 48: rv = soc_sbx_g2p3_value_read(&e->usedsap,
                                ed->fields[48].range, 0, argc, argv);
                 break;
        case 49: rv = soc_sbx_g2p3_value_read(&e->llcctrlhi,
                                ed->fields[49].range, 0, argc, argv);
                 break;
        case 50: rv = soc_sbx_g2p3_value_read(&e->llcctrllo,
                                ed->fields[50].range, 0, argc, argv);
                 break;
        case 51: rv = soc_sbx_g2p3_value_read(&e->usellcctrl,
                                ed->fields[51].range, 0, argc, argv);
                 break;
        case 52: rv = soc_sbx_g2p3_value_read(&e->enable,
                                ed->fields[52].range, 0, argc, argv);
                 break;
        case 53: rv = soc_sbx_g2p3_value_read(&e->mirror,
                                ed->fields[53].range, 0, argc, argv);
                 break;
        case 54: rv = soc_sbx_g2p3_value_read(&e->drop,
                                ed->fields[54].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_efp_set(unit,
                irule,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry diag shell delete implementation for efp */
int soc_sbx_g2p3_efp_shell_delete(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_efp_shell_delete(int unit,
         int argc, char **argv)
{
    int rv = 0, rv0;
    int all = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EFP_ID];
    int irule, nirule;
    void *indexpointers[1];

    indexpointers[0] = &irule;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_efp_first(unit,
                &nirule);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("iterator first function failed\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all) {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        if (all) {
            irule = nirule;

            rv = soc_sbx_g2p3_efp_next(unit,
                irule,
                &nirule);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
        rv0 = soc_sbx_g2p3_efp_delete(unit,
                irule);
        if (rv0) {
            soc_cm_print("delete of %s failed\n", ed->name);
            return rv0;
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry print accessor implementation for efp_v6 */
void soc_sbx_g2p3_efp_v6_print(int unit, 
    soc_sbx_g2p3_efp_v6_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EFP_V6_ID];

    int j, digits;
    uint8 *s;
    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->dbtype; w = 6;  break;
        case 1: v = e->usedbtype; w = 9;  break;
        case 2: v = e->port; w = 4;  break;
        case 3: v = e->useport; w = 7;  break;
        case 4: s = e->pbmpn; w = 5; goto bigfield;
        case 5: v = e->urg; w = 3;  break;
        case 6: v = e->useurg; w = 6;  break;
        case 7: v = e->ack; w = 3;  break;
        case 8: v = e->useack; w = 6;  break;
        case 9: v = e->psh; w = 3;  break;
        case 10: v = e->usepsh; w = 6;  break;
        case 11: v = e->rst; w = 3;  break;
        case 12: v = e->userst; w = 6;  break;
        case 13: v = e->syn; w = 3;  break;
        case 14: v = e->usesyn; w = 6;  break;
        case 15: v = e->fin; w = 3;  break;
        case 16: v = e->usefin; w = 6;  break;
        case 17: v = e->TC; w = 2;  break;
        case 18: v = e->useTC; w = 5;  break;
        case 19: v = e->nextheaderhi; w = 12;  break;
        case 20: v = e->nextheaderlo; w = 12;  break;
        case 21: v = e->sporthi; w = 7;  break;
        case 22: v = e->sportlo; w = 7;  break;
        case 23: v = e->dporthi; w = 7;  break;
        case 24: v = e->dportlo; w = 7;  break;
        case 25: s = e->sa; w = 2; goto bigfield;
        case 26: v = e->sawidth; w = 7;  break;
        case 27: s = e->da; w = 2; goto bigfield;
        case 28: v = e->dawidth; w = 7;  break;
        case 29: v = e->vid; w = 3;  break;
        case 30: v = e->usevid; w = 6;  break;
        case 31: v = e->enable; w = 6;  break;
        case 32: v = e->mirror; w = 6;  break;
        case 33: v = e->drop; w = 4;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
        continue;

    bigfield:
        digits = (width + 7) / 8;
        if ((col + w + 1 + 5 * digits) > 72) {
            soc_cm_print("\n  ");
            col=2;
        }
        soc_cm_print("%s=", fd->name);
        col += w + 1;
        for (j = 0; j < digits; j++) {
            soc_cm_print("0x%02x ", s[digits - j - 1]);
            col += 5;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for efp_v6 */
int soc_sbx_g2p3_efp_v6_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_efp_v6_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_efp_v6_t e0;
    soc_sbx_g2p3_efp_v6_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EFP_V6_ID];
    int all = 0;
    int irule;
    void *indexpointers[1];

    indexpointers[0] = &irule;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_efp_v6_first(unit,
                &irule);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("unexpected error in iterator first function\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all)
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_efp_v6_get(unit,
                irule,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_efp_v6_print(unit, e);

        if (all) {
            rv = soc_sbx_g2p3_efp_v6_next(unit,
                irule,
                &irule);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for efp_v6 */
int soc_sbx_g2p3_efp_v6_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_efp_v6_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_efp_v6_t e0;
    soc_sbx_g2p3_efp_v6_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EFP_V6_ID];
    int irule;
    void *indexpointers[1];

    indexpointers[0] = &irule;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_efp_v6_t_init(e);

    rv = soc_sbx_g2p3_efp_v6_get(unit,
                irule,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->dbtype,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->usedbtype,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->port,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->useport,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2p3_big_value_read(e->pbmpn,
                                ed->fields[4].width, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g2p3_value_read(&e->urg,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g2p3_value_read(&e->useurg,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g2p3_value_read(&e->ack,
                                ed->fields[7].range, 0, argc, argv);
                 break;
        case 8: rv = soc_sbx_g2p3_value_read(&e->useack,
                                ed->fields[8].range, 0, argc, argv);
                 break;
        case 9: rv = soc_sbx_g2p3_value_read(&e->psh,
                                ed->fields[9].range, 0, argc, argv);
                 break;
        case 10: rv = soc_sbx_g2p3_value_read(&e->usepsh,
                                ed->fields[10].range, 0, argc, argv);
                 break;
        case 11: rv = soc_sbx_g2p3_value_read(&e->rst,
                                ed->fields[11].range, 0, argc, argv);
                 break;
        case 12: rv = soc_sbx_g2p3_value_read(&e->userst,
                                ed->fields[12].range, 0, argc, argv);
                 break;
        case 13: rv = soc_sbx_g2p3_value_read(&e->syn,
                                ed->fields[13].range, 0, argc, argv);
                 break;
        case 14: rv = soc_sbx_g2p3_value_read(&e->usesyn,
                                ed->fields[14].range, 0, argc, argv);
                 break;
        case 15: rv = soc_sbx_g2p3_value_read(&e->fin,
                                ed->fields[15].range, 0, argc, argv);
                 break;
        case 16: rv = soc_sbx_g2p3_value_read(&e->usefin,
                                ed->fields[16].range, 0, argc, argv);
                 break;
        case 17: rv = soc_sbx_g2p3_value_read(&e->TC,
                                ed->fields[17].range, 0, argc, argv);
                 break;
        case 18: rv = soc_sbx_g2p3_value_read(&e->useTC,
                                ed->fields[18].range, 0, argc, argv);
                 break;
        case 19: rv = soc_sbx_g2p3_value_read(&e->nextheaderhi,
                                ed->fields[19].range, 0, argc, argv);
                 break;
        case 20: rv = soc_sbx_g2p3_value_read(&e->nextheaderlo,
                                ed->fields[20].range, 0, argc, argv);
                 break;
        case 21: rv = soc_sbx_g2p3_value_read(&e->sporthi,
                                ed->fields[21].range, 0, argc, argv);
                 break;
        case 22: rv = soc_sbx_g2p3_value_read(&e->sportlo,
                                ed->fields[22].range, 0, argc, argv);
                 break;
        case 23: rv = soc_sbx_g2p3_value_read(&e->dporthi,
                                ed->fields[23].range, 0, argc, argv);
                 break;
        case 24: rv = soc_sbx_g2p3_value_read(&e->dportlo,
                                ed->fields[24].range, 0, argc, argv);
                 break;
        case 25: rv = soc_sbx_g2p3_big_value_read(e->sa,
                                ed->fields[25].width, 0, argc, argv);
                 break;
        case 26: rv = soc_sbx_g2p3_value_read(&e->sawidth,
                                ed->fields[26].range, 0, argc, argv);
                 break;
        case 27: rv = soc_sbx_g2p3_big_value_read(e->da,
                                ed->fields[27].width, 0, argc, argv);
                 break;
        case 28: rv = soc_sbx_g2p3_value_read(&e->dawidth,
                                ed->fields[28].range, 0, argc, argv);
                 break;
        case 29: rv = soc_sbx_g2p3_value_read(&e->vid,
                                ed->fields[29].range, 0, argc, argv);
                 break;
        case 30: rv = soc_sbx_g2p3_value_read(&e->usevid,
                                ed->fields[30].range, 0, argc, argv);
                 break;
        case 31: rv = soc_sbx_g2p3_value_read(&e->enable,
                                ed->fields[31].range, 0, argc, argv);
                 break;
        case 32: rv = soc_sbx_g2p3_value_read(&e->mirror,
                                ed->fields[32].range, 0, argc, argv);
                 break;
        case 33: rv = soc_sbx_g2p3_value_read(&e->drop,
                                ed->fields[33].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_efp_v6_set(unit,
                irule,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry diag shell delete implementation for efp_v6 */
int soc_sbx_g2p3_efp_v6_shell_delete(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_efp_v6_shell_delete(int unit,
         int argc, char **argv)
{
    int rv = 0, rv0;
    int all = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_EFP_V6_ID];
    int irule, nirule;
    void *indexpointers[1];

    indexpointers[0] = &irule;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_efp_v6_first(unit,
                &nirule);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("iterator first function failed\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all) {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        if (all) {
            irule = nirule;

            rv = soc_sbx_g2p3_efp_v6_next(unit,
                irule,
                &nirule);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
        rv0 = soc_sbx_g2p3_efp_v6_delete(unit,
                irule);
        if (rv0) {
            soc_cm_print("delete of %s failed\n", ed->name);
            return rv0;
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry print accessor implementation for oamMultiplier */
void soc_sbx_g2p3_oammultiplier_print(int unit, 
    soc_sbx_g2p3_oammultiplier_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMMULTIPLIER_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->frameCount; w = 10;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for oamMultiplier */
int soc_sbx_g2p3_oammultiplier_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_oammultiplier_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_oammultiplier_t e0;
    soc_sbx_g2p3_oammultiplier_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMMULTIPLIER_ID];
    int ilosscount;
    int ithreshold;
    void *indexpointers[2];

    indexpointers[0] = &ilosscount;
    indexpointers[1] = &ithreshold;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_oammultiplier_get(unit,
                ilosscount,
                ithreshold,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_oammultiplier_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for oamMultiplier */
int soc_sbx_g2p3_oammultiplier_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_oammultiplier_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_oammultiplier_t e0;
    soc_sbx_g2p3_oammultiplier_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMMULTIPLIER_ID];
    int ilosscount;
    int ithreshold;
    void *indexpointers[2];

    indexpointers[0] = &ilosscount;
    indexpointers[1] = &ithreshold;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_oammultiplier_t_init(e);

    rv = soc_sbx_g2p3_oammultiplier_get(unit,
                ilosscount,
                ithreshold,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->frameCount,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_oammultiplier_set(unit,
                ilosscount,
                ithreshold,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for oamEpRemap */
void soc_sbx_g2p3_oamepremap_print(int unit, 
    soc_sbx_g2p3_oamepremap_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMEPREMAP_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->epIdx; w = 5;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for oamEpRemap */
int soc_sbx_g2p3_oamepremap_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_oamepremap_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_oamepremap_t e0;
    soc_sbx_g2p3_oamepremap_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMEPREMAP_ID];
    int iendpoint;
    int imdlevel;
    int itype;
    void *indexpointers[3];

    indexpointers[0] = &iendpoint;
    indexpointers[1] = &imdlevel;
    indexpointers[2] = &itype;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_oamepremap_get(unit,
                iendpoint,
                imdlevel,
                itype,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_oamepremap_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for oamEpRemap */
int soc_sbx_g2p3_oamepremap_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_oamepremap_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_oamepremap_t e0;
    soc_sbx_g2p3_oamepremap_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_OAMEPREMAP_ID];
    int iendpoint;
    int imdlevel;
    int itype;
    void *indexpointers[3];

    indexpointers[0] = &iendpoint;
    indexpointers[1] = &imdlevel;
    indexpointers[2] = &itype;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_oamepremap_t_init(e);

    rv = soc_sbx_g2p3_oamepremap_get(unit,
                iendpoint,
                imdlevel,
                itype,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->epIdx,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_oamepremap_set(unit,
                iendpoint,
                imdlevel,
                itype,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for ipv6da */
void soc_sbx_g2p3_ipv6da_print(int unit, 
    soc_sbx_g2p3_ipv6da_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DA_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->ftidx; w = 5;  break;
        case 1: v = e->ecmpmask; w = 8;  break;
        case 2: v = e->vid; w = 3;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ipv6da */
int soc_sbx_g2p3_ipv6da_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv6da_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ipv6da_t e0;
    soc_sbx_g2p3_ipv6da_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DA_ID];
    int all = 0;
    int iprefixbits;
    soc_sbx_g2p3_8_byte_t iip;
    void *indexpointers[2];

    indexpointers[0] = &iprefixbits;
    indexpointers[1] = &iip;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_ipv6da_first(unit,
                &iprefixbits,
                iip);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("unexpected error in iterator first function\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all)
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ipv6da_get(unit,
                iprefixbits,
                iip,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ipv6da_print(unit, e);

        if (all) {
            rv = soc_sbx_g2p3_ipv6da_next(unit,
                iprefixbits,
                iip,
                &iprefixbits,
                iip);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ipv6da */
int soc_sbx_g2p3_ipv6da_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ipv6da_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ipv6da_t e0;
    soc_sbx_g2p3_ipv6da_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DA_ID];
    int iprefixbits;
    soc_sbx_g2p3_8_byte_t iip;
    void *indexpointers[2];

    indexpointers[0] = &iprefixbits;
    indexpointers[1] = &iip;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ipv6da_t_init(e);

    rv = soc_sbx_g2p3_ipv6da_get(unit,
                iprefixbits,
                iip,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->ftidx,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->ecmpmask,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->vid,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ipv6da_set(unit,
                iprefixbits,
                iip,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry diag shell delete implementation for ipv6da */
int soc_sbx_g2p3_ipv6da_shell_delete(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv6da_shell_delete(int unit,
         int argc, char **argv)
{
    int rv = 0, rv0;
    int all = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DA_ID];
    int iprefixbits, niprefixbits;
    soc_sbx_g2p3_8_byte_t iip, niip;
    void *indexpointers[2];

    indexpointers[0] = &iprefixbits;
    indexpointers[1] = &iip;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_ipv6da_first(unit,
                &niprefixbits,
                niip);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("iterator first function failed\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all) {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        if (all) {
            iprefixbits = niprefixbits;
            sal_memcpy(iip, niip, 8);

            rv = soc_sbx_g2p3_ipv6da_next(unit,
                iprefixbits,
                iip,
                &niprefixbits,
                niip);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
        rv0 = soc_sbx_g2p3_ipv6da_delete(unit,
                iprefixbits,
                iip);
        if (rv0) {
            soc_cm_print("delete of %s failed\n", ed->name);
            return rv0;
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry print accessor implementation for ipv6dal0 */
void soc_sbx_g2p3_ipv6dal0_print(int unit, 
    soc_sbx_g2p3_ipv6dal0_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DAL0_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->pattern; w = 7;  break;
        case 1: v = e->singleton; w = 9;  break;
        case 2: v = e->pointer; w = 7;  break;
        case 3: v = e->leaf; w = 4;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ipv6dal0 */
int soc_sbx_g2p3_ipv6dal0_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv6dal0_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ipv6dal0_t e0;
    soc_sbx_g2p3_ipv6dal0_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DAL0_ID];
    int iaddr;
    void *indexpointers[1];

    indexpointers[0] = &iaddr;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ipv6dal0_get(unit,
                iaddr,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ipv6dal0_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ipv6dal0 */
int soc_sbx_g2p3_ipv6dal0_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ipv6dal0_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ipv6dal0_t e0;
    soc_sbx_g2p3_ipv6dal0_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DAL0_ID];
    int iaddr;
    void *indexpointers[1];

    indexpointers[0] = &iaddr;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ipv6dal0_t_init(e);

    rv = soc_sbx_g2p3_ipv6dal0_get(unit,
                iaddr,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->pattern,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->singleton,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->pointer,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->leaf,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ipv6dal0_set(unit,
                iaddr,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for ipv6daodd */
void soc_sbx_g2p3_ipv6daodd_print(int unit, 
    soc_sbx_g2p3_ipv6daodd_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DAODD_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->pattern; w = 7;  break;
        case 1: v = e->singleton; w = 9;  break;
        case 2: v = e->pointer; w = 7;  break;
        case 3: v = e->leaf; w = 4;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ipv6daodd */
int soc_sbx_g2p3_ipv6daodd_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv6daodd_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ipv6daodd_t e0;
    soc_sbx_g2p3_ipv6daodd_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DAODD_ID];
    int iaddr;
    void *indexpointers[1];

    indexpointers[0] = &iaddr;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ipv6daodd_get(unit,
                iaddr,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ipv6daodd_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ipv6daodd */
int soc_sbx_g2p3_ipv6daodd_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ipv6daodd_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ipv6daodd_t e0;
    soc_sbx_g2p3_ipv6daodd_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DAODD_ID];
    int iaddr;
    void *indexpointers[1];

    indexpointers[0] = &iaddr;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ipv6daodd_t_init(e);

    rv = soc_sbx_g2p3_ipv6daodd_get(unit,
                iaddr,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->pattern,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->singleton,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->pointer,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->leaf,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ipv6daodd_set(unit,
                iaddr,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for ipv6daeven */
void soc_sbx_g2p3_ipv6daeven_print(int unit, 
    soc_sbx_g2p3_ipv6daeven_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DAEVEN_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->pattern; w = 7;  break;
        case 1: v = e->singleton; w = 9;  break;
        case 2: v = e->pointer; w = 7;  break;
        case 3: v = e->leaf; w = 4;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ipv6daeven */
int soc_sbx_g2p3_ipv6daeven_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv6daeven_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ipv6daeven_t e0;
    soc_sbx_g2p3_ipv6daeven_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DAEVEN_ID];
    int iaddr;
    void *indexpointers[1];

    indexpointers[0] = &iaddr;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ipv6daeven_get(unit,
                iaddr,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ipv6daeven_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ipv6daeven */
int soc_sbx_g2p3_ipv6daeven_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ipv6daeven_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ipv6daeven_t e0;
    soc_sbx_g2p3_ipv6daeven_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DAEVEN_ID];
    int iaddr;
    void *indexpointers[1];

    indexpointers[0] = &iaddr;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ipv6daeven_t_init(e);

    rv = soc_sbx_g2p3_ipv6daeven_get(unit,
                iaddr,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->pattern,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->singleton,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->pointer,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->leaf,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ipv6daeven_set(unit,
                iaddr,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for ipv6dapayload */
void soc_sbx_g2p3_ipv6dapayload_print(int unit, 
    soc_sbx_g2p3_ipv6dapayload_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DAPAYLOAD_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->ftidx; w = 5;  break;
        case 1: v = e->ecmpmask; w = 8;  break;
        case 2: v = e->vid; w = 3;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ipv6dapayload */
int soc_sbx_g2p3_ipv6dapayload_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv6dapayload_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ipv6dapayload_t e0;
    soc_sbx_g2p3_ipv6dapayload_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DAPAYLOAD_ID];
    int iaddr;
    void *indexpointers[1];

    indexpointers[0] = &iaddr;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ipv6dapayload_get(unit,
                iaddr,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ipv6dapayload_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ipv6dapayload */
int soc_sbx_g2p3_ipv6dapayload_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ipv6dapayload_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ipv6dapayload_t e0;
    soc_sbx_g2p3_ipv6dapayload_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6DAPAYLOAD_ID];
    int iaddr;
    void *indexpointers[1];

    indexpointers[0] = &iaddr;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ipv6dapayload_t_init(e);

    rv = soc_sbx_g2p3_ipv6dapayload_get(unit,
                iaddr,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->ftidx,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->ecmpmask,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->vid,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ipv6dapayload_set(unit,
                iaddr,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for ipv6sa */
void soc_sbx_g2p3_ipv6sa_print(int unit, 
    soc_sbx_g2p3_ipv6sa_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SA_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->poe; w = 3;  break;
        case 1: v = e->rpfmode; w = 7;  break;
        case 2: v = e->srcdrop; w = 7;  break;
        case 3: v = e->srccnt; w = 6;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ipv6sa */
int soc_sbx_g2p3_ipv6sa_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv6sa_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ipv6sa_t e0;
    soc_sbx_g2p3_ipv6sa_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SA_ID];
    int all = 0;
    int iprefixbits;
    soc_sbx_g2p3_8_byte_t iip;
    void *indexpointers[2];

    indexpointers[0] = &iprefixbits;
    indexpointers[1] = &iip;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_ipv6sa_first(unit,
                &iprefixbits,
                iip);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("unexpected error in iterator first function\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all)
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ipv6sa_get(unit,
                iprefixbits,
                iip,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ipv6sa_print(unit, e);

        if (all) {
            rv = soc_sbx_g2p3_ipv6sa_next(unit,
                iprefixbits,
                iip,
                &iprefixbits,
                iip);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ipv6sa */
int soc_sbx_g2p3_ipv6sa_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ipv6sa_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ipv6sa_t e0;
    soc_sbx_g2p3_ipv6sa_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SA_ID];
    int iprefixbits;
    soc_sbx_g2p3_8_byte_t iip;
    void *indexpointers[2];

    indexpointers[0] = &iprefixbits;
    indexpointers[1] = &iip;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ipv6sa_t_init(e);

    rv = soc_sbx_g2p3_ipv6sa_get(unit,
                iprefixbits,
                iip,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->poe,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->rpfmode,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->srcdrop,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->srccnt,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ipv6sa_set(unit,
                iprefixbits,
                iip,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry diag shell delete implementation for ipv6sa */
int soc_sbx_g2p3_ipv6sa_shell_delete(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv6sa_shell_delete(int unit,
         int argc, char **argv)
{
    int rv = 0, rv0;
    int all = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SA_ID];
    int iprefixbits, niprefixbits;
    soc_sbx_g2p3_8_byte_t iip, niip;
    void *indexpointers[2];

    indexpointers[0] = &iprefixbits;
    indexpointers[1] = &iip;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_ipv6sa_first(unit,
                &niprefixbits,
                niip);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("iterator first function failed\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all) {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        if (all) {
            iprefixbits = niprefixbits;
            sal_memcpy(iip, niip, 8);

            rv = soc_sbx_g2p3_ipv6sa_next(unit,
                iprefixbits,
                iip,
                &niprefixbits,
                niip);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
        rv0 = soc_sbx_g2p3_ipv6sa_delete(unit,
                iprefixbits,
                iip);
        if (rv0) {
            soc_cm_print("delete of %s failed\n", ed->name);
            return rv0;
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry print accessor implementation for ipv6sal0 */
void soc_sbx_g2p3_ipv6sal0_print(int unit, 
    soc_sbx_g2p3_ipv6sal0_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SAL0_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->pattern; w = 7;  break;
        case 1: v = e->singleton; w = 9;  break;
        case 2: v = e->pointer; w = 7;  break;
        case 3: v = e->leaf; w = 4;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ipv6sal0 */
int soc_sbx_g2p3_ipv6sal0_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv6sal0_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ipv6sal0_t e0;
    soc_sbx_g2p3_ipv6sal0_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SAL0_ID];
    int iaddr;
    void *indexpointers[1];

    indexpointers[0] = &iaddr;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ipv6sal0_get(unit,
                iaddr,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ipv6sal0_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ipv6sal0 */
int soc_sbx_g2p3_ipv6sal0_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ipv6sal0_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ipv6sal0_t e0;
    soc_sbx_g2p3_ipv6sal0_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SAL0_ID];
    int iaddr;
    void *indexpointers[1];

    indexpointers[0] = &iaddr;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ipv6sal0_t_init(e);

    rv = soc_sbx_g2p3_ipv6sal0_get(unit,
                iaddr,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->pattern,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->singleton,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->pointer,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->leaf,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ipv6sal0_set(unit,
                iaddr,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for ipv6saodd */
void soc_sbx_g2p3_ipv6saodd_print(int unit, 
    soc_sbx_g2p3_ipv6saodd_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SAODD_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->pattern; w = 7;  break;
        case 1: v = e->singleton; w = 9;  break;
        case 2: v = e->pointer; w = 7;  break;
        case 3: v = e->leaf; w = 4;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ipv6saodd */
int soc_sbx_g2p3_ipv6saodd_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv6saodd_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ipv6saodd_t e0;
    soc_sbx_g2p3_ipv6saodd_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SAODD_ID];
    int iaddr;
    void *indexpointers[1];

    indexpointers[0] = &iaddr;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ipv6saodd_get(unit,
                iaddr,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ipv6saodd_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ipv6saodd */
int soc_sbx_g2p3_ipv6saodd_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ipv6saodd_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ipv6saodd_t e0;
    soc_sbx_g2p3_ipv6saodd_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SAODD_ID];
    int iaddr;
    void *indexpointers[1];

    indexpointers[0] = &iaddr;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ipv6saodd_t_init(e);

    rv = soc_sbx_g2p3_ipv6saodd_get(unit,
                iaddr,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->pattern,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->singleton,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->pointer,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->leaf,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ipv6saodd_set(unit,
                iaddr,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for ipv6saeven */
void soc_sbx_g2p3_ipv6saeven_print(int unit, 
    soc_sbx_g2p3_ipv6saeven_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SAEVEN_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->pattern; w = 7;  break;
        case 1: v = e->singleton; w = 9;  break;
        case 2: v = e->pointer; w = 7;  break;
        case 3: v = e->leaf; w = 4;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ipv6saeven */
int soc_sbx_g2p3_ipv6saeven_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv6saeven_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ipv6saeven_t e0;
    soc_sbx_g2p3_ipv6saeven_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SAEVEN_ID];
    int iaddr;
    void *indexpointers[1];

    indexpointers[0] = &iaddr;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ipv6saeven_get(unit,
                iaddr,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ipv6saeven_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ipv6saeven */
int soc_sbx_g2p3_ipv6saeven_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ipv6saeven_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ipv6saeven_t e0;
    soc_sbx_g2p3_ipv6saeven_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SAEVEN_ID];
    int iaddr;
    void *indexpointers[1];

    indexpointers[0] = &iaddr;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ipv6saeven_t_init(e);

    rv = soc_sbx_g2p3_ipv6saeven_get(unit,
                iaddr,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->pattern,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->singleton,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->pointer,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->leaf,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ipv6saeven_set(unit,
                iaddr,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for ipv6sapayload */
void soc_sbx_g2p3_ipv6sapayload_print(int unit, 
    soc_sbx_g2p3_ipv6sapayload_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SAPAYLOAD_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->poe; w = 3;  break;
        case 1: v = e->rpfmode; w = 7;  break;
        case 2: v = e->srcdrop; w = 7;  break;
        case 3: v = e->srccnt; w = 6;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ipv6sapayload */
int soc_sbx_g2p3_ipv6sapayload_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv6sapayload_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ipv6sapayload_t e0;
    soc_sbx_g2p3_ipv6sapayload_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SAPAYLOAD_ID];
    int iaddr;
    void *indexpointers[1];

    indexpointers[0] = &iaddr;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ipv6sapayload_get(unit,
                iaddr,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ipv6sapayload_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ipv6sapayload */
int soc_sbx_g2p3_ipv6sapayload_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ipv6sapayload_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ipv6sapayload_t e0;
    soc_sbx_g2p3_ipv6sapayload_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV6SAPAYLOAD_ID];
    int iaddr;
    void *indexpointers[1];

    indexpointers[0] = &iaddr;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ipv6sapayload_t_init(e);

    rv = soc_sbx_g2p3_ipv6sapayload_get(unit,
                iaddr,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->poe,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->rpfmode,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->srcdrop,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->srccnt,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ipv6sapayload_set(unit,
                iaddr,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for ipv4da */
void soc_sbx_g2p3_ipv4da_print(int unit, 
    soc_sbx_g2p3_ipv4da_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DA_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->ftidx; w = 5;  break;
        case 1: v = e->ecmpmask; w = 8;  break;
        case 2: v = e->vid; w = 3;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ipv4da */
int soc_sbx_g2p3_ipv4da_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv4da_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ipv4da_t e0;
    soc_sbx_g2p3_ipv4da_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DA_ID];
    int all = 0;
    int iprefixbits;
    int iip;
    int iipcxt;
    void *indexpointers[3];

    indexpointers[0] = &iprefixbits;
    indexpointers[1] = &iip;
    indexpointers[2] = &iipcxt;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_ipv4da_first(unit,
                &iprefixbits,
                &iip,
                &iipcxt);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("unexpected error in iterator first function\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all)
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ipv4da_get(unit,
                iprefixbits,
                iip,
                iipcxt,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ipv4da_print(unit, e);

        if (all) {
            rv = soc_sbx_g2p3_ipv4da_next(unit,
                iprefixbits,
                iip,
                iipcxt,
                &iprefixbits,
                &iip,
                &iipcxt);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ipv4da */
int soc_sbx_g2p3_ipv4da_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ipv4da_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ipv4da_t e0;
    soc_sbx_g2p3_ipv4da_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DA_ID];
    int iprefixbits;
    int iip;
    int iipcxt;
    void *indexpointers[3];

    indexpointers[0] = &iprefixbits;
    indexpointers[1] = &iip;
    indexpointers[2] = &iipcxt;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ipv4da_t_init(e);

    rv = soc_sbx_g2p3_ipv4da_get(unit,
                iprefixbits,
                iip,
                iipcxt,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->ftidx,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->ecmpmask,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->vid,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ipv4da_set(unit,
                iprefixbits,
                iip,
                iipcxt,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry diag shell delete implementation for ipv4da */
int soc_sbx_g2p3_ipv4da_shell_delete(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv4da_shell_delete(int unit,
         int argc, char **argv)
{
    int rv = 0, rv0;
    int all = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DA_ID];
    int iprefixbits, niprefixbits;
    int iip, niip;
    int iipcxt, niipcxt;
    void *indexpointers[3];

    indexpointers[0] = &iprefixbits;
    indexpointers[1] = &iip;
    indexpointers[2] = &iipcxt;

    if (argc > 0 && !sal_strcasecmp(argv[0], "all")) {
        if (argc > 1) {
            soc_cm_print("extra arguments following 'all'\n");
            return SOC_E_PARAM;
        }
        all = 1;
        rv = soc_sbx_g2p3_ipv4da_first(unit,
                &niprefixbits,
                &niip,
                &niipcxt);
        if (rv == SOC_E_NOT_FOUND) {
            soc_cm_print("no entries\n");
            return SOC_E_NONE;
        } else if (rv) {
            soc_cm_print("iterator first function failed\n");
            return rv;
        }
        argc--;
        argv++;
    }

    if (!all) {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        if (all) {
            iprefixbits = niprefixbits;
            iip = niip;
            iipcxt = niipcxt;

            rv = soc_sbx_g2p3_ipv4da_next(unit,
                iprefixbits,
                iip,
                iipcxt,
                &niprefixbits,
                &niip,
                &niipcxt);
            if (rv && rv != SOC_E_NOT_FOUND) {
                soc_cm_print("iterator next function failed\n");
                return rv;
            }
        }
        rv0 = soc_sbx_g2p3_ipv4da_delete(unit,
                iprefixbits,
                iip,
                iipcxt);
        if (rv0) {
            soc_cm_print("delete of %s failed\n", ed->name);
            return rv0;
        }
    } while (all && rv == SOC_E_NONE);

    return SOC_E_NONE;
}

/* entry print accessor implementation for ipv4dal0 */
void soc_sbx_g2p3_ipv4dal0_print(int unit, 
    soc_sbx_g2p3_ipv4dal0_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DAL0_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->pattern; w = 7;  break;
        case 1: v = e->singleton; w = 9;  break;
        case 2: v = e->pointer; w = 7;  break;
        case 3: v = e->leaf; w = 4;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ipv4dal0 */
int soc_sbx_g2p3_ipv4dal0_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv4dal0_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ipv4dal0_t e0;
    soc_sbx_g2p3_ipv4dal0_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DAL0_ID];
    int iaddr;
    void *indexpointers[1];

    indexpointers[0] = &iaddr;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ipv4dal0_get(unit,
                iaddr,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ipv4dal0_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ipv4dal0 */
int soc_sbx_g2p3_ipv4dal0_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ipv4dal0_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ipv4dal0_t e0;
    soc_sbx_g2p3_ipv4dal0_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DAL0_ID];
    int iaddr;
    void *indexpointers[1];

    indexpointers[0] = &iaddr;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ipv4dal0_t_init(e);

    rv = soc_sbx_g2p3_ipv4dal0_get(unit,
                iaddr,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->pattern,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->singleton,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->pointer,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->leaf,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ipv4dal0_set(unit,
                iaddr,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for ipv4daodd */
void soc_sbx_g2p3_ipv4daodd_print(int unit, 
    soc_sbx_g2p3_ipv4daodd_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DAODD_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->pattern; w = 7;  break;
        case 1: v = e->singleton; w = 9;  break;
        case 2: v = e->pointer; w = 7;  break;
        case 3: v = e->leaf; w = 4;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ipv4daodd */
int soc_sbx_g2p3_ipv4daodd_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv4daodd_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ipv4daodd_t e0;
    soc_sbx_g2p3_ipv4daodd_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DAODD_ID];
    int iaddr;
    void *indexpointers[1];

    indexpointers[0] = &iaddr;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ipv4daodd_get(unit,
                iaddr,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ipv4daodd_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ipv4daodd */
int soc_sbx_g2p3_ipv4daodd_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ipv4daodd_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ipv4daodd_t e0;
    soc_sbx_g2p3_ipv4daodd_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DAODD_ID];
    int iaddr;
    void *indexpointers[1];

    indexpointers[0] = &iaddr;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ipv4daodd_t_init(e);

    rv = soc_sbx_g2p3_ipv4daodd_get(unit,
                iaddr,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->pattern,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->singleton,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->pointer,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->leaf,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ipv4daodd_set(unit,
                iaddr,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for ipv4daeven */
void soc_sbx_g2p3_ipv4daeven_print(int unit, 
    soc_sbx_g2p3_ipv4daeven_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DAEVEN_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->pattern; w = 7;  break;
        case 1: v = e->singleton; w = 9;  break;
        case 2: v = e->pointer; w = 7;  break;
        case 3: v = e->leaf; w = 4;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ipv4daeven */
int soc_sbx_g2p3_ipv4daeven_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv4daeven_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ipv4daeven_t e0;
    soc_sbx_g2p3_ipv4daeven_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DAEVEN_ID];
    int iaddr;
    void *indexpointers[1];

    indexpointers[0] = &iaddr;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ipv4daeven_get(unit,
                iaddr,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ipv4daeven_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ipv4daeven */
int soc_sbx_g2p3_ipv4daeven_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ipv4daeven_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ipv4daeven_t e0;
    soc_sbx_g2p3_ipv4daeven_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DAEVEN_ID];
    int iaddr;
    void *indexpointers[1];

    indexpointers[0] = &iaddr;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ipv4daeven_t_init(e);

    rv = soc_sbx_g2p3_ipv4daeven_get(unit,
                iaddr,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->pattern,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->singleton,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->pointer,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->leaf,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ipv4daeven_set(unit,
                iaddr,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for ipv4dapayload */
void soc_sbx_g2p3_ipv4dapayload_print(int unit, 
    soc_sbx_g2p3_ipv4dapayload_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DAPAYLOAD_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->ftidx; w = 5;  break;
        case 1: v = e->ecmpmask; w = 8;  break;
        case 2: v = e->vid; w = 3;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ipv4dapayload */
int soc_sbx_g2p3_ipv4dapayload_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_ipv4dapayload_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_ipv4dapayload_t e0;
    soc_sbx_g2p3_ipv4dapayload_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DAPAYLOAD_ID];
    int iaddr;
    void *indexpointers[1];

    indexpointers[0] = &iaddr;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_ipv4dapayload_get(unit,
                iaddr,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_ipv4dapayload_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ipv4dapayload */
int soc_sbx_g2p3_ipv4dapayload_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_ipv4dapayload_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_ipv4dapayload_t e0;
    soc_sbx_g2p3_ipv4dapayload_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_IPV4DAPAYLOAD_ID];
    int iaddr;
    void *indexpointers[1];

    indexpointers[0] = &iaddr;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_ipv4dapayload_t_init(e);

    rv = soc_sbx_g2p3_ipv4dapayload_get(unit,
                iaddr,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->ftidx,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->ecmpmask,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->vid,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ipv4dapayload_set(unit,
                iaddr,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for P2FTI */
void soc_sbx_g2p3_p2fti_print(int unit, 
    soc_sbx_g2p3_p2fti_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2FTI_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->ftidx; w = 5;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for P2FTI */
int soc_sbx_g2p3_p2fti_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2p3_p2fti_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2p3_p2fti_t e0;
    soc_sbx_g2p3_p2fti_t *e = &e0;
    int rv;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2FTI_ID];
    int iport;
    int idmac;
    void *indexpointers[2];

    indexpointers[0] = &iport;
    indexpointers[1] = &idmac;
    {
        rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2p3_p2fti_get(unit,
                iport,
                idmac,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2p3_indexes_print(indexpointers, ed);
        soc_sbx_g2p3_p2fti_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for P2FTI */
int soc_sbx_g2p3_p2fti_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2p3_p2fti_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2p3_p2fti_t e0;
    soc_sbx_g2p3_p2fti_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_P2FTI_ID];
    int iport;
    int idmac;
    void *indexpointers[2];

    indexpointers[0] = &iport;
    indexpointers[1] = &idmac;

    rv = soc_sbx_g2p3_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2p3_p2fti_t_init(e);

    rv = soc_sbx_g2p3_p2fti_get(unit,
                iport,
                idmac,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->ftidx,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_p2fti_set(unit,
                iport,
                idmac,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for policer */
void soc_sbx_g2p3_policer_print(int unit, 
    soc_sbx_g2p3_policer_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_POLICER_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->cbsbytes; w = 8;  break;
        case 1: v = e->cirkbps; w = 7;  break;
        case 2: v = e->ebsbytes; w = 8;  break;
        case 3: v = e->eirkbps; w = 7;  break;
        case 4: v = e->mode; w = 4;  break;
        case 5: v = e->lenshift; w = 8;  break;
        case 6: v = e->colorblind; w = 10;  break;
        case 7: v = e->dropred; w = 7;  break;
        case 8: v = e->coupling; w = 8;  break;
        case 9: v = e->nodebit; w = 7;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry print accessor implementation for timer */
void soc_sbx_g2p3_timer_print(int unit, 
    soc_sbx_g2p3_timer_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_TIMER_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->ms; w = 2;  break;
        case 1: v = e->started; w = 7;  break;
        case 2: v = e->ucodereset; w = 10;  break;
        case 3: v = e->interrupt; w = 9;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry print accessor implementation for sequence */
void soc_sbx_g2p3_sequence_print(int unit, 
    soc_sbx_g2p3_sequence_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2p3_field_desc_t *fd;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_SEQUENCE_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->seqnum; w = 6;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2p3_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/*
 * Shell entry print implementation
 */
int soc_sbx_g2p3_entries_shell_print(int unit,
             int eid, int argc, char **argv);
int
soc_sbx_g2p3_entries_shell_print(int unit,
         int eid, int argc, char **argv)
{
    int rv;
    switch (eid) {
    case SOC_SBX_G2P3_P2E_ID:
        rv = soc_sbx_g2p3_p2e_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_EP2E_ID:
        rv = soc_sbx_g2p3_ep2e_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_P2E20_ID:
        rv = soc_sbx_g2p3_p2e20_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_EP2E20_ID:
        rv = soc_sbx_g2p3_ep2e20_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_P2E25_ID:
        rv = soc_sbx_g2p3_p2e25_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_EP2E25_ID:
        rv = soc_sbx_g2p3_ep2e25_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_TPID_ID:
        rv = soc_sbx_g2p3_tpid_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_OAM_RX_ID:
        rv = soc_sbx_g2p3_oam_rx_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_OAM_TX_ID:
        rv = soc_sbx_g2p3_oam_tx_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_LSMAC_ID:
        rv = soc_sbx_g2p3_lsmac_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_L2CPMAC_ID:
        rv = soc_sbx_g2p3_l2cpmac_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_OAMUPMAC_ID:
        rv = soc_sbx_g2p3_oamupmac_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_QOS_ID:
        rv = soc_sbx_g2p3_qos_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_DSCP_QOS_ID:
        rv = soc_sbx_g2p3_dscp_qos_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_IRT_ID:
        rv = soc_sbx_g2p3_irt_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_IRT_WRAP_ID:
        rv = soc_sbx_g2p3_irt_wrap_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_RT_MT_ID:
        rv = soc_sbx_g2p3_rt_mt_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_RT_RR0_ID:
        rv = soc_sbx_g2p3_rt_rr0_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_RT_RR1_ID:
        rv = soc_sbx_g2p3_rt_rr1_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_LAG_ID:
        rv = soc_sbx_g2p3_lag_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_RR_ID:
        rv = soc_sbx_g2p3_rr_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_XT_ID:
        rv = soc_sbx_g2p3_xt_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_MIRROR_ID:
        rv = soc_sbx_g2p3_mirror_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_EMIRROR_ID:
        rv = soc_sbx_g2p3_emirror_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_EMIRROR20_ID:
        rv = soc_sbx_g2p3_emirror20_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_EMIRROR25_ID:
        rv = soc_sbx_g2p3_emirror25_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_MAC_ID:
        rv = soc_sbx_g2p3_mac_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_MACL1_ID:
        rv = soc_sbx_g2p3_macl1_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_MACL2_ID:
        rv = soc_sbx_g2p3_macl2_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6DHOST_ID:
        rv = soc_sbx_g2p3_ipv6dhost_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6DHOSTL1_ID:
        rv = soc_sbx_g2p3_ipv6dhostl1_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6DHOSTL2_ID:
        rv = soc_sbx_g2p3_ipv6dhostl2_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_MST_ID:
        rv = soc_sbx_g2p3_mst_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_PV2E_ID:
        rv = soc_sbx_g2p3_pv2e_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_P2APPDATA_ID:
        rv = soc_sbx_g2p3_p2appdata_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_PV2APPDATA_ID:
        rv = soc_sbx_g2p3_pv2appdata_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6SHOST_ID:
        rv = soc_sbx_g2p3_ipv6shost_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6SHOSTL1_ID:
        rv = soc_sbx_g2p3_ipv6shostl1_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6SHOSTL2_ID:
        rv = soc_sbx_g2p3_ipv6shostl2_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_PVV2E_ID:
        rv = soc_sbx_g2p3_pvv2e_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_PVV2EPACK_ID:
        rv = soc_sbx_g2p3_pvv2epack_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_ISID2E_ID:
        rv = soc_sbx_g2p3_isid2e_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_OAMPVD2E_ID:
        rv = soc_sbx_g2p3_oampvd2e_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_OAMMAIDMEP2E_ID:
        rv = soc_sbx_g2p3_oammaidmep2e_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_CUCKOO_ID:
        rv = soc_sbx_g2p3_cuckoo_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_LEFT_ID:
        rv = soc_sbx_g2p3_left_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_RIGHT_ID:
        rv = soc_sbx_g2p3_right_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_OUTERLABELCUCKOO_ID:
        rv = soc_sbx_g2p3_outerlabelcuckoo_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_OUTERLABELLEFT_ID:
        rv = soc_sbx_g2p3_outerlabelleft_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_OUTERLABELRIGHT_ID:
        rv = soc_sbx_g2p3_outerlabelright_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_INNERLABELCUCKOO_ID:
        rv = soc_sbx_g2p3_innerlabelcuckoo_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_INNERLABELLEFT_ID:
        rv = soc_sbx_g2p3_innerlabelleft_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_INNERLABELRIGHT_ID:
        rv = soc_sbx_g2p3_innerlabelright_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_LABEL2E_ID:
        rv = soc_sbx_g2p3_label2e_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_TAGGED_MPLS_ID:
        rv = soc_sbx_g2p3_tagged_mpls_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_V2E_ID:
        rv = soc_sbx_g2p3_v2e_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_V2E1_ID:
        rv = soc_sbx_g2p3_v2e1_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_LP_ID:
        rv = soc_sbx_g2p3_lp_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_L2E_ID:
        rv = soc_sbx_g2p3_l2e_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_L2CP_ID:
        rv = soc_sbx_g2p3_l2cp_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_L2CPSLOW_ID:
        rv = soc_sbx_g2p3_l2cpslow_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_L2CPNOP_ID:
        rv = soc_sbx_g2p3_l2cpnop_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_FT_ID:
        rv = soc_sbx_g2p3_ft_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_OAMTIMERCALENDAR_ID:
        rv = soc_sbx_g2p3_oamtimercalendar_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_OAMPORTMDLEVEL2ETC_ID:
        rv = soc_sbx_g2p3_oamportmdlevel2etc_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_V4UC_STR_SEL_ID:
        rv = soc_sbx_g2p3_v4uc_str_sel_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_CMAC_ID:
        rv = soc_sbx_g2p3_cmac_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_BMAC_ID:
        rv = soc_sbx_g2p3_bmac_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6MCSG_ID:
        rv = soc_sbx_g2p3_ipv6mcsg_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6MCSGL1_ID:
        rv = soc_sbx_g2p3_ipv6mcsgl1_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6MCSGL2_ID:
        rv = soc_sbx_g2p3_ipv6mcsgl2_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6MCG_ID:
        rv = soc_sbx_g2p3_ipv6mcg_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6MCGL1_ID:
        rv = soc_sbx_g2p3_ipv6mcgl1_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6MCGL2_ID:
        rv = soc_sbx_g2p3_ipv6mcgl2_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV4MCG_ID:
        rv = soc_sbx_g2p3_ipv4mcg_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV4MCGL1_ID:
        rv = soc_sbx_g2p3_ipv4mcgl1_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV4MCGL2_ID:
        rv = soc_sbx_g2p3_ipv4mcgl2_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV4MCSG_ID:
        rv = soc_sbx_g2p3_ipv4mcsg_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV4MCSGL1_ID:
        rv = soc_sbx_g2p3_ipv4mcsgl1_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV4MCSGL2_ID:
        rv = soc_sbx_g2p3_ipv4mcsgl2_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV4SA_ID:
        rv = soc_sbx_g2p3_ipv4sa_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV4SAL0_ID:
        rv = soc_sbx_g2p3_ipv4sal0_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV4SAODD_ID:
        rv = soc_sbx_g2p3_ipv4saodd_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV4SAEVEN_ID:
        rv = soc_sbx_g2p3_ipv4saeven_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV4SAPAYLOAD_ID:
        rv = soc_sbx_g2p3_ipv4sapayload_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_IFP_ID:
        rv = soc_sbx_g2p3_ifp_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_IFP_V6_ID:
        rv = soc_sbx_g2p3_ifp_v6_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_EVP2E_ID:
        rv = soc_sbx_g2p3_evp2e_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_OI2E_ID:
        rv = soc_sbx_g2p3_oi2e_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_ETEENCAP_ID:
        rv = soc_sbx_g2p3_eteencap_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_ETEL2_ID:
        rv = soc_sbx_g2p3_etel2_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_OAMEP_ID:
        rv = soc_sbx_g2p3_oamep_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_REMARK_ID:
        rv = soc_sbx_g2p3_remark_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_EPV2E_ID:
        rv = soc_sbx_g2p3_epv2e_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_ESMAC_ID:
        rv = soc_sbx_g2p3_esmac_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_ERT_ID:
        rv = soc_sbx_g2p3_ert_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_ERT_WRAP_ID:
        rv = soc_sbx_g2p3_ert_wrap_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_V4MC_STR_SEL_ID:
        rv = soc_sbx_g2p3_v4mc_str_sel_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_EFP_ID:
        rv = soc_sbx_g2p3_efp_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_EFP_V6_ID:
        rv = soc_sbx_g2p3_efp_v6_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_OAMMULTIPLIER_ID:
        rv = soc_sbx_g2p3_oammultiplier_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_OAMEPREMAP_ID:
        rv = soc_sbx_g2p3_oamepremap_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6DA_ID:
        rv = soc_sbx_g2p3_ipv6da_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6DAL0_ID:
        rv = soc_sbx_g2p3_ipv6dal0_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6DAODD_ID:
        rv = soc_sbx_g2p3_ipv6daodd_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6DAEVEN_ID:
        rv = soc_sbx_g2p3_ipv6daeven_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6DAPAYLOAD_ID:
        rv = soc_sbx_g2p3_ipv6dapayload_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6SA_ID:
        rv = soc_sbx_g2p3_ipv6sa_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6SAL0_ID:
        rv = soc_sbx_g2p3_ipv6sal0_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6SAODD_ID:
        rv = soc_sbx_g2p3_ipv6saodd_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6SAEVEN_ID:
        rv = soc_sbx_g2p3_ipv6saeven_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6SAPAYLOAD_ID:
        rv = soc_sbx_g2p3_ipv6sapayload_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV4DA_ID:
        rv = soc_sbx_g2p3_ipv4da_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV4DAL0_ID:
        rv = soc_sbx_g2p3_ipv4dal0_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV4DAODD_ID:
        rv = soc_sbx_g2p3_ipv4daodd_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV4DAEVEN_ID:
        rv = soc_sbx_g2p3_ipv4daeven_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV4DAPAYLOAD_ID:
        rv = soc_sbx_g2p3_ipv4dapayload_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2P3_P2FTI_ID:
        rv = soc_sbx_g2p3_p2fti_shell_print(unit, argc, argv); break;
    default: rv = SOC_E_NOT_FOUND;
    }
    return rv;
}

/*
 * Shell entry set implementation
 */
int soc_sbx_g2p3_entries_shell_set(int unit, 
             int eid, int argc, char **argv);
int
soc_sbx_g2p3_entries_shell_set(int unit, 
         int eid, int argc, char **argv)
{
    int rv;
    switch (eid) {
    case SOC_SBX_G2P3_P2E_ID:
        rv = soc_sbx_g2p3_p2e_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_EP2E_ID:
        rv = soc_sbx_g2p3_ep2e_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_P2E20_ID:
        rv = soc_sbx_g2p3_p2e20_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_EP2E20_ID:
        rv = soc_sbx_g2p3_ep2e20_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_P2E25_ID:
        rv = soc_sbx_g2p3_p2e25_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_EP2E25_ID:
        rv = soc_sbx_g2p3_ep2e25_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_TPID_ID:
        rv = soc_sbx_g2p3_tpid_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_OAM_RX_ID:
        rv = soc_sbx_g2p3_oam_rx_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_OAM_TX_ID:
        rv = soc_sbx_g2p3_oam_tx_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_LSMAC_ID:
        rv = soc_sbx_g2p3_lsmac_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_L2CPMAC_ID:
        rv = soc_sbx_g2p3_l2cpmac_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_OAMUPMAC_ID:
        rv = soc_sbx_g2p3_oamupmac_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_QOS_ID:
        rv = soc_sbx_g2p3_qos_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_DSCP_QOS_ID:
        rv = soc_sbx_g2p3_dscp_qos_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_IRT_ID:
        rv = soc_sbx_g2p3_irt_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_IRT_WRAP_ID:
        rv = soc_sbx_g2p3_irt_wrap_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_RT_MT_ID:
        rv = soc_sbx_g2p3_rt_mt_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_RT_RR0_ID:
        rv = soc_sbx_g2p3_rt_rr0_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_RT_RR1_ID:
        rv = soc_sbx_g2p3_rt_rr1_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_LAG_ID:
        rv = soc_sbx_g2p3_lag_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_RR_ID:
        rv = soc_sbx_g2p3_rr_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_XT_ID:
        rv = soc_sbx_g2p3_xt_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_MIRROR_ID:
        rv = soc_sbx_g2p3_mirror_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_EMIRROR_ID:
        rv = soc_sbx_g2p3_emirror_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_EMIRROR20_ID:
        rv = soc_sbx_g2p3_emirror20_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_EMIRROR25_ID:
        rv = soc_sbx_g2p3_emirror25_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_MAC_ID:
        rv = soc_sbx_g2p3_mac_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_MACL1_ID:
        rv = soc_sbx_g2p3_macl1_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_MACL2_ID:
        rv = soc_sbx_g2p3_macl2_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6DHOST_ID:
        rv = soc_sbx_g2p3_ipv6dhost_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6DHOSTL1_ID:
        rv = soc_sbx_g2p3_ipv6dhostl1_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6DHOSTL2_ID:
        rv = soc_sbx_g2p3_ipv6dhostl2_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_MST_ID:
        rv = soc_sbx_g2p3_mst_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_PV2E_ID:
        rv = soc_sbx_g2p3_pv2e_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_P2APPDATA_ID:
        rv = soc_sbx_g2p3_p2appdata_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_PV2APPDATA_ID:
        rv = soc_sbx_g2p3_pv2appdata_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6SHOST_ID:
        rv = soc_sbx_g2p3_ipv6shost_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6SHOSTL1_ID:
        rv = soc_sbx_g2p3_ipv6shostl1_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6SHOSTL2_ID:
        rv = soc_sbx_g2p3_ipv6shostl2_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_PVV2E_ID:
        rv = soc_sbx_g2p3_pvv2e_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_PVV2EPACK_ID:
        rv = soc_sbx_g2p3_pvv2epack_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_ISID2E_ID:
        rv = soc_sbx_g2p3_isid2e_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_OAMPVD2E_ID:
        rv = soc_sbx_g2p3_oampvd2e_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_OAMMAIDMEP2E_ID:
        rv = soc_sbx_g2p3_oammaidmep2e_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_CUCKOO_ID:
        rv = soc_sbx_g2p3_cuckoo_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_LEFT_ID:
        rv = soc_sbx_g2p3_left_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_RIGHT_ID:
        rv = soc_sbx_g2p3_right_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_OUTERLABELCUCKOO_ID:
        rv = soc_sbx_g2p3_outerlabelcuckoo_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_OUTERLABELLEFT_ID:
        rv = soc_sbx_g2p3_outerlabelleft_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_OUTERLABELRIGHT_ID:
        rv = soc_sbx_g2p3_outerlabelright_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_INNERLABELCUCKOO_ID:
        rv = soc_sbx_g2p3_innerlabelcuckoo_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_INNERLABELLEFT_ID:
        rv = soc_sbx_g2p3_innerlabelleft_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_INNERLABELRIGHT_ID:
        rv = soc_sbx_g2p3_innerlabelright_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_LABEL2E_ID:
        rv = soc_sbx_g2p3_label2e_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_TAGGED_MPLS_ID:
        rv = soc_sbx_g2p3_tagged_mpls_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_V2E_ID:
        rv = soc_sbx_g2p3_v2e_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_V2E1_ID:
        rv = soc_sbx_g2p3_v2e1_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_LP_ID:
        rv = soc_sbx_g2p3_lp_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_L2E_ID:
        rv = soc_sbx_g2p3_l2e_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_L2CP_ID:
        rv = soc_sbx_g2p3_l2cp_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_L2CPSLOW_ID:
        rv = soc_sbx_g2p3_l2cpslow_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_L2CPNOP_ID:
        rv = soc_sbx_g2p3_l2cpnop_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_FT_ID:
        rv = soc_sbx_g2p3_ft_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_OAMTIMERCALENDAR_ID:
        rv = soc_sbx_g2p3_oamtimercalendar_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_OAMPORTMDLEVEL2ETC_ID:
        rv = soc_sbx_g2p3_oamportmdlevel2etc_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_V4UC_STR_SEL_ID:
        rv = soc_sbx_g2p3_v4uc_str_sel_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_CMAC_ID:
        rv = soc_sbx_g2p3_cmac_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_BMAC_ID:
        rv = soc_sbx_g2p3_bmac_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6MCSG_ID:
        rv = soc_sbx_g2p3_ipv6mcsg_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6MCSGL1_ID:
        rv = soc_sbx_g2p3_ipv6mcsgl1_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6MCSGL2_ID:
        rv = soc_sbx_g2p3_ipv6mcsgl2_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6MCG_ID:
        rv = soc_sbx_g2p3_ipv6mcg_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6MCGL1_ID:
        rv = soc_sbx_g2p3_ipv6mcgl1_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6MCGL2_ID:
        rv = soc_sbx_g2p3_ipv6mcgl2_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV4MCG_ID:
        rv = soc_sbx_g2p3_ipv4mcg_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV4MCGL1_ID:
        rv = soc_sbx_g2p3_ipv4mcgl1_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV4MCGL2_ID:
        rv = soc_sbx_g2p3_ipv4mcgl2_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV4MCSG_ID:
        rv = soc_sbx_g2p3_ipv4mcsg_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV4MCSGL1_ID:
        rv = soc_sbx_g2p3_ipv4mcsgl1_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV4MCSGL2_ID:
        rv = soc_sbx_g2p3_ipv4mcsgl2_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV4SA_ID:
        rv = soc_sbx_g2p3_ipv4sa_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV4SAL0_ID:
        rv = soc_sbx_g2p3_ipv4sal0_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV4SAODD_ID:
        rv = soc_sbx_g2p3_ipv4saodd_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV4SAEVEN_ID:
        rv = soc_sbx_g2p3_ipv4saeven_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV4SAPAYLOAD_ID:
        rv = soc_sbx_g2p3_ipv4sapayload_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_IFP_ID:
        rv = soc_sbx_g2p3_ifp_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_IFP_V6_ID:
        rv = soc_sbx_g2p3_ifp_v6_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_EVP2E_ID:
        rv = soc_sbx_g2p3_evp2e_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_OI2E_ID:
        rv = soc_sbx_g2p3_oi2e_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_ETEENCAP_ID:
        rv = soc_sbx_g2p3_eteencap_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_ETEL2_ID:
        rv = soc_sbx_g2p3_etel2_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_OAMEP_ID:
        rv = soc_sbx_g2p3_oamep_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_REMARK_ID:
        rv = soc_sbx_g2p3_remark_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_EPV2E_ID:
        rv = soc_sbx_g2p3_epv2e_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_ESMAC_ID:
        rv = soc_sbx_g2p3_esmac_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_ERT_ID:
        rv = soc_sbx_g2p3_ert_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_ERT_WRAP_ID:
        rv = soc_sbx_g2p3_ert_wrap_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_V4MC_STR_SEL_ID:
        rv = soc_sbx_g2p3_v4mc_str_sel_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_EFP_ID:
        rv = soc_sbx_g2p3_efp_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_EFP_V6_ID:
        rv = soc_sbx_g2p3_efp_v6_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_OAMMULTIPLIER_ID:
        rv = soc_sbx_g2p3_oammultiplier_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_OAMEPREMAP_ID:
        rv = soc_sbx_g2p3_oamepremap_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6DA_ID:
        rv = soc_sbx_g2p3_ipv6da_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6DAL0_ID:
        rv = soc_sbx_g2p3_ipv6dal0_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6DAODD_ID:
        rv = soc_sbx_g2p3_ipv6daodd_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6DAEVEN_ID:
        rv = soc_sbx_g2p3_ipv6daeven_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6DAPAYLOAD_ID:
        rv = soc_sbx_g2p3_ipv6dapayload_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6SA_ID:
        rv = soc_sbx_g2p3_ipv6sa_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6SAL0_ID:
        rv = soc_sbx_g2p3_ipv6sal0_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6SAODD_ID:
        rv = soc_sbx_g2p3_ipv6saodd_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6SAEVEN_ID:
        rv = soc_sbx_g2p3_ipv6saeven_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6SAPAYLOAD_ID:
        rv = soc_sbx_g2p3_ipv6sapayload_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV4DA_ID:
        rv = soc_sbx_g2p3_ipv4da_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV4DAL0_ID:
        rv = soc_sbx_g2p3_ipv4dal0_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV4DAODD_ID:
        rv = soc_sbx_g2p3_ipv4daodd_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV4DAEVEN_ID:
        rv = soc_sbx_g2p3_ipv4daeven_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV4DAPAYLOAD_ID:
        rv = soc_sbx_g2p3_ipv4dapayload_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2P3_P2FTI_ID:
        rv = soc_sbx_g2p3_p2fti_shell_set(unit, argc, argv); break;
    default: rv = SOC_E_NOT_FOUND;
    }
    return rv;
}

/*
 * Shell entry delete implementation
 */
int soc_sbx_g2p3_entries_shell_delete(int unit, 
             int eid, int argc, char **argv);
int
soc_sbx_g2p3_entries_shell_delete(int unit, 
         int eid, int argc, char **argv)
{
    int rv;
    switch (eid) {
    case SOC_SBX_G2P3_MAC_ID:
        rv = soc_sbx_g2p3_mac_shell_delete(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6DHOST_ID:
        rv = soc_sbx_g2p3_ipv6dhost_shell_delete(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6SHOST_ID:
        rv = soc_sbx_g2p3_ipv6shost_shell_delete(unit, argc, argv); break;
    case SOC_SBX_G2P3_PVV2E_ID:
        rv = soc_sbx_g2p3_pvv2e_shell_delete(unit, argc, argv); break;
    case SOC_SBX_G2P3_PVV2EPACK_ID:
        rv = soc_sbx_g2p3_pvv2epack_shell_delete(unit, argc, argv); break;
    case SOC_SBX_G2P3_ISID2E_ID:
        rv = soc_sbx_g2p3_isid2e_shell_delete(unit, argc, argv); break;
    case SOC_SBX_G2P3_OAMPVD2E_ID:
        rv = soc_sbx_g2p3_oampvd2e_shell_delete(unit, argc, argv); break;
    case SOC_SBX_G2P3_OAMMAIDMEP2E_ID:
        rv = soc_sbx_g2p3_oammaidmep2e_shell_delete(unit, argc, argv); break;
    case SOC_SBX_G2P3_CUCKOO_ID:
        rv = soc_sbx_g2p3_cuckoo_shell_delete(unit, argc, argv); break;
    case SOC_SBX_G2P3_OUTERLABELCUCKOO_ID:
        rv = soc_sbx_g2p3_outerlabelcuckoo_shell_delete(unit, argc, argv); break;
    case SOC_SBX_G2P3_INNERLABELCUCKOO_ID:
        rv = soc_sbx_g2p3_innerlabelcuckoo_shell_delete(unit, argc, argv); break;
    case SOC_SBX_G2P3_LABEL2E_ID:
        rv = soc_sbx_g2p3_label2e_shell_delete(unit, argc, argv); break;
    case SOC_SBX_G2P3_CMAC_ID:
        rv = soc_sbx_g2p3_cmac_shell_delete(unit, argc, argv); break;
    case SOC_SBX_G2P3_BMAC_ID:
        rv = soc_sbx_g2p3_bmac_shell_delete(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6MCSG_ID:
        rv = soc_sbx_g2p3_ipv6mcsg_shell_delete(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6MCG_ID:
        rv = soc_sbx_g2p3_ipv6mcg_shell_delete(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV4MCG_ID:
        rv = soc_sbx_g2p3_ipv4mcg_shell_delete(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV4MCSG_ID:
        rv = soc_sbx_g2p3_ipv4mcsg_shell_delete(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV4SA_ID:
        rv = soc_sbx_g2p3_ipv4sa_shell_delete(unit, argc, argv); break;
    case SOC_SBX_G2P3_IFP_ID:
        rv = soc_sbx_g2p3_ifp_shell_delete(unit, argc, argv); break;
    case SOC_SBX_G2P3_IFP_V6_ID:
        rv = soc_sbx_g2p3_ifp_v6_shell_delete(unit, argc, argv); break;
    case SOC_SBX_G2P3_EFP_ID:
        rv = soc_sbx_g2p3_efp_shell_delete(unit, argc, argv); break;
    case SOC_SBX_G2P3_EFP_V6_ID:
        rv = soc_sbx_g2p3_efp_v6_shell_delete(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6DA_ID:
        rv = soc_sbx_g2p3_ipv6da_shell_delete(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV6SA_ID:
        rv = soc_sbx_g2p3_ipv6sa_shell_delete(unit, argc, argv); break;
    case SOC_SBX_G2P3_IPV4DA_ID:
        rv = soc_sbx_g2p3_ipv4da_shell_delete(unit, argc, argv); break;
    default: rv = SOC_E_NOT_FOUND;
    }
    return rv;
}

/* Diag shell print counter memory contents */
int soc_sbx_g2p3_counters_shell_print(int unit,
                int cid, int argc, char **argv);
int soc_sbx_g2p3_counters_shell_print(int unit,
                int cid, int argc, char **argv)
{
    int rv, i;
    soc_sbx_g2p3_counter_value_t cv;
    uint32 lo, hi;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_counter_desc_t *cd = &tm->counters[cid];
    int clear = 1;
    int all   = 0;
    int print = 1;
    int lower = 0;
    int upper = cd->size - 1;
    int sang = 0;

    rv = soc_sbx_g2p3_range_parse(argc, argv, &lower, &upper,
                 &all, "all", &clear, "clear", &print, "print");
    if (rv) {
        return rv;
    }

    sang = 0;
    for (i = lower; i <= upper; i++) {
        switch (cid) {
        case SOC_SBX_G2P3_PDCTR_ID:
            rv = soc_sbx_g2p3_pdctr_get(unit, clear, i, &cv);
            break;
        case SOC_SBX_G2P3_RTCTR_ID:
            rv = soc_sbx_g2p3_rtctr_get(unit, clear, i, &cv);
            break;
        case SOC_SBX_G2P3_IRTCTR_ID:
            rv = soc_sbx_g2p3_irtctr_get(unit, clear, i, &cv);
            break;
        case SOC_SBX_G2P3_IFPCTR_ID:
            rv = soc_sbx_g2p3_ifpctr_get(unit, clear, i, &cv);
            break;
        case SOC_SBX_G2P3_IFP_V6CTR_ID:
            rv = soc_sbx_g2p3_ifp_v6ctr_get(unit, clear, i, &cv);
            break;
        case SOC_SBX_G2P3_ERTCTR_ID:
            rv = soc_sbx_g2p3_ertctr_get(unit, clear, i, &cv);
            break;
        case SOC_SBX_G2P3_EFPCTR_ID:
            rv = soc_sbx_g2p3_efpctr_get(unit, clear, i, &cv);
            break;
        case SOC_SBX_G2P3_EFP_V6CTR_ID:
            rv = soc_sbx_g2p3_efp_v6ctr_get(unit, clear, i, &cv);
            break;
        case SOC_SBX_G2P3_EXCCTR_ID:
            rv = soc_sbx_g2p3_excctr_get(unit, clear, i, &cv);
            break;
        case SOC_SBX_G2P3_INGCTR_ID:
            rv = soc_sbx_g2p3_ingctr_get(unit, clear, i, &cv);
            break;
        case SOC_SBX_G2P3_EGRCTR_ID:
            rv = soc_sbx_g2p3_egrctr_get(unit, clear, i, &cv);
            break;
        default: soc_cm_print("bogus counter ID\n"); return SOC_E_INTERNAL;      
        }
        
        if (print
            && (!COMPILER_64_IS_ZERO(cv.bytes)
                || !COMPILER_64_IS_ZERO(cv.bytes))) {
            soc_sbx_g2p3_print(cd->size, i);
            lo = COMPILER_64_LO(cv.bytes);
            hi = COMPILER_64_HI(cv.bytes);
            soc_cm_print(" 0x%08x%08x bytes, ", hi, lo);
            lo = COMPILER_64_LO(cv.packets);
            hi = COMPILER_64_HI(cv.packets);
            soc_cm_print("0x%08x%08x packets\n", hi, lo);
            sang = 1;
            if (!all) {
                break;
            }
        }
    }

    if (print && !sang) {
        soc_cm_print("no nonzero counters\n");
    }

    return SOC_E_NONE;
}

/* Policers shell print */
int soc_sbx_g2p3_policers_shell_print(int unit,
                int pid, int argc, char **argv);
int soc_sbx_g2p3_policers_shell_print(int unit,
                int pid, int argc, char **argv)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_policer_desc_t *pd = &tm->policers[pid];
    soc_sbx_g2p3_policer_t policer;
    soc_sbx_g2p3_timer_t timer;
    soc_sbx_g2p3_sequence_t sequence;
    int rv, i;
    int all = 0;
    int lower = 0;
    int upper = pd->size - 1;
    int spoke = 0;

    rv = soc_sbx_g2p3_range_parse(argc, argv, &lower, &upper,
                 &all, "all", NULL, NULL, NULL, NULL);
    if (rv) {
        return rv;
    }
    for (i = lower; i <= upper; i++) {
        switch (pid) {
        case SOC_SBX_G2P3_XTPOL_ID:
            rv = soc_sbx_g2p3_xtpol_get(unit, i, &policer);
            if (rv == SOC_E_NOT_FOUND) {
                break;
            } else if (rv) {
                soc_cm_print("error reading %s[0x%x]\n", pd->name, i);
                return rv;
            }
            soc_cm_print("%s[", pd->name);
            soc_sbx_g2p3_print(pd->size, i);
            soc_cm_print("]:\n");
            soc_sbx_g2p3_policer_print(unit, &policer);
            spoke = 1;
            break;
        case SOC_SBX_G2P3_INGEGRPOL_ID:
            rv = soc_sbx_g2p3_ingegrpol_get(unit, i, &policer);
            if (rv == SOC_E_NOT_FOUND) {
                break;
            } else if (rv) {
                soc_cm_print("error reading %s[0x%x]\n", pd->name, i);
                return rv;
            }
            soc_cm_print("%s[", pd->name);
            soc_sbx_g2p3_print(pd->size, i);
            soc_cm_print("]:\n");
            soc_sbx_g2p3_policer_print(unit, &policer);
            spoke = 1;
            break;
        case SOC_SBX_G2P3_OAMTIMER_ID:
            rv = soc_sbx_g2p3_oamtimer_get(unit, i, &timer);
            if (rv == SOC_E_NOT_FOUND) {
                break;
            } else if (rv) {
                soc_cm_print("error reading %s[0x%x]\n", pd->name, i);
                return rv;
            }
            soc_cm_print("%s[", pd->name);
            soc_sbx_g2p3_print(pd->size, i);
            soc_cm_print("]:\n");
            soc_sbx_g2p3_timer_print(unit, &timer);
            spoke = 1;
            break;
        case SOC_SBX_G2P3_OAMSEQ_ID:
            rv = soc_sbx_g2p3_oamseq_get(unit, i, &sequence);
            if (rv == SOC_E_NOT_FOUND) {
                break;
            } else if (rv) {
                soc_cm_print("error reading %s[0x%x]\n", pd->name, i);
                return rv;
            }
            soc_cm_print("%s[", pd->name);
            soc_sbx_g2p3_print(pd->size, i);
            soc_cm_print("]:\n");
            soc_sbx_g2p3_sequence_print(unit, &sequence);
            spoke = 1;
            break;
        default:
            soc_cm_print("unexpected policer bank id: %d\n", pid);
            return SOC_E_INTERNAL;
        }
        if (!all && spoke) {
            break;
        }
    }

    if (!spoke) {
        soc_cm_print("no valid policer\n");
    }
    return SOC_E_NONE;
}

/* Shell policer set function for xtpol */
int soc_sbx_g2p3_xtpol_shell_set(int unit, int argc, char **argv);
int soc_sbx_g2p3_xtpol_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g2p3_policer_t e0;
    soc_sbx_g2p3_policer_t *e = &e0;
    int rv, fidx, idx = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_policer_desc_t *pd =
        &tm->policers[SOC_SBX_G2P3_XTPOL_ID];
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_POLICER_ID];


    if (argc > 0) {
        rv = soc_sbx_g2p3_read(argv[0], pd->size, (uint32 *) &idx);
        if (rv == SOC_E_NONE) {
            argc--;
            argv++;
        }
    }
          
    soc_sbx_g2p3_policer_t_init(e);

    rv = soc_sbx_g2p3_xtpol_get(unit, idx, e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", pd->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->cbsbytes,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->cirkbps,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->ebsbytes,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->eirkbps,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2p3_value_read(&e->mode,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g2p3_value_read(&e->lenshift,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g2p3_value_read(&e->colorblind,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g2p3_value_read(&e->dropred,
                                ed->fields[7].range, 0, argc, argv);
                 break;
        case 8: rv = soc_sbx_g2p3_value_read(&e->coupling,
                                ed->fields[8].range, 0, argc, argv);
                 break;
        case 9: rv = soc_sbx_g2p3_value_read(&e->nodebit,
                                ed->fields[9].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_xtpol_set(unit, idx, e);

    if (rv) {
        soc_cm_print("set of %s failed\n", pd->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* Shell policer set function for ingegrpol */
int soc_sbx_g2p3_ingegrpol_shell_set(int unit, int argc, char **argv);
int soc_sbx_g2p3_ingegrpol_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g2p3_policer_t e0;
    soc_sbx_g2p3_policer_t *e = &e0;
    int rv, fidx, idx = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_policer_desc_t *pd =
        &tm->policers[SOC_SBX_G2P3_INGEGRPOL_ID];
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_POLICER_ID];


    if (argc > 0) {
        rv = soc_sbx_g2p3_read(argv[0], pd->size, (uint32 *) &idx);
        if (rv == SOC_E_NONE) {
            argc--;
            argv++;
        }
    }
          
    soc_sbx_g2p3_policer_t_init(e);

    rv = soc_sbx_g2p3_ingegrpol_get(unit, idx, e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", pd->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->cbsbytes,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->cirkbps,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->ebsbytes,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->eirkbps,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2p3_value_read(&e->mode,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g2p3_value_read(&e->lenshift,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g2p3_value_read(&e->colorblind,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g2p3_value_read(&e->dropred,
                                ed->fields[7].range, 0, argc, argv);
                 break;
        case 8: rv = soc_sbx_g2p3_value_read(&e->coupling,
                                ed->fields[8].range, 0, argc, argv);
                 break;
        case 9: rv = soc_sbx_g2p3_value_read(&e->nodebit,
                                ed->fields[9].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_ingegrpol_set(unit, idx, e);

    if (rv) {
        soc_cm_print("set of %s failed\n", pd->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* Shell policer set function for oamtimer */
int soc_sbx_g2p3_oamtimer_shell_set(int unit, int argc, char **argv);
int soc_sbx_g2p3_oamtimer_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g2p3_timer_t e0;
    soc_sbx_g2p3_timer_t *e = &e0;
    int rv, fidx, idx = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_policer_desc_t *pd =
        &tm->policers[SOC_SBX_G2P3_OAMTIMER_ID];
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_TIMER_ID];


    if (argc > 0) {
        rv = soc_sbx_g2p3_read(argv[0], pd->size, (uint32 *) &idx);
        if (rv == SOC_E_NONE) {
            argc--;
            argv++;
        }
    }
          
    soc_sbx_g2p3_timer_t_init(e);

    rv = soc_sbx_g2p3_oamtimer_get(unit, idx, e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", pd->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->ms,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2p3_value_read(&e->started,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2p3_value_read(&e->ucodereset,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2p3_value_read(&e->interrupt,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_oamtimer_set(unit, idx, e);

    if (rv) {
        soc_cm_print("set of %s failed\n", pd->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* Shell policer set function for oamseq */
int soc_sbx_g2p3_oamseq_shell_set(int unit, int argc, char **argv);
int soc_sbx_g2p3_oamseq_shell_set(int unit, int argc, char **argv)
{
    soc_sbx_g2p3_sequence_t e0;
    soc_sbx_g2p3_sequence_t *e = &e0;
    int rv, fidx, idx = 0;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_policer_desc_t *pd =
        &tm->policers[SOC_SBX_G2P3_OAMSEQ_ID];
    soc_sbx_g2p3_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2P3_SEQUENCE_ID];


    if (argc > 0) {
        rv = soc_sbx_g2p3_read(argv[0], pd->size, (uint32 *) &idx);
        if (rv == SOC_E_NONE) {
            argc--;
            argv++;
        }
    }
          
    soc_sbx_g2p3_sequence_t_init(e);

    rv = soc_sbx_g2p3_oamseq_get(unit, idx, e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", pd->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2p3_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2p3_value_read(&e->seqnum,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2p3_oamseq_set(unit, idx, e);

    if (rv) {
        soc_cm_print("set of %s failed\n", pd->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* Policer shell set */
int soc_sbx_g2p3_policers_shell_set(int unit,
                int pid, int argc, char **argv);
int soc_sbx_g2p3_policers_shell_set(int unit,
                int pid, int argc, char **argv)
{
    int rv;
    switch (pid) {
        case SOC_SBX_G2P3_XTPOL_ID:
            rv = soc_sbx_g2p3_xtpol_shell_set(unit, argc, argv);
            break;
        case SOC_SBX_G2P3_INGEGRPOL_ID:
            rv = soc_sbx_g2p3_ingegrpol_shell_set(unit, argc, argv);
            break;
        case SOC_SBX_G2P3_OAMTIMER_ID:
            rv = soc_sbx_g2p3_oamtimer_shell_set(unit, argc, argv);
            break;
        case SOC_SBX_G2P3_OAMSEQ_ID:
            rv = soc_sbx_g2p3_oamseq_shell_set(unit, argc, argv);
            break;
    default:
        soc_cm_print("unexpected policer bank id: %d\n", pid);
        return SOC_E_INTERNAL;
    }

    return rv;
}

/* Policer shell delete */
int soc_sbx_g2p3_policers_shell_delete(int unit,
                int pid, int argc, char **argv);
int soc_sbx_g2p3_policers_shell_delete(int unit,
                int pid, int argc, char **argv)
{
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_policer_desc_t *pd = &tm->policers[pid];
    int rv, i;
    int lower = 0;
    int upper = pd->size - 1;

    rv = soc_sbx_g2p3_range_parse(argc, argv, &lower, &upper,
                 NULL, NULL, NULL, NULL, NULL, NULL);
    if (rv) {
        return rv;
    }
    for (i = lower; i <= upper; i++) {
        switch (pid) {
        case SOC_SBX_G2P3_XTPOL_ID:
            rv = soc_sbx_g2p3_xtpol_delete(unit, i);
            if (rv == SOC_E_NOT_FOUND) {
                break;
            } else if (rv) {
                soc_cm_print("error deleting %s[0x%x]\n", pd->name, i);
                return rv;
            }
            break;
        case SOC_SBX_G2P3_INGEGRPOL_ID:
            rv = soc_sbx_g2p3_ingegrpol_delete(unit, i);
            if (rv == SOC_E_NOT_FOUND) {
                break;
            } else if (rv) {
                soc_cm_print("error deleting %s[0x%x]\n", pd->name, i);
                return rv;
            }
            break;
        case SOC_SBX_G2P3_OAMTIMER_ID:
            rv = soc_sbx_g2p3_oamtimer_delete(unit, i);
            if (rv == SOC_E_NOT_FOUND) {
                break;
            } else if (rv) {
                soc_cm_print("error deleting %s[0x%x]\n", pd->name, i);
                return rv;
            }
            break;
        case SOC_SBX_G2P3_OAMSEQ_ID:
            rv = soc_sbx_g2p3_oamseq_delete(unit, i);
            if (rv == SOC_E_NOT_FOUND) {
                break;
            } else if (rv) {
                soc_cm_print("error deleting %s[0x%x]\n", pd->name, i);
                return rv;
            }
            break;
        default:
            soc_cm_print("unexpected policer bank id: %d\n", pid);
            return SOC_E_INTERNAL;
        }
    }

    return SOC_E_NONE;
}

/* Diag shell print memory contents */
int soc_sbx_g2p3_memory_shell_print(int unit,
             int mid, int argc, char **argv);
int
soc_sbx_g2p3_memory_shell_print(int unit,
         int mid, int argc, char **argv)
{
    int rv, i, words, offset, iscnt, shimword;
    uint32 addr, v, prot, protsave = 0;
    char *name;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_memory_desc_t *md = &tm->memories[mid];
    int mwidth = md->width;
    int opcode;

    if (argc == 0) {
        soc_cm_print("missing address\n");
        return SOC_E_PARAM;
    }
    rv = soc_sbx_g2p3_read(argv[0], 1 << 23, &addr);
    if (rv) {
        soc_cm_print("illegal address %s\n", argv[0]);
        return SOC_E_PARAM;
    }

    rv = soc_sbx_g2p3_memory_bank_find(tm,
                  md, (int) addr, &name, &offset, &iscnt);
    if (rv) {
        soc_cm_print("illegal address %s\n", argv[0]);
        return rv;
    }

    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (iscnt) {
        switch (mid) {
        case SOC_SBX_G2P3_MM0_NAR0_ID:
            protsave
                = SAND_HAL_FE2000_READ_STRIDE(fe->regSet, MM, 0,
                                              MM_PROT_SCHEME0);
            prot = SAND_HAL_FE2000_MOD_FIELD(fe->regSet, MM_PROT_SCHEME0,
                                             NP0_PI_SCHEME,
                                             protsave,
                                             SB_FE2000_MM_35BITS_1BITPARITY);
            SAND_HAL_FE2000_WRITE_STRIDE(fe->regSet, MM, 0, MM_PROT_SCHEME0,
                                         prot);
            break;
        case SOC_SBX_G2P3_MM0_NAR1_ID:
            protsave
                = SAND_HAL_FE2000_READ_STRIDE(fe->regSet, MM, 0,
                                              MM_PROT_SCHEME0);
            prot = SAND_HAL_FE2000_MOD_FIELD(fe->regSet, MM_PROT_SCHEME0,
                                             NP1_PI_SCHEME,
                                             protsave,
                                             SB_FE2000_MM_35BITS_1BITPARITY);
            SAND_HAL_FE2000_WRITE_STRIDE(fe->regSet, MM, 0, MM_PROT_SCHEME0,
                                         prot);
            break;
        case SOC_SBX_G2P3_MM1_NAR0_ID:
            protsave
                = SAND_HAL_FE2000_READ_STRIDE(fe->regSet, MM, 1,
                                              MM_PROT_SCHEME0);
            prot = SAND_HAL_FE2000_MOD_FIELD(fe->regSet, MM_PROT_SCHEME0,
                                             NP0_PI_SCHEME,
                                             protsave,
                                             SB_FE2000_MM_35BITS_1BITPARITY);
            SAND_HAL_FE2000_WRITE_STRIDE(fe->regSet, MM, 1, MM_PROT_SCHEME0,
                                         prot);
            break;
        case SOC_SBX_G2P3_MM1_NAR1_ID:
            protsave
                = SAND_HAL_FE2000_READ_STRIDE(fe->regSet, MM, 1,
                                              MM_PROT_SCHEME0);
            prot = SAND_HAL_FE2000_MOD_FIELD(fe->regSet, MM_PROT_SCHEME0,
                                             NP1_PI_SCHEME,
                                             protsave,
                                             SB_FE2000_MM_35BITS_1BITPARITY);
            SAND_HAL_FE2000_WRITE_STRIDE(fe->regSet, MM, 1, MM_PROT_SCHEME0,
                                         prot);
            break;
        case SOC_SBX_G2P3_MM0_INT0_ID:
        case SOC_SBX_G2P3_MM0_INT1_ID:
        case SOC_SBX_G2P3_MM1_INT0_ID:
        case SOC_SBX_G2P3_MM1_INT1_ID:
            break;
        default:
            soc_cm_print("unexpected counter memory: %d\n", mid);
            sal_mutex_give(tm->dmabufmutex);
            return SOC_E_INTERNAL;
        }
        mwidth = 35;
    }

    words = (mwidth + 31) / 32;
    shimword = words < 2 && mid <= SOC_SBX_G2P3_MM1_INT1_ID;
    words += shimword;

    if (md->dma) {
        opcode = SB_FE2000_DMA_OPCODE_READ;
        tm->entrydmaop.opcode = opcode;
        tm->entrydmaop.words = (uint32) ((mwidth + 31) / 32);
        tm->entrydmaop.hostAddress = 
            (uint32 *) (tm->entrydmabuf);
        /*offset = (uint32) 
            (tb->base + ((idx * eb->stridebits) / mwidth));*/
          tm->entrydmaop.hostBusAddress = tm->entrydmabufhba; /*+ bytes;*/
          tm->entrydmaop.feAddress = (uint32)
            SB_FE2000_DMA_MAKE_ADDRESS(mid, addr);
          rv = sbFe2000DmaRequest(fe->pDmaMgr, INT_TO_PTR(unit),
                                 &tm->entrydmaop);
    }else{
        rv = sbFe2000UtilReadIndir(fe->regSet, 1, md->descending,
                               md->reg, addr, words,
                               (uint32 *) tm->entrydmabuf);
    }

    if (iscnt) {
        switch (mid) {
        case SOC_SBX_G2P3_MM0_NAR0_ID:
        case SOC_SBX_G2P3_MM0_NAR1_ID:
            SAND_HAL_FE2000_WRITE_STRIDE(fe->regSet, MM, 0, MM_PROT_SCHEME0,
                                  protsave);
            break;
        case SOC_SBX_G2P3_MM1_NAR0_ID:
        case SOC_SBX_G2P3_MM1_NAR1_ID:
            SAND_HAL_FE2000_WRITE_STRIDE(fe->regSet, MM, 1, MM_PROT_SCHEME0,
                                  protsave);
            break;
        }
    }

    if (rv) {
        soc_cm_print("memory read from %s[0x%x] failed\n",
                tm->memories[mid].name, addr);
        sal_mutex_give(tm->dmabufmutex);
        return SOC_E_FAIL;
    }
        
    soc_cm_print("%s[0x%x]=",  tm->memories[mid].name, addr);
    if (name) {
        soc_cm_print("%s[0x%x]=", name, offset);
    }
    for (i = 0; i < words - shimword; i++) {
      v = tm->entrydmabuf[i * 4 + 0]
          | (tm->entrydmabuf[i * 4 + 1] << 8)
          | (tm->entrydmabuf[i * 4 + 2] << 16)
          | (tm->entrydmabuf[i * 4 + 3] << 24);
      soc_sbx_g2p3_print(-1, v);
      soc_cm_print(" ");
    }
    soc_cm_print("\n");
    sal_mutex_give(tm->dmabufmutex);
    return SOC_E_NONE;
}

/* Diag shell set memory contents */
int soc_sbx_g2p3_memory_shell_set(int unit, 
             int mid, int argc, char **argv);
int
soc_sbx_g2p3_memory_shell_set(int unit, 
         int mid, int argc, char **argv)
{
    int rv, i, offset, iscnt, words, shimword;
    uint32 v, addr, prot, protsave = 0;
    char *name;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_memory_desc_t *md = &tm->memories[mid];
    int mwidth = md->width;
    int opcode;

    if (argc == 0) {
        soc_cm_print("missing address\n");
        return SOC_E_PARAM;
    }

    rv = soc_sbx_g2p3_read(argv[0], 1 << 23, &addr);
    if (rv) {
        soc_cm_print("illegal address %s\n", argv[0]);
        return 0;
    }
    argc--;
    argv++;

    rv = soc_sbx_g2p3_memory_bank_find(tm,
                  md, (int) addr, &name, &offset, &iscnt);
    if (rv) {
        soc_cm_print("illegal address %s\n", argv[0]);
        return rv;
    }
    if (iscnt) {
        mwidth = 35;
    }

    words = (mwidth + 31) / 32;
    shimword = words < 2 && mid <= SOC_SBX_G2P3_MM1_INT1_ID;
    words += shimword;

    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    for (i = 0; i < words - shimword; i++) {
        if (!argc) {
            soc_cm_print("missing value\n");
            sal_mutex_give(tm->dmabufmutex);
            return SOC_E_PARAM;
        }
          
        rv = soc_sbx_g2p3_read(argv[0],
                    i == words - 1 ? mwidth % 32 : -1, &v);
        if (rv) {
            soc_cm_print("illegal value '%s'\n", argv[i + 1]);
            sal_mutex_give(tm->dmabufmutex);
            return SOC_E_PARAM;
        }
        tm->entrydmabuf[i * 4 + 0] = v;
        tm->entrydmabuf[i * 4 + 1] = v >> 8;
        tm->entrydmabuf[i * 4 + 2] = v >> 16;
        tm->entrydmabuf[i * 4 + 3] = v >> 24;
        argc--;
        argv++;
    }

    if (iscnt) {
        switch (mid) {
        case SOC_SBX_G2P3_MM0_NAR0_ID:
            protsave
                = SAND_HAL_FE2000_READ_STRIDE(fe->regSet, MM, 0,
                                              MM_PROT_SCHEME0);
            prot = SAND_HAL_FE2000_MOD_FIELD(fe->regSet, MM_PROT_SCHEME0,
                                             NP0_PI_SCHEME,
                                             protsave,
                                             SB_FE2000_MM_35BITS_1BITPARITY);
            SAND_HAL_FE2000_WRITE_STRIDE(fe->regSet, MM, 0, MM_PROT_SCHEME0,
                                  prot);
            break;
        case SOC_SBX_G2P3_MM0_NAR1_ID:
            protsave
                = SAND_HAL_FE2000_READ_STRIDE(fe->regSet, MM, 0,
                                              MM_PROT_SCHEME0);
            prot = SAND_HAL_FE2000_MOD_FIELD(fe->regSet, MM_PROT_SCHEME0,
                                             NP1_PI_SCHEME,
                                             protsave,
                                             SB_FE2000_MM_35BITS_1BITPARITY);
            SAND_HAL_FE2000_WRITE_STRIDE(fe->regSet, MM, 0, MM_PROT_SCHEME0,
                                         prot);
            break;
        case SOC_SBX_G2P3_MM1_NAR0_ID:
            protsave
                = SAND_HAL_FE2000_READ_STRIDE(fe->regSet, MM, 1,
                                              MM_PROT_SCHEME0);
            prot = SAND_HAL_FE2000_MOD_FIELD(fe->regSet, MM_PROT_SCHEME0,
                                             NP0_PI_SCHEME,
                                             protsave,
                                             SB_FE2000_MM_35BITS_1BITPARITY);
            SAND_HAL_FE2000_WRITE_STRIDE(fe->regSet, MM, 1,
                                         MM_PROT_SCHEME0,
                                         prot);
            break;
        case SOC_SBX_G2P3_MM1_NAR1_ID:
            protsave
                = SAND_HAL_FE2000_READ_STRIDE(fe->regSet, MM, 1,
                                              MM_PROT_SCHEME0);
            prot = SAND_HAL_FE2000_MOD_FIELD(fe->regSet, MM_PROT_SCHEME0,
                                             NP1_PI_SCHEME,
                                             protsave,
                                             SB_FE2000_MM_35BITS_1BITPARITY);
            SAND_HAL_FE2000_WRITE_STRIDE(fe->regSet, MM, 1, MM_PROT_SCHEME0,
                                         prot);
            break;
        case SOC_SBX_G2P3_MM0_INT0_ID:
        case SOC_SBX_G2P3_MM0_INT1_ID:
        case SOC_SBX_G2P3_MM1_INT0_ID:
        case SOC_SBX_G2P3_MM1_INT1_ID:
            break;
        default:
            soc_cm_print("unexpected counter memory: %d\n", mid);
            sal_mutex_give(tm->dmabufmutex);
            return SOC_E_INTERNAL;
        }
    }

    if (md->dma) {
        opcode = SB_FE2000_DMA_OPCODE_WRITE;
        tm->entrydmaop.opcode = opcode;
        tm->entrydmaop.words = (uint32) ((mwidth + 31) / 32);
        tm->entrydmaop.hostAddress = 
            (uint32 *) (tm->entrydmabuf);
          tm->entrydmaop.hostBusAddress = tm->entrydmabufhba; /*+ bytes;*/
          tm->entrydmaop.feAddress = (uint32)
            SB_FE2000_DMA_MAKE_ADDRESS(mid, addr);
          rv = sbFe2000DmaRequest(fe->pDmaMgr, INT_TO_PTR(unit),
                                 &tm->entrydmaop);
    }else{
        rv = sbFe2000UtilWriteIndir(fe->regSet, 1, md->descending,
                                    md->reg, addr, words, 
                                    (uint32 *) tm->entrydmabuf);
    }

    if (iscnt) {
        switch (mid) {
        case SOC_SBX_G2P3_MM0_NAR0_ID:
        case SOC_SBX_G2P3_MM0_NAR1_ID:
            SAND_HAL_FE2000_WRITE_STRIDE(fe->regSet, MM, 0, MM_PROT_SCHEME0,
                                  protsave);
            break;
        case SOC_SBX_G2P3_MM1_NAR0_ID:
        case SOC_SBX_G2P3_MM1_NAR1_ID:
            SAND_HAL_FE2000_WRITE_STRIDE(fe->regSet, MM, 1, MM_PROT_SCHEME0,
                                  protsave);
            break;
        }
    }

    if (rv) {
        soc_cm_print("memory write to %s[0x%x] failed\n",
                tm->memories[mid].name, addr);
        sal_mutex_give(tm->dmabufmutex);
        return SOC_E_FAIL;
    }

    sal_mutex_give(tm->dmabufmutex);

    return SOC_E_NONE;
}
int soc_sbx_g2p3_memory_map_shell_print(int unit, char *name);
int soc_sbx_g2p3_memory_map_shell_print(int unit, char *name)
{
    int i, j, base, base0, size0, slen;
    int fw = 20;
    char *s;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2p3_table_desc_t *td;
    soc_sbx_g2p3_memory_bank_desc_t *mb;

    if (name) {
        for (i = 0; i < SOC_SBX_G2P3_TABLE_MAX_ID; i++) {
            td = &tm->tables[i];
            if (!sal_strcasecmp(td->name, name)) {
                soc_cm_print("\nMemory map for table %s\n", name);
                soc_cm_print("Bank  Memory    Port  Width  Base     Size\n");
                soc_cm_print("-----------------------------------------"
                        "-----\n");
                for (j = 0; j < td->nbanks; j++) {
                    soc_cm_print("%-6d%-11s%-5d%-7d0x%06x 0x%06x\n",
                           j, tm->memories[td->banks[j].memory].name,
                           td->banks[j].memory,
                           td->banks[j].width,
                           td->banks[j].base, td->banks[j].size);
                }
                soc_cm_print("\n");
                return SOC_E_NONE;
            }
        }
        return SOC_E_PARAM;
    } else {
        for (i = 0; i < SOC_SBX_G2P3_MEMORY_MAX_ID; i++) {
            if (tm->memories[i].nbanks) {
                soc_cm_print("Memory map for %s", tm->memories[i].name);
                if (tm->memories[i].dma) {
                    soc_cm_print(" (cpu port %d)", i);
                }
                soc_cm_print("\n%-*s%-*s%s\n",
                        fw, "Element", fw, "Base", "Size");
                soc_cm_print("------------------------------------"
                        "----------------\n");
                base = 0;
                for (j = 0; j < tm->memories[i].nbanks; j++) {
                    mb = &tm->memories[i].banks[j];
                    soc_sbx_g2p3_memory_bank_params_get(&base0, &size0, mb, tm);
                    if (base != base0) {
                        soc_cm_print("%-*s0x%06x%-*s0x%06x\n",
                                fw, "UNUSED", base, fw - 8,
                                "", (base0 - base));
                    }
                    switch (mb->type) {
                    case SOC_SBX_G2P3_TABLE_BANK_TYPE:
                        td = &tm->tables[mb->number];
                        soc_cm_print("%s", td->name);
                        slen = sal_strlen(td->name);
                        if (td->nbanks > 1) {
                            soc_cm_print("%c", '0' + mb->bank);
                            slen++;
                        }
                        soc_cm_print("%*s", fw - slen, "");
                        break;
                    case SOC_SBX_G2P3_COUNTER_BANK_TYPE:
                        s = "counter bank";
                        slen = sal_strlen(s);
                        soc_cm_print("%s %-2d", s, mb->number);
                        soc_cm_print("%*s", fw - slen - 3, "");
                        break;
                    case SOC_SBX_G2P3_POLICER_BANK_TYPE:
                        s = "policer bank";
                        slen = sal_strlen(s);
                        soc_cm_print("%s %-2d", s, mb->number);
                        soc_cm_print("%*s", fw - slen - 3, "");
                    }
                    soc_cm_print("0x%06x%-*s0x%06x\n",
                            base0, fw - 8, "", size0);
                    base = base0 + size0;
                }
                soc_cm_print("%-*s0x%06x\n\n", fw, "END", base);
            }
        }
    }
    return SOC_E_NONE;
}

/*
 * Diag shell print driver implementation
 */
int soc_sbx_g2p3_shell_print(int unit, int argc, char **argv)
{
    int i;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;

    for (i = 0; i < SOC_SBX_G2P3_CONSTANT_MAX_ID; i++) {
        if (!sal_strcasecmp(argv[0], tm->constants[i].name)) {
          return soc_sbx_g2p3_constant_shell_print(unit, i);
        }
    }
    for (i = 0; i < SOC_SBX_G2P3_GLOBAL_MAX_ID; i++) {
        if (!sal_strcasecmp(argv[0], tm->globals[i].name)) {
          return soc_sbx_g2p3_global_shell_print(unit, i);
        }
    }
    for (i = 0; i < SOC_SBX_G2P3_ENTRY_MAX_ID; i++) {
        if (!sal_strcasecmp(argv[0], tm->entries[i].name)
            && tm->entries[i].nindexes) {
            return soc_sbx_g2p3_entries_shell_print(unit,
                            i, argc - 1, &argv[1]);
        }
    }
    for (i = 0; i < SOC_SBX_G2P3_COUNTER_MAX_ID; i++) {
        if (!sal_strcasecmp(argv[0], tm->counters[i].name)) {
            return soc_sbx_g2p3_counters_shell_print(unit,
                            i, argc - 1, &argv[1]);
        }
    }
    for (i = 0; i < SOC_SBX_G2P3_POLICER_MAX_ID; i++) {
        if (!sal_strcasecmp(argv[0], tm->policers[i].name)) {
            return soc_sbx_g2p3_policers_shell_print(unit,
                            i, argc - 1, &argv[1]);
        }
    }
    for (i = 0; i < SOC_SBX_G2P3_MEMORY_MAX_ID; i++) {
        if (!sal_strcasecmp(argv[0], tm->memories[i].name)) {
            return soc_sbx_g2p3_memory_shell_print(unit,
                            i, argc - 1, &argv[1]);
        }
    }
    if (!sal_strcasecmp(argv[0], "memmap")) {
        if (argc > 2) {
            soc_cm_print("extra arguments to %s command\n",
                    "memmap");
        }
        return soc_sbx_g2p3_memory_map_shell_print(unit,
                         argc > 1 ? argv[1] : NULL);
    }
    return SOC_E_PARAM;
}

/*
 * Diag shell set driver implementation
 */
int soc_sbx_g2p3_shell_set(int unit, int argc, char **argv)
{
    int i;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;

    for (i = 0; i < SOC_SBX_G2P3_GLOBAL_MAX_ID; i++) {
        if (!sal_strcasecmp(argv[0], tm->globals[i].name)) {
            return soc_sbx_g2p3_global_shell_set(unit,
                            i, argc - 1, &argv[1]);
        }
    }
    for (i = 0; i < SOC_SBX_G2P3_ENTRY_MAX_ID; i++) {
        if (!sal_strcasecmp(argv[0], tm->entries[i].name)
            && tm->entries[i].nindexes) {
            return soc_sbx_g2p3_entries_shell_set(unit,
                            i, argc - 1, &argv[1]);
        }
    }
    for (i = 0; i < SOC_SBX_G2P3_POLICER_MAX_ID; i++) {
        if (!sal_strcasecmp(argv[0], tm->policers[i].name)) {
            return soc_sbx_g2p3_policers_shell_set(unit,
                            i, argc - 1, &argv[1]);
        }
    }
    for (i = 0; i < SOC_SBX_G2P3_MEMORY_MAX_ID; i++) {
        if (!sal_strcasecmp(argv[0], tm->memories[i].name)) {
            return soc_sbx_g2p3_memory_shell_set(unit,
                            i, argc - 1, &argv[1]);
        }
    }
    return SOC_E_PARAM;
}

/*
 * Diag shell delete driver implementation
 */
int soc_sbx_g2p3_shell_delete(int unit, int argc, char **argv)
{
    int i;
    soc_sbx_g2p3_state_t *fe =
        (soc_sbx_g2p3_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2p3_table_manager_t *tm = fe->tableinfo;

    for (i = 0; i < SOC_SBX_G2P3_ENTRY_MAX_ID; i++) {
        if (!sal_strcasecmp(argv[0], tm->entries[i].name)
            && tm->entries[i].nindexes) {
            return soc_sbx_g2p3_entries_shell_delete(unit,
                            i, argc - 1, &argv[1]);
        }
    }
    for (i = 0; i < SOC_SBX_G2P3_POLICER_MAX_ID; i++) {
        if (!sal_strcasecmp(argv[0], tm->policers[i].name)) {
            return soc_sbx_g2p3_policers_shell_delete(unit,
                            i, argc - 1, &argv[1]);
        }
    }
    return SOC_E_PARAM;
}

/* Shell get command usage string */
char soc_sbx_g2p3_get_usage[] =
"g2p3get [<table> idx0=<i0> ...|<constant>|<global>\n"
"          |<counter> [all|<cnum>] [noclear] [noprint]\n"
"          |<memory> <addr>|memmap [table]]\n"
"        memmap          (print memory map) \n"
"        max_ports       (constant) \n"
"        ipv4_vrf_bits   (constant) \n"
"        EXC_IP_CHECKSUM_IDX (constant) \n"
"        EXC_STP_BLOCKED_IDX (constant) \n"
"        EXC_SMAC_DROP_IDX (constant) \n"
"        EXC_SMAC_UNKNOWN_IDX (constant) \n"
"        EXC_MAC_HAIRPIN_IDX (constant) \n"
"        EXC_DMAC_DROP_IDX (constant) \n"
"        EXC_TTL_EXPIRED_IDX (constant) \n"
"        EXC_EGR_STP_BLOCKED_IDX (constant) \n"
"        EXC_SPLIT_IDX   (constant) \n"
"        EXC_MTU_IDX     (constant) \n"
"        EXC_OAM_MISMATCH (constant) \n"
"        EXC_OAM_LEARN   (constant) \n"
"        EXC_OAM_NO_ENDPOINT (constant) \n"
"        EXC_OAM_TYPE    (constant) \n"
"        EXC_OAM_RDI     (constant) \n"
"        EXC_VLAN_DROP_IDX (constant) \n"
"        EXC_V4MC_RPF_CHECK_IDX (constant) \n"
"        EXC_URPF_DROP_IDX (constant) \n"
"        EXC_IP_SA_DROP_IDX (constant) \n"
"        EXC_MIM_BAD_FORMAT_IDX (constant) \n"
"        EXC_ISID2E_MISS_IDX (constant) \n"
"        EXC_OAM_THRESHOLD_EXCEEDED (constant) \n"
"        EXC_OAM_COPY_TO_HOST (constant) \n"
"        EXC_OAM_PARAM_CHANGE (constant) \n"
"        EXC_BAD_OUTER_LABEL_IDX (constant) \n"
"        EXC_BAD_INNER_LABEL_IDX (constant) \n"
"        EXC_LSP_PING_IDX (constant) \n"
"        EXC_TOO_MANY_LABELS_IDX (constant) \n"
"        EXC_EGR_DROP_TAGGED_IDX (constant) \n"
"        EXC_EGR_DROP_UNTAGGED_IDX (constant) \n"
"        EXC_EGR_OAM_LINK_IDX (constant) \n"
"        EXC_OAM_EP_INVALID_IDX (constant) \n"
"        EXC_DCN_IDX     (constant) \n"
"        EXC_MPLS_FILTER_IDX (constant) \n"
"        EXC_MIN_FREE_EXCEPTION (constant) \n"
"        MAX_FREE_EXCEPTION (constant) \n"
"        EXC_SMAC_LEARN_IDX (constant) \n"
"        EXC_PIM_IDX     (constant) \n"
"        EXC_IGMP_IDX    (constant) \n"
"        EXC_RT_COPY_IDX (constant) \n"
"        EXC_L2CP_COPY_IDX (constant) \n"
"        EXC_DMAC_COPY_IDX (constant) \n"
"        EXC_IPREDIRECT_IDX (constant) \n"
"        EXC_BMAC_LEARN_IDX (constant) \n"
"        EXC_COPY_MAX_IDX (constant) \n"
"        HTYPE_ERH       (constant) \n"
"        HTYPE_ETYPE     (constant) \n"
"        HTYPE_ETH       (constant) \n"
"        HTYPE_IETH      (constant) \n"
"        HTYPE_LLC       (constant) \n"
"        HTYPE_SNAP      (constant) \n"
"        HTYPE_VTAG      (constant) \n"
"        HTYPE_DVTAG     (constant) \n"
"        HTYPE_MPLS      (constant) \n"
"        HTYPE_IPV4      (constant) \n"
"        HTYPE_IPV6      (constant) \n"
"        HTYPE_ACH       (constant) \n"
"        HTYPE_MIM       (constant) \n"
"        HTYPE_ELEN      (constant) \n"
"        HTYPE_UNKN      (constant) \n"
"        TRAP_OAMLABELPRESENT (constant) \n"
"        TRAP_LINKLOOPBACK (constant) \n"
"        LSMAC_TABLE_SIZE (constant) \n"
"        L2CPMAC_TABLE_SIZE (constant) \n"
"        OAMUPMAC_TABLE_SIZE (constant) \n"
"        OAMEPREMAP_C2_TABLE_SIZE (constant) \n"
"        OAMMULTIPLIER_C2_TABLE_SIZE (constant) \n"
"        EGRCTR_CA_COUNTER_SIZE (constant) \n"
"        MAC_CA_TABLE_SIZE (constant) \n"
"        PTYPE_UNKNOWN_UNICAST (constant) \n"
"        PTYPE_KNOWN_UNICAST (constant) \n"
"        PTYPE_MULTICAST (constant) \n"
"        PTYPE_BROADCAST (constant) \n"
"        PTYPE_LAST      (constant) \n"
"        CUCKOO_TYPE_PVV (constant) \n"
"        CUCKOO_TYPE_ISID (constant) \n"
"        CUCKOO_TYPE_PVD (constant) \n"
"        CUCKOO_TYPE_MAIDMEP (constant) \n"
"        CUCKOO_TYPE_SHIFT (constant) \n"
"        OAM_EP_SUBTYPE_CCM (constant) \n"
"        OAM_EP_SUBTYPE_LM (constant) \n"
"        OAM_EP_SUBTYPE_DM (constant) \n"
"        OAM_EP_SUBTYPE_SHIFT (constant) \n"
"        OAM_TYPE_INVALID (constant) \n"
"        OAM_TYPE_ENET   (constant) \n"
"        OAM_TYPE_MPLS_PWE (constant) \n"
"        OAM_TYPE_MPLS_LSP (constant) \n"
"        OAM_FUNCTION_UNUSED (constant) \n"
"        OAM_FUNCTION_BFD (constant) \n"
"        OAM_FUNCTION_LM (constant) \n"
"        OAM_FUNCTION_DM (constant) \n"
"        OAM_FUNCTION_CCM_FIRST (constant) \n"
"        OAM_FUNCTION_CCM_SECOND (constant) \n"
"        OAM_FUNCTION_CCM_PEER (constant) \n"
"        OAM_FUNCTION_PSC (constant) \n"
"        OAM_FUNCTION_PM (constant) \n"
"        OAM_FUNCTION_CCM_LOCAL (constant) \n"
"        OAM_NUM_ENDPOINTS (constant) \n"
"        OAM_MAX_CALENDAR (constant) \n"
"        OAM_BUBBLE_TIMEOUT (constant) \n"
"        OAM_LIST_MGR_SIZE (constant) \n"
"        OAM_LIST_MGR_SIZE_CA (constant) \n"
"        OAM_BUBBLE_TIMER_ADDR (constant) \n"
"        OAM_LIST_MGR_ADDR (constant) \n"
"        OAM_INTERVAL1   (constant) \n"
"        OAM_INTERVAL2   (constant) \n"
"        OAM_INTERVAL3   (constant) \n"
"        OAM_INTERVAL4   (constant) \n"
"        OAM_INTERVAL5   (constant) \n"
"        OAM_INTERVAL6   (constant) \n"
"        OAM_INTERVAL7   (constant) \n"
"        OAM_REMOTE_EP_BASE (constant) \n"
"        MAX_QOS_PROFILE_INDEX (constant) \n"
"        MAX_QOS_MAP_TABLE (constant) \n"
"        MAX_QOS_REMARK_TABLE (constant) \n"
"        MAX_L2CP_TYPES  (constant) \n"
"        MAX_L2CP_SUBTYPES (constant) \n"
"        URPF_DEFAULT_PID (constant) \n"
"        stpstate_forward (constant) \n"
"        stpstate_block  (constant) \n"
"        stpstate_learn  (constant) \n"
"        mplstp_loopback_oam (constant) \n"
"        mplstp_loopback_full (constant) \n"
"        mplstp_loopback_none (constant) \n"
"        label_lsr       (constant) \n"
"        label_eth_pwe3  (constant) \n"
"        label_ler       (constant) \n"
"        label_ces_pwe3  (constant) \n"
"        contexts        (global) \n"
"        tpid0           (global) \n"
"        tpid1           (global) \n"
"        tpid2           (global) \n"
"        defitag         (global) \n"
"        age             (global) \n"
"        labelcuckoo_abseed (global) \n"
"        cuckoo_abseed   (global) \n"
"        node            (global) \n"
"        vlan_ft_base    (global) \n"
"        vpws_vlan       (global) \n"
"        vpws_ft_offset  (global) \n"
"        eex_mirror0     (global) \n"
"        eex_mirror1     (global) \n"
"        max_pids        (global) \n"
"        mc_ft_offset    (global) \n"
"        oam_drop_bit    (global) \n"
"        oam_enet_continue_byte (global) \n"
"        oam_mpls_continue_byte (global) \n"
"        oam_enet_frame_len (global) \n"
"        oam_mpls_frame_len (global) \n"
"        oam_source_queue (global) \n"
"        oam_dest_queue  (global) \n"
"        oam_source_buffer (global) \n"
"        oam_bubble_timer_offset (global) \n"
"        oam_sa_lm       (global) \n"
"        oam_sa_dm       (global) \n"
"        oam_mpls_sa_lm  (global) \n"
"        oam_mpls_sa_dm  (global) \n"
"        oam_pwe_ip_sa   (global) \n"
"        oam_pwe_udp_dest_port (global) \n"
"        oam_mirror_index (global) \n"
"        oam_loopback_qid (global) \n"
"        oam_sa_4lo      (global) \n"
"        oam_sa_2hi      (global) \n"
"        oam_sa_4lo_aux  (global) \n"
"        oam_sa_2hi_aux  (global) \n"
"        oam_bfd_state_table (global) \n"
"        oam_bfd_rdi_diag_code (global) \n"
"        oam_tx_packets_per_bubble (global) \n"
"        oam_tx_packets_per_bubble_ca (global) \n"
"        oam_psc_rx_filter (global) \n"
"        oam_local_fe_qid (global) \n"
"        blackhole_vlan  (global) \n"
"        igmp_proxy_mode (global) \n"
"        static_lag      (global) \n"
"        ipv4_checksum_mode (global) \n"
"        exit_filter_on_btag (global) \n"
"        switch_meter_adjust (global) \n"
"        rc1_rule_startidx (global) \n"
"        ipv6_acl_enable (global) \n"
"        oi2eoff         (global) \n"
"        ete0plus1       (global) \n"
"        ete1plus1       (global) \n"
"        p2e             port=<port> \n"
"        ep2e            port=<port> \n"
"        p2e20           port=<port> \n"
"        ep2e20          port=<port> \n"
"        p2e25           port=<port> \n"
"        ep2e25          port=<port> \n"
"        tpid            tpidi=<tpidi> \n"
"        oam_rx          rule=<rule> \n"
"        oam_tx          rule=<rule> \n"
"        lsmac           lsi=<lsi> \n"
"        l2cpmac         lsi=<lsi> \n"
"        oamupmac        lsi=<lsi> \n"
"        qos             de=<de> pri=<pri> prof=<prof> \n"
"        dscp_qos        dscp=<dscp> prof=<prof> \n"
"        irt             rule=<rule> \n"
"        irt_wrap        rule=<rule> \n"
"        rt_mt           rule=<rule> \n"
"        rt_rr0          rule=<rule> \n"
"        rt              rule=<rule> \n"
"        rt_rr1          rule=<rule> \n"
"        lag             lagi=<lagi> \n"
"        rr              rri=<rri> \n"
"        xt              xi=<xi> \n"
"        mirror          mi=<mi> \n"
"        emirror         mirror=<mirror> \n"
"        emirror20       mirror=<mirror> \n"
"        emirror25       mirror=<mirror> \n"
"        mac             mac=<mac> vlan=<vlan> bmac=<bmac> \n"
"        macl1           l1i=<l1i> \n"
"        macl2           maci=<maci> \n"
"        ipv6dhost       ip=<ip> \n"
"        ipv6dhostl1     l1i=<l1i> \n"
"        ipv6dhostl2     hosti=<hosti> \n"
"        mst             msti=<msti> \n"
"        pv2e            vid=<vid> port=<port> \n"
"        p2appdata       port=<port> \n"
"        pv2appdata      vid=<vid> port=<port> \n"
"        ipv6shost       ip=<ip> \n"
"        ipv6shostl1     l1i=<l1i> \n"
"        ipv6shostl2     hosti=<hosti> \n"
"        pvv2e           ivid=<ivid> ovid=<ovid> port=<port> \n"
"        pvv2epack       ovid=<ovid> port=<port> ivid=<ivid> \n"
"        isid2e          isid=<isid> \n"
"        oampvd2e        port=<port> vid=<vid> dir=<dir> tag=<tag> \n"
"        oammaidmep2e    maid=<maid> mepid=<mepid> \n"
"        cuckoo          key=<key> type=<type> \n"
"        left            li=<li> \n"
"        right           ri=<ri> \n"
"        outerlabelcuckoo key=<key> type=<type> \n"
"        outerlabelleft  li=<li> \n"
"        outerlabelright ri=<ri> \n"
"        innerlabelcuckoo key=<key> type=<type> \n"
"        innerlabelleft  li=<li> \n"
"        innerlabelright ri=<ri> \n"
"        label2e         label=<label> \n"
"        tagged_mpls     rule=<rule> \n"
"        v2e             vlan=<vlan> \n"
"        v2e1            vlan=<vlan> \n"
"        lp              lpi=<lpi> \n"
"        l2e             label=<label> \n"
"        l2cp            lsb=<lsb> port=<port> \n"
"        l2cpslow        subcode=<subcode> port=<port> \n"
"        l2cpnop         i=<i> \n"
"        ft              fti=<fti> \n"
"        OamTimerCalendar listMgrIndex=<listMgrIndex> \n"
"        OamPortMdLevel2Etc portMd=<portMd> \n"
"        v4uc_str_sel    rule=<rule> \n"
"        cmac            mac=<mac> vlan=<vlan> \n"
"        bmac            mac=<mac> vlan=<vlan> \n"
"        ipv6mcsg        g=<g> s=<s> vlan=<vlan> \n"
"        ipv6mcsgl1      l1i=<l1i> \n"
"        ipv6mcsgl2      mcgi=<mcgi> \n"
"        ipv6mcg         g=<g> vlan=<vlan> \n"
"        ipv6mcgl1       l1i=<l1i> \n"
"        ipv6mcgl2       mcgi=<mcgi> \n"
"        ipv4mcg         g=<g> vlan=<vlan> \n"
"        ipv4mcgl1       l1i=<l1i> \n"
"        ipv4mcgl2       mcgi=<mcgi> \n"
"        ipv4mcsg        g=<g> s=<s> vlan=<vlan> \n"
"        ipv4mcsgl1      l1i=<l1i> \n"
"        ipv4mcsgl2      mcgi=<mcgi> \n"
"        ipv4sa          prefixbits=<prefixbits> ip=<ip> ipcxt=<ipcxt> \n"
"        ipv4sal0        addr=<addr> \n"
"        ipv4saodd       addr=<addr> \n"
"        ipv4saeven      addr=<addr> \n"
"        ipv4sapayload   addr=<addr> \n"
"        ifp             rule=<rule> \n"
"        ifp_v6          rule=<rule> \n"
"        evp2e           vlan=<vlan> port=<port> \n"
"        oi2e            oi=<oi> \n"
"        eteencap        etei=<etei> \n"
"        etel2           etei=<etei> \n"
"        oamEp           epIdx=<epIdx> \n"
"        remark          e=<e> dp=<dp> cos=<cos> prof=<prof> \n"
"        epv2e           vid=<vid> port=<port> \n"
"        esmac           smaci=<smaci> \n"
"        ert             rule=<rule> \n"
"        ert_wrap        rule=<rule> \n"
"        v4mc_str_sel    rule=<rule> \n"
"        efp             rule=<rule> \n"
"        efp_v6          rule=<rule> \n"
"        oamMultiplier   lossCount=<lossCount> threshold=<threshold> \n"
"        oamEpRemap      endpoint=<endpoint> mdLevel=<mdLevel> \n"
"                        type=<type> \n"
"        ipv6da          prefixbits=<prefixbits> ip=<ip> \n"
"        ipv6dal0        addr=<addr> \n"
"        ipv6daodd       addr=<addr> \n"
"        ipv6daeven      addr=<addr> \n"
"        ipv6dapayload   addr=<addr> \n"
"        ipv6sa          prefixbits=<prefixbits> ip=<ip> \n"
"        ipv6sal0        addr=<addr> \n"
"        ipv6saodd       addr=<addr> \n"
"        ipv6saeven      addr=<addr> \n"
"        ipv6sapayload   addr=<addr> \n"
"        ipv4da          prefixbits=<prefixbits> ip=<ip> ipcxt=<ipcxt> \n"
"        ipv4dal0        addr=<addr> \n"
"        ipv4daodd       addr=<addr> \n"
"        ipv4daeven      addr=<addr> \n"
"        ipv4dapayload   addr=<addr> \n"
"        P2FTI           port=<port> dmac=<dmac> \n"
"        pdctr           [<cnum>|all] [noclear] (counter) \n"
"        rtctr           [<cnum>|all] [noclear] (counter) \n"
"        irtctr          [<cnum>|all] [noclear] (counter) \n"
"        ifpctr          [<cnum>|all] [noclear] (counter) \n"
"        ifp_v6ctr       [<cnum>|all] [noclear] (counter) \n"
"        ertctr          [<cnum>|all] [noclear] (counter) \n"
"        efpctr          [<cnum>|all] [noclear] (counter) \n"
"        efp_v6ctr       [<cnum>|all] [noclear] (counter) \n"
"        excctr          [<cnum>|all] [noclear] (counter) \n"
"        ingctr          [<cnum>|all] [noclear] (counter) \n"
"        egrctr          [<cnum>|all] [noclear] (counter) \n"
"        mm0_nar0        <addr> (memory) \n"
"        mm0_nar1        <addr> (memory) \n"
"        mm0_wide        <addr> (memory) \n"
"        mm0_int0        <addr> (memory) \n"
"        mm0_int1        <addr> (memory) \n"
"        mm1_nar0        <addr> (memory) \n"
"        mm1_nar1        <addr> (memory) \n"
"        mm1_wide        <addr> (memory) \n"
"        mm1_int0        <addr> (memory) \n"
"        mm1_int1        <addr> (memory) \n"
"        rc0_rr          <addr> (memory) \n"
"        rc1_rr          <addr> (memory) \n"
"        rxportdata      <addr> (memory) \n"
"        initialqstate20 <addr> (memory) \n"
"        initialqstate25 <addr> (memory) \n"
"        emirrorhw20     <addr> (memory) \n"
"        emirrorhw25     <addr> (memory) \n"
;

/* Shell set command usage string */
char soc_sbx_g2p3_set_usage[] =
"g2p3set [<table> idx0=<i0> ...[field0=<f0> ...]\n"
"          |<global> v|<memory> <addr> v]\n"
"        contexts        <value> (global) \n"
"        tpid0           <value> (global) \n"
"        tpid1           <value> (global) \n"
"        tpid2           <value> (global) \n"
"        defitag         <value> (global) \n"
"        age             <value> (global) \n"
"        labelcuckoo_abseed <value> (global) \n"
"        cuckoo_abseed   <value> (global) \n"
"        node            <value> (global) \n"
"        vlan_ft_base    <value> (global) \n"
"        vpws_vlan       <value> (global) \n"
"        vpws_ft_offset  <value> (global) \n"
"        eex_mirror0     <value> (global) \n"
"        eex_mirror1     <value> (global) \n"
"        max_pids        <value> (global) \n"
"        mc_ft_offset    <value> (global) \n"
"        oam_drop_bit    <value> (global) \n"
"        oam_enet_continue_byte <value> (global) \n"
"        oam_mpls_continue_byte <value> (global) \n"
"        oam_enet_frame_len <value> (global) \n"
"        oam_mpls_frame_len <value> (global) \n"
"        oam_source_queue <value> (global) \n"
"        oam_dest_queue  <value> (global) \n"
"        oam_source_buffer <value> (global) \n"
"        oam_bubble_timer_offset <value> (global) \n"
"        oam_sa_lm       <value> (global) \n"
"        oam_sa_dm       <value> (global) \n"
"        oam_mpls_sa_lm  <value> (global) \n"
"        oam_mpls_sa_dm  <value> (global) \n"
"        oam_pwe_ip_sa   <value> (global) \n"
"        oam_pwe_udp_dest_port <value> (global) \n"
"        oam_mirror_index <value> (global) \n"
"        oam_loopback_qid <value> (global) \n"
"        oam_sa_4lo      <value> (global) \n"
"        oam_sa_2hi      <value> (global) \n"
"        oam_sa_4lo_aux  <value> (global) \n"
"        oam_sa_2hi_aux  <value> (global) \n"
"        oam_bfd_state_table <value> (global) \n"
"        oam_bfd_rdi_diag_code <value> (global) \n"
"        oam_tx_packets_per_bubble <value> (global) \n"
"        oam_tx_packets_per_bubble_ca <value> (global) \n"
"        oam_psc_rx_filter <value> (global) \n"
"        oam_local_fe_qid <value> (global) \n"
"        blackhole_vlan  <value> (global) \n"
"        igmp_proxy_mode <value> (global) \n"
"        static_lag      <value> (global) \n"
"        ipv4_checksum_mode <value> (global) \n"
"        exit_filter_on_btag <value> (global) \n"
"        switch_meter_adjust <value> (global) \n"
"        rc1_rule_startidx <value> (global) \n"
"        ipv6_acl_enable <value> (global) \n"
"        oi2eoff         <value> (global) \n"
"        ete0plus1       <value> (global) \n"
"        ete1plus1       <value> (global) \n"
"        p2e             port=<port> [ port=<port> \n"
"                        nativevid=<nativevid> defcfi=<defcfi> \n"
"                        defpri=<defpri> defstrip=<defstrip> \n"
"                        pstrip=<pstrip> mim=<mim> mplstp=<mplstp> \n"
"                        mask=<mask> customer=<customer> \n"
"                        provider=<provider> oamloop=<oamloop> \n"
"                        stpid1=<stpid1> twintpid=<twintpid> pbb=<pbb> \n"
"                        ipv4mc=<ipv4mc> state=<state> pport=<pport> \n"
"                        htype=<htype> ] \n"
"        ep2e            port=<port> [ mim=<mim> pid=<pid> \n"
"                        stpid0=<stpid0> stpid1=<stpid1> \n"
"                        customer=<customer> keeperh=<keeperh> \n"
"                        port=<port> mirroridx=<mirroridx> mask=<mask> \n"
"                        oamloop=<oamloop> pbb=<pbb> state=<state> \n"
"                        htype=<htype> ] \n"
"        p2e20           port=<port> [ port=<port> \n"
"                        nativevid=<nativevid> defcfi=<defcfi> \n"
"                        defpri=<defpri> defstrip=<defstrip> \n"
"                        pstrip=<pstrip> mim=<mim> mplstp=<mplstp> \n"
"                        mask=<mask> customer=<customer> \n"
"                        provider=<provider> oamloop=<oamloop> \n"
"                        stpid1=<stpid1> twintpid=<twintpid> pbb=<pbb> \n"
"                        ipv4mc=<ipv4mc> state=<state> pport=<pport> \n"
"                        htype=<htype> ] \n"
"        ep2e20          port=<port> [ mim=<mim> pid=<pid> \n"
"                        stpid0=<stpid0> stpid1=<stpid1> \n"
"                        customer=<customer> keeperh=<keeperh> \n"
"                        port=<port> mirroridx=<mirroridx> mask=<mask> \n"
"                        oamloop=<oamloop> pbb=<pbb> state=<state> \n"
"                        htype=<htype> ] \n"
"        p2e25           port=<port> [ port=<port> \n"
"                        nativevid=<nativevid> defcfi=<defcfi> \n"
"                        defpri=<defpri> defstrip=<defstrip> \n"
"                        pstrip=<pstrip> mim=<mim> mplstp=<mplstp> \n"
"                        mask=<mask> customer=<customer> \n"
"                        provider=<provider> oamloop=<oamloop> \n"
"                        stpid1=<stpid1> twintpid=<twintpid> pbb=<pbb> \n"
"                        ipv4mc=<ipv4mc> state=<state> pport=<pport> \n"
"                        htype=<htype> ] \n"
"        ep2e25          port=<port> [ mim=<mim> pid=<pid> \n"
"                        stpid0=<stpid0> stpid1=<stpid1> \n"
"                        customer=<customer> keeperh=<keeperh> \n"
"                        port=<port> mirroridx=<mirroridx> mask=<mask> \n"
"                        oamloop=<oamloop> pbb=<pbb> state=<state> \n"
"                        htype=<htype> ] \n"
"        tpid            tpidi=<tpidi> [ tpid=<tpid> ] \n"
"        oam_rx          rule=<rule> [ valid=<valid> ] \n"
"        oam_tx          rule=<rule> [ valid=<valid> ] \n"
"        lsmac           lsi=<lsi> [ port=<port> useport=<useport> \n"
"                        mac=<mac> ] \n"
"        l2cpmac         lsi=<lsi> [ port=<port> useport=<useport> \n"
"                        mac=<mac> ] \n"
"        oamupmac        lsi=<lsi> [ mac=<mac> mask=<mask> ] \n"
"        qos             de=<de> pri=<pri> prof=<prof> [ e=<e> dp=<dp> \n"
"                        cos=<cos> fcos=<fcos> mefcos=<mefcos> ] \n"
"        dscp_qos        dscp=<dscp> prof=<prof> [ e=<e> dp=<dp> \n"
"                        cos=<cos> fcos=<fcos> mefcos=<mefcos> ] \n"
"        irt             rule=<rule> [ vlan=<vlan> ftidx=<ftidx> \n"
"                        mirror=<mirror> usevlan=<usevlan> \n"
"                        useftidx=<useftidx> copy=<copy> dp=<dp> \n"
"                        cos=<cos> fcos=<fcos> usedp=<usedp> \n"
"                        usecos=<usecos> policer=<policer> \n"
"                        typedpolice=<typedpolice> mefcos=<mefcos> \n"
"                        mef=<mef> ] \n"
"        irt_wrap        rule=<rule> [ vlan=<vlan> ftidx=<ftidx> \n"
"                        mirror=<mirror> usevlan=<usevlan> \n"
"                        useftidx=<useftidx> copy=<copy> dp=<dp> \n"
"                        cos=<cos> fcos=<fcos> usedp=<usedp> \n"
"                        usecos=<usecos> policer=<policer> \n"
"                        typedpolice=<typedpolice> mefcos=<mefcos> \n"
"                        mef=<mef> ] \n"
"        rt_mt           rule=<rule> [ policer=<policer> ] \n"
"        rt_rr0          rule=<rule> [ resv=<resv> usevlan=<usevlan> \n"
"                        useftidx=<useftidx> vlan=<vlan> ftidx=<ftidx> \n"
"                        copy=<copy> dp=<dp> usedp=<usedp> \n"
"                        mirror=<mirror> typedpolice=<typedpolice> \n"
"                        mefcos=<mefcos> mef=<mef> cos=<cos> \n"
"                        fcos=<fcos> usecos=<usecos> emirror=<emirror> \n"
"                        drop=<drop> rtidx=<rtidx> ] \n"
"        rt              rule=<rule> [ ] \n"
"        rt_rr1          rule=<rule> [ resv=<resv> usevlan=<usevlan> \n"
"                        useftidx=<useftidx> vlan=<vlan> ftidx=<ftidx> \n"
"                        copy=<copy> dp=<dp> usedp=<usedp> \n"
"                        mirror=<mirror> typedpolice=<typedpolice> \n"
"                        mefcos=<mefcos> mef=<mef> cos=<cos> \n"
"                        fcos=<fcos> usecos=<usecos> emirror=<emirror> \n"
"                        drop=<drop> rtidx=<rtidx> ] \n"
"        lag             lagi=<lagi> [ qid=<qid> oi=<oi> ] \n"
"        rr              rri=<rri> [ backup=<backup> ] \n"
"        xt              xi=<xi> [ forward=<forward> dp=<dp> qid=<qid> \n"
"                        trunc=<trunc> learn=<learn> \n"
"                        ppspolice=<ppspolice> policer=<policer> ] \n"
"        mirror          mi=<mi> [ yellow=<yellow> qid=<qid> oi=<oi> ] \n"
"        emirror         mirror=<mirror> [ local=<local> port=<port> \n"
"                        qid=<qid> oi=<oi> ] \n"
"        emirror20       mirror=<mirror> [ queue=<queue> \n"
"                        hdrpresent=<hdrpresent> \n"
"                        dropsrcpkt=<dropsrcpkt> ] \n"
"        emirror25       mirror=<mirror> [ queue=<queue> \n"
"                        hdrpresent=<hdrpresent> \n"
"                        dropsrcpkt=<dropsrcpkt> higighdr=<higighdr> \n"
"                        overwritehdr=<overwritehdr> \n"
"                        hdrdata0=<hdrdata0> hdrdata1=<hdrdata1> \n"
"                        hdrdata2=<hdrdata2> hdrdata3=<hdrdata3> ] \n"
"        mac             mac=<mac> vlan=<vlan> bmac=<bmac> [ age=<age> \n"
"                        pid=<pid> dcopy=<dcopy> dcopycos=<dcopycos> \n"
"                        ddrop=<ddrop> sdrop=<sdrop> dontage=<dontage> \n"
"                        bsdrop=<bsdrop> bpid=<bpid> btid=<btid> ] \n"
"        macl1           l1i=<l1i> [ usemap=<usemap> pointer=<pointer> \n"
"                        salt=<salt> ] \n"
"        macl2           maci=<maci> [ mac=<mac> vlan=<vlan> \n"
"                        bmac=<bmac> age=<age> pid=<pid> dcopy=<dcopy> \n"
"                        dcopycos=<dcopycos> ddrop=<ddrop> \n"
"                        sdrop=<sdrop> dontage=<dontage> \n"
"                        notage=<notage> bsdrop=<bsdrop> bpid=<bpid> \n"
"                        btid=<btid> ] \n"
"        ipv6dhost       ip=<ip> [ ftidx=<ftidx> ecmpmask=<ecmpmask> \n"
"                        vid=<vid> ] \n"
"        ipv6dhostl1     l1i=<l1i> [ usemap=<usemap> pointer=<pointer> \n"
"                        salt=<salt> ] \n"
"        ipv6dhostl2     hosti=<hosti> [ key=<key> ftidx=<ftidx> \n"
"                        ecmpmask=<ecmpmask> vid=<vid> ] \n"
"        mst             msti=<msti> [ learn=<learn> pim=<pim> \n"
"                        igmp=<igmp> rtcopy=<rtcopy> \n"
"                        l2cpcopy=<l2cpcopy> dcopy=<dcopy> \n"
"                        ipredirect=<ipredirect> \n"
"                        learn_bmac=<learn_bmac> mirroridx=<mirroridx> \n"
"                        vsi=<vsi> ] \n"
"        pv2e            vid=<vid> port=<port> [ lpi=<lpi> vlan=<vlan> \n"
"                        stpstate=<stpstate> \n"
"                        untagged_strip=<untagged_strip> vpws=<vpws> ] \n"
"        p2appdata       port=<port> [ ifilteren=<ifilteren> \n"
"                        efilteren=<efilteren> ] \n"
"        pv2appdata      vid=<vid> port=<port> [ member=<member> ] \n"
"        ipv6shost       ip=<ip> [ poe=<poe> rpfmode=<rpfmode> \n"
"                        srcdrop=<srcdrop> srccnt=<srccnt> ] \n"
"        ipv6shostl1     l1i=<l1i> [ usemap=<usemap> pointer=<pointer> \n"
"                        salt=<salt> ] \n"
"        ipv6shostl2     hosti=<hosti> [ key=<key> ftidx=<ftidx> \n"
"                        ecmpmask=<ecmpmask> vid=<vid> ] \n"
"        pvv2e           ivid=<ivid> ovid=<ovid> port=<port> [ \n"
"                        lpi=<lpi> vlan=<vlan> stpstate=<stpstate> \n"
"                        untagged_strip=<untagged_strip> vpws=<vpws> \n"
"                        vid=<vid> replace=<replace> \n"
"                        keeporstrip=<keeporstrip> ] \n"
"        pvv2epack       ovid=<ovid> port=<port> ivid=<ivid> [ \n"
"                        lpi=<lpi> vlan=<vlan> stpstate=<stpstate> \n"
"                        untagged_strip=<untagged_strip> vpws=<vpws> \n"
"                        vid=<vid> replace=<replace> \n"
"                        keeporstrip=<keeporstrip> ] \n"
"        isid2e          isid=<isid> [ lpi=<lpi> vlan=<vlan> \n"
"                        stpstate=<stpstate> ] \n"
"        oampvd2e        port=<port> vid=<vid> dir=<dir> tag=<tag> [ \n"
"                        endpointPtr=<endpointPtr> ftIdx=<ftIdx> \n"
"                        mdLevelEp=<mdLevelEp> mdLevelFwd=<mdLevelFwd> \n"
"                        ] \n"
"        oammaidmep2e    maid=<maid> mepid=<mepid> [ \n"
"                        endpointPtr=<endpointPtr> epValid=<epValid> ] \n"
"        cuckoo          key=<key> type=<type> [ pay=<pay> ] \n"
"        left            li=<li> [ pay=<pay> key=<key> ] \n"
"        right           ri=<ri> [ pay=<pay> key=<key> ] \n"
"        outerlabelcuckoo key=<key> type=<type> [ pay=<pay> ] \n"
"        outerlabelleft  li=<li> [ pay=<pay> key=<key> ] \n"
"        outerlabelright ri=<ri> [ pay=<pay> key=<key> ] \n"
"        innerlabelcuckoo key=<key> type=<type> [ pay=<pay> ] \n"
"        innerlabelleft  li=<li> [ pay=<pay> key=<key> ] \n"
"        innerlabelright ri=<ri> [ pay=<pay> key=<key> ] \n"
"        label2e         label=<label> [ vlan=<vlan> ftidx0=<ftidx0> \n"
"                        opcode=<opcode> lpidx=<lpidx> cos=<cos> \n"
"                        loopback=<loopback> vpws=<vpws> \n"
"                        ftidx1=<ftidx1> stpstate=<stpstate> \n"
"                        elsp=<elsp> pipe=<pipe> ] \n"
"        tagged_mpls     rule=<rule> [ valid=<valid> ] \n"
"        v2e             vlan=<vlan> [ pim=<pim> igmp=<igmp> \n"
"                        forceflood=<forceflood> \n"
"                        dropunksmac=<dropunksmac> \n"
"                        dontlearn=<dontlearn> vrf=<vrf> \n"
"                        v6mcmode=<v6mcmode> v4mcmode=<v4mcmode> \n"
"                        laghash=<laghash> v4route=<v4route> \n"
"                        v6route=<v6route> ] \n"
"        v2e1            vlan=<vlan> [ vrid0=<vrid0> vrid1=<vrid1> \n"
"                        vrid2=<vrid2> vrid3=<vrid3> ] \n"
"        lp              lpi=<lpi> [ pid=<pid> qos=<qos> \n"
"                        useexp=<useexp> usedscp=<usedscp> \n"
"                        updatefdp=<updatefdp> mirror=<mirror> \n"
"                        updaterdp=<updaterdp> policer=<policer> \n"
"                        typedpolice=<typedpolice> mefcos=<mefcos> \n"
"                        mef=<mef> cocounter=<cocounter> \n"
"                        priclass=<priclass> allpri=<allpri> \n"
"                        xtpolreplace=<xtpolreplace> counter=<counter> \n"
"                        typedcount=<typedcount> color=<color> \n"
"                        usecolor=<usecolor> oamepi=<oamepi> ] \n"
"        l2e             label=<label> [ vlan=<vlan> \n"
"                        stpstate=<stpstate> elsp=<elsp> pipe=<pipe> \n"
"                        ftidx=<ftidx> oamen=<oamen> leren=<leren> ] \n"
"        l2cp            lsb=<lsb> port=<port> [ ftidx=<ftidx> \n"
"                        forward=<forward> passstp=<passstp> \n"
"                        copy=<copy> ] \n"
"        l2cpslow        subcode=<subcode> port=<port> [ ftidx=<ftidx> \n"
"                        forward=<forward> passstp=<passstp> \n"
"                        copy=<copy> ] \n"
"        l2cpnop         i=<i> [ ftidx=<ftidx> forward=<forward> \n"
"                        passstp=<passstp> copy=<copy> ] \n"
"        ft              fti=<fti> [ rridx=<rridx> excidx=<excidx> \n"
"                        lenadj=<lenadj> mc=<mc> t=<t> hc=<hc> oi=<oi> \n"
"                        qid=<qid> lagbase=<lagbase> lagsize=<lagsize> \n"
"                        lag=<lag> oib=<oib> qidb=<qidb> \n"
"                        lagbaseb=<lagbaseb> lagsizeb=<lagsizeb> \n"
"                        lagb=<lagb> ] \n"
"        OamTimerCalendar listMgrIndex=<listMgrIndex> [ \n"
"                        endpointPtr=<endpointPtr> \n"
"                        xmitPeriod=<xmitPeriod> xmitCount=<xmitCount> \n"
"                        ] \n"
"        OamPortMdLevel2Etc portMd=<portMd> [ valid=<valid> fwd=<fwd> \n"
"                        epIdx=<epIdx> ] \n"
"        v4uc_str_sel    rule=<rule> [ valid=<valid> ] \n"
"        cmac            mac=<mac> vlan=<vlan> [ age=<age> pid=<pid> \n"
"                        dcopy=<dcopy> dcopycos=<dcopycos> \n"
"                        ddrop=<ddrop> sdrop=<sdrop> dontage=<dontage> \n"
"                        ] \n"
"        bmac            mac=<mac> vlan=<vlan> [ bsdrop=<bsdrop> \n"
"                        bpid=<bpid> btid=<btid> ] \n"
"        ipv6mcsg        g=<g> s=<s> vlan=<vlan> [ ftidx=<ftidx> \n"
"                        rpfunion=<rpfunion> proccopy=<proccopy> ] \n"
"        ipv6mcsgl1      l1i=<l1i> [ usemap=<usemap> pointer=<pointer> \n"
"                        salt=<salt> ] \n"
"        ipv6mcsgl2      mcgi=<mcgi> [ g=<g> s=<s> vlan=<vlan> \n"
"                        proccopy=<proccopy> ftidx=<ftidx> \n"
"                        rpfunion=<rpfunion> ] \n"
"        ipv6mcg         g=<g> vlan=<vlan> [ ftidx=<ftidx> \n"
"                        rpfunion=<rpfunion> proccopy=<proccopy> ] \n"
"        ipv6mcgl1       l1i=<l1i> [ usemap=<usemap> pointer=<pointer> \n"
"                        salt=<salt> ] \n"
"        ipv6mcgl2       mcgi=<mcgi> [ g=<g> ftidx=<ftidx> \n"
"                        rpfunion=<rpfunion> vlan=<vlan> \n"
"                        proccopy=<proccopy> ] \n"
"        ipv4mcg         g=<g> vlan=<vlan> [ ftidx=<ftidx> \n"
"                        rpfunion=<rpfunion> proccopy=<proccopy> ] \n"
"        ipv4mcgl1       l1i=<l1i> [ usemap=<usemap> pointer=<pointer> \n"
"                        salt=<salt> ] \n"
"        ipv4mcgl2       mcgi=<mcgi> [ g=<g> ftidx=<ftidx> \n"
"                        rpfunion=<rpfunion> vlan=<vlan> \n"
"                        proccopy=<proccopy> ] \n"
"        ipv4mcsg        g=<g> s=<s> vlan=<vlan> [ ftidx=<ftidx> \n"
"                        rpfunion=<rpfunion> proccopy=<proccopy> ] \n"
"        ipv4mcsgl1      l1i=<l1i> [ usemap=<usemap> pointer=<pointer> \n"
"                        salt=<salt> ] \n"
"        ipv4mcsgl2      mcgi=<mcgi> [ g=<g> s=<s> ftidx=<ftidx> \n"
"                        rpfunion=<rpfunion> vlan=<vlan> \n"
"                        proccopy=<proccopy> ] \n"
"        ipv4sa          prefixbits=<prefixbits> ip=<ip> ipcxt=<ipcxt> \n"
"                        [ poe=<poe> rpfmode=<rpfmode> \n"
"                        srcdrop=<srcdrop> srccnt=<srccnt> ] \n"
"        ipv4sal0        addr=<addr> [ pattern=<pattern> \n"
"                        singleton=<singleton> pointer=<pointer> \n"
"                        leaf=<leaf> ] \n"
"        ipv4saodd       addr=<addr> [ pattern=<pattern> \n"
"                        singleton=<singleton> pointer=<pointer> \n"
"                        leaf=<leaf> ] \n"
"        ipv4saeven      addr=<addr> [ pattern=<pattern> \n"
"                        singleton=<singleton> pointer=<pointer> \n"
"                        leaf=<leaf> ] \n"
"        ipv4sapayload   addr=<addr> [ poe=<poe> rpfmode=<rpfmode> \n"
"                        srcdrop=<srcdrop> srccnt=<srccnt> ] \n"
"        ifp             rule=<rule> [ dbtype=<dbtype> \n"
"                        usedbtype=<usedbtype> port=<port> \n"
"                        useport=<useport> pbmpn=<pbmpn> pri=<pri> \n"
"                        usepri=<usepri> fragment=<fragment> \n"
"                        usefragment=<usefragment> urg=<urg> \n"
"                        useurg=<useurg> ack=<ack> useack=<useack> \n"
"                        psh=<psh> usepsh=<usepsh> rst=<rst> \n"
"                        userst=<userst> syn=<syn> usesyn=<usesyn> \n"
"                        fin=<fin> usefin=<usefin> dscp=<dscp> \n"
"                        usedscp=<usedscp> ecn=<ecn> useecn=<useecn> \n"
"                        proto=<proto> useproto=<useproto> \n"
"                        sporthi=<sporthi> sportlo=<sportlo> \n"
"                        dporthi=<dporthi> dportlo=<dportlo> sa=<sa> \n"
"                        sawidth=<sawidth> da=<da> dawidth=<dawidth> \n"
"                        etype=<etype> useetype=<useetype> smac=<smac> \n"
"                        smacwidth=<smacwidth> dmac=<dmac> \n"
"                        dmacwidth=<dmacwidth> vid=<vid> \n"
"                        usevid=<usevid> ssaphi=<ssaphi> \n"
"                        ssaplo=<ssaplo> usessap=<usessap> \n"
"                        dsaphi=<dsaphi> dsaplo=<dsaplo> \n"
"                        usedsap=<usedsap> llcctrlhi=<llcctrlhi> \n"
"                        llcctrllo=<llcctrllo> usellcctrl=<usellcctrl> \n"
"                        enable=<enable> vlan=<vlan> ftidx=<ftidx> \n"
"                        mirror=<mirror> usevlan=<usevlan> \n"
"                        useftidx=<useftidx> copy=<copy> dp=<dp> \n"
"                        cos=<cos> fcos=<fcos> usedp=<usedp> \n"
"                        usecos=<usecos> policer=<policer> \n"
"                        typedpolice=<typedpolice> mefcos=<mefcos> \n"
"                        mef=<mef> ] \n"
"        ifp_v6          rule=<rule> [ dbtype=<dbtype> \n"
"                        usedbtype=<usedbtype> port=<port> \n"
"                        useport=<useport> pbmpn=<pbmpn> urg=<urg> \n"
"                        useurg=<useurg> ack=<ack> useack=<useack> \n"
"                        psh=<psh> usepsh=<usepsh> rst=<rst> \n"
"                        userst=<userst> syn=<syn> usesyn=<usesyn> \n"
"                        fin=<fin> usefin=<usefin> TC=<TC> \n"
"                        useTC=<useTC> nextheaderhi=<nextheaderhi> \n"
"                        nextheaderlo=<nextheaderlo> sporthi=<sporthi> \n"
"                        sportlo=<sportlo> dporthi=<dporthi> \n"
"                        dportlo=<dportlo> sa=<sa> sawidth=<sawidth> \n"
"                        da=<da> dawidth=<dawidth> vid=<vid> \n"
"                        usevid=<usevid> enable=<enable> vlan=<vlan> \n"
"                        ftidx=<ftidx> mirror=<mirror> \n"
"                        usevlan=<usevlan> useftidx=<useftidx> \n"
"                        copy=<copy> dp=<dp> cos=<cos> fcos=<fcos> \n"
"                        usedp=<usedp> usecos=<usecos> \n"
"                        policer=<policer> typedpolice=<typedpolice> \n"
"                        mefcos=<mefcos> mef=<mef> ] \n"
"        evp2e           vlan=<vlan> port=<port> [ eteptr=<eteptr> \n"
"                        counter=<counter> cocounter=<cocounter> \n"
"                        priclass=<priclass> allpri=<allpri> ] \n"
"        oi2e            oi=<oi> [ eteptr=<eteptr> counter=<counter> \n"
"                        cocounter=<cocounter> priclass=<priclass> \n"
"                        allpri=<allpri> ] \n"
"        eteencap        etei=<etei> [ l2ete=<l2ete> dmacset=<dmacset> \n"
"                        dmacsetlsb=<dmacsetlsb> \n"
"                        dscpremark=<dscpremark> remark=<remark> \n"
"                        mplsttldec=<mplsttldec> encaplen=<encaplen> \n"
"                        encapmac=<encapmac> nostrip=<nostrip> \n"
"                        noclass=<noclass> etepid=<etepid> \n"
"                        tunnelenter=<tunnelenter> \n"
"                        exp0remark=<exp0remark> \n"
"                        exp1remark=<exp1remark> \n"
"                        exp2remark=<exp2remark> ttl0dec=<ttl0dec> \n"
"                        ttl1dec=<ttl1dec> ttl2dec=<ttl2dec> \n"
"                        smacset=<smacset> nosplitcheck=<nosplitcheck> \n"
"                        ttlcheck=<ttlcheck> ipttldec=<ipttldec> \n"
"                        add_pwcw=<add_pwcw> dmac5=<dmac5> \n"
"                        dmac4=<dmac4> dmac3=<dmac3> dmac2=<dmac2> \n"
"                        dmac1=<dmac1> dmac0=<dmac0> vlan=<vlan> \n"
"                        vid=<vid> pricfi=<pricfi> tpid=<tpid> \n"
"                        mimtype=<mimtype> btag_vid=<btag_vid> \n"
"                        btag_pricfi=<btag_pricfi> \n"
"                        btag_tpid=<btag_tpid> ttl2=<ttl2> s2=<s2> \n"
"                        exp2=<exp2> label2=<label2> etype=<etype> \n"
"                        pid=<pid> isid=<isid> rsvd=<rsvd> ucm=<ucm> \n"
"                        dei=<dei> pcp=<pcp> ttl0=<ttl0> s0=<s0> \n"
"                        exp0=<exp0> label0=<label0> ttl1=<ttl1> \n"
"                        s1=<s1> exp1=<exp1> label1=<label1> ] \n"
"        etel2           etei=<etei> [ dscpremark=<dscpremark> \n"
"                        encaplen=<encaplen> nostrip=<nostrip> \n"
"                        noclass=<noclass> remark=<remark> \n"
"                        nosplitcheck=<nosplitcheck> usetag=<usetag> \n"
"                        dropuntagged=<dropuntagged> \n"
"                        droptagged=<droptagged> smacindex=<smacindex> \n"
"                        stpcheck=<stpcheck> vid=<vid> \n"
"                        defpricfi=<defpricfi> mtu=<mtu> \n"
"                        usevid=<usevid> ] \n"
"        oamEp           epIdx=<epIdx> [ nextentry=<nextentry> \n"
"                        function=<function> type=<type> \n"
"                        interval=<interval> mdlevel=<mdlevel> \n"
"                        singletx=<singletx> mode=<mode> dir=<dir> \n"
"                        conttohost=<conttohost> \n"
"                        singletohost=<singletohost> ftidx=<ftidx> \n"
"                        m=<m> d=<d> a=<a> c=<c> unibi=<unibi> cv=<cv> \n"
"                        fbit=<fbit> counteridx=<counteridx> \n"
"                        multiplieridx=<multiplieridx> rxfc=<rxfc> \n"
"                        rdi=<rdi> mip=<mip> lm=<lm> notlm=<notlm> \n"
"                        mepid=<mepid> intpri=<intpri> \n"
"                        smacaux=<smacaux> smacadd=<smacadd> \n"
"                        smacoffset=<smacoffset> sid=<sid> tx=<tx> \n"
"                        yourdiscrim=<yourdiscrim> \n"
"                        mydiscrim=<mydiscrim> rxfcl=<rxfcl> \n"
"                        nextentry_store=<nextentry_store> \n"
"                        ftidx_store=<ftidx_store> delaysec=<delaysec> \n"
"                        remotesec=<remotesec> maidw3=<maidw3> \n"
"                        maidw2=<maidw2> maidw9=<maidw9> \n"
"                        maidw8=<maidw8> maidcrc=<maidcrc> path=<path> \n"
"                        fpath=<fpath> reserved=<reserved> \n"
"                        revertive=<revertive> pt=<pt> \n"
"                        request=<request> version=<version> \n"
"                        pschdr=<pschdr> slowrate=<slowrate> \n"
"                        filter=<filter> burst=<burst> \n"
"                        pscentry=<pscentry> ipda=<ipda> txfcf=<txfcf> \n"
"                        txfcb=<txfcb> maidw1=<maidw1> maidw0=<maidw0> \n"
"                        maidw7=<maidw7> maidw6=<maidw6> \n"
"                        maxslowrate=<maxslowrate> peerrdi=<peerrdi> \n"
"                        ackrdi=<ackrdi> ackrdi_rdi=<ackrdi_rdi> \n"
"                        policerid=<policerid> \n"
"                        udpsourceport=<udpsourceport> \n"
"                        multipoint=<multipoint> peerstate=<peerstate> \n"
"                        final=<final> poll=<poll> \n"
"                        localstate=<localstate> diag=<diag> \n"
"                        peerdetectmulti=<peerdetectmulti> \n"
"                        localdetectmulti=<localdetectmulti> \n"
"                        framelossfar=<framelossfar> \n"
"                        framelossnear=<framelossnear> \n"
"                        delaynanosec=<delaynanosec> \n"
"                        remotenanosec=<remotenanosec> maidw5=<maidw5> \n"
"                        maidw4=<maidw4> maidw11=<maidw11> \n"
"                        maidw10=<maidw10> maxfilter=<maxfilter> \n"
"                        tlvlength=<tlvlength> tlv0_3=<tlv0_3> ] \n"
"        remark          e=<e> dp=<dp> cos=<cos> prof=<prof> [ \n"
"                        cfi=<cfi> pri=<pri> exp=<exp> dscp=<dscp> ] \n"
"        epv2e           vid=<vid> port=<port> [ drop=<drop> \n"
"                        strip=<strip> ] \n"
"        esmac           smaci=<smaci> [ smac5=<smac5> smac4=<smac4> \n"
"                        smac3=<smac3> smac2=<smac2> smac1=<smac1> \n"
"                        smac0=<smac0> ] \n"
"        ert             rule=<rule> [ mirror=<mirror> drop=<drop> ] \n"
"        ert_wrap        rule=<rule> [ mirror=<mirror> drop=<drop> ] \n"
"        v4mc_str_sel    rule=<rule> [ valid=<valid> ] \n"
"        efp             rule=<rule> [ dbtype=<dbtype> \n"
"                        usedbtype=<usedbtype> port=<port> \n"
"                        useport=<useport> pbmpn=<pbmpn> pri=<pri> \n"
"                        usepri=<usepri> fragment=<fragment> \n"
"                        usefragment=<usefragment> urg=<urg> \n"
"                        useurg=<useurg> ack=<ack> useack=<useack> \n"
"                        psh=<psh> usepsh=<usepsh> rst=<rst> \n"
"                        userst=<userst> syn=<syn> usesyn=<usesyn> \n"
"                        fin=<fin> usefin=<usefin> dscp=<dscp> \n"
"                        usedscp=<usedscp> ecn=<ecn> useecn=<useecn> \n"
"                        proto=<proto> useproto=<useproto> \n"
"                        sporthi=<sporthi> sportlo=<sportlo> \n"
"                        dporthi=<dporthi> dportlo=<dportlo> sa=<sa> \n"
"                        sawidth=<sawidth> da=<da> dawidth=<dawidth> \n"
"                        etype=<etype> useetype=<useetype> smac=<smac> \n"
"                        smacwidth=<smacwidth> dmac=<dmac> \n"
"                        dmacwidth=<dmacwidth> pvlan=<pvlan> \n"
"                        usepvlan=<usepvlan> ssaphi=<ssaphi> \n"
"                        ssaplo=<ssaplo> usessap=<usessap> \n"
"                        dsaphi=<dsaphi> dsaplo=<dsaplo> \n"
"                        usedsap=<usedsap> llcctrlhi=<llcctrlhi> \n"
"                        llcctrllo=<llcctrllo> usellcctrl=<usellcctrl> \n"
"                        enable=<enable> mirror=<mirror> drop=<drop> ] \n"
"        efp_v6          rule=<rule> [ dbtype=<dbtype> \n"
"                        usedbtype=<usedbtype> port=<port> \n"
"                        useport=<useport> pbmpn=<pbmpn> urg=<urg> \n"
"                        useurg=<useurg> ack=<ack> useack=<useack> \n"
"                        psh=<psh> usepsh=<usepsh> rst=<rst> \n"
"                        userst=<userst> syn=<syn> usesyn=<usesyn> \n"
"                        fin=<fin> usefin=<usefin> TC=<TC> \n"
"                        useTC=<useTC> nextheaderhi=<nextheaderhi> \n"
"                        nextheaderlo=<nextheaderlo> sporthi=<sporthi> \n"
"                        sportlo=<sportlo> dporthi=<dporthi> \n"
"                        dportlo=<dportlo> sa=<sa> sawidth=<sawidth> \n"
"                        da=<da> dawidth=<dawidth> vid=<vid> \n"
"                        usevid=<usevid> enable=<enable> \n"
"                        mirror=<mirror> drop=<drop> ] \n"
"        oamMultiplier   lossCount=<lossCount> threshold=<threshold> [ \n"
"                        frameCount=<frameCount> ] \n"
"        oamEpRemap      endpoint=<endpoint> mdLevel=<mdLevel> \n"
"                        type=<type> [ epIdx=<epIdx> ] \n"
"        ipv6da          prefixbits=<prefixbits> ip=<ip> [ \n"
"                        ftidx=<ftidx> ecmpmask=<ecmpmask> vid=<vid> ] \n"
"        ipv6dal0        addr=<addr> [ pattern=<pattern> \n"
"                        singleton=<singleton> pointer=<pointer> \n"
"                        leaf=<leaf> ] \n"
"        ipv6daodd       addr=<addr> [ pattern=<pattern> \n"
"                        singleton=<singleton> pointer=<pointer> \n"
"                        leaf=<leaf> ] \n"
"        ipv6daeven      addr=<addr> [ pattern=<pattern> \n"
"                        singleton=<singleton> pointer=<pointer> \n"
"                        leaf=<leaf> ] \n"
"        ipv6dapayload   addr=<addr> [ ftidx=<ftidx> \n"
"                        ecmpmask=<ecmpmask> vid=<vid> ] \n"
"        ipv6sa          prefixbits=<prefixbits> ip=<ip> [ poe=<poe> \n"
"                        rpfmode=<rpfmode> srcdrop=<srcdrop> \n"
"                        srccnt=<srccnt> ] \n"
"        ipv6sal0        addr=<addr> [ pattern=<pattern> \n"
"                        singleton=<singleton> pointer=<pointer> \n"
"                        leaf=<leaf> ] \n"
"        ipv6saodd       addr=<addr> [ pattern=<pattern> \n"
"                        singleton=<singleton> pointer=<pointer> \n"
"                        leaf=<leaf> ] \n"
"        ipv6saeven      addr=<addr> [ pattern=<pattern> \n"
"                        singleton=<singleton> pointer=<pointer> \n"
"                        leaf=<leaf> ] \n"
"        ipv6sapayload   addr=<addr> [ poe=<poe> rpfmode=<rpfmode> \n"
"                        srcdrop=<srcdrop> srccnt=<srccnt> ] \n"
"        ipv4da          prefixbits=<prefixbits> ip=<ip> ipcxt=<ipcxt> \n"
"                        [ ftidx=<ftidx> ecmpmask=<ecmpmask> vid=<vid> \n"
"                        ] \n"
"        ipv4dal0        addr=<addr> [ pattern=<pattern> \n"
"                        singleton=<singleton> pointer=<pointer> \n"
"                        leaf=<leaf> ] \n"
"        ipv4daodd       addr=<addr> [ pattern=<pattern> \n"
"                        singleton=<singleton> pointer=<pointer> \n"
"                        leaf=<leaf> ] \n"
"        ipv4daeven      addr=<addr> [ pattern=<pattern> \n"
"                        singleton=<singleton> pointer=<pointer> \n"
"                        leaf=<leaf> ] \n"
"        ipv4dapayload   addr=<addr> [ ftidx=<ftidx> \n"
"                        ecmpmask=<ecmpmask> vid=<vid> ] \n"
"        P2FTI           port=<port> dmac=<dmac> [ ftidx=<ftidx> ] \n"
"        mm0_nar0        <addr> <value> (memory) \n"
"        mm0_nar1        <addr> <value> (memory) \n"
"        mm0_wide        <addr> <value> (memory) \n"
"        mm0_int0        <addr> <value> (memory) \n"
"        mm0_int1        <addr> <value> (memory) \n"
"        mm1_nar0        <addr> <value> (memory) \n"
"        mm1_nar1        <addr> <value> (memory) \n"
"        mm1_wide        <addr> <value> (memory) \n"
"        mm1_int0        <addr> <value> (memory) \n"
"        mm1_int1        <addr> <value> (memory) \n"
"        rc0_rr          <addr> <value> (memory) \n"
"        rc1_rr          <addr> <value> (memory) \n"
"        rxportdata      <addr> <value> (memory) \n"
"        initialqstate20 <addr> <value> (memory) \n"
"        initialqstate25 <addr> <value> (memory) \n"
"        emirrorhw20     <addr> <value> (memory) \n"
"        emirrorhw25     <addr> <value> (memory) \n"
;

/* Shell delete command usage string */
char soc_sbx_g2p3_delete_usage[] =
"g2p3delete <table> idx0=<i0> ...\n"
"        mac             mac=<mac> vlan=<vlan> bmac=<bmac> \n"
"        ipv6dhost       ip=<ip> \n"
"        ipv6shost       ip=<ip> \n"
"        pvv2e           ivid=<ivid> ovid=<ovid> port=<port> \n"
"        pvv2epack       ovid=<ovid> port=<port> ivid=<ivid> \n"
"        isid2e          isid=<isid> \n"
"        oampvd2e        port=<port> vid=<vid> dir=<dir> tag=<tag> \n"
"        oammaidmep2e    maid=<maid> mepid=<mepid> \n"
"        cuckoo          key=<key> type=<type> \n"
"        outerlabelcuckoo key=<key> type=<type> \n"
"        innerlabelcuckoo key=<key> type=<type> \n"
"        label2e         label=<label> \n"
"        cmac            mac=<mac> vlan=<vlan> \n"
"        bmac            mac=<mac> vlan=<vlan> \n"
"        ipv6mcsg        g=<g> s=<s> vlan=<vlan> \n"
"        ipv6mcg         g=<g> vlan=<vlan> \n"
"        ipv4mcg         g=<g> vlan=<vlan> \n"
"        ipv4mcsg        g=<g> s=<s> vlan=<vlan> \n"
"        ipv4sa          prefixbits=<prefixbits> ip=<ip> ipcxt=<ipcxt> \n"
"        ifp             rule=<rule> \n"
"        ifp_v6          rule=<rule> \n"
"        efp             rule=<rule> \n"
"        efp_v6          rule=<rule> \n"
"        ipv6da          prefixbits=<prefixbits> ip=<ip> \n"
"        ipv6sa          prefixbits=<prefixbits> ip=<ip> \n"
"        ipv4da          prefixbits=<prefixbits> ip=<ip> ipcxt=<ipcxt> \n"
;
#endif 
