/*
 * $Id: g2xx_defs.c 1.9.60.2 Broadcom SDK $
 *
 *
 * $Copyright: Copyright 2011 Broadcom Corporation.
 * This program is the proprietary software of Broadcom Corporation
 * and/or its licensors, and may only be used, duplicated, modified
 * or distributed pursuant to the terms and conditions of a separate,
 * written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized
 * License, Broadcom grants no license (express or implied), right
 * to use, or waiver of any kind with respect to the Software, and
 * Broadcom expressly reserves all rights in and to the Software
 * and all intellectual property rights therein.  IF YOU HAVE
 * NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE
 * IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
 * ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of
 * Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS
 * PROVIDED "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
 * OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL,
 * INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER
 * ARISING OUT OF OR IN ANY WAY RELATING TO YOUR USE OF OR INABILITY
 * TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF
 * THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR USD 1.00,
 * WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING
 * ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.$
 * 
 *
 * g2xx_defs.c: XXX Custom Microcode microcode accessor functions
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 */
#include <soc/sbx/g2xx/g2xx_int.h>
#include <soc/sbx/sbx_drv.h>
#include <sal/core/libc.h>
#include <sal/appl/sal.h>
#include <soc/sbx/fe2k/sbFe2000Util.h>
#define UTG_MALLOC(x) sal_alloc((x), "utg");

/* Static symbol name for initialization */
char soc_sbx_g2xx_sym[128];

/* Only for debugging */
char *soc_sbx_g2xx_errsym;

/* Parse an integer */
int soc_sbx_g2xx_read(char *a, int range, uint32 *vp);
int soc_sbx_g2xx_read(char *a, int range, uint32 *vp)
{
    uint32 v;

    if (a[0] < '0' || '9' < a[0]) {
        return SOC_E_PARAM;
    }
    v = sal_ctoi(a, 0);
    if (0 < range && ((uint32) range) <= v) {
        return SOC_E_PARAM;
    }
    *vp = v;
    return SOC_E_NONE;
}

/* Read an arbitrarily large value from shell command arguments */
int soc_sbx_g2xx_big_value_read(uint8 *v,
                int width, int noarg0, int argc, char **argv);
int soc_sbx_g2xx_big_value_read(uint8 *v,
                int width, int noarg0, int argc, char **argv)
{
    int i, rv, vwidth, n = 0;
    int bytes = (width + 7) / 8;
    char *s, *s0;
    uint8 c;
    uint8 b[6];
    uint32 v0, v1;

    sal_memset(v, 0, bytes);
    if (noarg0) {
        s = *argv;
    } else {
        for(s = *argv; *s && *s != '='; s++);
        if (!*s) {
            if (argc < 2) {
                soc_cm_print("no value given for %s\n", *argv);
                return -1;
            }
            argv++;
            argc--;
            s = *argv;
            n++;
        } else if (*s == '=') {
            s++;
        }
    }
      
    for(s0 = s; *s0 && *s0 != '.' && *s0 != '-' && *s0 != ':'; s0++);

    if (*s0 == '.') {
        v1 = 0;
        vwidth = 0;
        c = (uint8) *s++;
        for (i = 0; i < 4; i++) {
            if (!('0' <= c && c <= '9')) {
                soc_cm_print("illegal octet in IP address %s\n", *argv);
                return -1;
            }
            v0 = 0;
            for (; '0' <= c && c <= '9'; c = (uint8) *s++) {
                v0 = v0 * 10 + (c - '0');
                if (v0 > 255) {
                    soc_cm_print("octet too large in IP address %s\n", *argv);
                    return -1;
                }
            }
            v1 = (v1 << 8) + v0;
            if (c && (i == 3 || c != '.')) {
                soc_cm_print("illegal number %s\n", *argv);
                return -1;
            }
            if (c) c = (uint8) *s++;
            if (vwidth) {
                vwidth += 8;
            } else {
                for (; ((uint32) (1 << vwidth)) <= v0; vwidth++);
            }
            if (vwidth > width) {
                soc_cm_print("number is too large %s\n", *argv);
                return -1;
            }
        }

        for (i = 0; v1 && i < bytes; i++) {
            v[i] = v1;
            v1 >>= 8;
        }
        return n + 1;
    } else if (*s0 == '-' || *s0 == ':') {
        vwidth = 0;
        c = (uint8) *s++;
        for (i = 0; i < 6; i++) {
            if (!(('0' <= c && c <= '9')
                  || ('A' <= c && c <= 'F')
                  || ('a' <= c && c <= 'f'))) {
                soc_cm_print("illegal octet in MAC address %s\n", *argv);
                return -1;
            }
            v0 = 0;
            for (;('0' <= c && c <= '9')
                 || ('A' <= c && c <= 'F')
                 || ('a' <= c && c <= 'f');
                 c = (uint8) *s++) {
                if ('0' <= c && c <= '9') {
                  c -= '0';
                } else if ('A' <= c && c <= 'F') {
                  c -= 'A' - 10;
                } else if ('a' <= c && c <= 'f') {
                  c -= 'a' - 10;
                }
                v0 = v0 * 16 + c;
                if (v0 > 255) {
                    soc_cm_print("octet too large in MAC address %s\n", *argv);
                    return -1;
                }
            }
            if (c && (i == 5 || (c != ':' && c != '-'))) {
                soc_cm_print("illegal number %s\n", *argv);
                return -1;
            }
            if (c) c = (uint8) *s++;
            if (vwidth) {
                vwidth += 8;
            } else {
                for (; ((uint32) (1 << vwidth)) <= v0; vwidth++);
            }
            if (vwidth > width) {
                soc_cm_print("number is too large %s\n", *argv);
                return -1;
            }
            b[i] = v0;
        }
        for (i = 0; i < bytes; i++) {
            v[i] = b[i];
        }
        return n + 1;
    }

    rv = soc_sbx_g2xx_read(s, -1, &v0);
    if (rv) {
        if (noarg0) {
            return 0;
        }
        soc_cm_print("illegal number %s\n", *argv);
        return -1;
    }

    for (vwidth = 0;
         ((uint32) (1 << vwidth)) <= v0 && vwidth < 32;
         vwidth++);
    if (vwidth > width) {
        soc_cm_print("number is too large %s\n", *argv);
        return -1;
    }
    if (vwidth > 8) {
        for (i = 0; v0; i++) {
            v[i] = v0;
            v0 >>= 8;
        }
        return n + 1;
    }

    for (i = 0; i < bytes; i++) {
        rv = soc_sbx_g2xx_read(s, 256, &v0);
        if (rv) {
            break;
        }
        if (v0) {
            for (vwidth = 0; ((uint32) (1 << vwidth)) <= v0; vwidth++);
            vwidth += i * 8;
        }
        if (vwidth > width) {
            soc_cm_print("number is too large %s\n", *argv);
            return -1;
        }
        v[i] = v0;
        n++;
        argv++;
        argc--;
        if (!argc) {
            break;
        }
        s = *argv;
    }
    return n;
}

/* Read a 32 bit value from shell command arguments */
int soc_sbx_g2xx_value_read(uint32 *v,
                int range, int noarg0, int argc, char **argv);
int soc_sbx_g2xx_value_read(uint32 *v,
                int range, int noarg0, int argc, char **argv)
{
    uint8 b[4];
    uint32 v0;
    int rv;

    rv = soc_sbx_g2xx_big_value_read(b, 32, noarg0, argc, argv);
    if (rv > 0) {
        v0 = b[0] | (b[1] << 8) | (b[2] << 16) | (b[3] << 24);
        if (0 < range && ((uint32) range) <= v0) {
            soc_cm_print("value 0x%x too large in %s\n", v0, *argv);
            return -1;
        }
        *v = v0;
    }
    return rv;
}

/* Print an integer */
int soc_sbx_g2xx_print(int range, uint32 v);
int soc_sbx_g2xx_print(int range, uint32 v)
{
    int d = 8;

    if (0 < range) {
      for (d = 0; d < 8; d++) {
        if (range <= (1 << (d * 4))) break;
      }
    }
    soc_cm_print("0x%0*x", d, v);
    return 2 + d;
}

/* Get a constant value */
int soc_sbx_g2xx_constant_get(int unit, char *sym, uint32 *vp);
int soc_sbx_g2xx_constant_get(int unit, char *sym, uint32 *vp)
{
    int s;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
  
    s = sbFe2000GetNamedConstant(fe->regSet, fe->ucode, sym, vp);
    if (s != 0) {
      return SOC_E_NOT_FOUND;
    }
    return SOC_E_NONE;
}

/* Set a global value into the running microcode */
int soc_sbx_g2xx_global_set(int unit, char *sym, uint32 v);
int soc_sbx_g2xx_global_set(int unit, char *sym, uint32 v)
{
    int s;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
  
    s = sbFe2000SetNamedConstant(fe->regSet, fe->ucode, sym, v);
    if (s != 0) {
      return SOC_E_NOT_FOUND;
    }
    return SOC_E_NONE;
}

/* Get a global value */
int soc_sbx_g2xx_global_get(int unit, char *sym, uint32 *vp);
int soc_sbx_g2xx_global_get(int unit, char *sym, uint32 *vp)
{
    int s;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
  
    s = sbFe2000GetNamedConstant(fe->regSet, fe->ucode, sym, vp);
    if (s != 0) {
      return SOC_E_NOT_FOUND;
    }
    return SOC_E_NONE;
}

/* Insert a bit string into a buffer */
void soc_sbx_g2xx_insert(uint8 *b,
                int bbe, int pos, int width,
                uint8 *b0, int b0be, int swab);
void soc_sbx_g2xx_insert(uint8 *b,
                int bbe, int pos, int width,
                uint8 *b0, int b0be, int swab)
{
    int c, m, binc, b0inc, off;
        
    if (bbe) {
        b -= pos / 8;
        binc = -1;
    } else {
        b += pos / 8;
        binc = 1;
    }
    if (b0be) {
        b0inc = -1;
    } else {
        b0inc = 1;
    }
    if (swab) {
        off = ((width + 7) / 8) - 1;
        if (b0be) off = -off;
        b0 += off;
        b0inc = -b0inc;
    }
    pos %= 8;

    for (c = *b0; 8 < width; c = *(b0 += b0inc), b += binc, width -= 8) {
        *b = (*b & (0xff >> (8 - pos))) | (c << pos);
        if (pos != 0)
            *(b + binc) = (*(b + binc) & (0xff << pos)) | (c >> (8 - pos));
    }

    m = ((0xff >> (8 - pos)) | (0xff << (pos + width)));
    *b = (*b & m) | ((c << pos) & ~m);
    width -= 8 - pos;
    if (width > 0)
        *(b + binc) = (*(b + binc) & (0xff << width)) 
            | ((c >> (8 - pos)) & (0xff >> (8 - width)));
}

/* OR a bit string into a buffer */
void soc_sbx_g2xx_insert_or(uint8 *b,
                int bbe, int pos, int width,
                uint8 *b0, int b0be, int swab);
void soc_sbx_g2xx_insert_or(uint8 *b,
                int bbe, int pos, int width,
                uint8 *b0, int b0be, int swab)
{
    int c, m, binc, b0inc, off;
        
    if (bbe) {
        b -= pos / 8;
        binc = -1;
    } else {
        b += pos / 8;
        binc = 1;
    }
    if (b0be) {
        b0inc = -1;
    } else {
        b0inc = 1;
    }
    if (swab) {
        off = ((width + 7) / 8) - 1;
        if (b0be) off = -off;
        b0 += off;
        b0inc = -b0inc;
    }
    pos %= 8;

    for (c = *b0; 8 < width; c = *(b0 += b0inc), b += binc , width -= 8) {
        *b |= (c << pos);
        if (pos) *(b + binc) |= (c >> (8 - pos));
    }

    m = ((0xff >> (8 - pos)) | (0xff << (pos + width)));
    *b |= (c << pos) & ~m;
    width -= 8 - pos;
    if (width > 0) *(b + binc) |= (c >> (8 - pos)) & (0xff >> (8 - width));
}

/*
 * Extract a bit string into a buffer 
 *
 * b (source) and b0 (destination) can overlap as long as b >= b0 and
 * swab == 0.  This behavior is exploited by the entry_read_write function
 */
void soc_sbx_g2xx_extract(uint8 *b,
                int bbe, int pos, int width,
                uint8 *b0, int b0be, int swab);
void soc_sbx_g2xx_extract(uint8 *b,
                int bbe, int pos, int width,
                uint8 *b0, int b0be, int swab)
{
    int c, binc, b0inc, off;
        
    if (bbe) {
        b -= pos / 8;
        binc = -1;
    } else {
        b += pos / 8;
        binc = 1;
    }
    if (b0be) {
        b0inc = -1;
    } else {
        b0inc = 1;
    }
    if (swab) {
        off = ((width + 7) / 8) - 1;
        if (b0be) off = -off;
        b0 += off;
        b0inc = -b0inc;
    }
    pos %= 8;

    for (;;b0 += b0inc, b += binc, width -= 8) {
        c = (((*b >> pos) & 0xff)
             | (pos != 0 && width > (8 - pos) ? *(b + binc) << (8 - pos) : 0));
        if (width <= 8) break;
        *b0 = c;
    }

    *b0 = c & ~(0xff << width);
}

/* Read or write an entry */
int soc_sbx_g2xx_entry_read_write(int unit, int read, int idx,
                 soc_sbx_g2xx_entry_desc_t *ed);
int soc_sbx_g2xx_entry_read_write(int unit, int read, int idx,
                 soc_sbx_g2xx_entry_desc_t *ed)
{
    int i, s, width, bytes, pos, offset, rmw, opcode;
    int mwidth = 0;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2xx_entry_bank_t *eb = NULL;
    soc_sbx_g2xx_table_bank_t *tb;
    soc_sbx_g2xx_memory_desc_t *md;
    uint8 buf[4] = {0, 0, 0, 0};

    bytes = 0;
    i = 0;
    rmw = 0;
    opcode = read ? SB_FE2000_DMA_OPCODE_READ : SB_FE2000_DMA_OPCODE_WRITE;
    while (i < ed->nbanks) {
        eb = &ed->banks[i];
        width = eb->width;
        tb = &td->banks[eb->tablebank];
        md = &tm->memories[tb->memory];
        mwidth = md->width;

        if (eb->width < mwidth) {
            if (ed->nbanks > 1) {
                return SOC_E_INTERNAL;
            }
            if (opcode == SB_FE2000_DMA_OPCODE_WRITE) {
                buf[0] = tm->entrydmabuf[0];
                buf[1] = tm->entrydmabuf[1];
                buf[2] = tm->entrydmabuf[2];
                buf[3] = tm->entrydmabuf[3];
                opcode = SB_FE2000_DMA_OPCODE_READ;
                rmw = 1;
            } else if (rmw) {
                pos = eb->width * (idx % (mwidth / eb->width));
                soc_sbx_g2xx_insert(tm->entrydmabuf,
                       0, pos, eb->width, buf, 0, 0);
                opcode = SB_FE2000_DMA_OPCODE_WRITE;
                rmw = 0;
            }
            width = mwidth;
        }
      
        tm->entrydmaop.opcode = opcode;
        tm->entrydmaop.words = (uint32) ((width + 31) / 32);
        tm->entrydmaop.hostAddress = 
            (uint32 *) (tm->entrydmabuf + bytes);
        offset = (uint32) 
            (tb->base + ((idx * eb->stridebits) / mwidth));
        if (md->dma) {
          tm->entrydmaop.hostBusAddress = tm->entrydmabufhba + bytes;
          tm->entrydmaop.feAddress = (uint32)
            SB_FE2000_DMA_MAKE_ADDRESS(tb->memory, offset);
          s = sbFe2000DmaRequest(fe->pDmaMgr, INT_TO_PTR(unit),
                                 &tm->entrydmaop);
          if (s) {
              return SOC_E_FAIL;
          }
        } else {
            if (opcode == SB_FE2000_DMA_OPCODE_WRITE) {
                s = sbFe2000UtilWriteIndir(fe->regSet, 1, md->descending,
                                           md->reg, offset,
                                           tm->entrydmaop.words,
                                           tm->entrydmaop.hostAddress);
            } else {
                s = sbFe2000UtilReadIndir(fe->regSet, 1, md->descending,
                                          md->reg, offset,
                                          tm->entrydmaop.words,
                                          tm->entrydmaop.hostAddress);
            }
            if (s) {
                return SOC_E_TIMEOUT;
            }
        }
        if (!rmw) {
            bytes += width / 8;
            i++;
        }
    }

    if (eb->width < mwidth && read) {
        pos = eb->width * (idx % (mwidth / eb->width));
        soc_sbx_g2xx_extract(tm->entrydmabuf,
               0, pos, eb->width, tm->entrydmabuf, 0, 0);
    }
    return SOC_E_NONE;
}

/* Format a microcode package symbol (for get or set) */
void soc_sbx_g2xx_ucode_symbol_format(
                char *sym, int symlen,
                char *s0, char *s1, int d, char *s2, char *s3);
void soc_sbx_g2xx_ucode_symbol_format(
                char *sym, int symlen,
                char *s0, char *s1, int d, char *s2, char *s3)
{
    char *s;
    char c;

    if (d >= 0) {
        sal_snprintf(sym, symlen, "%s%s%s%d%s%s%s%s",
                     s0, *s0 ? "_" : s0,
                     s1, 
                     d,
                     *s2 ? "_" : s2, s2, 
                     *s3 ? "_" : s3, s3);
    } else {
        sal_snprintf(sym, symlen, "%s%s%s%s%s%s%s",
                     s0, *s0 ? "_" : s0,
                     s1, 
                     *s2 ? "_" : s2, s2, 
                     *s3 ? "_" : s3, s3);
    }

    for (s = sym; (c = *s); s++) {
        if ('a' <= c && c <= 'z') {
            *s = c - ('a' - 'A');
        }
    }
}

/* Get a symbol from the microcode package */
int soc_sbx_g2xx_ucode_get(int unit,
                char *sym, int symlen, int *v,
                char *s0, char *s1, int d, char *s2, char *s3);
int soc_sbx_g2xx_ucode_get(int unit,
                char *sym, int symlen, int *v,
                char *s0, char *s1, int d, char *s2, char *s3)
{
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;

    soc_sbx_g2xx_ucode_symbol_format(sym, symlen, s0, s1, d, s2, s3);

    if (sbFe2000GetNamedConstant(fe->regSet, fe->ucode, sym, (uint32 *) v)) {
        return SOC_E_NOT_FOUND;
    }
    return SOC_E_NONE;
}

/* Set a symbol from the microcode package */
int soc_sbx_g2xx_ucode_set(int unit,
                char *sym, int symlen, int v,
                char *s0, char *s1, int d, char *s2, char *s3);
int soc_sbx_g2xx_ucode_set(int unit,
                char *sym, int symlen, int v,
                char *s0, char *s1, int d, char *s2, char *s3)
{
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;

    soc_sbx_g2xx_ucode_symbol_format(sym, symlen, s0, s1, d, s2, s3);

    if (sbFe2000SetNamedConstant(fe->regSet, fe->ucode, sym, v)) {
        return SOC_E_NOT_FOUND;
    }
    return SOC_E_NONE;
}
/* Find an entry index from a name */
int soc_sbx_g2xx_index_find(
                soc_sbx_g2xx_entry_desc_t *ed, char *a);
int soc_sbx_g2xx_index_find(
                soc_sbx_g2xx_entry_desc_t *ed, char *a)
{
    int i, l;

    for (i = 0; i < ed->nindexes; i++) {
        if (!sal_strcasecmp(a, ed->indexes[i].name)) {
          return i;
        }
        l = sal_strlen(ed->indexes[i].name);
        if (!sal_strncasecmp(a, ed->indexes[i].name, l)
            && a[l] == '=') {
          return i;
      }
    }
    return -1;
}

/* Read a sequence of index arguments */
int soc_sbx_g2xx_indexes_read(void **idxs,
                soc_sbx_g2xx_entry_desc_t *ed, int argc, char **argv);
int soc_sbx_g2xx_indexes_read(void **idxs,
                soc_sbx_g2xx_entry_desc_t *ed, int argc, char **argv)
{
    int rv, i, noarg0, bytes, n = 0;
    
    for (i = 0; i < ed->nindexes; i++) {
        bytes = (ed->indexes[i].width + 7) / 8;
        if (bytes < 4) { bytes = 4; }
        sal_memset(idxs[i], 0, bytes);
    }

    while (argc) {
        i = soc_sbx_g2xx_index_find(ed, *argv);
        noarg0 = i < 0;
        if (noarg0) {
            i = 0;
            if (n != 0 || ed->nindexes != 1) {
                break;
            }
        }

        if (ed->indexes[i].width > 32) {
            rv = soc_sbx_g2xx_big_value_read(idxs[i],
                           ed->indexes[i].width, noarg0, argc, argv);
        } else {
            rv = soc_sbx_g2xx_value_read(idxs[i],
                          ed->indexes[i].range, noarg0, argc, argv);
        }
        if (rv < 0) {
            return -1;
        }
        if (rv == 0) {
            break;
        }
        n += rv;
        argc -= rv;
        argv += rv;
    }
    return n;
}

/* Print a sequence of indexes */
void soc_sbx_g2xx_indexes_print(void **indexpointers,
                soc_sbx_g2xx_entry_desc_t *ed);
void soc_sbx_g2xx_indexes_print(void **indexpointers,
                soc_sbx_g2xx_entry_desc_t *ed)
{
    int i, j;
    int bytes;

    soc_cm_print("%s[", ed->name);
    for (i = 0; i < ed->nindexes; i++) {
        soc_cm_print("%s=", ed->indexes[i].name);
        bytes = (ed->indexes[i].width + 7) / 8;
        if (bytes > 4) {
            for (j = 0; j < bytes; j++) {
                soc_cm_print("0x%02x%s",
                        ((uint8 *) indexpointers[i])[j],
                        j < bytes - 1 ? " " : "");
            }
        } else {
            soc_sbx_g2xx_print(ed->indexes[i].range,
                   *((uint32 *) indexpointers[i]));
        }
        if (i + 1 < ed->nindexes) {
            soc_cm_print(" ");
        }
    }
    soc_cm_print("]:\n");
}

/* Parse range arguments with optional flags */
int soc_sbx_g2xx_range_parse(int argc, char **argv,
                int *lower, int *upper,
                int *f0, char *f0name,
                int *f1, char *f1name,
                int *f2, char *f2name);
int soc_sbx_g2xx_range_parse(int argc, char **argv,
                int *lower, int *upper,
                int *f0, char *f0name,
                int *f1, char *f1name,
                int *f2, char *f2name)
{
    int max, rv;
    int num = 0;
    char *s;

    max = *upper + 1;
    while (argc) {
        s = argv[0];
        if (f0name && !sal_strcasecmp(s, f0name)) {
            *f0 = 1;
        } else if (f0name
                   && (s[0] == 'n' || s[0] == 'N')
                   && (s[1] == 'o' || s[1] == 'O')
                   && !sal_strcasecmp(&s[2], f0name)) {
            *f0 = 0;
        } else if (f1name && !sal_strcasecmp(s, f1name)) {
            *f1 = 1;
        } else if (f1name
                   && (s[0] == 'n' || s[0] == 'N')
                   && (s[1] == 'o' || s[1] == 'O')
                   && !sal_strcasecmp(&s[2], f1name)) {
            *f1 = 0;
        } else if (f2name && !sal_strcasecmp(s, f2name)) {
            *f2 = 1;
        } else if (f2name
                   && (s[0] == 'n' || s[0] == 'N')
                   && (s[1] == 'o' || s[1] == 'O')
                   && !sal_strcasecmp(&s[2], f2name)) {
            *f2 = 0;
        } else {
            rv = soc_sbx_g2xx_read(s, max, (uint32 *) lower);
            if (rv == SOC_E_NONE) {
                for(s = *argv; *s && *s != '-'; s++);
                if (*s) {
                    s++;
                    rv = soc_sbx_g2xx_read(s, max, (uint32 *) upper);
                    if (rv) {
                        soc_cm_print("illegal upper bound in range %s\n", s);
                        return SOC_E_FAIL;
                    }
                } else if (argc > 1) {
                    rv = soc_sbx_g2xx_read(argv[1], max, (uint32 *) &num);
                    if (rv == SOC_E_NONE) {
                        *upper = *lower + num - 1;
                        if (*upper >= max) {
                            soc_cm_print("%s overflows the legal range\n",
                                    argv[1]);
                            return SOC_E_NONE;
                        }
                        argv++;
                        argc--;
                    } else {
                        *upper = *lower;
                    }
                } else {
                    *upper = *lower;
                }
            } else {
                soc_cm_print("unexpected argument: %s\n", s);
                return SOC_E_PARAM;
            }
        }
        argv++;
        argc--;
    }
    return SOC_E_NONE;
}
/* Find an entry field from a name */
int soc_sbx_g2xx_field_find(
                soc_sbx_g2xx_entry_desc_t *ed, char *a);
int soc_sbx_g2xx_field_find(
                soc_sbx_g2xx_entry_desc_t *ed, char *a)
{
    int i, l;

    for (i = 0; i < ed->nfields; i++) {
        if (!sal_strcasecmp(a, ed->fields[i].name)) {
          return i;
        }
        l = sal_strlen(ed->fields[i].name);
        if (!sal_strncasecmp(a, ed->fields[i].name, l)
            && a[l] == '=') {
          return i;
      }
      
    }
    return -1;
}

/* Update the base of a table bank */
int soc_sbx_g2xx_table_bank_base_set(int unit,
                int tid, int bank, int base);
int soc_sbx_g2xx_table_bank_base_set(int unit,
                int tid, int bank, int base)
{
    int s;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_table_desc_t *td = &tm->tables[tid];
    char *e = "";

    td->banks[bank].base = base;
     
    s = soc_sbx_g2xx_ucode_set(unit, soc_sbx_g2xx_sym, 128,
                base, e, td->name, bank == 0 ? -1 : bank, e, "BASE");
    return s;
}

/* Update the base of a counter bank */
int soc_sbx_g2xx_counter_bank_base_set(int unit,
                int bank, int base);
int soc_sbx_g2xx_counter_bank_base_set(int unit,
                int bank, int base)
{
    int s;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_counter_bank_desc_t *cb = &tm->counterbanks[bank];
    char *e = "";

    cb->base = base;
    s = soc_sbx_g2xx_ucode_set(unit, soc_sbx_g2xx_sym, 128,
                base, e, "COUNTER_BANK", bank, e, "BASE");
    return s;
}

/* Update the base of a policer bank */
int soc_sbx_g2xx_policer_bank_base_set(int unit,
                int bank, int base);
int soc_sbx_g2xx_policer_bank_base_set(int unit,
                int bank, int base)
{
    /* no policers */
    return SOC_E_PARAM;
}

/* Sets a memory bank base */
int soc_sbx_g2xx_memory_bank_base_set(int unit,
                soc_sbx_g2xx_memory_bank_desc_t *mb, int base);
int soc_sbx_g2xx_memory_bank_base_set(int unit,
                soc_sbx_g2xx_memory_bank_desc_t *mb, int base)
{
    int s = SOC_E_INTERNAL;

    switch (mb->type) {
    case SOC_SBX_G2XX_TABLE_BANK_TYPE:
        s = soc_sbx_g2xx_table_bank_base_set(unit,
                      mb->number, mb->bank, base);
        break;
    case SOC_SBX_G2XX_COUNTER_BANK_TYPE:
        s = soc_sbx_g2xx_counter_bank_base_set(unit,
                      mb->number, base);
        break;
    case SOC_SBX_G2XX_POLICER_BANK_TYPE:
        s = soc_sbx_g2xx_policer_bank_base_set(unit,
                      mb->number, base);
        break;
    }

    return s;
}

/* Get the base & size of a bank in a memory */
void soc_sbx_g2xx_memory_bank_params_get(int *base, int *size,
                soc_sbx_g2xx_memory_bank_desc_t *mb,
                soc_sbx_g2xx_table_manager_t *tm);  
void soc_sbx_g2xx_memory_bank_params_get(int *base, int *size,
                soc_sbx_g2xx_memory_bank_desc_t *mb,
                soc_sbx_g2xx_table_manager_t *tm)
{
    soc_sbx_g2xx_table_bank_t *tb;

    switch (mb->type) {
    case SOC_SBX_G2XX_TABLE_BANK_TYPE:
        tb = &tm->tables[mb->number].banks[mb->bank];
        *base = tb->base;
        *size = tb->size * tb->width / tm->memories[tb->memory].width;
        break;
    case SOC_SBX_G2XX_COUNTER_BANK_TYPE:
        *base = tm->counterbanks[mb->number].base;
        *size = tm->counterbanks[mb->number].size;
        break;
    case SOC_SBX_G2XX_POLICER_BANK_TYPE:
        *base = tm->policerbanks[mb->number].base;
        *size = tm->policerbanks[mb->number].size;
        break;
    }
}

/* Pack all memory banks based on current sizes */
int soc_sbx_g2xx_memory_banks_pack(int unit);
int soc_sbx_g2xx_memory_banks_pack(int unit)
{
    int s = SOC_E_NONE;
    int i, j, base, size;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_memory_desc_t *md;
    soc_sbx_g2xx_memory_bank_desc_t *mb;

    for (i = 0; !s && i < SOC_SBX_G2XX_MEMORY_MAX_ID; i++) {
        md = &tm->memories[i];
        for (j = 0; !s && j < md->nbanks; j++) {
            mb = &md->banks[j];
            if (j) {
                soc_sbx_g2xx_memory_bank_params_get(&base, &size,
                          &md->banks[j - 1], tm);
            } else {
                base = 0;
                size = 0;
            }
            base = base + size;
            s = soc_sbx_g2xx_memory_bank_base_set(unit, mb, base);
        }
    }

    return s;
}

/* Slide the base of all banks from a starting bank in a memory */
int soc_sbx_g2xx_bank_slide(int unit,
                soc_sbx_g2xx_memory_desc_t *md,
                int mbank, int offset);
int soc_sbx_g2xx_bank_slide(int unit,
                soc_sbx_g2xx_memory_desc_t *md,
                int mbank, int offset)
{
    int s = SOC_E_NONE;
    int i, base, size;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_memory_bank_desc_t *mb;

    for (i = mbank; !s && i < md->nbanks; i++) {
        mb = &md->banks[i];
        soc_sbx_g2xx_memory_bank_params_get(&base, &size, mb, tm);
        s = soc_sbx_g2xx_memory_bank_base_set(unit, mb, base + offset);
    }

    return SOC_E_NONE;
}

/* Realign aligned table banks */
int soc_sbx_g2xx_tables_realign(int unit);
int soc_sbx_g2xx_tables_realign(int unit)
{
    int s, tid, first, i, maxbase, mbank, base, size, offset;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_table_desc_t *td;
    soc_sbx_g2xx_table_bank_t *tb;
    soc_sbx_g2xx_memory_desc_t *md;

    for (tid = tm->alignedlist; tid != -1; tid = td->nextaligned) {
        td = &tm->tables[tid];
        if (td->banks[0].size == 0) continue;
        maxbase = 0;
        first = (td->type == SOC_SBX_G2XX_LPM_TABLE_TYPE
                 || td->type == SOC_SBX_G2XX_EML_TABLE_TYPE);
        for (i = first; i < td->nbanks; i++) {
            tb = &td->banks[i];
            mbank = tb->mbank;
            md = &tm->memories[tb->memory];
            if (mbank > 0) {
                soc_sbx_g2xx_memory_bank_params_get(&base, &size,
                          &md->banks[mbank - 1], tm);
                if (maxbase < base + size) {
                    maxbase = base + size;
                }
            }
        }
        for (i = first; i < td->nbanks; i++) {
            tb = &td->banks[i];
            offset = maxbase - tb->base;
            md = &tm->memories[tb->memory];
            s = soc_sbx_g2xx_bank_slide(unit, md, tb->mbank, offset);
            if (s) {
                return s;
            }
        }
    }

    return SOC_E_NONE;
}

/* Set an entry index range from a table size */
void soc_sbx_g2xx_entry_index_ranges_set(int unit,
                soc_sbx_g2xx_entry_id_t eid);
void soc_sbx_g2xx_entry_index_ranges_set(int unit,
                soc_sbx_g2xx_entry_id_t eid)
{
    int i, j, isize, max;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed = &tm->entries[eid];
    soc_sbx_g2xx_entry_bank_t *eb = &ed->banks[0];
    soc_sbx_g2xx_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2xx_table_bank_t *tb = &td->banks[eb->tablebank];
    
    i = ed->nindexes - 1;
    if (ed->table != SOC_SBX_G2XX_TABLE_MAX_ID
        && ed->type != SOC_SBX_G2XX_EXT_ENTRY_TYPE
        && ed->type != SOC_SBX_G2XX_LPM_ENTRY_TYPE
        && ed->type != SOC_SBX_G2XX_EML_ENTRY_TYPE
        && ed->type != SOC_SBX_G2XX_EM32_ENTRY_TYPE) {

        isize = (tb->size * tb->width / eb->stridebits) - 1;
        for (; 0 <= i; i--) {
            max = isize >> ed->indexes[i].pos;
            if (max) {
                ed->indexes[i].range = max + 1;
                if (i == ed->nindexes - 1) {
                    for (j = 1; 1 << j < max; j++);
                    ed->indexes[i].width = j;
                    ed->indexeswidth =
                        ed->indexes[i].pos + ed->indexes[i].width;
                }
                i--;
                break;
            } else {
                ed->indexes[i].range = 1;
            }
        }
    }
    for (; 0 <= i; i--) {
        ed->indexes[i].range = ed->indexes[i].orange;
    }
}

/* Set the size of a table */
int soc_sbx_g2xx_generic_table_size_set(int unit,
                soc_sbx_g2xx_table_id_t tid, int size, int pack);
int soc_sbx_g2xx_generic_table_size_set(int unit,
                soc_sbx_g2xx_table_id_t tid, int size, int pack)
{
    int s, i, size0;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_table_desc_t *td = &tm->tables[tid];
    soc_sbx_g2xx_table_bank_t *tb;
    soc_sbx_g2xx_entry_desc_t *ed;
    char *e = "";


    for (i = 0; i < td->nbanks; i++) {
        tb = &td->banks[i];
        size0 = (size && !i && td->b0size) ? td->b0size : size;
        tb->size = size0;
        s = soc_sbx_g2xx_ucode_set(unit,
                    soc_sbx_g2xx_sym, 128,
                    size0, e, td->name, i == 0 ? -1 : i, e,
                    "SIZE");
        if (s) {
            return s;
        }
    }

    if (pack) {
        s = soc_sbx_g2xx_memory_banks_pack(unit);
        if (s) {
            return s;
        }
        s = soc_sbx_g2xx_tables_realign(unit);
        if (s) {
            return s;
        }
    }

    for (i = 0; i < SOC_SBX_G2XX_ENTRY_MAX_ID; i++) {
        ed = &tm->entries[i];
        if (ed->table == tid) {
            soc_sbx_g2xx_entry_index_ranges_set(unit, i);
        }
    }

    return SOC_E_NONE;
}

/* Set the size of a counter */
int soc_sbx_g2xx_generic_counter_size_set(int unit,
                int cid, int size, int pack);
int soc_sbx_g2xx_generic_counter_size_set(int unit,
                int cid, int size, int pack)
{
    /* no counters */
    return SOC_E_PARAM;
}

/* Set the size of a policer */
int soc_sbx_g2xx_generic_policer_size_set(int unit,
                int pid, int size, int pack);
int soc_sbx_g2xx_generic_policer_size_set(int unit,
                int pid, int size, int pack)
{
    /* no policers */
    return SOC_E_PARAM;
}

void soc_sbx_g2xx_memory_bank_sort(int size,
                soc_sbx_g2xx_memory_bank_desc_t *mb,
                soc_sbx_g2xx_table_manager_t *tm);
void soc_sbx_g2xx_memory_bank_sort(int size,
                soc_sbx_g2xx_memory_bank_desc_t *mb,
                soc_sbx_g2xx_table_manager_t *tm)
{
    int i, j;
    int basea, sizea, baseb, sizeb;
    int t;

    for (i = 0; i < size; i++) {
        soc_sbx_g2xx_memory_bank_params_get(&basea, &sizea, &mb[i], tm);
        for (j = i + 1; j < size; j++) {
            soc_sbx_g2xx_memory_bank_params_get(&baseb, &sizeb, &mb[j], tm);
            if (baseb < basea) {
                t = mb[i].type;
                mb[i].type = mb[j].type;
                mb[j].type = t;
                t = mb[i].number;
                mb[i].number = mb[j].number;
                mb[j].number = t;
                t = mb[i].bank;
                mb[i].bank = mb[j].bank;
                mb[j].bank = t;
                basea = baseb;
                sizea = sizeb;
            }
        }
    }
}

void soc_sbx_g2xx_memory_banks_init(soc_sbx_g2xx_table_manager_t *tm);
void soc_sbx_g2xx_memory_banks_init(soc_sbx_g2xx_table_manager_t *tm)
{
    int i, j, k;
    int p = 0;
    soc_sbx_g2xx_memory_desc_t *md;
    soc_sbx_g2xx_memory_bank_desc_t *mb;

    for (i = 0; i < SOC_SBX_G2XX_MEMORY_MAX_ID; i++) {
        md = &tm->memories[i];
        md->banks = &tm->memorybanks[p];
        md->nbanks = 0;
        for (j = 0; j < SOC_SBX_G2XX_TABLE_MAX_ID; j++) {
            for (k = 0; k < tm->tables[j].nbanks; k++) {
                if (tm->tables[j].banks[k].memory == i) {
                    tm->memorybanks[p].type =
                        SOC_SBX_G2XX_TABLE_BANK_TYPE;
                    tm->memorybanks[p].number = j;
                    tm->memorybanks[p].bank = k;
                    p++;
                    md->nbanks++;
                }
            }
        }
        for (j = 0; j < SOC_SBX_G2XX_COUNTER_BANKS_MAX; j++) {
            if (tm->counterbanks[j].base >= 0
                && tm->counterbanks[j].memory == i) {
                tm->memorybanks[p].type =
                    SOC_SBX_G2XX_COUNTER_BANK_TYPE;
                tm->memorybanks[p].number = j;
                tm->memorybanks[p].bank = 0;
                p++;
                md->nbanks++;
            }
        }
        for (j = 0; j < SOC_SBX_G2XX_POLICER_BANKS_MAX; j++) {
            if (tm->policerbanks[j].base >= 0
                && tm->policerbanks[j].memory == i) {
                tm->memorybanks[p].type =
                    SOC_SBX_G2XX_POLICER_BANK_TYPE;
                tm->memorybanks[p].number = j;
                tm->memorybanks[p].bank = 0;
                p++;
                md->nbanks++;
            }
        }
    }

    for (i = 0; i < SOC_SBX_G2XX_MEMORY_MAX_ID; i++) {
        md = &tm->memories[i];
        soc_sbx_g2xx_memory_bank_sort(md->nbanks, md->banks, tm);
        for (j = md->nbanks - 1; 0 <= j; j--) {
            mb = &md->banks[j];
            switch (mb->type) {
            case SOC_SBX_G2XX_TABLE_BANK_TYPE:
                tm->tables[mb->number].banks[mb->bank].mbank = j;
                if (tm->tables[mb->number].nextaligned) {
                    mb->nextaligned = md->alignedlist;
                    md->alignedlist = j;
                }
                break;
            case SOC_SBX_G2XX_COUNTER_BANK_TYPE:
                tm->counterbanks[mb->number].mbank = j;
                break;
            case SOC_SBX_G2XX_POLICER_BANK_TYPE:
                tm->policerbanks[mb->number].mbank = j;
                break;
            }
        }
    }
}

/* Find a memory bank member by address */
int soc_sbx_g2xx_memory_bank_find(
                soc_sbx_g2xx_table_manager_t *tm,
                soc_sbx_g2xx_memory_desc_t *md,
                int addr, char **name, int *offset, int *iscnt)
{
    /* no counters */
    return SOC_E_PARAM;
}

void soc_sbx_g2xx_tables_aligned_topo_sort_walk(int unit, int tid);
void soc_sbx_g2xx_tables_aligned_topo_sort_walk(int unit, int tid)
{
    int i, first, ctid;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_table_desc_t *td = &tm->tables[tid];
    soc_sbx_g2xx_table_bank_t *tb;
    soc_sbx_g2xx_memory_desc_t *md;
    soc_sbx_g2xx_memory_bank_desc_t *mb;

    if (td->nextaligned == -2) {
        first = (td->type == SOC_SBX_G2XX_LPM_TABLE_TYPE
                 || td->type == SOC_SBX_G2XX_EML_TABLE_TYPE);
        for (i = first; i < td->nbanks; i++) {
            tb = &td->banks[i];
            md = &tm->memories[tb->memory];
            mb = &md->banks[tb->mbank];
            if (mb->nextaligned != -1) {
                ctid = md->banks[mb->nextaligned].number;
                soc_sbx_g2xx_tables_aligned_topo_sort_walk(unit, ctid);
            }
        }
        td->nextaligned = tm->alignedlist;
        tm->alignedlist = tid;
    }
}

void soc_sbx_g2xx_tables_aligned_topo_sort(int unit);
void soc_sbx_g2xx_tables_aligned_topo_sort(int unit)
{
    int i;

    for (i = 0; i < SOC_SBX_G2XX_TABLE_MAX_ID; i++) {
        soc_sbx_g2xx_tables_aligned_topo_sort_walk(unit, i);
    }
}

/* Generic policer set implementation */
int soc_sbx_g2xx_generic_policer_set(int unit,
                int pid, int policer,
                soc_sbx_g2xx_policer_t *p)
{
    soc_sbx_g2xx_state_t *fe =
       (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_policer_desc_t *pd =
        &tm->policers[pid];
    soc_sbx_g2xx_policer_bank_desc_t *pb =
        &tm->policerbanks[pd->bank];
    sbZfFe2000PmPolicerConfig_t pc;
    uint32 n;
    sbStatus_t s;

    if (policer >= pd->size) {
        return SOC_E_PARAM;
    }
    if (p->mode != SB_FE_2000_PM_PMODE_RFC_2697
        && p->mode != SB_FE_2000_PM_PMODE_RFC_2698
        && p->mode != SB_FE_2000_PM_PMODE_RFC_4115
        && p->mode != SB_FE_2000_PM_PMODE_RFC_MEF) {
        return SOC_E_PARAM;
    }
    if (p->lenshift > 7) {
        return SOC_E_PARAM;
    }

    sbZfFe2000PmPolicerConfig_InitInstance(&pc);
    pc.uRfcMode = p->mode;
    pc.uLenShift = p->lenshift;
    pc.uRate = sbFe2000PmConvertRate(tm->policerbanks[pd->bank].kbps);
    pc.uCBS = p->cbsbytes;
    pc.uCIR = p->cirkbps;
    pc.uEBS = p->ebsbytes;
    pc.uEIR = p->eirkbps;
    pc.bBlindMode = !!p->colorblind;
    pc.bDropOnRed = !!p->dropred;
    pc.bCoupling = !!p->coupling;
    pc.bCBSNoDecrement = !!p->nodebit;
    pc.bEBSNoDecrement = !!p->nodebit;

    n = (uint32) (policer + pb->base + pd->base - tm->policerbase);
    s = sbFe2000PmPolicerDelete(fe->pm, n);
    s = sbFe2000PmPolicerCreate(fe->pm, n, &pc, &n);

    return soc_sbx_translate_status(s);
}

/* Generic policer get implementation */
int soc_sbx_g2xx_generic_policer_get(int unit,
                int pid, int policer,
                soc_sbx_g2xx_policer_t *p)
{
    soc_sbx_g2xx_state_t *fe =
       (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_policer_desc_t *pd =
        &tm->policers[pid];
    soc_sbx_g2xx_policer_bank_desc_t *pb = &tm->policerbanks[pd->bank];
    sbZfFe2000PmPolicerConfig_t pc;
    uint32 n;
    sbStatus_t s;

    if (policer >= pd->size) {
        return SOC_E_PARAM;
    }

    n = (uint32) (policer + pb->base + pd->base - tm->policerbase);
    s = sbFe2000PmPolicerRead(fe->pm, n, &pc);

    if (!s) {
        p->mode = pc.uRfcMode;
        p->lenshift = pc.uLenShift;
        p->cbsbytes = pc.uCBS;
        p->cirkbps = pc.uCIR;
        p->ebsbytes = pc.uEBS;
        p->eirkbps = pc.uEIR;
        p->colorblind = !!pc.bBlindMode;
        p->dropred = !!pc.bDropOnRed;
        p->coupling = !!pc.bCoupling;
        p->nodebit = !!pc.bCBSNoDecrement;
    }
        
    return soc_sbx_translate_status(s);
}

/* Generic policer delete implementation */
int soc_sbx_g2xx_generic_policer_delete(int unit, int pid, int policer)
{
    soc_sbx_g2xx_state_t *fe =
       (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_policer_desc_t *pd =
        &tm->policers[pid];
    soc_sbx_g2xx_policer_bank_desc_t *pb = &tm->policerbanks[pd->bank];
    uint32 n;
    sbStatus_t s;

    if (policer >= pd->size) {
        return SOC_E_PARAM;
    }

    n = (uint32) (policer + pb->base + pd->base - tm->policerbase);
    s = sbFe2000PmPolicerDelete(fe->pm, n);
    return soc_sbx_translate_status(s);
}

/* Generic timer set implementation */
int soc_sbx_g2xx_generic_timer_set(int unit,
                int pid, int timer,
                soc_sbx_g2xx_timer_t *p)
{
    soc_sbx_g2xx_state_t *fe =
       (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_policer_desc_t *pd =
        &tm->policers[pid];
    soc_sbx_g2xx_policer_bank_desc_t *pb =
        &tm->policerbanks[pd->bank];
    sbZfFe2000PmOamTimerConfig_t tc;
    uint32 n;
    sbStatus_t s;

    if (timer >= pd->size) {
        return SOC_E_PARAM;
    }
    if (p->ms > 10 * 60 * 1000) {
        return SOC_E_PARAM;
    }

    sbZfFe2000PmOamTimerConfig_InitInstance(&tc);
    tc.uRate = sbFe2000PmConvertRate(tm->policerbanks[pd->bank].kbps);
    tc.uDeadline = p->ms;
    tc.bStarted = !!p->started;
    tc.bStrict = 0;
    tc.bReset = !!p->ucodereset;
    tc.bInterrupt = !!p->interrupt;

    n = (uint32) (timer + pb->base + pd->base - tm->policerbase);
    s = sbFe2000PmOamTimerDelete(fe->pm, n);
    s = sbFe2000PmOamTimerCreate(fe->pm, n, &tc, &n);

    return soc_sbx_translate_status(s);
}

/* Generic timer get implementation */
int soc_sbx_g2xx_generic_timer_get(int unit,
                int pid, int timer,
                soc_sbx_g2xx_timer_t *p)
{
    soc_sbx_g2xx_state_t *fe =
       (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_policer_desc_t *pd =
        &tm->policers[pid];
    soc_sbx_g2xx_policer_bank_desc_t *pb = &tm->policerbanks[pd->bank];
    sbZfFe2000PmOamTimerConfig_t tc;
    uint32 n;
    sbStatus_t s;

    if (timer >= pd->size) {
        return SOC_E_PARAM;
    }

    n = (uint32) (timer + pb->base + pd->base - tm->policerbase);
    s = sbFe2000PmOamTimerRead(fe->pm, n, &tc);

    if (!s) {
        p->ms = tc.uDeadline;
        p->started = !!tc.bStarted;
        p->ucodereset = !!tc.bReset;
        p->interrupt = !!tc.bInterrupt;
    }
        
    return soc_sbx_translate_status(s);
}

/* Generic timer delete implementation */
int soc_sbx_g2xx_generic_timer_delete(int unit, int pid, int timer)
{
    soc_sbx_g2xx_state_t *fe =
       (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_policer_desc_t *pd =
        &tm->policers[pid];
    soc_sbx_g2xx_policer_bank_desc_t *pb = &tm->policerbanks[pd->bank];
    uint32 n;
    sbStatus_t s;

    if (timer >= pd->size) {
        return SOC_E_PARAM;
    }

    n = (uint32) (timer + pb->base + pd->base - tm->policerbase);
    s = sbFe2000PmOamTimerDelete(fe->pm, n);
    return soc_sbx_translate_status(s);
}

/* Generic sequence set implementation */
int soc_sbx_g2xx_generic_sequence_set(int unit,
                int pid, int sequence,
                soc_sbx_g2xx_sequence_t *p)
{
    soc_sbx_g2xx_state_t *fe =
       (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_policer_desc_t *pd =
        &tm->policers[pid];
    soc_sbx_g2xx_policer_bank_desc_t *pb =
        &tm->policerbanks[pd->bank];
    uint32 n;
    sbStatus_t s;

    if (sequence >= pd->size) {
        return SOC_E_PARAM;
    }

    p = p;
    n = (uint32) (sequence + pb->base + pd->base - tm->policerbase);
    s = sbFe2000PmOamSeqGenDelete(fe->pm, n);
    s = sbFe2000PmOamSeqGenCreate(fe->pm, n, &n);

    return soc_sbx_translate_status(s);
}

/* Generic sequence get implementation */
int soc_sbx_g2xx_generic_sequence_get(int unit,
                int pid, int sequence,
                soc_sbx_g2xx_sequence_t *p)
{
    soc_sbx_g2xx_state_t *fe =
       (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_policer_desc_t *pd =
        &tm->policers[pid];

    if (sequence >= pd->size) {
        return SOC_E_PARAM;
    }

    p->seqnum = 0;
        
    return SOC_E_NONE;
}

/* Generic sequence delete implementation */
int soc_sbx_g2xx_generic_sequence_delete(int unit, int pid, int sequence)
{
    soc_sbx_g2xx_state_t *fe =
       (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_policer_desc_t *pd =
        &tm->policers[pid];
    soc_sbx_g2xx_policer_bank_desc_t *pb = &tm->policerbanks[pd->bank];
    uint32 n;
    sbStatus_t s;

    if (sequence >= pd->size) {
        return SOC_E_PARAM;
    }

    n = (uint32) (sequence + pb->base + pd->base - tm->policerbase);
    s = sbFe2000PmOamSeqGenDelete(fe->pm, n);
    return soc_sbx_translate_status(s);
}

/* Uninitialization function implementation */
int soc_sbx_g2xx_uninit(int unit)
{
    int i;
    int s = SOC_E_NONE;

    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm;

    if (!fe->tableinfo) return s;
    tm = fe->tableinfo;
    if (tm->entrydmabuf) soc_cm_sfree(unit, tm->entrydmabuf);
    if (tm->dmabufmutex) sal_mutex_destroy(tm->dmabufmutex);
    if (tm->memorybanks) sal_free(tm->memorybanks);
    if (tm->memories)    sal_free(tm->memories);
    if (tm->policers)    sal_free(tm->policers);
    if (tm->counters)    sal_free(tm->counters);
    if (tm->entries) {
        for (i = 0; i < SOC_SBX_G2XX_ENTRY_MAX_ID; i++) {
            if (tm->entries[i].fields) {
                sal_free(tm->entries[i].fields);
            }
            if (tm->entries[i].indexes) {
                sal_free(tm->entries[i].indexes);
            }
        }
        sal_free(tm->entries);
    }
    if (tm->tables) {
        sal_free(tm->tables);
    }
    if (tm->globals)     sal_free(tm->globals);
    if (tm->constants)   sal_free(tm->constants);
    sal_free(tm);
    fe->tableinfo = NULL;

    return s;
}

/*
 * Microcode definitions subsystem initializer implementation
 */
int soc_sbx_g2xx_init(int unit)
{
    char *e = "";
    int i, j, pbset, s;
    uint32 v;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm;

    soc_sbx_g2xx_errsym = soc_sbx_g2xx_sym;

    if (fe->tableinfo) {
        return soc_sbx_g2xx_reload(unit);
    }

    tm = UTG_MALLOC(sizeof(soc_sbx_g2xx_table_manager_t));
    if (!tm) {
      return SOC_E_MEMORY;
    }
    sal_memset(tm, 0, sizeof(soc_sbx_g2xx_table_manager_t));
    fe->tableinfo = tm;
    fe->regSet = (sbhandle)unit;

    v = 0x1;
    tm->behost = !*((uint8 *) &v);

    /*
     * Per-constant state initialization
     */
    tm->constants = UTG_MALLOC(sizeof(soc_sbx_g2xx_constant_desc_t)
                           * SOC_SBX_G2XX_CONSTANT_MAX_ID);
    if (!tm->constants) {
      soc_sbx_g2xx_uninit(unit);
      return SOC_E_MEMORY;
    }
    tm->constants[SOC_SBX_G2XX_MIN_FREE_EXCEPTION_ID].name =
        "MIN_FREE_EXCEPTION";
    tm->constants[SOC_SBX_G2XX_EXC_COPY_TO_HOST_ID].name =
        "EXC_COPY_TO_HOST";
    tm->constants[SOC_SBX_G2XX_MAX_FREE_EXCEPTION_ID].name =
        "MAX_FREE_EXCEPTION";
    tm->constants[SOC_SBX_G2XX_HTYPE_ERH_ID].name =
        "HTYPE_ERH";
    tm->constants[SOC_SBX_G2XX_HTYPE_ETYPE_ID].name =
        "HTYPE_ETYPE";
    tm->constants[SOC_SBX_G2XX_HTYPE_ETH_ID].name =
        "HTYPE_ETH";
    tm->constants[SOC_SBX_G2XX_HTYPE_IETH_ID].name =
        "HTYPE_IETH";
    tm->constants[SOC_SBX_G2XX_HTYPE_VTAG_ID].name =
        "HTYPE_VTAG";
    tm->constants[SOC_SBX_G2XX_HTYPE_IPV4_ID].name =
        "HTYPE_IPV4";
    tm->constants[SOC_SBX_G2XX_HTYPE_ELEN_ID].name =
        "HTYPE_ELEN";
    tm->constants[SOC_SBX_G2XX_HTYPE_UNKN_ID].name =
        "HTYPE_UNKN";
    tm->constants[SOC_SBX_G2XX_LSMAC_TABLE_SIZE_ID].name =
        "LSMAC_TABLE_SIZE";

    /*
     * Global value initialization
     */
    tm->globals = UTG_MALLOC(sizeof(soc_sbx_g2xx_memory_desc_t)
                         * SOC_SBX_G2XX_GLOBAL_MAX_ID);
    if (!tm->globals) {
        soc_sbx_g2xx_uninit(unit);
        return SOC_E_MEMORY;
    }
    tm->globals[SOC_SBX_G2XX_TPID0_ID].name =
        "tpid0";
    tm->globals[SOC_SBX_G2XX_TPID1_ID].name =
        "tpid1";
    tm->globals[SOC_SBX_G2XX_TPID2_ID].name =
        "tpid2";
    tm->globals[SOC_SBX_G2XX_NODE_ID].name =
        "node";

    for (i = 0; i < SOC_SBX_G2XX_GLOBAL_MAX_ID; i++) {
        s = soc_sbx_g2xx_ucode_get(unit,
                  soc_sbx_g2xx_sym,
                  128,
                  &tm->globals[i].range,
                  "GLOBAL",
                  tm->globals[i].name,
                  -1,
                  e,
                  "RANGE");
        if (s) {
            soc_sbx_g2xx_uninit(unit);
            return s;
        }
        s = soc_sbx_g2xx_ucode_get(unit,
                  soc_sbx_g2xx_sym,
                  128,
                  &tm->globals[i].value,
                  "GLOBAL",
                  tm->globals[i].name,
                  -1,
                  e,
                  e);
        if (s) {
            soc_sbx_g2xx_uninit(unit);
            return s;
        }
    }

    /*
     * Per-table state initialization
     */
    tm->tables = UTG_MALLOC(sizeof(soc_sbx_g2xx_table_desc_t)
                         * SOC_SBX_G2XX_TABLE_MAX_ID);
    if (!tm->tables) {
        soc_sbx_g2xx_uninit(unit);
        return SOC_E_MEMORY;
    }
    sal_memset(tm->tables, 0, sizeof(soc_sbx_g2xx_table_desc_t)
           * SOC_SBX_G2XX_TABLE_MAX_ID);

    tm->alignedlist = -1;
    tm->tables[SOC_SBX_G2XX_PORTDATA20_TABLE_ID].name =
        "portdata20";
    tm->tables[SOC_SBX_G2XX_PORTDATA25_TABLE_ID].name =
        "portdata25";
    tm->tables[SOC_SBX_G2XX_XT_TABLE_ID].name =
        "xt";

    for (i = 0; i < SOC_SBX_G2XX_TABLE_MAX_ID; i++) {
        s = soc_sbx_g2xx_ucode_get(unit,
                  soc_sbx_g2xx_sym,
                  128,
                  &tm->tables[i].nbanks,
                  e,
                  tm->tables[i].name,
                  -1,
                  e,
                  "TABLE_BANKS");
        if (s) {
            soc_sbx_g2xx_uninit(unit);
            return s;
        }
        s = soc_sbx_g2xx_ucode_get(unit,
                  soc_sbx_g2xx_sym,
                  128,
                  &j,
                  e,
                  tm->tables[i].name,
                  -1,
                  e,
                  "TABLE_ALIGN");
        if (s) {
            soc_sbx_g2xx_uninit(unit);
            return s;
        }
        tm->tables[i].nextaligned = j ? -2 : 0;
        s = soc_sbx_g2xx_ucode_get(unit,
                  soc_sbx_g2xx_sym,
                  128,
                  &tm->tables[i].type,
                  e,
                  tm->tables[i].name,
                  -1,
                  e,
                  "TABLE_TYPE");
        if (s) {
            soc_sbx_g2xx_uninit(unit);
            return s;
        }
        for (j = 0; j < tm->tables[i].nbanks; j++) {
            s = soc_sbx_g2xx_ucode_get(unit,
                      soc_sbx_g2xx_sym,
                      128,
                      &tm->tables[i].banks[j].memory,
                      e,
                      tm->tables[i].name,
                      j == 0 ? -1 : j,
                      e,
                      "MEMORY");
            if (s) {
                soc_sbx_g2xx_uninit(unit);
                return s;
            }
            s = soc_sbx_g2xx_ucode_get(unit,
                      soc_sbx_g2xx_sym,
                      128,
                      &tm->tables[i].banks[j].base,
                      e,
                      tm->tables[i].name,
                      j == 0 ? -1 : j,
                      e,
                      "BASE");
            if (s) {
                soc_sbx_g2xx_uninit(unit);
                return s;
            }
            s = soc_sbx_g2xx_ucode_get(unit,
                      soc_sbx_g2xx_sym,
                      128,
                      &tm->tables[i].banks[j].size,
                      e,
                      tm->tables[i].name,
                      j == 0 ? -1 : j,
                      e,
                      "SIZE");
            if (s) {
                soc_sbx_g2xx_uninit(unit);
                return s;
            }
            s = soc_sbx_g2xx_ucode_get(unit,
                      soc_sbx_g2xx_sym,
                      128,
                      &tm->tables[i].banks[j].width,
                      e,
                      tm->tables[i].name,
                      j == 0 ? -1 : j,
                      e,
                      "TABLE_WIDTH");
            if (s) {
                soc_sbx_g2xx_uninit(unit);
                return s;
            }
        }
    }

    /*
     * Per-entry state initialization
     */
    tm->entries = UTG_MALLOC(sizeof(soc_sbx_g2xx_entry_desc_t)
                         * SOC_SBX_G2XX_ENTRY_MAX_ID);
    if (!tm->entries) {
        soc_sbx_g2xx_uninit(unit);
        return SOC_E_MEMORY;
    }

    /* Zero indexes & entries pointers */
    sal_memset(tm->entries, 0, sizeof(soc_sbx_g2xx_entry_desc_t)
           * SOC_SBX_G2XX_ENTRY_MAX_ID);

    tm->entries[SOC_SBX_G2XX_P2E_ID].name =
        "p2e";
    tm->entries[SOC_SBX_G2XX_P2E_ID].table =
        SOC_SBX_G2XX_TABLE_MAX_ID;
    tm->entries[SOC_SBX_G2XX_P2E_ID].pack =
        (soc_sbx_g2xx_complex_pack_f_t) soc_sbx_g2xx_p2e_pack;
    tm->entries[SOC_SBX_G2XX_P2E_ID].esize =
        sizeof(soc_sbx_g2xx_p2e_t);
    tm->entries[SOC_SBX_G2XX_P2E_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2XX_P2E_ID].nfields = 18;

    tm->entries[SOC_SBX_G2XX_EP2E_ID].name =
        "ep2e";
    tm->entries[SOC_SBX_G2XX_EP2E_ID].table =
        SOC_SBX_G2XX_TABLE_MAX_ID;
    tm->entries[SOC_SBX_G2XX_EP2E_ID].pack =
        (soc_sbx_g2xx_complex_pack_f_t) soc_sbx_g2xx_ep2e_pack;
    tm->entries[SOC_SBX_G2XX_EP2E_ID].esize =
        sizeof(soc_sbx_g2xx_ep2e_t);
    tm->entries[SOC_SBX_G2XX_EP2E_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2XX_EP2E_ID].nfields = 13;

    tm->entries[SOC_SBX_G2XX_P2E20_ID].name =
        "p2e20";
    tm->entries[SOC_SBX_G2XX_P2E20_ID].table =
        SOC_SBX_G2XX_PORTDATA20_TABLE_ID;
    tm->entries[SOC_SBX_G2XX_P2E20_ID].pack =
        (soc_sbx_g2xx_complex_pack_f_t) soc_sbx_g2xx_p2e20_pack;
    tm->entries[SOC_SBX_G2XX_P2E20_ID].esize =
        sizeof(soc_sbx_g2xx_p2e20_t);
    tm->entries[SOC_SBX_G2XX_P2E20_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2XX_P2E20_ID].nfields = 18;

    tm->entries[SOC_SBX_G2XX_EP2E20_ID].name =
        "ep2e20";
    tm->entries[SOC_SBX_G2XX_EP2E20_ID].table =
        SOC_SBX_G2XX_PORTDATA20_TABLE_ID;
    tm->entries[SOC_SBX_G2XX_EP2E20_ID].pack =
        (soc_sbx_g2xx_complex_pack_f_t) soc_sbx_g2xx_ep2e20_pack;
    tm->entries[SOC_SBX_G2XX_EP2E20_ID].esize =
        sizeof(soc_sbx_g2xx_ep2e20_t);
    tm->entries[SOC_SBX_G2XX_EP2E20_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2XX_EP2E20_ID].nfields = 13;

    tm->entries[SOC_SBX_G2XX_P2E25_ID].name =
        "p2e25";
    tm->entries[SOC_SBX_G2XX_P2E25_ID].table =
        SOC_SBX_G2XX_PORTDATA25_TABLE_ID;
    tm->entries[SOC_SBX_G2XX_P2E25_ID].pack =
        (soc_sbx_g2xx_complex_pack_f_t) soc_sbx_g2xx_p2e25_pack;
    tm->entries[SOC_SBX_G2XX_P2E25_ID].esize =
        sizeof(soc_sbx_g2xx_p2e25_t);
    tm->entries[SOC_SBX_G2XX_P2E25_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2XX_P2E25_ID].nfields = 18;

    tm->entries[SOC_SBX_G2XX_EP2E25_ID].name =
        "ep2e25";
    tm->entries[SOC_SBX_G2XX_EP2E25_ID].table =
        SOC_SBX_G2XX_PORTDATA25_TABLE_ID;
    tm->entries[SOC_SBX_G2XX_EP2E25_ID].pack =
        (soc_sbx_g2xx_complex_pack_f_t) soc_sbx_g2xx_ep2e25_pack;
    tm->entries[SOC_SBX_G2XX_EP2E25_ID].esize =
        sizeof(soc_sbx_g2xx_ep2e25_t);
    tm->entries[SOC_SBX_G2XX_EP2E25_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2XX_EP2E25_ID].nfields = 13;

    tm->entries[SOC_SBX_G2XX_TPID_ID].name =
        "tpid";
    tm->entries[SOC_SBX_G2XX_TPID_ID].table =
        SOC_SBX_G2XX_TABLE_MAX_ID;
    tm->entries[SOC_SBX_G2XX_TPID_ID].pack =
        (soc_sbx_g2xx_complex_pack_f_t) soc_sbx_g2xx_tpid_pack;
    tm->entries[SOC_SBX_G2XX_TPID_ID].esize =
        sizeof(soc_sbx_g2xx_tpid_t);
    tm->entries[SOC_SBX_G2XX_TPID_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2XX_TPID_ID].nfields = 1;

    tm->entries[SOC_SBX_G2XX_LSMAC_ID].name =
        "lsmac";
    tm->entries[SOC_SBX_G2XX_LSMAC_ID].table =
        SOC_SBX_G2XX_TABLE_MAX_ID;
    tm->entries[SOC_SBX_G2XX_LSMAC_ID].pack =
        (soc_sbx_g2xx_complex_pack_f_t) soc_sbx_g2xx_lsmac_pack;
    tm->entries[SOC_SBX_G2XX_LSMAC_ID].esize =
        sizeof(soc_sbx_g2xx_lsmac_t);
    tm->entries[SOC_SBX_G2XX_LSMAC_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2XX_LSMAC_ID].nfields = 3;

    tm->entries[SOC_SBX_G2XX_XT_ID].name =
        "xt";
    tm->entries[SOC_SBX_G2XX_XT_ID].table =
        SOC_SBX_G2XX_XT_TABLE_ID;
    tm->entries[SOC_SBX_G2XX_XT_ID].pack =
        (soc_sbx_g2xx_complex_pack_f_t) soc_sbx_g2xx_xt_pack;
    tm->entries[SOC_SBX_G2XX_XT_ID].esize =
        sizeof(soc_sbx_g2xx_xt_t);
    tm->entries[SOC_SBX_G2XX_XT_ID].nindexes = 1;
    tm->entries[SOC_SBX_G2XX_XT_ID].nfields = 7;

    tm->entries[SOC_SBX_G2XX_POLICER_ID].name =
        "policer";
    tm->entries[SOC_SBX_G2XX_POLICER_ID].table =
        SOC_SBX_G2XX_TABLE_MAX_ID;
    tm->entries[SOC_SBX_G2XX_POLICER_ID].pack =
        (soc_sbx_g2xx_complex_pack_f_t) soc_sbx_g2xx_policer_pack;
    tm->entries[SOC_SBX_G2XX_POLICER_ID].esize =
        sizeof(soc_sbx_g2xx_policer_t);
    tm->entries[SOC_SBX_G2XX_POLICER_ID].nindexes = 0;
    tm->entries[SOC_SBX_G2XX_POLICER_ID].nfields = 10;

    tm->entries[SOC_SBX_G2XX_TIMER_ID].name =
        "timer";
    tm->entries[SOC_SBX_G2XX_TIMER_ID].table =
        SOC_SBX_G2XX_TABLE_MAX_ID;
    tm->entries[SOC_SBX_G2XX_TIMER_ID].pack =
        (soc_sbx_g2xx_complex_pack_f_t) soc_sbx_g2xx_timer_pack;
    tm->entries[SOC_SBX_G2XX_TIMER_ID].esize =
        sizeof(soc_sbx_g2xx_timer_t);
    tm->entries[SOC_SBX_G2XX_TIMER_ID].nindexes = 0;
    tm->entries[SOC_SBX_G2XX_TIMER_ID].nfields = 4;

    tm->entries[SOC_SBX_G2XX_SEQUENCE_ID].name =
        "sequence";
    tm->entries[SOC_SBX_G2XX_SEQUENCE_ID].table =
        SOC_SBX_G2XX_TABLE_MAX_ID;
    tm->entries[SOC_SBX_G2XX_SEQUENCE_ID].pack =
        (soc_sbx_g2xx_complex_pack_f_t) soc_sbx_g2xx_sequence_pack;
    tm->entries[SOC_SBX_G2XX_SEQUENCE_ID].esize =
        sizeof(soc_sbx_g2xx_sequence_t);
    tm->entries[SOC_SBX_G2XX_SEQUENCE_ID].nindexes = 0;
    tm->entries[SOC_SBX_G2XX_SEQUENCE_ID].nfields = 1;

    for (i = 0; i < SOC_SBX_G2XX_ENTRY_MAX_ID; i++) {
        s = soc_sbx_g2xx_ucode_get(unit,
                    soc_sbx_g2xx_sym,
                    128,
                    &tm->entries[i].nbanks,
                    e,
                    tm->entries[i].name,
                    -1,
                    e,
                    "BANKS");
        if (s) {
            soc_sbx_g2xx_uninit(unit);
            return s;
        }
        s = soc_sbx_g2xx_ucode_get(unit,
                    soc_sbx_g2xx_sym,
                    128,
                    &tm->entries[i].type,
                    e,
                    tm->entries[i].name,
                    -1,
                    e,
                    "TYPE");
        if (s) {
            soc_sbx_g2xx_uninit(unit);
            return s;
        }
        tm->entries[i].epsize = 0;
        for (j = 0; j < tm->entries[i].nbanks; j++) {
            s = soc_sbx_g2xx_ucode_get(unit,
                        soc_sbx_g2xx_sym,
                        128,
                        &tm->entries[i].banks[j].tablebank,
                        e,
                        tm->entries[i].name,
                        j == 0 ? -1 : j,
                        e,
                        "BANK");
            if (s) {
                soc_sbx_g2xx_uninit(unit);
                return s;
            }
            s = soc_sbx_g2xx_ucode_get(unit,
                        soc_sbx_g2xx_sym,
                        128,
                        &tm->entries[i].banks[j].width,
                        e,
                        tm->entries[i].name,
                        j == 0 ? -1 : j,
                        e,
                        "WIDTH");
            if (s) {
                soc_sbx_g2xx_uninit(unit);
                return s;
            }
            tm->entries[i].epsize += tm->entries[i].banks[j].width;
            s = soc_sbx_g2xx_ucode_get(unit,
                        soc_sbx_g2xx_sym,
                        128,
                        &tm->entries[i].banks[j].stridebits,
                        e,
                        tm->entries[i].name,
                        j == 0 ? -1 : j,
                        e,
                        "STRIDE");
            if (s) {
                soc_sbx_g2xx_uninit(unit);
                return s;
            }
            tm->entries[i].totalwidth +=
                tm->entries[i].banks[j].width;
        }

        /*
         * Per-index state initialization
         */
        if (tm->entries[i].nindexes) {
            tm->entries[i].indexes =
                UTG_MALLOC(sizeof(soc_sbx_g2xx_index_desc_t)
                       * tm->entries[i].nindexes);
            if (!tm->entries[i].indexes) {
                soc_sbx_g2xx_uninit(unit);
                return SOC_E_MEMORY;
            }
            sal_memset(tm->entries[i].indexes, 0, 
              (sizeof(soc_sbx_g2xx_index_desc_t) * tm->entries[i].nindexes));
        }

        switch (i) {
        case SOC_SBX_G2XX_P2E_ID:
            tm->entries[i].indexes[0].name = "port";
            break;
        case SOC_SBX_G2XX_EP2E_ID:
            tm->entries[i].indexes[0].name = "port";
            break;
        case SOC_SBX_G2XX_P2E20_ID:
            tm->entries[i].indexes[0].name = "port";
            break;
        case SOC_SBX_G2XX_EP2E20_ID:
            tm->entries[i].indexes[0].name = "port";
            break;
        case SOC_SBX_G2XX_P2E25_ID:
            tm->entries[i].indexes[0].name = "port";
            break;
        case SOC_SBX_G2XX_EP2E25_ID:
            tm->entries[i].indexes[0].name = "port";
            break;
        case SOC_SBX_G2XX_TPID_ID:
            tm->entries[i].indexes[0].name = "tpidi";
            break;
        case SOC_SBX_G2XX_LSMAC_ID:
            tm->entries[i].indexes[0].name = "lsi";
            break;
        case SOC_SBX_G2XX_XT_ID:
            tm->entries[i].indexes[0].name = "xi";
            break;
        case SOC_SBX_G2XX_POLICER_ID:
            break;
        case SOC_SBX_G2XX_TIMER_ID:
            break;
        case SOC_SBX_G2XX_SEQUENCE_ID:
            break;
        }

        for (j = 0; j < tm->entries[i].nindexes; j++) {
            s = soc_sbx_g2xx_ucode_get(unit,
                        soc_sbx_g2xx_sym,
                        128,
                        &tm->entries[i].indexes[j].pos,
                        e,
                        tm->entries[i].name,
                        -1,
                        tm->entries[i].indexes[j].name,
                        "INDEX_POSITION");
            if (s) {
                soc_sbx_g2xx_uninit(unit);
                return s;
            }
            s = soc_sbx_g2xx_ucode_get(unit,
                        soc_sbx_g2xx_sym,
                        128,
                        &tm->entries[i].indexes[j].orange,
                        e,
                        tm->entries[i].name,
                        -1,
                        tm->entries[i].indexes[j].name,
                        "INDEX_RANGE");
            if (s) {
                soc_sbx_g2xx_uninit(unit);
                return s;
            }
            tm->entries[i].indexes[j].range
                = tm->entries[i].indexes[j].orange;
            s = soc_sbx_g2xx_ucode_get(unit,
                        soc_sbx_g2xx_sym,
                        128,
                        &tm->entries[i].indexes[j].width,
                        e,
                        tm->entries[i].name,
                        -1,
                        tm->entries[i].indexes[j].name,
                        "INDEX_WIDTH");
            if (s) {
                soc_sbx_g2xx_uninit(unit);
                return s;
            }
            s = soc_sbx_g2xx_ucode_get(unit,
                        soc_sbx_g2xx_sym,
                        128,
                        &tm->entries[i].indexes[j].format,
                        e,
                        tm->entries[i].name,
                        -1,
                        tm->entries[i].indexes[j].name,
                        "FORMAT");
            if (s) {
                soc_sbx_g2xx_uninit(unit);
                return s;
            }
        }

        if (tm->entries[i].nindexes) {
            tm->entries[i].indexeswidth =
                ((tm->entries[i].indexes[tm->entries[i].nindexes - 1].pos
                  + tm->entries[i].indexes[tm->entries[i].nindexes - 1].width
                  + 7) / 8) * 8;
        }

        soc_sbx_g2xx_entry_index_ranges_set(unit, i);


        /*
         * Per-field state initialization
         */
        if (tm->entries[i].nfields) {
            tm->entries[i].fields =
                UTG_MALLOC(sizeof(soc_sbx_g2xx_field_desc_t)
                       * tm->entries[i].nfields);
            if (!tm->entries[i].fields) {
                soc_sbx_g2xx_uninit(unit);
                return SOC_E_MEMORY;
            }
        }

        switch (i) {
        case SOC_SBX_G2XX_P2E_ID:
            tm->entries[i].fields[0].name = "port";
            tm->entries[i].fields[1].name = "nativevid";
            tm->entries[i].fields[2].name = "defcfi";
            tm->entries[i].fields[3].name = "defpri";
            tm->entries[i].fields[4].name = "defstrip";
            tm->entries[i].fields[5].name = "pstrip";
            tm->entries[i].fields[6].name = "mim";
            tm->entries[i].fields[7].name = "mask";
            tm->entries[i].fields[8].name = "customer";
            tm->entries[i].fields[9].name = "provider";
            tm->entries[i].fields[10].name = "oamloop";
            tm->entries[i].fields[11].name = "stpid1";
            tm->entries[i].fields[12].name = "twintpid";
            tm->entries[i].fields[13].name = "pbb";
            tm->entries[i].fields[14].name = "ipv4mc";
            tm->entries[i].fields[15].name = "state";
            tm->entries[i].fields[16].name = "pport";
            tm->entries[i].fields[17].name = "htype";
            break;
        case SOC_SBX_G2XX_EP2E_ID:
            tm->entries[i].fields[0].name = "mim";
            tm->entries[i].fields[1].name = "pid";
            tm->entries[i].fields[2].name = "stpid0";
            tm->entries[i].fields[3].name = "stpid1";
            tm->entries[i].fields[4].name = "customer";
            tm->entries[i].fields[5].name = "keeperh";
            tm->entries[i].fields[6].name = "port";
            tm->entries[i].fields[7].name = "mirroridx";
            tm->entries[i].fields[8].name = "mask";
            tm->entries[i].fields[9].name = "oamloop";
            tm->entries[i].fields[10].name = "pbb";
            tm->entries[i].fields[11].name = "state";
            tm->entries[i].fields[12].name = "htype";
            break;
        case SOC_SBX_G2XX_P2E20_ID:
            tm->entries[i].fields[0].name = "port";
            tm->entries[i].fields[1].name = "nativevid";
            tm->entries[i].fields[2].name = "defcfi";
            tm->entries[i].fields[3].name = "defpri";
            tm->entries[i].fields[4].name = "defstrip";
            tm->entries[i].fields[5].name = "pstrip";
            tm->entries[i].fields[6].name = "mim";
            tm->entries[i].fields[7].name = "mask";
            tm->entries[i].fields[8].name = "customer";
            tm->entries[i].fields[9].name = "provider";
            tm->entries[i].fields[10].name = "oamloop";
            tm->entries[i].fields[11].name = "stpid1";
            tm->entries[i].fields[12].name = "twintpid";
            tm->entries[i].fields[13].name = "pbb";
            tm->entries[i].fields[14].name = "ipv4mc";
            tm->entries[i].fields[15].name = "state";
            tm->entries[i].fields[16].name = "pport";
            tm->entries[i].fields[17].name = "htype";
            break;
        case SOC_SBX_G2XX_EP2E20_ID:
            tm->entries[i].fields[0].name = "mim";
            tm->entries[i].fields[1].name = "pid";
            tm->entries[i].fields[2].name = "stpid0";
            tm->entries[i].fields[3].name = "stpid1";
            tm->entries[i].fields[4].name = "customer";
            tm->entries[i].fields[5].name = "keeperh";
            tm->entries[i].fields[6].name = "port";
            tm->entries[i].fields[7].name = "mirroridx";
            tm->entries[i].fields[8].name = "mask";
            tm->entries[i].fields[9].name = "oamloop";
            tm->entries[i].fields[10].name = "pbb";
            tm->entries[i].fields[11].name = "state";
            tm->entries[i].fields[12].name = "htype";
            break;
        case SOC_SBX_G2XX_P2E25_ID:
            tm->entries[i].fields[0].name = "port";
            tm->entries[i].fields[1].name = "nativevid";
            tm->entries[i].fields[2].name = "defcfi";
            tm->entries[i].fields[3].name = "defpri";
            tm->entries[i].fields[4].name = "defstrip";
            tm->entries[i].fields[5].name = "pstrip";
            tm->entries[i].fields[6].name = "mim";
            tm->entries[i].fields[7].name = "mask";
            tm->entries[i].fields[8].name = "customer";
            tm->entries[i].fields[9].name = "provider";
            tm->entries[i].fields[10].name = "oamloop";
            tm->entries[i].fields[11].name = "stpid1";
            tm->entries[i].fields[12].name = "twintpid";
            tm->entries[i].fields[13].name = "pbb";
            tm->entries[i].fields[14].name = "ipv4mc";
            tm->entries[i].fields[15].name = "state";
            tm->entries[i].fields[16].name = "pport";
            tm->entries[i].fields[17].name = "htype";
            break;
        case SOC_SBX_G2XX_EP2E25_ID:
            tm->entries[i].fields[0].name = "mim";
            tm->entries[i].fields[1].name = "pid";
            tm->entries[i].fields[2].name = "stpid0";
            tm->entries[i].fields[3].name = "stpid1";
            tm->entries[i].fields[4].name = "customer";
            tm->entries[i].fields[5].name = "keeperh";
            tm->entries[i].fields[6].name = "port";
            tm->entries[i].fields[7].name = "mirroridx";
            tm->entries[i].fields[8].name = "mask";
            tm->entries[i].fields[9].name = "oamloop";
            tm->entries[i].fields[10].name = "pbb";
            tm->entries[i].fields[11].name = "state";
            tm->entries[i].fields[12].name = "htype";
            break;
        case SOC_SBX_G2XX_TPID_ID:
            tm->entries[i].fields[0].name = "tpid";
            break;
        case SOC_SBX_G2XX_LSMAC_ID:
            tm->entries[i].fields[0].name = "port";
            tm->entries[i].fields[1].name = "useport";
            tm->entries[i].fields[2].name = "mac";
            break;
        case SOC_SBX_G2XX_XT_ID:
            tm->entries[i].fields[0].name = "forward";
            tm->entries[i].fields[1].name = "dp";
            tm->entries[i].fields[2].name = "qid";
            tm->entries[i].fields[3].name = "trunc";
            tm->entries[i].fields[4].name = "learn";
            tm->entries[i].fields[5].name = "ppspolice";
            tm->entries[i].fields[6].name = "policer";
            break;
        case SOC_SBX_G2XX_POLICER_ID:
            tm->entries[i].fields[0].name = "cbsbytes";
            tm->entries[i].fields[1].name = "cirkbps";
            tm->entries[i].fields[2].name = "ebsbytes";
            tm->entries[i].fields[3].name = "eirkbps";
            tm->entries[i].fields[4].name = "mode";
            tm->entries[i].fields[5].name = "lenshift";
            tm->entries[i].fields[6].name = "colorblind";
            tm->entries[i].fields[7].name = "dropred";
            tm->entries[i].fields[8].name = "coupling";
            tm->entries[i].fields[9].name = "nodebit";
            break;
        case SOC_SBX_G2XX_TIMER_ID:
            tm->entries[i].fields[0].name = "ms";
            tm->entries[i].fields[1].name = "started";
            tm->entries[i].fields[2].name = "ucodereset";
            tm->entries[i].fields[3].name = "interrupt";
            break;
        case SOC_SBX_G2XX_SEQUENCE_ID:
            tm->entries[i].fields[0].name = "seqnum";
            break;
        }

        for (j = 0; j < tm->entries[i].nfields; j++) {
            s = soc_sbx_g2xx_ucode_get(unit,
                        soc_sbx_g2xx_sym,
                        128,
                        &tm->entries[i].fields[j].pos,
                        e,
                        tm->entries[i].name,
                        -1,
                        tm->entries[i].fields[j].name,
                        "POSITION");
            if (s) {
                soc_sbx_g2xx_uninit(unit);
                return s;
            }
            s = soc_sbx_g2xx_ucode_get(unit,
                        soc_sbx_g2xx_sym,
                        128,
                        &tm->entries[i].fields[j].range,
                        e,
                        tm->entries[i].name,
                        -1,
                        tm->entries[i].fields[j].name,
                        "RANGE");
            if (s) {
                soc_sbx_g2xx_uninit(unit);
                return s;
            }
            s = soc_sbx_g2xx_ucode_get(unit,
                        soc_sbx_g2xx_sym,
                        128,
                        &tm->entries[i].fields[j].width,
                        e,
                        tm->entries[i].name,
                        -1,
                        tm->entries[i].fields[j].name,
                        "WIDTH");
            if (s) {
                soc_sbx_g2xx_uninit(unit);
                return s;
            }
        }
    }

    /*
     * Per-counter state initialization
     */
    for (i = 0; i < SOC_SBX_G2XX_COUNTER_BANKS_MAX; i++) {
        tm->counterbanks[i].base = -1;
    }
    tm->counters = UTG_MALLOC(sizeof(soc_sbx_g2xx_counter_desc_t)
                         * SOC_SBX_G2XX_COUNTER_MAX_ID);
    if (!tm->counters) {
        soc_sbx_g2xx_uninit(unit);
        return SOC_E_MEMORY;
    }


    /*
     * Per-policer state initialization
     */
    for (i = 0; i < SOC_SBX_G2XX_POLICER_BANKS_MAX; i++) {
        tm->policerbanks[i].base = -1;
    }
    tm->policers = UTG_MALLOC(sizeof(soc_sbx_g2xx_policer_desc_t)
                         * SOC_SBX_G2XX_POLICER_MAX_ID);
    if (!tm->policers) {
        soc_sbx_g2xx_uninit(unit);
        return SOC_E_MEMORY;
    }

    pbset = 0;

    /*
     * Per-memory state initialization
     */
    tm->memories = UTG_MALLOC(sizeof(soc_sbx_g2xx_memory_desc_t)
                              * SOC_SBX_G2XX_MEMORY_MAX_ID);
    if (!tm->memories) {
        soc_sbx_g2xx_uninit(unit);
        return SOC_E_MEMORY;
    }

    tm->memories[SOC_SBX_G2XX_MM0_NAR0_ID]
        .name = "mm0_nar0";
    tm->memories[SOC_SBX_G2XX_MM0_NAR0_ID]
        .dma = 1;
    tm->memories[SOC_SBX_G2XX_MM0_NAR0_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G2XX_MM0_NAR0_ID].reg
        = SAND_HAL_FE2000_REG_OFFSET(fe->regSet,
              MM0_NARROW_PORT0_MEM_ACC_CTRL);
    tm->memories[SOC_SBX_G2XX_MM0_NAR0_ID].alignedlist = -1;

    tm->memories[SOC_SBX_G2XX_MM0_NAR1_ID]
        .name = "mm0_nar1";
    tm->memories[SOC_SBX_G2XX_MM0_NAR1_ID]
        .dma = 1;
    tm->memories[SOC_SBX_G2XX_MM0_NAR1_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G2XX_MM0_NAR1_ID].reg
        = SAND_HAL_FE2000_REG_OFFSET(fe->regSet,
              MM0_NARROW_PORT1_MEM_ACC_CTRL);
    tm->memories[SOC_SBX_G2XX_MM0_NAR1_ID].alignedlist = -1;

    tm->memories[SOC_SBX_G2XX_MM0_WIDE_ID]
        .name = "mm0_wide";
    tm->memories[SOC_SBX_G2XX_MM0_WIDE_ID]
        .dma = 1;
    tm->memories[SOC_SBX_G2XX_MM0_WIDE_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G2XX_MM0_WIDE_ID].reg
        = SAND_HAL_FE2000_REG_OFFSET(fe->regSet,
              MM0_WIDE_PORT_MEM_ACC_CTRL);
    tm->memories[SOC_SBX_G2XX_MM0_WIDE_ID].alignedlist = -1;

    tm->memories[SOC_SBX_G2XX_MM0_INT0_ID]
        .name = "mm0_int0";
    tm->memories[SOC_SBX_G2XX_MM0_INT0_ID]
        .dma = 1;
    tm->memories[SOC_SBX_G2XX_MM0_INT0_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G2XX_MM0_INT0_ID].reg
        = SAND_HAL_FE2000_REG_OFFSET(fe->regSet,
              MM0_INT0_MEM_ACC_CTRL);
    tm->memories[SOC_SBX_G2XX_MM0_INT0_ID].alignedlist = -1;

    tm->memories[SOC_SBX_G2XX_MM0_INT1_ID]
        .name = "mm0_int1";
    tm->memories[SOC_SBX_G2XX_MM0_INT1_ID]
        .dma = 1;
    tm->memories[SOC_SBX_G2XX_MM0_INT1_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G2XX_MM0_INT1_ID].reg
        = SAND_HAL_FE2000_REG_OFFSET(fe->regSet,
              MM0_INT1_MEM_ACC_CTRL);
    tm->memories[SOC_SBX_G2XX_MM0_INT1_ID].alignedlist = -1;

    tm->memories[SOC_SBX_G2XX_MM1_NAR0_ID]
        .name = "mm1_nar0";
    tm->memories[SOC_SBX_G2XX_MM1_NAR0_ID]
        .dma = 1;
    tm->memories[SOC_SBX_G2XX_MM1_NAR0_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G2XX_MM1_NAR0_ID].reg
        = SAND_HAL_FE2000_REG_OFFSET(fe->regSet,
              MM1_NARROW_PORT0_MEM_ACC_CTRL);
    tm->memories[SOC_SBX_G2XX_MM1_NAR0_ID].alignedlist = -1;

    tm->memories[SOC_SBX_G2XX_MM1_NAR1_ID]
        .name = "mm1_nar1";
    tm->memories[SOC_SBX_G2XX_MM1_NAR1_ID]
        .dma = 1;
    tm->memories[SOC_SBX_G2XX_MM1_NAR1_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G2XX_MM1_NAR1_ID].reg
        = SAND_HAL_FE2000_REG_OFFSET(fe->regSet,
              MM1_NARROW_PORT1_MEM_ACC_CTRL);
    tm->memories[SOC_SBX_G2XX_MM1_NAR1_ID].alignedlist = -1;

    tm->memories[SOC_SBX_G2XX_MM1_WIDE_ID]
        .name = "mm1_wide";
    tm->memories[SOC_SBX_G2XX_MM1_WIDE_ID]
        .dma = 1;
    tm->memories[SOC_SBX_G2XX_MM1_WIDE_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G2XX_MM1_WIDE_ID].reg
        = SAND_HAL_FE2000_REG_OFFSET(fe->regSet,
              MM1_WIDE_PORT_MEM_ACC_CTRL);
    tm->memories[SOC_SBX_G2XX_MM1_WIDE_ID].alignedlist = -1;

    tm->memories[SOC_SBX_G2XX_MM1_INT0_ID]
        .name = "mm1_int0";
    tm->memories[SOC_SBX_G2XX_MM1_INT0_ID]
        .dma = 1;
    tm->memories[SOC_SBX_G2XX_MM1_INT0_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G2XX_MM1_INT0_ID].reg
        = SAND_HAL_FE2000_REG_OFFSET(fe->regSet,
              MM1_INT0_MEM_ACC_CTRL);
    tm->memories[SOC_SBX_G2XX_MM1_INT0_ID].alignedlist = -1;

    tm->memories[SOC_SBX_G2XX_MM1_INT1_ID]
        .name = "mm1_int1";
    tm->memories[SOC_SBX_G2XX_MM1_INT1_ID]
        .dma = 1;
    tm->memories[SOC_SBX_G2XX_MM1_INT1_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G2XX_MM1_INT1_ID].reg
        = SAND_HAL_FE2000_REG_OFFSET(fe->regSet,
              MM1_INT1_MEM_ACC_CTRL);
    tm->memories[SOC_SBX_G2XX_MM1_INT1_ID].alignedlist = -1;

    tm->memories[SOC_SBX_G2XX_RC0_RR_ID]
        .name = "rc0_rr";
    tm->memories[SOC_SBX_G2XX_RC0_RR_ID]
        .dma = 0;
    tm->memories[SOC_SBX_G2XX_RC0_RR_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G2XX_RC0_RR_ID].reg
        = SAND_HAL_FE2000_REG_OFFSET(fe->regSet,
              RC0_RR_MEM_ACC_CTRL);
    tm->memories[SOC_SBX_G2XX_RC0_RR_ID].alignedlist = -1;

    tm->memories[SOC_SBX_G2XX_RC1_RR_ID]
        .name = "rc1_rr";
    tm->memories[SOC_SBX_G2XX_RC1_RR_ID]
        .dma = 0;
    tm->memories[SOC_SBX_G2XX_RC1_RR_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G2XX_RC1_RR_ID].reg
        = SAND_HAL_FE2000_REG_OFFSET(fe->regSet,
              RC1_RR_MEM_ACC_CTRL);
    tm->memories[SOC_SBX_G2XX_RC1_RR_ID].alignedlist = -1;

    tm->memories[SOC_SBX_G2XX_RXPORTDATA_ID]
        .name = "rxportdata";
    tm->memories[SOC_SBX_G2XX_RXPORTDATA_ID]
        .dma = 0;
    tm->memories[SOC_SBX_G2XX_RXPORTDATA_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G2XX_RXPORTDATA_ID].reg
        = SAND_HAL_FE2000_REG_OFFSET(fe->regSet,
              PP_RX_PORT_DATA_MEM_ACC_CTRL);
    tm->memories[SOC_SBX_G2XX_RXPORTDATA_ID].alignedlist = -1;

    tm->memories[SOC_SBX_G2XX_INITIALQSTATE20_ID]
        .name = "initialqstate20";
    tm->memories[SOC_SBX_G2XX_INITIALQSTATE20_ID]
        .dma = 0;
    tm->memories[SOC_SBX_G2XX_INITIALQSTATE20_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G2XX_INITIALQSTATE20_ID].reg
        = SAND_HAL_FE2000_REG_OFFSET(fe->regSet,
              PP_INITIAL_QUEUE_STATE_MEM_ACC_CTRL);
    tm->memories[SOC_SBX_G2XX_INITIALQSTATE20_ID].alignedlist = -1;

    tm->memories[SOC_SBX_G2XX_INITIALQSTATE25_ID]
        .name = "initialqstate25";
    tm->memories[SOC_SBX_G2XX_INITIALQSTATE25_ID]
        .dma = 0;
    tm->memories[SOC_SBX_G2XX_INITIALQSTATE25_ID]
        .descending = 1;
    tm->memories[SOC_SBX_G2XX_INITIALQSTATE25_ID].reg
        = SAND_HAL_FE2000_REG_OFFSET(fe->regSet,
              PP_INITIAL_QUEUE_STATE_MEM_ACC_CTRL);
    tm->memories[SOC_SBX_G2XX_INITIALQSTATE25_ID].alignedlist = -1;

    for (i = 0; i < SOC_SBX_G2XX_MEMORY_MAX_ID; i++) {
        s = soc_sbx_g2xx_ucode_get(unit,
                  soc_sbx_g2xx_sym,
                  128,
                  &tm->memories[i].width,
                  e,
                  tm->memories[i].name, 
                  -1,
                  e,
                  "WIDTH");
        if (s) {
            soc_sbx_g2xx_uninit(unit);
            return s;
        }
        s = soc_sbx_g2xx_ucode_get(unit,
                  soc_sbx_g2xx_sym,
                  128,
                  &tm->memories[i].size,
                  e,
                  tm->memories[i].name, 
                  -1,
                  e,
                  "SIZE");
        if (s) {
            soc_sbx_g2xx_uninit(unit);
            return s;
        }
    }

    j = 0;
    for (i = 0; i < SOC_SBX_G2XX_COUNTER_BANKS_MAX; i++){
        if (tm->counterbanks[i].base > 0) j++;
    }
    for (i = 0; i < SOC_SBX_G2XX_POLICER_BANKS_MAX; i++){
        if (tm->policerbanks[i].base > 0) j++;
    }
    j = SOC_SBX_G2XX_COUNTER_BANKS_MAX + SOC_SBX_G2XX_POLICER_BANKS_MAX;
    for (i = 0; i < SOC_SBX_G2XX_TABLE_MAX_ID; i++){
        j += tm->tables[i].nbanks;
    }

    tm->memorybanks = UTG_MALLOC(sizeof(soc_sbx_g2xx_memory_bank_desc_t) * j);
    if (!tm->memorybanks) {
        soc_sbx_g2xx_uninit(unit);
        return SOC_E_MEMORY;
    }

    soc_sbx_g2xx_memory_banks_init(tm);
    soc_sbx_g2xx_tables_aligned_topo_sort(unit);

    tm->bufsize = 1024;
    tm->entrydmabuf = soc_cm_salloc(unit, tm->bufsize * sizeof(uint32),
                             "entry dma");
    if (!tm->entrydmabuf) {
        return SOC_E_MEMORY;
    }
    tm->entrydmabufhba = soc_cm_l2p(unit, tm->entrydmabuf);
    tm->entrydmaop.dmaHandle.handle = INT_TO_PTR(unit);

    tm->dmabufmutex = sal_mutex_create("dma mutex");
    if (!tm->dmabufmutex) {
        return SOC_E_RESOURCE;
    }

    return SOC_E_NONE;
}

/*
 * Restore microcode push-down parameters
 */
int soc_sbx_g2xx_reload(int unit)
{
    int i, j, base, size;
    int s = SOC_E_NONE;
    soc_sbx_g2xx_state_t *fe =
      (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_memory_desc_t *md;
    soc_sbx_g2xx_memory_bank_desc_t *mb;
    char *e = "";

    for (i = 0; s == SOC_E_NONE && i < SOC_SBX_G2XX_GLOBAL_MAX_ID; i++) {
        s = soc_sbx_g2xx_ucode_set(unit, 
                    soc_sbx_g2xx_sym,
                    128,
                    tm->globals[i].value,
                    "GLOBAL", tm->globals[i].name, -1, e, e);
    }

    for (i = 0; s == SOC_E_NONE && i < SOC_SBX_G2XX_MEMORY_MAX_ID; i++) {
        md = &tm->memories[i];
        for (j = 0; s == SOC_E_NONE && j < md->nbanks; j++) {
            mb = &md->banks[j];
            soc_sbx_g2xx_memory_bank_params_get(&base, &size, mb, tm);
            switch (mb->type) {
            case SOC_SBX_G2XX_TABLE_BANK_TYPE:
                s = soc_sbx_g2xx_table_bank_base_set(unit,
                              mb->number, mb->bank, base);
                break;
            case SOC_SBX_G2XX_COUNTER_BANK_TYPE:
                s = soc_sbx_g2xx_counter_bank_base_set(unit,
                              mb->number, base);
                break;
            case SOC_SBX_G2XX_POLICER_BANK_TYPE:
                s = soc_sbx_g2xx_policer_bank_base_set(unit,
                              mb->number, base);
                break;
            }
        }
    }

    for (i = 0; s == SOC_E_NONE && i < SOC_SBX_G2XX_TABLE_MAX_ID; i++) {
        s = soc_sbx_g2xx_generic_table_size_set(unit, i,
                      tm->tables[i].banks[tm->tables[i].nbanks - 1].size, 0);
    }
    return s;
}

/*
 * Microcode subsystem recovery implementation
 */
int soc_sbx_g2xx_recover(int unit)
{
    char *e = "";
    int i, s;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;

    /*
     * Global value recovery
     */
    for (i = 0; i < SOC_SBX_G2XX_GLOBAL_MAX_ID; i++) {
        s = soc_sbx_g2xx_ucode_get(unit,
                  soc_sbx_g2xx_sym,
                  128,
                  &tm->globals[i].value,
                  "GLOBAL",
                  tm->globals[i].name,
                  -1,
                  e,
                  e);
        if (s) {
            return s;
        }
    }
    
    return SOC_E_NONE;
}

/*
 * Memory accessor implementation
 */
int soc_sbx_g2xx_memory_params_get(int unit, int mid,
                soc_sbx_g2xx_memory_params_t *mp)
{
    soc_sbx_g2xx_state_t *fe =
      (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_memory_desc_t *md;

    if (mid > SOC_SBX_G2XX_MEMORY_MAX_ID) {
        return SOC_E_PARAM;
    }
    md = &tm->memories[mid];
    if (!md->dma) {
        return SOC_E_PARAM;
    }
    
    mp->width = md->width;
    mp->size = md->size;

    return SOC_E_NONE;
}

int soc_sbx_g2xx_memory_size_set(int unit, int mid, int size)

{
    soc_sbx_g2xx_state_t *fe =
      (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_memory_desc_t *md;

    if (mid > SOC_SBX_G2XX_MEMORY_MAX_ID) {
        return SOC_E_PARAM;
    }
    md = &tm->memories[mid];
    if (!md->dma) {
        return SOC_E_PARAM;
    }
    
    md->size = size;

    return SOC_E_NONE;
}

/*
 * Shared constant accessors implementation
 */

int soc_sbx_g2xx_min_free_exception_get(int unit, uint32 *vp)
{
    char *s = "MIN_FREE_EXCEPTION";
    soc_sbx_g2xx_errsym = s;
    return soc_sbx_g2xx_constant_get(unit, s, vp);
}

int soc_sbx_g2xx_exc_copy_to_host_get(int unit, uint32 *vp)
{
    char *s = "EXC_COPY_TO_HOST";
    soc_sbx_g2xx_errsym = s;
    return soc_sbx_g2xx_constant_get(unit, s, vp);
}

int soc_sbx_g2xx_max_free_exception_get(int unit, uint32 *vp)
{
    char *s = "MAX_FREE_EXCEPTION";
    soc_sbx_g2xx_errsym = s;
    return soc_sbx_g2xx_constant_get(unit, s, vp);
}

int soc_sbx_g2xx_htype_erh_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_ERH";
    soc_sbx_g2xx_errsym = s;
    return soc_sbx_g2xx_constant_get(unit, s, vp);
}

int soc_sbx_g2xx_htype_etype_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_ETYPE";
    soc_sbx_g2xx_errsym = s;
    return soc_sbx_g2xx_constant_get(unit, s, vp);
}

int soc_sbx_g2xx_htype_eth_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_ETH";
    soc_sbx_g2xx_errsym = s;
    return soc_sbx_g2xx_constant_get(unit, s, vp);
}

int soc_sbx_g2xx_htype_ieth_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_IETH";
    soc_sbx_g2xx_errsym = s;
    return soc_sbx_g2xx_constant_get(unit, s, vp);
}

int soc_sbx_g2xx_htype_vtag_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_VTAG";
    soc_sbx_g2xx_errsym = s;
    return soc_sbx_g2xx_constant_get(unit, s, vp);
}

int soc_sbx_g2xx_htype_ipv4_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_IPV4";
    soc_sbx_g2xx_errsym = s;
    return soc_sbx_g2xx_constant_get(unit, s, vp);
}

int soc_sbx_g2xx_htype_elen_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_ELEN";
    soc_sbx_g2xx_errsym = s;
    return soc_sbx_g2xx_constant_get(unit, s, vp);
}

int soc_sbx_g2xx_htype_unkn_get(int unit, uint32 *vp)
{
    char *s = "HTYPE_UNKN";
    soc_sbx_g2xx_errsym = s;
    return soc_sbx_g2xx_constant_get(unit, s, vp);
}

int soc_sbx_g2xx_lsmac_table_size_get(int unit, uint32 *vp)
{
    char *s = "LSMAC_TABLE_SIZE";
    soc_sbx_g2xx_errsym = s;
    return soc_sbx_g2xx_constant_get(unit, s, vp);
}

/*
 * Global value accessor implementation
 */

int soc_sbx_g2xx_tpid0_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_TPID0";
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2XX_TPID0_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2xx_errsym = sym;
    s = soc_sbx_g2xx_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2XX_TPID0_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2xx_tpid0_get(int unit, uint32 *vp)
{
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2XX_TPID0_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2xx_tpid1_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_TPID1";
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2XX_TPID1_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2xx_errsym = sym;
    s = soc_sbx_g2xx_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2XX_TPID1_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2xx_tpid1_get(int unit, uint32 *vp)
{
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2XX_TPID1_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2xx_tpid2_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_TPID2";
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2XX_TPID2_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2xx_errsym = sym;
    s = soc_sbx_g2xx_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2XX_TPID2_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2xx_tpid2_get(int unit, uint32 *vp)
{
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2XX_TPID2_ID].value;

    return SOC_E_NONE;
}

int soc_sbx_g2xx_node_set(int unit, uint32 v)
{
    int s;
    char *sym = "GLOBAL_NODE";
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    int r = tm->globals[SOC_SBX_G2XX_NODE_ID].range;

    if (0 < r && ((uint32) r) <= v) {
        return SOC_E_PARAM;
    }
    soc_sbx_g2xx_errsym = sym;
    s = soc_sbx_g2xx_global_set(unit, sym, v);
    if (s) {
        return s;
    }
    tm->globals[SOC_SBX_G2XX_NODE_ID].value = v;

    return SOC_E_NONE;
}

int soc_sbx_g2xx_node_get(int unit, uint32 *vp)
{
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    *vp = tm->globals[SOC_SBX_G2XX_NODE_ID].value;

    return SOC_E_NONE;
}

/*
 * Table state accessor implementations
 */

/* get table bank parameters for portdata20 */
int soc_sbx_g2xx_portdata20_bank_params_get(int unit, int bank,
                soc_sbx_g2xx_table_bank_params_t *p)
{
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_table_desc_t *td = &tm->tables[SOC_SBX_G2XX_PORTDATA20_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for portdata20 */
int soc_sbx_g2xx_portdata20_table_size_get(int unit)
{
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_table_desc_t *td = &tm->tables[SOC_SBX_G2XX_PORTDATA20_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for portdata20 */
int soc_sbx_g2xx_portdata20_table_size_set(int unit, int size)
{
    return soc_sbx_g2xx_generic_table_size_set(unit,
                     SOC_SBX_G2XX_PORTDATA20_TABLE_ID, size, 1);
}

/* get table bank parameters for portdata25 */
int soc_sbx_g2xx_portdata25_bank_params_get(int unit, int bank,
                soc_sbx_g2xx_table_bank_params_t *p)
{
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_table_desc_t *td = &tm->tables[SOC_SBX_G2XX_PORTDATA25_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for portdata25 */
int soc_sbx_g2xx_portdata25_table_size_get(int unit)
{
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_table_desc_t *td = &tm->tables[SOC_SBX_G2XX_PORTDATA25_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for portdata25 */
int soc_sbx_g2xx_portdata25_table_size_set(int unit, int size)
{
    return soc_sbx_g2xx_generic_table_size_set(unit,
                     SOC_SBX_G2XX_PORTDATA25_TABLE_ID, size, 1);
}

/* get table bank parameters for xt */
int soc_sbx_g2xx_xt_bank_params_get(int unit, int bank,
                soc_sbx_g2xx_table_bank_params_t *p)
{
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_table_desc_t *td = &tm->tables[SOC_SBX_G2XX_XT_TABLE_ID];

    if (bank >= td->nbanks) {
        return SOC_E_NOT_FOUND;
    }

    p->base = td->banks[bank].base;
    p->size = td->banks[bank].size;
    p->memory = td->banks[bank].memory;

    return SOC_E_NONE;
}

/* get table size for xt */
int soc_sbx_g2xx_xt_table_size_get(int unit)
{
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_table_desc_t *td = &tm->tables[SOC_SBX_G2XX_XT_TABLE_ID];

    return td->banks[td->nbanks - 1].size;
}

/* set table size for xt */
int soc_sbx_g2xx_xt_table_size_set(int unit, int size)
{
    return soc_sbx_g2xx_generic_table_size_set(unit,
                     SOC_SBX_G2XX_XT_TABLE_ID, size, 1);
}

/*
 * Entry accessor implementation
 */

/*
 * Entry accessor implementations for p2e
 */

void soc_sbx_g2xx_p2e_t_init(
    soc_sbx_g2xx_p2e_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2xx_p2e_t));
    e->defstrip = 0x1;
}

/* entry size function for p2e */
int soc_sbx_g2xx_p2e_size(int unit)
{
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_P2E_ID];
    soc_sbx_g2xx_entry_bank_t *eb = &ed->banks[0];

    return (eb->width + (eb->stridebits - 1)) / eb->stridebits;
}

/* entry pack accessor implementation for p2e */
int soc_sbx_g2xx_p2e_pack(int unit,
    soc_sbx_g2xx_p2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_P2E_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->port; break;
        case 1: p = (uint8 *) &e->nativevid; break;
        case 2: p = (uint8 *) &e->defcfi; break;
        case 3: p = (uint8 *) &e->defpri; break;
        case 4: p = (uint8 *) &e->defstrip; break;
        case 5: p = (uint8 *) &e->pstrip; break;
        case 6: p = (uint8 *) &e->mim; break;
        case 7: p = (uint8 *) e->mask; break;
        case 8: p = (uint8 *) &e->customer; break;
        case 9: p = (uint8 *) &e->provider; break;
        case 10: p = (uint8 *) &e->oamloop; break;
        case 11: p = (uint8 *) &e->stpid1; break;
        case 12: p = (uint8 *) &e->twintpid; break;
        case 13: p = (uint8 *) &e->pbb; break;
        case 14: p = (uint8 *) &e->ipv4mc; break;
        case 15: p = (uint8 *) &e->state; break;
        case 16: p = (uint8 *) &e->pport; break;
        case 17: p = (uint8 *) &e->htype; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2xx_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for p2e */
int soc_sbx_g2xx_p2e_unpack(int unit,
                soc_sbx_g2xx_p2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_P2E_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->port; break;
        case 1: p = (uint8 *) &e->nativevid; break;
        case 2: p = (uint8 *) &e->defcfi; break;
        case 3: p = (uint8 *) &e->defpri; break;
        case 4: p = (uint8 *) &e->defstrip; break;
        case 5: p = (uint8 *) &e->pstrip; break;
        case 6: p = (uint8 *) &e->mim; break;
        case 7: p = (uint8 *) e->mask; break;
        case 8: p = (uint8 *) &e->customer; break;
        case 9: p = (uint8 *) &e->provider; break;
        case 10: p = (uint8 *) &e->oamloop; break;
        case 11: p = (uint8 *) &e->stpid1; break;
        case 12: p = (uint8 *) &e->twintpid; break;
        case 13: p = (uint8 *) &e->pbb; break;
        case 14: p = (uint8 *) &e->ipv4mc; break;
        case 15: p = (uint8 *) &e->state; break;
        case 16: p = (uint8 *) &e->pport; break;
        case 17: p = (uint8 *) &e->htype; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2xx_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for p2e */
int soc_sbx_g2xx_p2e_index_check(int unit,
                int *vindex,
                int iport)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_P2E_ID];
    soc_sbx_g2xx_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iport; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2xx_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2XX_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2XX_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2xx_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for p2e */
int soc_sbx_g2xx_p2e_entry_check(int unit,
                soc_sbx_g2xx_p2e_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_P2E_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->port; break;
        case 1: ev = e->nativevid; break;
        case 2: ev = e->defcfi; break;
        case 3: ev = e->defpri; break;
        case 4: ev = e->defstrip; break;
        case 5: ev = e->pstrip; break;
        case 6: ev = e->mim; break;
        case 7: ev = e->mask[0]; break;
        case 8: ev = e->customer; break;
        case 9: ev = e->provider; break;
        case 10: ev = e->oamloop; break;
        case 11: ev = e->stpid1; break;
        case 12: ev = e->twintpid; break;
        case 13: ev = e->pbb; break;
        case 14: ev = e->ipv4mc; break;
        case 15: ev = e->state; break;
        case 16: ev = e->pport; break;
        case 17: ev = e->htype; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2xx_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for p2e */
int soc_sbx_g2xx_p2e_set(int unit,
                int iport,
                soc_sbx_g2xx_p2e_t *e)
{
    int s, key[32];

    s = soc_sbx_g2xx_p2e_index_check(unit, key,
                iport);
    if (s) {
        return s;
    }

    s = soc_sbx_g2xx_p2e_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2xx_p2e_set_ext(unit,
                iport,
                e);

    return s;
}

/* entry get accessor implementation for p2e */
int soc_sbx_g2xx_p2e_get(int unit,
                int iport,
                soc_sbx_g2xx_p2e_t *e)
{
    int s, key[32];

    s = soc_sbx_g2xx_p2e_index_check(unit, key,
                iport);
    if (s) {
        return s;
    }
    s = soc_sbx_g2xx_p2e_get_ext(unit,
                iport,
                e);

    return s;
}

/*
 * Entry accessor implementations for ep2e
 */

void soc_sbx_g2xx_ep2e_t_init(
    soc_sbx_g2xx_ep2e_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2xx_ep2e_t));
}

/* entry size function for ep2e */
int soc_sbx_g2xx_ep2e_size(int unit)
{
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_EP2E_ID];
    soc_sbx_g2xx_entry_bank_t *eb = &ed->banks[0];

    return (eb->width + (eb->stridebits - 1)) / eb->stridebits;
}

/* entry pack accessor implementation for ep2e */
int soc_sbx_g2xx_ep2e_pack(int unit,
    soc_sbx_g2xx_ep2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_EP2E_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->mim; break;
        case 1: p = (uint8 *) &e->pid; break;
        case 2: p = (uint8 *) &e->stpid0; break;
        case 3: p = (uint8 *) &e->stpid1; break;
        case 4: p = (uint8 *) &e->customer; break;
        case 5: p = (uint8 *) &e->keeperh; break;
        case 6: p = (uint8 *) &e->port; break;
        case 7: p = (uint8 *) &e->mirroridx; break;
        case 8: p = (uint8 *) e->mask; break;
        case 9: p = (uint8 *) &e->oamloop; break;
        case 10: p = (uint8 *) &e->pbb; break;
        case 11: p = (uint8 *) &e->state; break;
        case 12: p = (uint8 *) &e->htype; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2xx_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ep2e */
int soc_sbx_g2xx_ep2e_unpack(int unit,
                soc_sbx_g2xx_ep2e_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_EP2E_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->mim; break;
        case 1: p = (uint8 *) &e->pid; break;
        case 2: p = (uint8 *) &e->stpid0; break;
        case 3: p = (uint8 *) &e->stpid1; break;
        case 4: p = (uint8 *) &e->customer; break;
        case 5: p = (uint8 *) &e->keeperh; break;
        case 6: p = (uint8 *) &e->port; break;
        case 7: p = (uint8 *) &e->mirroridx; break;
        case 8: p = (uint8 *) e->mask; break;
        case 9: p = (uint8 *) &e->oamloop; break;
        case 10: p = (uint8 *) &e->pbb; break;
        case 11: p = (uint8 *) &e->state; break;
        case 12: p = (uint8 *) &e->htype; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2xx_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ep2e */
int soc_sbx_g2xx_ep2e_index_check(int unit,
                int *vindex,
                int iport)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_EP2E_ID];
    soc_sbx_g2xx_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iport; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2xx_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2XX_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2XX_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2xx_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ep2e */
int soc_sbx_g2xx_ep2e_entry_check(int unit,
                soc_sbx_g2xx_ep2e_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_EP2E_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->mim; break;
        case 1: ev = e->pid; break;
        case 2: ev = e->stpid0; break;
        case 3: ev = e->stpid1; break;
        case 4: ev = e->customer; break;
        case 5: ev = e->keeperh; break;
        case 6: ev = e->port; break;
        case 7: ev = e->mirroridx; break;
        case 8: ev = e->mask[0]; break;
        case 9: ev = e->oamloop; break;
        case 10: ev = e->pbb; break;
        case 11: ev = e->state; break;
        case 12: ev = e->htype; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2xx_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for ep2e */
int soc_sbx_g2xx_ep2e_set(int unit,
                int iport,
                soc_sbx_g2xx_ep2e_t *e)
{
    int s, key[32];

    s = soc_sbx_g2xx_ep2e_index_check(unit, key,
                iport);
    if (s) {
        return s;
    }

    s = soc_sbx_g2xx_ep2e_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2xx_ep2e_set_ext(unit,
                iport,
                e);

    return s;
}

/* entry get accessor implementation for ep2e */
int soc_sbx_g2xx_ep2e_get(int unit,
                int iport,
                soc_sbx_g2xx_ep2e_t *e)
{
    int s, key[32];

    s = soc_sbx_g2xx_ep2e_index_check(unit, key,
                iport);
    if (s) {
        return s;
    }
    s = soc_sbx_g2xx_ep2e_get_ext(unit,
                iport,
                e);

    return s;
}

/*
 * Entry accessor implementations for p2e20
 */

void soc_sbx_g2xx_p2e20_t_init(
    soc_sbx_g2xx_p2e20_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2xx_p2e20_t));
    e->defstrip = 0x1;
}

/* entry pack accessor implementation for p2e20 */
int soc_sbx_g2xx_p2e20_pack(int unit,
    soc_sbx_g2xx_p2e20_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_P2E20_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->port; break;
        case 1: p = (uint8 *) &e->nativevid; break;
        case 2: p = (uint8 *) &e->defcfi; break;
        case 3: p = (uint8 *) &e->defpri; break;
        case 4: p = (uint8 *) &e->defstrip; break;
        case 5: p = (uint8 *) &e->pstrip; break;
        case 6: p = (uint8 *) &e->mim; break;
        case 7: p = (uint8 *) e->mask; break;
        case 8: p = (uint8 *) &e->customer; break;
        case 9: p = (uint8 *) &e->provider; break;
        case 10: p = (uint8 *) &e->oamloop; break;
        case 11: p = (uint8 *) &e->stpid1; break;
        case 12: p = (uint8 *) &e->twintpid; break;
        case 13: p = (uint8 *) &e->pbb; break;
        case 14: p = (uint8 *) &e->ipv4mc; break;
        case 15: p = (uint8 *) &e->state; break;
        case 16: p = (uint8 *) &e->pport; break;
        case 17: p = (uint8 *) &e->htype; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2xx_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for p2e20 */
int soc_sbx_g2xx_p2e20_unpack(int unit,
                soc_sbx_g2xx_p2e20_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_P2E20_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->port; break;
        case 1: p = (uint8 *) &e->nativevid; break;
        case 2: p = (uint8 *) &e->defcfi; break;
        case 3: p = (uint8 *) &e->defpri; break;
        case 4: p = (uint8 *) &e->defstrip; break;
        case 5: p = (uint8 *) &e->pstrip; break;
        case 6: p = (uint8 *) &e->mim; break;
        case 7: p = (uint8 *) e->mask; break;
        case 8: p = (uint8 *) &e->customer; break;
        case 9: p = (uint8 *) &e->provider; break;
        case 10: p = (uint8 *) &e->oamloop; break;
        case 11: p = (uint8 *) &e->stpid1; break;
        case 12: p = (uint8 *) &e->twintpid; break;
        case 13: p = (uint8 *) &e->pbb; break;
        case 14: p = (uint8 *) &e->ipv4mc; break;
        case 15: p = (uint8 *) &e->state; break;
        case 16: p = (uint8 *) &e->pport; break;
        case 17: p = (uint8 *) &e->htype; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2xx_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for p2e20 */
int soc_sbx_g2xx_p2e20_index_check(int unit,
                int *vindex,
                int iport)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_P2E20_ID];
    soc_sbx_g2xx_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iport; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2xx_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2XX_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2XX_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2xx_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for p2e20 */
int soc_sbx_g2xx_p2e20_entry_check(int unit,
                soc_sbx_g2xx_p2e20_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_P2E20_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->port; break;
        case 1: ev = e->nativevid; break;
        case 2: ev = e->defcfi; break;
        case 3: ev = e->defpri; break;
        case 4: ev = e->defstrip; break;
        case 5: ev = e->pstrip; break;
        case 6: ev = e->mim; break;
        case 7: ev = e->mask[0]; break;
        case 8: ev = e->customer; break;
        case 9: ev = e->provider; break;
        case 10: ev = e->oamloop; break;
        case 11: ev = e->stpid1; break;
        case 12: ev = e->twintpid; break;
        case 13: ev = e->pbb; break;
        case 14: ev = e->ipv4mc; break;
        case 15: ev = e->state; break;
        case 16: ev = e->pport; break;
        case 17: ev = e->htype; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2xx_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* p2e20 table size get */
int soc_sbx_g2xx_p2e20_entry_table_size_get(int unit,
                int *tsize,
                int iport)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_P2E20_ID];
    soc_sbx_g2xx_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2xx_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2xx_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = iport; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2xx_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for p2e20 */
int soc_sbx_g2xx_p2e20_set(int unit,
                int iport,
                soc_sbx_g2xx_p2e20_t *e)
{
    int s, key[32], sset;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_P2E20_ID];

    s = soc_sbx_g2xx_p2e20_index_check(unit, key,
                iport);
    if (s) {
        return s;
    }

    s = soc_sbx_g2xx_p2e20_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2xx_p2e20_set_hook(unit, &sset, key,
                iport,
                e);
    if (sset) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2xx_p2e20_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2xx_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for p2e20 */
int soc_sbx_g2xx_p2e20_get(int unit,
                int iport,
                soc_sbx_g2xx_p2e20_t *e)
{
    int s, key[32], sset;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_P2E20_ID];

    s = soc_sbx_g2xx_p2e20_index_check(unit, key,
                iport);
    if (s) {
        return s;
    }
    s = soc_sbx_g2xx_p2e20_get_hook(unit, &sset, key,
                iport);
    if (sset) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2xx_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2xx_p2e20_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for ep2e20
 */

void soc_sbx_g2xx_ep2e20_t_init(
    soc_sbx_g2xx_ep2e20_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2xx_ep2e20_t));
}

/* entry pack accessor implementation for ep2e20 */
int soc_sbx_g2xx_ep2e20_pack(int unit,
    soc_sbx_g2xx_ep2e20_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_EP2E20_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->mim; break;
        case 1: p = (uint8 *) &e->pid; break;
        case 2: p = (uint8 *) &e->stpid0; break;
        case 3: p = (uint8 *) &e->stpid1; break;
        case 4: p = (uint8 *) &e->customer; break;
        case 5: p = (uint8 *) &e->keeperh; break;
        case 6: p = (uint8 *) &e->port; break;
        case 7: p = (uint8 *) &e->mirroridx; break;
        case 8: p = (uint8 *) e->mask; break;
        case 9: p = (uint8 *) &e->oamloop; break;
        case 10: p = (uint8 *) &e->pbb; break;
        case 11: p = (uint8 *) &e->state; break;
        case 12: p = (uint8 *) &e->htype; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2xx_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ep2e20 */
int soc_sbx_g2xx_ep2e20_unpack(int unit,
                soc_sbx_g2xx_ep2e20_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_EP2E20_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->mim; break;
        case 1: p = (uint8 *) &e->pid; break;
        case 2: p = (uint8 *) &e->stpid0; break;
        case 3: p = (uint8 *) &e->stpid1; break;
        case 4: p = (uint8 *) &e->customer; break;
        case 5: p = (uint8 *) &e->keeperh; break;
        case 6: p = (uint8 *) &e->port; break;
        case 7: p = (uint8 *) &e->mirroridx; break;
        case 8: p = (uint8 *) e->mask; break;
        case 9: p = (uint8 *) &e->oamloop; break;
        case 10: p = (uint8 *) &e->pbb; break;
        case 11: p = (uint8 *) &e->state; break;
        case 12: p = (uint8 *) &e->htype; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2xx_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ep2e20 */
int soc_sbx_g2xx_ep2e20_index_check(int unit,
                int *vindex,
                int iport)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_EP2E20_ID];
    soc_sbx_g2xx_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iport; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2xx_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2XX_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2XX_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2xx_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ep2e20 */
int soc_sbx_g2xx_ep2e20_entry_check(int unit,
                soc_sbx_g2xx_ep2e20_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_EP2E20_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->mim; break;
        case 1: ev = e->pid; break;
        case 2: ev = e->stpid0; break;
        case 3: ev = e->stpid1; break;
        case 4: ev = e->customer; break;
        case 5: ev = e->keeperh; break;
        case 6: ev = e->port; break;
        case 7: ev = e->mirroridx; break;
        case 8: ev = e->mask[0]; break;
        case 9: ev = e->oamloop; break;
        case 10: ev = e->pbb; break;
        case 11: ev = e->state; break;
        case 12: ev = e->htype; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2xx_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* ep2e20 table size get */
int soc_sbx_g2xx_ep2e20_entry_table_size_get(int unit,
                int *tsize,
                int iport)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_EP2E20_ID];
    soc_sbx_g2xx_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2xx_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2xx_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = iport; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2xx_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for ep2e20 */
int soc_sbx_g2xx_ep2e20_set(int unit,
                int iport,
                soc_sbx_g2xx_ep2e20_t *e)
{
    int s, key[32], sset;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_EP2E20_ID];

    s = soc_sbx_g2xx_ep2e20_index_check(unit, key,
                iport);
    if (s) {
        return s;
    }

    s = soc_sbx_g2xx_ep2e20_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2xx_ep2e20_set_hook(unit, &sset, key,
                iport,
                e);
    if (sset) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2xx_ep2e20_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2xx_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for ep2e20 */
int soc_sbx_g2xx_ep2e20_get(int unit,
                int iport,
                soc_sbx_g2xx_ep2e20_t *e)
{
    int s, key[32], sset;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_EP2E20_ID];

    s = soc_sbx_g2xx_ep2e20_index_check(unit, key,
                iport);
    if (s) {
        return s;
    }
    s = soc_sbx_g2xx_ep2e20_get_hook(unit, &sset, key,
                iport);
    if (sset) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2xx_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2xx_ep2e20_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for p2e25
 */

void soc_sbx_g2xx_p2e25_t_init(
    soc_sbx_g2xx_p2e25_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2xx_p2e25_t));
    e->defstrip = 0x1;
}

/* entry pack accessor implementation for p2e25 */
int soc_sbx_g2xx_p2e25_pack(int unit,
    soc_sbx_g2xx_p2e25_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_P2E25_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->port; break;
        case 1: p = (uint8 *) &e->nativevid; break;
        case 2: p = (uint8 *) &e->defcfi; break;
        case 3: p = (uint8 *) &e->defpri; break;
        case 4: p = (uint8 *) &e->defstrip; break;
        case 5: p = (uint8 *) &e->pstrip; break;
        case 6: p = (uint8 *) &e->mim; break;
        case 7: p = (uint8 *) e->mask; break;
        case 8: p = (uint8 *) &e->customer; break;
        case 9: p = (uint8 *) &e->provider; break;
        case 10: p = (uint8 *) &e->oamloop; break;
        case 11: p = (uint8 *) &e->stpid1; break;
        case 12: p = (uint8 *) &e->twintpid; break;
        case 13: p = (uint8 *) &e->pbb; break;
        case 14: p = (uint8 *) &e->ipv4mc; break;
        case 15: p = (uint8 *) &e->state; break;
        case 16: p = (uint8 *) &e->pport; break;
        case 17: p = (uint8 *) &e->htype; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2xx_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for p2e25 */
int soc_sbx_g2xx_p2e25_unpack(int unit,
                soc_sbx_g2xx_p2e25_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_P2E25_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->port; break;
        case 1: p = (uint8 *) &e->nativevid; break;
        case 2: p = (uint8 *) &e->defcfi; break;
        case 3: p = (uint8 *) &e->defpri; break;
        case 4: p = (uint8 *) &e->defstrip; break;
        case 5: p = (uint8 *) &e->pstrip; break;
        case 6: p = (uint8 *) &e->mim; break;
        case 7: p = (uint8 *) e->mask; break;
        case 8: p = (uint8 *) &e->customer; break;
        case 9: p = (uint8 *) &e->provider; break;
        case 10: p = (uint8 *) &e->oamloop; break;
        case 11: p = (uint8 *) &e->stpid1; break;
        case 12: p = (uint8 *) &e->twintpid; break;
        case 13: p = (uint8 *) &e->pbb; break;
        case 14: p = (uint8 *) &e->ipv4mc; break;
        case 15: p = (uint8 *) &e->state; break;
        case 16: p = (uint8 *) &e->pport; break;
        case 17: p = (uint8 *) &e->htype; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2xx_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for p2e25 */
int soc_sbx_g2xx_p2e25_index_check(int unit,
                int *vindex,
                int iport)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_P2E25_ID];
    soc_sbx_g2xx_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iport; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2xx_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2XX_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2XX_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2xx_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for p2e25 */
int soc_sbx_g2xx_p2e25_entry_check(int unit,
                soc_sbx_g2xx_p2e25_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_P2E25_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->port; break;
        case 1: ev = e->nativevid; break;
        case 2: ev = e->defcfi; break;
        case 3: ev = e->defpri; break;
        case 4: ev = e->defstrip; break;
        case 5: ev = e->pstrip; break;
        case 6: ev = e->mim; break;
        case 7: ev = e->mask[0]; break;
        case 8: ev = e->customer; break;
        case 9: ev = e->provider; break;
        case 10: ev = e->oamloop; break;
        case 11: ev = e->stpid1; break;
        case 12: ev = e->twintpid; break;
        case 13: ev = e->pbb; break;
        case 14: ev = e->ipv4mc; break;
        case 15: ev = e->state; break;
        case 16: ev = e->pport; break;
        case 17: ev = e->htype; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2xx_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* p2e25 table size get */
int soc_sbx_g2xx_p2e25_entry_table_size_get(int unit,
                int *tsize,
                int iport)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_P2E25_ID];
    soc_sbx_g2xx_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2xx_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2xx_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = iport; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2xx_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for p2e25 */
int soc_sbx_g2xx_p2e25_set(int unit,
                int iport,
                soc_sbx_g2xx_p2e25_t *e)
{
    int s, key[32], sset;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_P2E25_ID];

    s = soc_sbx_g2xx_p2e25_index_check(unit, key,
                iport);
    if (s) {
        return s;
    }

    s = soc_sbx_g2xx_p2e25_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2xx_p2e25_set_hook(unit, &sset, key,
                iport,
                e);
    if (sset) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2xx_p2e25_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2xx_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for p2e25 */
int soc_sbx_g2xx_p2e25_get(int unit,
                int iport,
                soc_sbx_g2xx_p2e25_t *e)
{
    int s, key[32], sset;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_P2E25_ID];

    s = soc_sbx_g2xx_p2e25_index_check(unit, key,
                iport);
    if (s) {
        return s;
    }
    s = soc_sbx_g2xx_p2e25_get_hook(unit, &sset, key,
                iport);
    if (sset) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2xx_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2xx_p2e25_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for ep2e25
 */

void soc_sbx_g2xx_ep2e25_t_init(
    soc_sbx_g2xx_ep2e25_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2xx_ep2e25_t));
}

/* entry pack accessor implementation for ep2e25 */
int soc_sbx_g2xx_ep2e25_pack(int unit,
    soc_sbx_g2xx_ep2e25_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_EP2E25_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->mim; break;
        case 1: p = (uint8 *) &e->pid; break;
        case 2: p = (uint8 *) &e->stpid0; break;
        case 3: p = (uint8 *) &e->stpid1; break;
        case 4: p = (uint8 *) &e->customer; break;
        case 5: p = (uint8 *) &e->keeperh; break;
        case 6: p = (uint8 *) &e->port; break;
        case 7: p = (uint8 *) &e->mirroridx; break;
        case 8: p = (uint8 *) e->mask; break;
        case 9: p = (uint8 *) &e->oamloop; break;
        case 10: p = (uint8 *) &e->pbb; break;
        case 11: p = (uint8 *) &e->state; break;
        case 12: p = (uint8 *) &e->htype; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2xx_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for ep2e25 */
int soc_sbx_g2xx_ep2e25_unpack(int unit,
                soc_sbx_g2xx_ep2e25_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_EP2E25_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->mim; break;
        case 1: p = (uint8 *) &e->pid; break;
        case 2: p = (uint8 *) &e->stpid0; break;
        case 3: p = (uint8 *) &e->stpid1; break;
        case 4: p = (uint8 *) &e->customer; break;
        case 5: p = (uint8 *) &e->keeperh; break;
        case 6: p = (uint8 *) &e->port; break;
        case 7: p = (uint8 *) &e->mirroridx; break;
        case 8: p = (uint8 *) e->mask; break;
        case 9: p = (uint8 *) &e->oamloop; break;
        case 10: p = (uint8 *) &e->pbb; break;
        case 11: p = (uint8 *) &e->state; break;
        case 12: p = (uint8 *) &e->htype; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2xx_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for ep2e25 */
int soc_sbx_g2xx_ep2e25_index_check(int unit,
                int *vindex,
                int iport)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_EP2E25_ID];
    soc_sbx_g2xx_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &iport; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2xx_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2XX_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2XX_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2xx_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for ep2e25 */
int soc_sbx_g2xx_ep2e25_entry_check(int unit,
                soc_sbx_g2xx_ep2e25_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_EP2E25_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->mim; break;
        case 1: ev = e->pid; break;
        case 2: ev = e->stpid0; break;
        case 3: ev = e->stpid1; break;
        case 4: ev = e->customer; break;
        case 5: ev = e->keeperh; break;
        case 6: ev = e->port; break;
        case 7: ev = e->mirroridx; break;
        case 8: ev = e->mask[0]; break;
        case 9: ev = e->oamloop; break;
        case 10: ev = e->pbb; break;
        case 11: ev = e->state; break;
        case 12: ev = e->htype; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2xx_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* ep2e25 table size get */
int soc_sbx_g2xx_ep2e25_entry_table_size_get(int unit,
                int *tsize,
                int iport)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_EP2E25_ID];
    soc_sbx_g2xx_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2xx_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2xx_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = iport; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2xx_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for ep2e25 */
int soc_sbx_g2xx_ep2e25_set(int unit,
                int iport,
                soc_sbx_g2xx_ep2e25_t *e)
{
    int s, key[32], sset;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_EP2E25_ID];

    s = soc_sbx_g2xx_ep2e25_index_check(unit, key,
                iport);
    if (s) {
        return s;
    }

    s = soc_sbx_g2xx_ep2e25_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2xx_ep2e25_set_hook(unit, &sset, key,
                iport,
                e);
    if (sset) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2xx_ep2e25_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2xx_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for ep2e25 */
int soc_sbx_g2xx_ep2e25_get(int unit,
                int iport,
                soc_sbx_g2xx_ep2e25_t *e)
{
    int s, key[32], sset;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_EP2E25_ID];

    s = soc_sbx_g2xx_ep2e25_index_check(unit, key,
                iport);
    if (s) {
        return s;
    }
    s = soc_sbx_g2xx_ep2e25_get_hook(unit, &sset, key,
                iport);
    if (sset) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2xx_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2xx_ep2e25_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for tpid
 */

void soc_sbx_g2xx_tpid_t_init(
    soc_sbx_g2xx_tpid_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2xx_tpid_t));
}

/* entry size function for tpid */
int soc_sbx_g2xx_tpid_size(int unit)
{
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_TPID_ID];
    soc_sbx_g2xx_entry_bank_t *eb = &ed->banks[0];

    return (eb->width + (eb->stridebits - 1)) / eb->stridebits;
}

/* entry pack accessor implementation for tpid */
int soc_sbx_g2xx_tpid_pack(int unit,
    soc_sbx_g2xx_tpid_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_TPID_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->tpid; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2xx_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for tpid */
int soc_sbx_g2xx_tpid_unpack(int unit,
                soc_sbx_g2xx_tpid_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_TPID_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->tpid; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2xx_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for tpid */
int soc_sbx_g2xx_tpid_index_check(int unit,
                int *vindex,
                int itpidi)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_TPID_ID];
    soc_sbx_g2xx_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &itpidi; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2xx_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2XX_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2XX_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2xx_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for tpid */
int soc_sbx_g2xx_tpid_entry_check(int unit,
                soc_sbx_g2xx_tpid_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_TPID_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->tpid; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2xx_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for tpid */
int soc_sbx_g2xx_tpid_set(int unit,
                int itpidi,
                soc_sbx_g2xx_tpid_t *e)
{
    int s, key[32];

    s = soc_sbx_g2xx_tpid_index_check(unit, key,
                itpidi);
    if (s) {
        return s;
    }

    s = soc_sbx_g2xx_tpid_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2xx_tpid_set_ext(unit,
                itpidi,
                e);

    return s;
}

/* entry get accessor implementation for tpid */
int soc_sbx_g2xx_tpid_get(int unit,
                int itpidi,
                soc_sbx_g2xx_tpid_t *e)
{
    int s, key[32];

    s = soc_sbx_g2xx_tpid_index_check(unit, key,
                itpidi);
    if (s) {
        return s;
    }
    s = soc_sbx_g2xx_tpid_get_ext(unit,
                itpidi,
                e);

    return s;
}

/*
 * Entry accessor implementations for lsmac
 */

void soc_sbx_g2xx_lsmac_t_init(
    soc_sbx_g2xx_lsmac_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2xx_lsmac_t));
}

/* entry size function for lsmac */
int soc_sbx_g2xx_lsmac_size(int unit)
{
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_LSMAC_ID];
    soc_sbx_g2xx_entry_bank_t *eb = &ed->banks[0];

    return (eb->width + (eb->stridebits - 1)) / eb->stridebits;
}

/* entry pack accessor implementation for lsmac */
int soc_sbx_g2xx_lsmac_pack(int unit,
    soc_sbx_g2xx_lsmac_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_LSMAC_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->port; break;
        case 1: p = (uint8 *) &e->useport; break;
        case 2: p = (uint8 *) e->mac; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2xx_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for lsmac */
int soc_sbx_g2xx_lsmac_unpack(int unit,
                soc_sbx_g2xx_lsmac_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_LSMAC_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->port; break;
        case 1: p = (uint8 *) &e->useport; break;
        case 2: p = (uint8 *) e->mac; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2xx_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for lsmac */
int soc_sbx_g2xx_lsmac_index_check(int unit,
                int *vindex,
                int ilsi)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_LSMAC_ID];
    soc_sbx_g2xx_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ilsi; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2xx_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2XX_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2XX_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2xx_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for lsmac */
int soc_sbx_g2xx_lsmac_entry_check(int unit,
                soc_sbx_g2xx_lsmac_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_LSMAC_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->port; break;
        case 1: ev = e->useport; break;
        case 2: ev = e->mac[0]; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2xx_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* entry set accessor implementation for lsmac */
int soc_sbx_g2xx_lsmac_set(int unit,
                int ilsi,
                soc_sbx_g2xx_lsmac_t *e)
{
    int s, key[32];

    s = soc_sbx_g2xx_lsmac_index_check(unit, key,
                ilsi);
    if (s) {
        return s;
    }

    s = soc_sbx_g2xx_lsmac_entry_check(unit, e);

    if (s) {
        return s;
    }
    s = soc_sbx_g2xx_lsmac_set_ext(unit,
                ilsi,
                e);

    return s;
}

/* entry get accessor implementation for lsmac */
int soc_sbx_g2xx_lsmac_get(int unit,
                int ilsi,
                soc_sbx_g2xx_lsmac_t *e)
{
    int s, key[32];

    s = soc_sbx_g2xx_lsmac_index_check(unit, key,
                ilsi);
    if (s) {
        return s;
    }
    s = soc_sbx_g2xx_lsmac_get_ext(unit,
                ilsi,
                e);

    return s;
}

/*
 * Entry accessor implementations for xt
 */

void soc_sbx_g2xx_xt_t_init(
    soc_sbx_g2xx_xt_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2xx_xt_t));
}

/* entry pack accessor implementation for xt */
int soc_sbx_g2xx_xt_pack(int unit,
    soc_sbx_g2xx_xt_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_XT_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->forward; break;
        case 1: p = (uint8 *) &e->dp; break;
        case 2: p = (uint8 *) &e->qid; break;
        case 3: p = (uint8 *) &e->trunc; break;
        case 4: p = (uint8 *) &e->learn; break;
        case 5: p = (uint8 *) &e->ppspolice; break;
        case 6: p = (uint8 *) &e->policer; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2xx_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for xt */
int soc_sbx_g2xx_xt_unpack(int unit,
                soc_sbx_g2xx_xt_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_XT_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->forward; break;
        case 1: p = (uint8 *) &e->dp; break;
        case 2: p = (uint8 *) &e->qid; break;
        case 3: p = (uint8 *) &e->trunc; break;
        case 4: p = (uint8 *) &e->learn; break;
        case 5: p = (uint8 *) &e->ppspolice; break;
        case 6: p = (uint8 *) &e->policer; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2xx_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* entry index checker for xt */
int soc_sbx_g2xx_xt_index_check(int unit,
                int *vindex,
                int ixi)
{
    int i, r, pos, width, fmt, ibe, pibe;
    uint8 *p, *p0;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_XT_ID];
    soc_sbx_g2xx_index_desc_t *id;
    int psize =
        (ed->indexeswidth + sizeof(int) * 8 - 1) / (sizeof(int) * 8)
        * sizeof(int);
    int be = tm->behost;
    int pkbe = be;

    sal_memset(vindex, 0, psize);

    p0 = ((uint8 *) vindex) + (pkbe ? psize - 1 : 0);

    for (i = 0; i < ed->nindexes; i++) {
        id = &ed->indexes[i];
        width = id->width;
        pos = id->pos;
        fmt = id->format;
        switch (i) {
        case 0: p = (uint8 *) &ixi; break;
        default: return SOC_E_INTERNAL;
        }
        r = ed->indexes[i].range;
        if (0 < r && r <= *(int *) p) {
            soc_sbx_g2xx_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        ibe = be && width <= 32;
        if (ibe) {
            p += sizeof(int) - 1;
        }
	pibe = 
	  (fmt == SOC_SBX_G2XX_BE_INTEGER_FORMAT
	   || (fmt == SOC_SBX_G2XX_NATIVE_INTEGER_FORMAT && be));
        soc_sbx_g2xx_insert(p0,
               pkbe, pos, width, p, ibe, pibe != pkbe);
    }

    return SOC_E_NONE;
}

/* entry argument checker for xt */
int soc_sbx_g2xx_xt_entry_check(int unit,
                soc_sbx_g2xx_xt_t *e)
{
    int i, r;
    uint32 ev = 0;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_XT_ID];

    for (i = 0; i < ed->nfields; i++) {
        switch (i) {
        case 0: ev = e->forward; break;
        case 1: ev = e->dp; break;
        case 2: ev = e->qid; break;
        case 3: ev = e->trunc; break;
        case 4: ev = e->learn; break;
        case 5: ev = e->ppspolice; break;
        case 6: ev = e->policer; break;
        }
        r = ed->fields[i].range;
        if (0 < r && ((uint32) r) <= ev) {
            soc_sbx_g2xx_errsym = ed->fields[i].name;
            return SOC_E_PARAM;
        }
    }

    return SOC_E_NONE;
}

/* xt table size get */
int soc_sbx_g2xx_xt_entry_table_size_get(int unit,
                int *tsize,
                int ixi)
{
    int i, r, bits = 0, ecount = 0, v = 0;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_XT_ID];
    soc_sbx_g2xx_entry_bank_t *eb = &ed->banks[0];
    int ebwidth = eb->width;
    soc_sbx_g2xx_table_desc_t *td = &tm->tables[ed->table];
    soc_sbx_g2xx_table_bank_t *tb = &td->banks[eb->tablebank];
    int tbwidth = tb->width;

    for (i = ed->nindexes - 1; 0 <= i ; i--) {
        switch (i) {
        case 0: v = ixi; break;
        }
        bits += ed->indexes[i].width;
        r = 1 << ed->indexes[i].width;
        if (v < 1 || r < v
            || (ecount && r != v)
            || bits > 32) {
            soc_sbx_g2xx_errsym = ed->indexes[i].name;
            return SOC_E_PARAM;
        }
        if (!ecount && (v > 1 || i == 0)) {
            ecount = v << ed->indexes[i].pos;
        }
    }

    *tsize = (ecount * ebwidth + (tbwidth - 1)) / tbwidth;
    return SOC_E_NONE;
}

/* entry set accessor implementation for xt */
int soc_sbx_g2xx_xt_set(int unit,
                int ixi,
                soc_sbx_g2xx_xt_t *e)
{
    int s, key[32];
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_XT_ID];

    s = soc_sbx_g2xx_xt_index_check(unit, key,
                ixi);
    if (s) {
        return s;
    }

    s = soc_sbx_g2xx_xt_entry_check(unit, e);

    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);

    s = soc_sbx_g2xx_xt_pack(unit, 
                  e, tm->entrydmabuf, ed->epsize);
    if (!s) {
        s = soc_sbx_g2xx_entry_read_write(unit, 0, key[0], ed);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/* entry get accessor implementation for xt */
int soc_sbx_g2xx_xt_get(int unit,
                int ixi,
                soc_sbx_g2xx_xt_t *e)
{
    int s, key[32];
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_XT_ID];

    s = soc_sbx_g2xx_xt_index_check(unit, key,
                ixi);
    if (s) {
        return s;
    }
    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (!s) {
        s = soc_sbx_g2xx_entry_read_write(unit, 1, key[0], ed);
    }
    if (!s) {
        s = soc_sbx_g2xx_xt_unpack(unit,
                        e, tm->entrydmabuf, ed->epsize);
    }
    sal_mutex_give(tm->dmabufmutex);

    return s;
}

/*
 * Entry accessor implementations for policer
 */

void soc_sbx_g2xx_policer_t_init(
    soc_sbx_g2xx_policer_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2xx_policer_t));
}

/* entry size function for policer */
int soc_sbx_g2xx_policer_size(int unit)
{
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_POLICER_ID];
    soc_sbx_g2xx_entry_bank_t *eb = &ed->banks[0];

    return (eb->width + (eb->stridebits - 1)) / eb->stridebits;
}

/* entry pack accessor implementation for policer */
int soc_sbx_g2xx_policer_pack(int unit,
    soc_sbx_g2xx_policer_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_POLICER_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->cbsbytes; break;
        case 1: p = (uint8 *) &e->cirkbps; break;
        case 2: p = (uint8 *) &e->ebsbytes; break;
        case 3: p = (uint8 *) &e->eirkbps; break;
        case 4: p = (uint8 *) &e->mode; break;
        case 5: p = (uint8 *) &e->lenshift; break;
        case 6: p = (uint8 *) &e->colorblind; break;
        case 7: p = (uint8 *) &e->dropred; break;
        case 8: p = (uint8 *) &e->coupling; break;
        case 9: p = (uint8 *) &e->nodebit; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2xx_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for policer */
int soc_sbx_g2xx_policer_unpack(int unit,
                soc_sbx_g2xx_policer_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_POLICER_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->cbsbytes; break;
        case 1: p = (uint8 *) &e->cirkbps; break;
        case 2: p = (uint8 *) &e->ebsbytes; break;
        case 3: p = (uint8 *) &e->eirkbps; break;
        case 4: p = (uint8 *) &e->mode; break;
        case 5: p = (uint8 *) &e->lenshift; break;
        case 6: p = (uint8 *) &e->colorblind; break;
        case 7: p = (uint8 *) &e->dropred; break;
        case 8: p = (uint8 *) &e->coupling; break;
        case 9: p = (uint8 *) &e->nodebit; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2xx_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/*
 * Entry accessor implementations for timer
 */

void soc_sbx_g2xx_timer_t_init(
    soc_sbx_g2xx_timer_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2xx_timer_t));
}

/* entry size function for timer */
int soc_sbx_g2xx_timer_size(int unit)
{
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_TIMER_ID];
    soc_sbx_g2xx_entry_bank_t *eb = &ed->banks[0];

    return (eb->width + (eb->stridebits - 1)) / eb->stridebits;
}

/* entry pack accessor implementation for timer */
int soc_sbx_g2xx_timer_pack(int unit,
    soc_sbx_g2xx_timer_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_TIMER_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->ms; break;
        case 1: p = (uint8 *) &e->started; break;
        case 2: p = (uint8 *) &e->ucodereset; break;
        case 3: p = (uint8 *) &e->interrupt; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2xx_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for timer */
int soc_sbx_g2xx_timer_unpack(int unit,
                soc_sbx_g2xx_timer_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_TIMER_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->ms; break;
        case 1: p = (uint8 *) &e->started; break;
        case 2: p = (uint8 *) &e->ucodereset; break;
        case 3: p = (uint8 *) &e->interrupt; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2xx_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/*
 * Entry accessor implementations for sequence
 */

void soc_sbx_g2xx_sequence_t_init(
    soc_sbx_g2xx_sequence_t *e)
{
    sal_memset(e, 0, sizeof(soc_sbx_g2xx_sequence_t));
}

/* entry size function for sequence */
int soc_sbx_g2xx_sequence_size(int unit)
{
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_SEQUENCE_ID];
    soc_sbx_g2xx_entry_bank_t *eb = &ed->banks[0];

    return (eb->width + (eb->stridebits - 1)) / eb->stridebits;
}

/* entry pack accessor implementation for sequence */
int soc_sbx_g2xx_sequence_pack(int unit,
    soc_sbx_g2xx_sequence_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_SEQUENCE_ID];
    int be = tm->behost;

    sal_memset(b, 0, bsz);

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->seqnum; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2xx_insert_or(b,
                0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}         

/* entry unpack accessor implementation for sequence */
int soc_sbx_g2xx_sequence_unpack(int unit,
                soc_sbx_g2xx_sequence_t *e, uint8 *b, int bsz)
{
    int i, pos, width, fbe;
    uint8 *p;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_SEQUENCE_ID];
    int be = tm->behost;

    bsz = bsz;
    sal_memset(e, 0, sizeof(*e));

    for (i = 0; i < ed->nfields; i++) {
        width = ed->fields[i].width;
        pos = ed->fields[i].pos;
        switch (i) {
        case 0: p = (uint8 *) &e->seqnum; break;
        default: return SOC_E_INTERNAL;
        }
        fbe = be && width <= 32;
        if (fbe) {
            p += sizeof(uint32) - 1;
        }
        soc_sbx_g2xx_extract(b,
               0, pos, width, p, fbe, 0);
    }

    return SOC_E_NONE;
}

/* Get counter bank description implementation */
int soc_sbx_g2xx_counter_bank_params_get(int unit, int bank,
                soc_sbx_g2xx_counter_bank_params_t *p)
{
    /* no counters */
    return SOC_E_PARAM;
}

/* Get policer bank description implementation */
int soc_sbx_g2xx_policer_bank_params_get(int unit, int bank,
                soc_sbx_g2xx_policer_bank_params_t *p)
{
    /* no policers */
    return SOC_E_PARAM;
}

/*
 * Diag shell constant value print
 */
int soc_sbx_g2xx_constant_shell_print(int unit, int cid);
int
soc_sbx_g2xx_constant_shell_print(int unit, int cid)
{
    uint32 v;
    int rv = SOC_E_INTERNAL;

    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;

    switch (cid) {
    case SOC_SBX_G2XX_MIN_FREE_EXCEPTION_ID:
        rv = soc_sbx_g2xx_min_free_exception_get(unit, &v); break;
    case SOC_SBX_G2XX_EXC_COPY_TO_HOST_ID:
        rv = soc_sbx_g2xx_exc_copy_to_host_get(unit, &v); break;
    case SOC_SBX_G2XX_MAX_FREE_EXCEPTION_ID:
        rv = soc_sbx_g2xx_max_free_exception_get(unit, &v); break;
    case SOC_SBX_G2XX_HTYPE_ERH_ID:
        rv = soc_sbx_g2xx_htype_erh_get(unit, &v); break;
    case SOC_SBX_G2XX_HTYPE_ETYPE_ID:
        rv = soc_sbx_g2xx_htype_etype_get(unit, &v); break;
    case SOC_SBX_G2XX_HTYPE_ETH_ID:
        rv = soc_sbx_g2xx_htype_eth_get(unit, &v); break;
    case SOC_SBX_G2XX_HTYPE_IETH_ID:
        rv = soc_sbx_g2xx_htype_ieth_get(unit, &v); break;
    case SOC_SBX_G2XX_HTYPE_VTAG_ID:
        rv = soc_sbx_g2xx_htype_vtag_get(unit, &v); break;
    case SOC_SBX_G2XX_HTYPE_IPV4_ID:
        rv = soc_sbx_g2xx_htype_ipv4_get(unit, &v); break;
    case SOC_SBX_G2XX_HTYPE_ELEN_ID:
        rv = soc_sbx_g2xx_htype_elen_get(unit, &v); break;
    case SOC_SBX_G2XX_HTYPE_UNKN_ID:
        rv = soc_sbx_g2xx_htype_unkn_get(unit, &v); break;
    case SOC_SBX_G2XX_LSMAC_TABLE_SIZE_ID:
        rv = soc_sbx_g2xx_lsmac_table_size_get(unit, &v); break;
    }
    if (rv) {
        soc_cm_print("constant %s get timeout\n",
                tm->constants[cid].name);
        return rv;
    }

    soc_cm_print("%s=", tm->constants[cid].name);
    soc_sbx_g2xx_print(-1, v);
    soc_cm_print("\n");
    return SOC_E_NONE;
}

/*
 * Diag shell global value print
 */
int soc_sbx_g2xx_global_shell_print(int unit, int gid);
int
soc_sbx_g2xx_global_shell_print(int unit, int gid)
{
    uint32 v;
    int rv = SOC_E_INTERNAL;

    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;

    switch (gid) {
    case SOC_SBX_G2XX_TPID0_ID:
        rv = soc_sbx_g2xx_tpid0_get(unit, &v); break;
    case SOC_SBX_G2XX_TPID1_ID:
        rv = soc_sbx_g2xx_tpid1_get(unit, &v); break;
    case SOC_SBX_G2XX_TPID2_ID:
        rv = soc_sbx_g2xx_tpid2_get(unit, &v); break;
    case SOC_SBX_G2XX_NODE_ID:
        rv = soc_sbx_g2xx_node_get(unit, &v); break;
    }
    if (rv) {
        soc_cm_print("global %s get timeout\n",
                tm->globals[gid].name);
        return rv;
    }

    soc_cm_print("%s=", tm->globals[gid].name);
    soc_sbx_g2xx_print(tm->globals[gid].range, v);
    soc_cm_print("\n");
    return SOC_E_NONE;
}


/*
 * Diag shell global value set
 */
int soc_sbx_g2xx_global_shell_set(int unit,
             int gid, int argc, char **argv);
int
soc_sbx_g2xx_global_shell_set(int unit, 
         int gid, int argc, char **argv)
{
    int rv;
    uint32 v;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;

    if (argc == 0) {
        soc_cm_print("missing value\n");
        return SOC_E_PARAM;
    }
    rv = soc_sbx_g2xx_read(argv[0], tm->globals[gid].range, &v);
    if (rv) {
        soc_cm_print("illegal value '%s'\n", argv[0]);
        return SOC_E_PARAM;
    }
    switch (gid) {
    case SOC_SBX_G2XX_TPID0_ID:
        rv = soc_sbx_g2xx_tpid0_set(unit, v); break;
    case SOC_SBX_G2XX_TPID1_ID:
        rv = soc_sbx_g2xx_tpid1_set(unit, v); break;
    case SOC_SBX_G2XX_TPID2_ID:
        rv = soc_sbx_g2xx_tpid2_set(unit, v); break;
    case SOC_SBX_G2XX_NODE_ID:
        rv = soc_sbx_g2xx_node_set(unit, v); break;
    }
    if (rv) {
        soc_cm_print("global %s set timeout\n",
                tm->globals[gid].name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for p2e */
void soc_sbx_g2xx_p2e_print(int unit, 
    soc_sbx_g2xx_p2e_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2xx_field_desc_t *fd;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_P2E_ID];

    int j, digits;
    uint8 *s;
    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->port; w = 4;  break;
        case 1: v = e->nativevid; w = 9;  break;
        case 2: v = e->defcfi; w = 6;  break;
        case 3: v = e->defpri; w = 6;  break;
        case 4: v = e->defstrip; w = 8;  break;
        case 5: v = e->pstrip; w = 6;  break;
        case 6: v = e->mim; w = 3;  break;
        case 7: s = e->mask; w = 4; goto bigfield;
        case 8: v = e->customer; w = 8;  break;
        case 9: v = e->provider; w = 8;  break;
        case 10: v = e->oamloop; w = 7;  break;
        case 11: v = e->stpid1; w = 6;  break;
        case 12: v = e->twintpid; w = 8;  break;
        case 13: v = e->pbb; w = 3;  break;
        case 14: v = e->ipv4mc; w = 6;  break;
        case 15: v = e->state; w = 5;  break;
        case 16: v = e->pport; w = 5;  break;
        case 17: v = e->htype; w = 5;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2xx_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
        continue;

    bigfield:
        digits = (width + 7) / 8;
        if ((col + w + 1 + 5 * digits) > 72) {
            soc_cm_print("\n  ");
            col=2;
        }
        soc_cm_print("%s=", fd->name);
        col += w + 1;
        for (j = 0; j < digits; j++) {
            soc_cm_print("0x%02x ", s[digits - j - 1]);
            col += 5;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for p2e */
int soc_sbx_g2xx_p2e_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2xx_p2e_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2xx_p2e_t e0;
    soc_sbx_g2xx_p2e_t *e = &e0;
    int rv;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_P2E_ID];
    int iport;
    void *indexpointers[1];

    indexpointers[0] = &iport;
    {
        rv = soc_sbx_g2xx_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2xx_p2e_get(unit,
                iport,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2xx_indexes_print(indexpointers, ed);
        soc_sbx_g2xx_p2e_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for p2e */
int soc_sbx_g2xx_p2e_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2xx_p2e_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2xx_p2e_t e0;
    soc_sbx_g2xx_p2e_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_P2E_ID];
    int iport;
    void *indexpointers[1];

    indexpointers[0] = &iport;

    rv = soc_sbx_g2xx_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2xx_p2e_t_init(e);

    rv = soc_sbx_g2xx_p2e_get(unit,
                iport,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2xx_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2xx_value_read(&e->port,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2xx_value_read(&e->nativevid,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2xx_value_read(&e->defcfi,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2xx_value_read(&e->defpri,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2xx_value_read(&e->defstrip,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g2xx_value_read(&e->pstrip,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g2xx_value_read(&e->mim,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g2xx_big_value_read(e->mask,
                                ed->fields[7].width, 0, argc, argv);
                 break;
        case 8: rv = soc_sbx_g2xx_value_read(&e->customer,
                                ed->fields[8].range, 0, argc, argv);
                 break;
        case 9: rv = soc_sbx_g2xx_value_read(&e->provider,
                                ed->fields[9].range, 0, argc, argv);
                 break;
        case 10: rv = soc_sbx_g2xx_value_read(&e->oamloop,
                                ed->fields[10].range, 0, argc, argv);
                 break;
        case 11: rv = soc_sbx_g2xx_value_read(&e->stpid1,
                                ed->fields[11].range, 0, argc, argv);
                 break;
        case 12: rv = soc_sbx_g2xx_value_read(&e->twintpid,
                                ed->fields[12].range, 0, argc, argv);
                 break;
        case 13: rv = soc_sbx_g2xx_value_read(&e->pbb,
                                ed->fields[13].range, 0, argc, argv);
                 break;
        case 14: rv = soc_sbx_g2xx_value_read(&e->ipv4mc,
                                ed->fields[14].range, 0, argc, argv);
                 break;
        case 15: rv = soc_sbx_g2xx_value_read(&e->state,
                                ed->fields[15].range, 0, argc, argv);
                 break;
        case 16: rv = soc_sbx_g2xx_value_read(&e->pport,
                                ed->fields[16].range, 0, argc, argv);
                 break;
        case 17: rv = soc_sbx_g2xx_value_read(&e->htype,
                                ed->fields[17].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2xx_p2e_set(unit,
                iport,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for ep2e */
void soc_sbx_g2xx_ep2e_print(int unit, 
    soc_sbx_g2xx_ep2e_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2xx_field_desc_t *fd;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_EP2E_ID];

    int j, digits;
    uint8 *s;
    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->mim; w = 3;  break;
        case 1: v = e->pid; w = 3;  break;
        case 2: v = e->stpid0; w = 6;  break;
        case 3: v = e->stpid1; w = 6;  break;
        case 4: v = e->customer; w = 8;  break;
        case 5: v = e->keeperh; w = 7;  break;
        case 6: v = e->port; w = 4;  break;
        case 7: v = e->mirroridx; w = 9;  break;
        case 8: s = e->mask; w = 4; goto bigfield;
        case 9: v = e->oamloop; w = 7;  break;
        case 10: v = e->pbb; w = 3;  break;
        case 11: v = e->state; w = 5;  break;
        case 12: v = e->htype; w = 5;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2xx_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
        continue;

    bigfield:
        digits = (width + 7) / 8;
        if ((col + w + 1 + 5 * digits) > 72) {
            soc_cm_print("\n  ");
            col=2;
        }
        soc_cm_print("%s=", fd->name);
        col += w + 1;
        for (j = 0; j < digits; j++) {
            soc_cm_print("0x%02x ", s[digits - j - 1]);
            col += 5;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ep2e */
int soc_sbx_g2xx_ep2e_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2xx_ep2e_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2xx_ep2e_t e0;
    soc_sbx_g2xx_ep2e_t *e = &e0;
    int rv;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_EP2E_ID];
    int iport;
    void *indexpointers[1];

    indexpointers[0] = &iport;
    {
        rv = soc_sbx_g2xx_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2xx_ep2e_get(unit,
                iport,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2xx_indexes_print(indexpointers, ed);
        soc_sbx_g2xx_ep2e_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ep2e */
int soc_sbx_g2xx_ep2e_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2xx_ep2e_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2xx_ep2e_t e0;
    soc_sbx_g2xx_ep2e_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_EP2E_ID];
    int iport;
    void *indexpointers[1];

    indexpointers[0] = &iport;

    rv = soc_sbx_g2xx_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2xx_ep2e_t_init(e);

    rv = soc_sbx_g2xx_ep2e_get(unit,
                iport,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2xx_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2xx_value_read(&e->mim,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2xx_value_read(&e->pid,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2xx_value_read(&e->stpid0,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2xx_value_read(&e->stpid1,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2xx_value_read(&e->customer,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g2xx_value_read(&e->keeperh,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g2xx_value_read(&e->port,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g2xx_value_read(&e->mirroridx,
                                ed->fields[7].range, 0, argc, argv);
                 break;
        case 8: rv = soc_sbx_g2xx_big_value_read(e->mask,
                                ed->fields[8].width, 0, argc, argv);
                 break;
        case 9: rv = soc_sbx_g2xx_value_read(&e->oamloop,
                                ed->fields[9].range, 0, argc, argv);
                 break;
        case 10: rv = soc_sbx_g2xx_value_read(&e->pbb,
                                ed->fields[10].range, 0, argc, argv);
                 break;
        case 11: rv = soc_sbx_g2xx_value_read(&e->state,
                                ed->fields[11].range, 0, argc, argv);
                 break;
        case 12: rv = soc_sbx_g2xx_value_read(&e->htype,
                                ed->fields[12].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2xx_ep2e_set(unit,
                iport,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for p2e20 */
void soc_sbx_g2xx_p2e20_print(int unit, 
    soc_sbx_g2xx_p2e20_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2xx_field_desc_t *fd;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_P2E20_ID];

    int j, digits;
    uint8 *s;
    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->port; w = 4;  break;
        case 1: v = e->nativevid; w = 9;  break;
        case 2: v = e->defcfi; w = 6;  break;
        case 3: v = e->defpri; w = 6;  break;
        case 4: v = e->defstrip; w = 8;  break;
        case 5: v = e->pstrip; w = 6;  break;
        case 6: v = e->mim; w = 3;  break;
        case 7: s = e->mask; w = 4; goto bigfield;
        case 8: v = e->customer; w = 8;  break;
        case 9: v = e->provider; w = 8;  break;
        case 10: v = e->oamloop; w = 7;  break;
        case 11: v = e->stpid1; w = 6;  break;
        case 12: v = e->twintpid; w = 8;  break;
        case 13: v = e->pbb; w = 3;  break;
        case 14: v = e->ipv4mc; w = 6;  break;
        case 15: v = e->state; w = 5;  break;
        case 16: v = e->pport; w = 5;  break;
        case 17: v = e->htype; w = 5;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2xx_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
        continue;

    bigfield:
        digits = (width + 7) / 8;
        if ((col + w + 1 + 5 * digits) > 72) {
            soc_cm_print("\n  ");
            col=2;
        }
        soc_cm_print("%s=", fd->name);
        col += w + 1;
        for (j = 0; j < digits; j++) {
            soc_cm_print("0x%02x ", s[digits - j - 1]);
            col += 5;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for p2e20 */
int soc_sbx_g2xx_p2e20_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2xx_p2e20_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2xx_p2e20_t e0;
    soc_sbx_g2xx_p2e20_t *e = &e0;
    int rv;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_P2E20_ID];
    int iport;
    void *indexpointers[1];

    indexpointers[0] = &iport;
    {
        rv = soc_sbx_g2xx_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2xx_p2e20_get(unit,
                iport,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2xx_indexes_print(indexpointers, ed);
        soc_sbx_g2xx_p2e20_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for p2e20 */
int soc_sbx_g2xx_p2e20_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2xx_p2e20_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2xx_p2e20_t e0;
    soc_sbx_g2xx_p2e20_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_P2E20_ID];
    int iport;
    void *indexpointers[1];

    indexpointers[0] = &iport;

    rv = soc_sbx_g2xx_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2xx_p2e20_t_init(e);

    rv = soc_sbx_g2xx_p2e20_get(unit,
                iport,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2xx_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2xx_value_read(&e->port,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2xx_value_read(&e->nativevid,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2xx_value_read(&e->defcfi,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2xx_value_read(&e->defpri,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2xx_value_read(&e->defstrip,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g2xx_value_read(&e->pstrip,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g2xx_value_read(&e->mim,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g2xx_big_value_read(e->mask,
                                ed->fields[7].width, 0, argc, argv);
                 break;
        case 8: rv = soc_sbx_g2xx_value_read(&e->customer,
                                ed->fields[8].range, 0, argc, argv);
                 break;
        case 9: rv = soc_sbx_g2xx_value_read(&e->provider,
                                ed->fields[9].range, 0, argc, argv);
                 break;
        case 10: rv = soc_sbx_g2xx_value_read(&e->oamloop,
                                ed->fields[10].range, 0, argc, argv);
                 break;
        case 11: rv = soc_sbx_g2xx_value_read(&e->stpid1,
                                ed->fields[11].range, 0, argc, argv);
                 break;
        case 12: rv = soc_sbx_g2xx_value_read(&e->twintpid,
                                ed->fields[12].range, 0, argc, argv);
                 break;
        case 13: rv = soc_sbx_g2xx_value_read(&e->pbb,
                                ed->fields[13].range, 0, argc, argv);
                 break;
        case 14: rv = soc_sbx_g2xx_value_read(&e->ipv4mc,
                                ed->fields[14].range, 0, argc, argv);
                 break;
        case 15: rv = soc_sbx_g2xx_value_read(&e->state,
                                ed->fields[15].range, 0, argc, argv);
                 break;
        case 16: rv = soc_sbx_g2xx_value_read(&e->pport,
                                ed->fields[16].range, 0, argc, argv);
                 break;
        case 17: rv = soc_sbx_g2xx_value_read(&e->htype,
                                ed->fields[17].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2xx_p2e20_set(unit,
                iport,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for ep2e20 */
void soc_sbx_g2xx_ep2e20_print(int unit, 
    soc_sbx_g2xx_ep2e20_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2xx_field_desc_t *fd;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_EP2E20_ID];

    int j, digits;
    uint8 *s;
    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->mim; w = 3;  break;
        case 1: v = e->pid; w = 3;  break;
        case 2: v = e->stpid0; w = 6;  break;
        case 3: v = e->stpid1; w = 6;  break;
        case 4: v = e->customer; w = 8;  break;
        case 5: v = e->keeperh; w = 7;  break;
        case 6: v = e->port; w = 4;  break;
        case 7: v = e->mirroridx; w = 9;  break;
        case 8: s = e->mask; w = 4; goto bigfield;
        case 9: v = e->oamloop; w = 7;  break;
        case 10: v = e->pbb; w = 3;  break;
        case 11: v = e->state; w = 5;  break;
        case 12: v = e->htype; w = 5;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2xx_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
        continue;

    bigfield:
        digits = (width + 7) / 8;
        if ((col + w + 1 + 5 * digits) > 72) {
            soc_cm_print("\n  ");
            col=2;
        }
        soc_cm_print("%s=", fd->name);
        col += w + 1;
        for (j = 0; j < digits; j++) {
            soc_cm_print("0x%02x ", s[digits - j - 1]);
            col += 5;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ep2e20 */
int soc_sbx_g2xx_ep2e20_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2xx_ep2e20_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2xx_ep2e20_t e0;
    soc_sbx_g2xx_ep2e20_t *e = &e0;
    int rv;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_EP2E20_ID];
    int iport;
    void *indexpointers[1];

    indexpointers[0] = &iport;
    {
        rv = soc_sbx_g2xx_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2xx_ep2e20_get(unit,
                iport,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2xx_indexes_print(indexpointers, ed);
        soc_sbx_g2xx_ep2e20_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ep2e20 */
int soc_sbx_g2xx_ep2e20_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2xx_ep2e20_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2xx_ep2e20_t e0;
    soc_sbx_g2xx_ep2e20_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_EP2E20_ID];
    int iport;
    void *indexpointers[1];

    indexpointers[0] = &iport;

    rv = soc_sbx_g2xx_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2xx_ep2e20_t_init(e);

    rv = soc_sbx_g2xx_ep2e20_get(unit,
                iport,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2xx_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2xx_value_read(&e->mim,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2xx_value_read(&e->pid,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2xx_value_read(&e->stpid0,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2xx_value_read(&e->stpid1,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2xx_value_read(&e->customer,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g2xx_value_read(&e->keeperh,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g2xx_value_read(&e->port,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g2xx_value_read(&e->mirroridx,
                                ed->fields[7].range, 0, argc, argv);
                 break;
        case 8: rv = soc_sbx_g2xx_big_value_read(e->mask,
                                ed->fields[8].width, 0, argc, argv);
                 break;
        case 9: rv = soc_sbx_g2xx_value_read(&e->oamloop,
                                ed->fields[9].range, 0, argc, argv);
                 break;
        case 10: rv = soc_sbx_g2xx_value_read(&e->pbb,
                                ed->fields[10].range, 0, argc, argv);
                 break;
        case 11: rv = soc_sbx_g2xx_value_read(&e->state,
                                ed->fields[11].range, 0, argc, argv);
                 break;
        case 12: rv = soc_sbx_g2xx_value_read(&e->htype,
                                ed->fields[12].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2xx_ep2e20_set(unit,
                iport,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for p2e25 */
void soc_sbx_g2xx_p2e25_print(int unit, 
    soc_sbx_g2xx_p2e25_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2xx_field_desc_t *fd;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_P2E25_ID];

    int j, digits;
    uint8 *s;
    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->port; w = 4;  break;
        case 1: v = e->nativevid; w = 9;  break;
        case 2: v = e->defcfi; w = 6;  break;
        case 3: v = e->defpri; w = 6;  break;
        case 4: v = e->defstrip; w = 8;  break;
        case 5: v = e->pstrip; w = 6;  break;
        case 6: v = e->mim; w = 3;  break;
        case 7: s = e->mask; w = 4; goto bigfield;
        case 8: v = e->customer; w = 8;  break;
        case 9: v = e->provider; w = 8;  break;
        case 10: v = e->oamloop; w = 7;  break;
        case 11: v = e->stpid1; w = 6;  break;
        case 12: v = e->twintpid; w = 8;  break;
        case 13: v = e->pbb; w = 3;  break;
        case 14: v = e->ipv4mc; w = 6;  break;
        case 15: v = e->state; w = 5;  break;
        case 16: v = e->pport; w = 5;  break;
        case 17: v = e->htype; w = 5;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2xx_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
        continue;

    bigfield:
        digits = (width + 7) / 8;
        if ((col + w + 1 + 5 * digits) > 72) {
            soc_cm_print("\n  ");
            col=2;
        }
        soc_cm_print("%s=", fd->name);
        col += w + 1;
        for (j = 0; j < digits; j++) {
            soc_cm_print("0x%02x ", s[digits - j - 1]);
            col += 5;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for p2e25 */
int soc_sbx_g2xx_p2e25_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2xx_p2e25_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2xx_p2e25_t e0;
    soc_sbx_g2xx_p2e25_t *e = &e0;
    int rv;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_P2E25_ID];
    int iport;
    void *indexpointers[1];

    indexpointers[0] = &iport;
    {
        rv = soc_sbx_g2xx_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2xx_p2e25_get(unit,
                iport,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2xx_indexes_print(indexpointers, ed);
        soc_sbx_g2xx_p2e25_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for p2e25 */
int soc_sbx_g2xx_p2e25_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2xx_p2e25_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2xx_p2e25_t e0;
    soc_sbx_g2xx_p2e25_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_P2E25_ID];
    int iport;
    void *indexpointers[1];

    indexpointers[0] = &iport;

    rv = soc_sbx_g2xx_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2xx_p2e25_t_init(e);

    rv = soc_sbx_g2xx_p2e25_get(unit,
                iport,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2xx_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2xx_value_read(&e->port,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2xx_value_read(&e->nativevid,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2xx_value_read(&e->defcfi,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2xx_value_read(&e->defpri,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2xx_value_read(&e->defstrip,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g2xx_value_read(&e->pstrip,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g2xx_value_read(&e->mim,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g2xx_big_value_read(e->mask,
                                ed->fields[7].width, 0, argc, argv);
                 break;
        case 8: rv = soc_sbx_g2xx_value_read(&e->customer,
                                ed->fields[8].range, 0, argc, argv);
                 break;
        case 9: rv = soc_sbx_g2xx_value_read(&e->provider,
                                ed->fields[9].range, 0, argc, argv);
                 break;
        case 10: rv = soc_sbx_g2xx_value_read(&e->oamloop,
                                ed->fields[10].range, 0, argc, argv);
                 break;
        case 11: rv = soc_sbx_g2xx_value_read(&e->stpid1,
                                ed->fields[11].range, 0, argc, argv);
                 break;
        case 12: rv = soc_sbx_g2xx_value_read(&e->twintpid,
                                ed->fields[12].range, 0, argc, argv);
                 break;
        case 13: rv = soc_sbx_g2xx_value_read(&e->pbb,
                                ed->fields[13].range, 0, argc, argv);
                 break;
        case 14: rv = soc_sbx_g2xx_value_read(&e->ipv4mc,
                                ed->fields[14].range, 0, argc, argv);
                 break;
        case 15: rv = soc_sbx_g2xx_value_read(&e->state,
                                ed->fields[15].range, 0, argc, argv);
                 break;
        case 16: rv = soc_sbx_g2xx_value_read(&e->pport,
                                ed->fields[16].range, 0, argc, argv);
                 break;
        case 17: rv = soc_sbx_g2xx_value_read(&e->htype,
                                ed->fields[17].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2xx_p2e25_set(unit,
                iport,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for ep2e25 */
void soc_sbx_g2xx_ep2e25_print(int unit, 
    soc_sbx_g2xx_ep2e25_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2xx_field_desc_t *fd;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_EP2E25_ID];

    int j, digits;
    uint8 *s;
    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->mim; w = 3;  break;
        case 1: v = e->pid; w = 3;  break;
        case 2: v = e->stpid0; w = 6;  break;
        case 3: v = e->stpid1; w = 6;  break;
        case 4: v = e->customer; w = 8;  break;
        case 5: v = e->keeperh; w = 7;  break;
        case 6: v = e->port; w = 4;  break;
        case 7: v = e->mirroridx; w = 9;  break;
        case 8: s = e->mask; w = 4; goto bigfield;
        case 9: v = e->oamloop; w = 7;  break;
        case 10: v = e->pbb; w = 3;  break;
        case 11: v = e->state; w = 5;  break;
        case 12: v = e->htype; w = 5;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2xx_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
        continue;

    bigfield:
        digits = (width + 7) / 8;
        if ((col + w + 1 + 5 * digits) > 72) {
            soc_cm_print("\n  ");
            col=2;
        }
        soc_cm_print("%s=", fd->name);
        col += w + 1;
        for (j = 0; j < digits; j++) {
            soc_cm_print("0x%02x ", s[digits - j - 1]);
            col += 5;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for ep2e25 */
int soc_sbx_g2xx_ep2e25_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2xx_ep2e25_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2xx_ep2e25_t e0;
    soc_sbx_g2xx_ep2e25_t *e = &e0;
    int rv;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_EP2E25_ID];
    int iport;
    void *indexpointers[1];

    indexpointers[0] = &iport;
    {
        rv = soc_sbx_g2xx_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2xx_ep2e25_get(unit,
                iport,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2xx_indexes_print(indexpointers, ed);
        soc_sbx_g2xx_ep2e25_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for ep2e25 */
int soc_sbx_g2xx_ep2e25_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2xx_ep2e25_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2xx_ep2e25_t e0;
    soc_sbx_g2xx_ep2e25_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_EP2E25_ID];
    int iport;
    void *indexpointers[1];

    indexpointers[0] = &iport;

    rv = soc_sbx_g2xx_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2xx_ep2e25_t_init(e);

    rv = soc_sbx_g2xx_ep2e25_get(unit,
                iport,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2xx_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2xx_value_read(&e->mim,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2xx_value_read(&e->pid,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2xx_value_read(&e->stpid0,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2xx_value_read(&e->stpid1,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2xx_value_read(&e->customer,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g2xx_value_read(&e->keeperh,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g2xx_value_read(&e->port,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        case 7: rv = soc_sbx_g2xx_value_read(&e->mirroridx,
                                ed->fields[7].range, 0, argc, argv);
                 break;
        case 8: rv = soc_sbx_g2xx_big_value_read(e->mask,
                                ed->fields[8].width, 0, argc, argv);
                 break;
        case 9: rv = soc_sbx_g2xx_value_read(&e->oamloop,
                                ed->fields[9].range, 0, argc, argv);
                 break;
        case 10: rv = soc_sbx_g2xx_value_read(&e->pbb,
                                ed->fields[10].range, 0, argc, argv);
                 break;
        case 11: rv = soc_sbx_g2xx_value_read(&e->state,
                                ed->fields[11].range, 0, argc, argv);
                 break;
        case 12: rv = soc_sbx_g2xx_value_read(&e->htype,
                                ed->fields[12].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2xx_ep2e25_set(unit,
                iport,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for tpid */
void soc_sbx_g2xx_tpid_print(int unit, 
    soc_sbx_g2xx_tpid_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2xx_field_desc_t *fd;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_TPID_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->tpid; w = 4;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2xx_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for tpid */
int soc_sbx_g2xx_tpid_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2xx_tpid_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2xx_tpid_t e0;
    soc_sbx_g2xx_tpid_t *e = &e0;
    int rv;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_TPID_ID];
    int itpidi;
    void *indexpointers[1];

    indexpointers[0] = &itpidi;
    {
        rv = soc_sbx_g2xx_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2xx_tpid_get(unit,
                itpidi,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2xx_indexes_print(indexpointers, ed);
        soc_sbx_g2xx_tpid_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for tpid */
int soc_sbx_g2xx_tpid_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2xx_tpid_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2xx_tpid_t e0;
    soc_sbx_g2xx_tpid_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_TPID_ID];
    int itpidi;
    void *indexpointers[1];

    indexpointers[0] = &itpidi;

    rv = soc_sbx_g2xx_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2xx_tpid_t_init(e);

    rv = soc_sbx_g2xx_tpid_get(unit,
                itpidi,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2xx_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2xx_value_read(&e->tpid,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2xx_tpid_set(unit,
                itpidi,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for lsmac */
void soc_sbx_g2xx_lsmac_print(int unit, 
    soc_sbx_g2xx_lsmac_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2xx_field_desc_t *fd;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_LSMAC_ID];

    int j, digits;
    uint8 *s;
    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->port; w = 4;  break;
        case 1: v = e->useport; w = 7;  break;
        case 2: s = e->mac; w = 3; goto bigfield;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2xx_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
        continue;

    bigfield:
        digits = (width + 7) / 8;
        if ((col + w + 1 + 5 * digits) > 72) {
            soc_cm_print("\n  ");
            col=2;
        }
        soc_cm_print("%s=", fd->name);
        col += w + 1;
        for (j = 0; j < digits; j++) {
            soc_cm_print("0x%02x ", s[digits - j - 1]);
            col += 5;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for lsmac */
int soc_sbx_g2xx_lsmac_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2xx_lsmac_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2xx_lsmac_t e0;
    soc_sbx_g2xx_lsmac_t *e = &e0;
    int rv;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_LSMAC_ID];
    int ilsi;
    void *indexpointers[1];

    indexpointers[0] = &ilsi;
    {
        rv = soc_sbx_g2xx_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2xx_lsmac_get(unit,
                ilsi,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2xx_indexes_print(indexpointers, ed);
        soc_sbx_g2xx_lsmac_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for lsmac */
int soc_sbx_g2xx_lsmac_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2xx_lsmac_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2xx_lsmac_t e0;
    soc_sbx_g2xx_lsmac_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_LSMAC_ID];
    int ilsi;
    void *indexpointers[1];

    indexpointers[0] = &ilsi;

    rv = soc_sbx_g2xx_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2xx_lsmac_t_init(e);

    rv = soc_sbx_g2xx_lsmac_get(unit,
                ilsi,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2xx_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2xx_value_read(&e->port,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2xx_value_read(&e->useport,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2xx_big_value_read(e->mac,
                                ed->fields[2].width, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2xx_lsmac_set(unit,
                ilsi,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for xt */
void soc_sbx_g2xx_xt_print(int unit, 
    soc_sbx_g2xx_xt_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2xx_field_desc_t *fd;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_XT_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->forward; w = 7;  break;
        case 1: v = e->dp; w = 2;  break;
        case 2: v = e->qid; w = 3;  break;
        case 3: v = e->trunc; w = 5;  break;
        case 4: v = e->learn; w = 5;  break;
        case 5: v = e->ppspolice; w = 9;  break;
        case 6: v = e->policer; w = 7;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2xx_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry diag shell print implementation for xt */
int soc_sbx_g2xx_xt_shell_print(int unit,
             int argc, char **argv);
int
soc_sbx_g2xx_xt_shell_print(int unit,
         int argc, char **argv)
{
    soc_sbx_g2xx_xt_t e0;
    soc_sbx_g2xx_xt_t *e = &e0;
    int rv;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_XT_ID];
    int ixi;
    void *indexpointers[1];

    indexpointers[0] = &ixi;
    {
        rv = soc_sbx_g2xx_indexes_read(indexpointers, ed, argc, argv);
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        if (rv != argc) {
            soc_cm_print("'%s' is not a valid index for %s\n",
                    argv[rv], ed->name);
            return SOC_E_PARAM;
        }
    }

    do {
        rv = soc_sbx_g2xx_xt_get(unit,
                ixi,
                e);

        if (rv) {
            soc_cm_print("get of %s failed\n", ed->name);
            return rv;
        }

        soc_sbx_g2xx_indexes_print(indexpointers, ed);
        soc_sbx_g2xx_xt_print(unit, e);
    } while (0);

    return SOC_E_NONE;
}

/* entry diag shell set implementation for xt */
int soc_sbx_g2xx_xt_shell_set(int unit,
                int argc, char **argv);
int soc_sbx_g2xx_xt_shell_set(int unit,
                int argc, char **argv)
{
    soc_sbx_g2xx_xt_t e0;
    soc_sbx_g2xx_xt_t *e = &e0;
    int rv, fidx;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_XT_ID];
    int ixi;
    void *indexpointers[1];

    indexpointers[0] = &ixi;

    rv = soc_sbx_g2xx_indexes_read(indexpointers, ed, argc, argv);
    if (rv < 0) {
        return SOC_E_PARAM;
    }
    argv += rv;
    argc -= rv;

    soc_sbx_g2xx_xt_t_init(e);

    rv = soc_sbx_g2xx_xt_get(unit,
                ixi,
                e);

    if (rv && rv != SOC_E_NOT_FOUND) {
        soc_cm_print("get of %s failed\n", ed->name);
        return rv;
    }
    
    while (argc) {
        fidx = soc_sbx_g2xx_field_find(ed, argv[0]);
        if (fidx < 0) {
            soc_cm_print("unexpected field name '%s'\n", argv[0]);
            return SOC_E_PARAM;
        }
        switch (fidx) {
        case 0: rv = soc_sbx_g2xx_value_read(&e->forward,
                                ed->fields[0].range, 0, argc, argv);
                 break;
        case 1: rv = soc_sbx_g2xx_value_read(&e->dp,
                                ed->fields[1].range, 0, argc, argv);
                 break;
        case 2: rv = soc_sbx_g2xx_value_read(&e->qid,
                                ed->fields[2].range, 0, argc, argv);
                 break;
        case 3: rv = soc_sbx_g2xx_value_read(&e->trunc,
                                ed->fields[3].range, 0, argc, argv);
                 break;
        case 4: rv = soc_sbx_g2xx_value_read(&e->learn,
                                ed->fields[4].range, 0, argc, argv);
                 break;
        case 5: rv = soc_sbx_g2xx_value_read(&e->ppspolice,
                                ed->fields[5].range, 0, argc, argv);
                 break;
        case 6: rv = soc_sbx_g2xx_value_read(&e->policer,
                                ed->fields[6].range, 0, argc, argv);
                 break;
        }
        if (rv < 0) {
            return SOC_E_PARAM;
        }
        argc -= rv;
        argv += rv;
    }
    rv = soc_sbx_g2xx_xt_set(unit,
                ixi,
                e);

    if (rv) {
        soc_cm_print("set of %s failed\n", ed->name);
        return rv;
    }
    return SOC_E_NONE;
}

/* entry print accessor implementation for policer */
void soc_sbx_g2xx_policer_print(int unit, 
    soc_sbx_g2xx_policer_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2xx_field_desc_t *fd;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_POLICER_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->cbsbytes; w = 8;  break;
        case 1: v = e->cirkbps; w = 7;  break;
        case 2: v = e->ebsbytes; w = 8;  break;
        case 3: v = e->eirkbps; w = 7;  break;
        case 4: v = e->mode; w = 4;  break;
        case 5: v = e->lenshift; w = 8;  break;
        case 6: v = e->colorblind; w = 10;  break;
        case 7: v = e->dropred; w = 7;  break;
        case 8: v = e->coupling; w = 8;  break;
        case 9: v = e->nodebit; w = 7;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2xx_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry print accessor implementation for timer */
void soc_sbx_g2xx_timer_print(int unit, 
    soc_sbx_g2xx_timer_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2xx_field_desc_t *fd;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_TIMER_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->ms; w = 2;  break;
        case 1: v = e->started; w = 7;  break;
        case 2: v = e->ucodereset; w = 10;  break;
        case 3: v = e->interrupt; w = 9;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2xx_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/* entry print accessor implementation for sequence */
void soc_sbx_g2xx_sequence_print(int unit, 
    soc_sbx_g2xx_sequence_t *e)
{
    int i, col, width, iffok, w = 0;
    uint32 v = 0;
    soc_sbx_g2xx_field_desc_t *fd;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_entry_desc_t *ed =
        &tm->entries[SOC_SBX_G2XX_SEQUENCE_ID];

    soc_cm_print("  ");
    col=2;
    for(i = 0; i < ed->nfields; i++) {
        fd = &ed->fields[i];
        width = fd->width;
        iffok = 1;
        switch (i) {
        case 0: v = e->seqnum; w = 6;  break;
        }

        if (iffok) {
            if (col + w + 1 + 2 + (width + 3) / 4 > 72) {
                soc_cm_print("\n  ");
                col=2;
            }
            soc_cm_print("%s=", fd->name);
            col += w + 1;
            w = soc_sbx_g2xx_print(fd->range, v);
            col += w;
            soc_cm_print(" ");
            col++;
        }
    }
    soc_cm_print("\n");
}

/*
 * Shell entry print implementation
 */
int soc_sbx_g2xx_entries_shell_print(int unit,
             int eid, int argc, char **argv);
int
soc_sbx_g2xx_entries_shell_print(int unit,
         int eid, int argc, char **argv)
{
    int rv;
    switch (eid) {
    case SOC_SBX_G2XX_P2E_ID:
        rv = soc_sbx_g2xx_p2e_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2XX_EP2E_ID:
        rv = soc_sbx_g2xx_ep2e_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2XX_P2E20_ID:
        rv = soc_sbx_g2xx_p2e20_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2XX_EP2E20_ID:
        rv = soc_sbx_g2xx_ep2e20_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2XX_P2E25_ID:
        rv = soc_sbx_g2xx_p2e25_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2XX_EP2E25_ID:
        rv = soc_sbx_g2xx_ep2e25_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2XX_TPID_ID:
        rv = soc_sbx_g2xx_tpid_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2XX_LSMAC_ID:
        rv = soc_sbx_g2xx_lsmac_shell_print(unit, argc, argv); break;
    case SOC_SBX_G2XX_XT_ID:
        rv = soc_sbx_g2xx_xt_shell_print(unit, argc, argv); break;
    default: rv = SOC_E_NOT_FOUND;
    }
    return rv;
}

/*
 * Shell entry set implementation
 */
int soc_sbx_g2xx_entries_shell_set(int unit, 
             int eid, int argc, char **argv);
int
soc_sbx_g2xx_entries_shell_set(int unit, 
         int eid, int argc, char **argv)
{
    int rv;
    switch (eid) {
    case SOC_SBX_G2XX_P2E_ID:
        rv = soc_sbx_g2xx_p2e_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2XX_EP2E_ID:
        rv = soc_sbx_g2xx_ep2e_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2XX_P2E20_ID:
        rv = soc_sbx_g2xx_p2e20_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2XX_EP2E20_ID:
        rv = soc_sbx_g2xx_ep2e20_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2XX_P2E25_ID:
        rv = soc_sbx_g2xx_p2e25_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2XX_EP2E25_ID:
        rv = soc_sbx_g2xx_ep2e25_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2XX_TPID_ID:
        rv = soc_sbx_g2xx_tpid_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2XX_LSMAC_ID:
        rv = soc_sbx_g2xx_lsmac_shell_set(unit, argc, argv); break;
    case SOC_SBX_G2XX_XT_ID:
        rv = soc_sbx_g2xx_xt_shell_set(unit, argc, argv); break;
    default: rv = SOC_E_NOT_FOUND;
    }
    return rv;
}

/*
 * Shell entry delete implementation
 */
int soc_sbx_g2xx_entries_shell_delete(int unit, 
             int eid, int argc, char **argv);
int
soc_sbx_g2xx_entries_shell_delete(int unit, 
         int eid, int argc, char **argv)
{
    int rv;
    switch (eid) {
    default: rv = SOC_E_NOT_FOUND;
    }
    return rv;
}

/* Diag shell print counter memory contents */
int soc_sbx_g2xx_counters_shell_print(int unit,
                int cid, int argc, char **argv);
int soc_sbx_g2xx_counters_shell_print(int unit,
                int cid, int argc, char **argv)
{
    int rv, i;
    soc_sbx_g2xx_counter_value_t cv;
    uint32 lo, hi;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_counter_desc_t *cd = &tm->counters[cid];
    int clear = 1;
    int all   = 0;
    int print = 1;
    int lower = 0;
    int upper = cd->size - 1;
    int sang = 0;

    rv = soc_sbx_g2xx_range_parse(argc, argv, &lower, &upper,
                 &all, "all", &clear, "clear", &print, "print");
    if (rv) {
        return rv;
    }

    sang = 0;
    for (i = lower; i <= upper; i++) {
        switch (cid) {
        default: soc_cm_print("bogus counter ID\n"); return SOC_E_INTERNAL;      
        }
        
        if (print
            && (!COMPILER_64_IS_ZERO(cv.bytes)
                || !COMPILER_64_IS_ZERO(cv.bytes))) {
            soc_sbx_g2xx_print(cd->size, i);
            lo = COMPILER_64_LO(cv.bytes);
            hi = COMPILER_64_HI(cv.bytes);
            soc_cm_print(" 0x%08x%08x bytes, ", hi, lo);
            lo = COMPILER_64_LO(cv.packets);
            hi = COMPILER_64_HI(cv.packets);
            soc_cm_print("0x%08x%08x packets\n", hi, lo);
            sang = 1;
            if (!all) {
                break;
            }
        }
    }

    if (print && !sang) {
        soc_cm_print("no nonzero counters\n");
    }

    return SOC_E_NONE;
}

/* Policers shell print */
int soc_sbx_g2xx_policers_shell_print(int unit,
                int pid, int argc, char **argv);
int soc_sbx_g2xx_policers_shell_print(int unit,
                int pid, int argc, char **argv)
{
    soc_cm_print("no valid policers\n");
    return SOC_E_NONE;
}

/* Policer shell set */
int soc_sbx_g2xx_policers_shell_set(int unit,
                int pid, int argc, char **argv);
int soc_sbx_g2xx_policers_shell_set(int unit,
                int pid, int argc, char **argv)
{
    int rv;
    switch (pid) {
    default:
        soc_cm_print("unexpected policer bank id: %d\n", pid);
        return SOC_E_INTERNAL;
    }

    return rv;
}

/* Policer shell delete */
int soc_sbx_g2xx_policers_shell_delete(int unit,
                int pid, int argc, char **argv);
int soc_sbx_g2xx_policers_shell_delete(int unit,
                int pid, int argc, char **argv)
{
    soc_cm_print("no valid policers\n");
    return SOC_E_NONE;
}

/* Diag shell print memory contents */
int soc_sbx_g2xx_memory_shell_print(int unit,
             int mid, int argc, char **argv);
int
soc_sbx_g2xx_memory_shell_print(int unit,
         int mid, int argc, char **argv)
{
    int rv, i, words, offset, iscnt, shimword;
    uint32 addr, v, prot, protsave = 0;
    char *name;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_memory_desc_t *md = &tm->memories[mid];
    int mwidth = md->width;
    int opcode;

    if (argc == 0) {
        soc_cm_print("missing address\n");
        return SOC_E_PARAM;
    }
    rv = soc_sbx_g2xx_read(argv[0], 1 << 23, &addr);
    if (rv) {
        soc_cm_print("illegal address %s\n", argv[0]);
        return SOC_E_PARAM;
    }

    rv = soc_sbx_g2xx_memory_bank_find(tm,
                  md, (int) addr, &name, &offset, &iscnt);
    if (rv) {
        soc_cm_print("illegal address %s\n", argv[0]);
        return rv;
    }

    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    if (iscnt) {
        switch (mid) {
        case SOC_SBX_G2XX_MM0_NAR0_ID:
            protsave
                = SAND_HAL_FE2000_READ_STRIDE(fe->regSet, MM, 0,
                                              MM_PROT_SCHEME0);
            prot = SAND_HAL_FE2000_MOD_FIELD(fe->regSet, MM_PROT_SCHEME0,
                                             NP0_PI_SCHEME,
                                             protsave,
                                             SB_FE2000_MM_35BITS_1BITPARITY);
            SAND_HAL_FE2000_WRITE_STRIDE(fe->regSet, MM, 0, MM_PROT_SCHEME0,
                                         prot);
            break;
        case SOC_SBX_G2XX_MM0_NAR1_ID:
            protsave
                = SAND_HAL_FE2000_READ_STRIDE(fe->regSet, MM, 0,
                                              MM_PROT_SCHEME0);
            prot = SAND_HAL_FE2000_MOD_FIELD(fe->regSet, MM_PROT_SCHEME0,
                                             NP1_PI_SCHEME,
                                             protsave,
                                             SB_FE2000_MM_35BITS_1BITPARITY);
            SAND_HAL_FE2000_WRITE_STRIDE(fe->regSet, MM, 0, MM_PROT_SCHEME0,
                                         prot);
            break;
        case SOC_SBX_G2XX_MM1_NAR0_ID:
            protsave
                = SAND_HAL_FE2000_READ_STRIDE(fe->regSet, MM, 1,
                                              MM_PROT_SCHEME0);
            prot = SAND_HAL_FE2000_MOD_FIELD(fe->regSet, MM_PROT_SCHEME0,
                                             NP0_PI_SCHEME,
                                             protsave,
                                             SB_FE2000_MM_35BITS_1BITPARITY);
            SAND_HAL_FE2000_WRITE_STRIDE(fe->regSet, MM, 1, MM_PROT_SCHEME0,
                                         prot);
            break;
        case SOC_SBX_G2XX_MM1_NAR1_ID:
            protsave
                = SAND_HAL_FE2000_READ_STRIDE(fe->regSet, MM, 1,
                                              MM_PROT_SCHEME0);
            prot = SAND_HAL_FE2000_MOD_FIELD(fe->regSet, MM_PROT_SCHEME0,
                                             NP1_PI_SCHEME,
                                             protsave,
                                             SB_FE2000_MM_35BITS_1BITPARITY);
            SAND_HAL_FE2000_WRITE_STRIDE(fe->regSet, MM, 1, MM_PROT_SCHEME0,
                                         prot);
            break;
        case SOC_SBX_G2XX_MM0_INT0_ID:
        case SOC_SBX_G2XX_MM0_INT1_ID:
        case SOC_SBX_G2XX_MM1_INT0_ID:
        case SOC_SBX_G2XX_MM1_INT1_ID:
            break;
        default:
            soc_cm_print("unexpected counter memory: %d\n", mid);
            sal_mutex_give(tm->dmabufmutex);
            return SOC_E_INTERNAL;
        }
        mwidth = 35;
    }

    words = (mwidth + 31) / 32;
    shimword = words < 2 && mid <= SOC_SBX_G2XX_MM1_INT1_ID;
    words += shimword;

    if (md->dma) {
        opcode = SB_FE2000_DMA_OPCODE_READ;
        tm->entrydmaop.opcode = opcode;
        tm->entrydmaop.words = (uint32) ((mwidth + 31) / 32);
        tm->entrydmaop.hostAddress = 
            (uint32 *) (tm->entrydmabuf);
        /*offset = (uint32) 
            (tb->base + ((idx * eb->stridebits) / mwidth));*/
          tm->entrydmaop.hostBusAddress = tm->entrydmabufhba; /*+ bytes;*/
          tm->entrydmaop.feAddress = (uint32)
            SB_FE2000_DMA_MAKE_ADDRESS(mid, addr);
          rv = sbFe2000DmaRequest(fe->pDmaMgr, INT_TO_PTR(unit),
                                 &tm->entrydmaop);
    }else{
        rv = sbFe2000UtilReadIndir(fe->regSet, 1, md->descending,
                               md->reg, addr, words,
                               (uint32 *) tm->entrydmabuf);
    }

    if (iscnt) {
        switch (mid) {
        case SOC_SBX_G2XX_MM0_NAR0_ID:
        case SOC_SBX_G2XX_MM0_NAR1_ID:
            SAND_HAL_FE2000_WRITE_STRIDE(fe->regSet, MM, 0, MM_PROT_SCHEME0,
                                  protsave);
            break;
        case SOC_SBX_G2XX_MM1_NAR0_ID:
        case SOC_SBX_G2XX_MM1_NAR1_ID:
            SAND_HAL_FE2000_WRITE_STRIDE(fe->regSet, MM, 1, MM_PROT_SCHEME0,
                                  protsave);
            break;
        }
    }

    if (rv) {
        soc_cm_print("memory read from %s[0x%x] failed\n",
                tm->memories[mid].name, addr);
        sal_mutex_give(tm->dmabufmutex);
        return SOC_E_FAIL;
    }
        
    soc_cm_print("%s[0x%x]=",  tm->memories[mid].name, addr);
    if (name) {
        soc_cm_print("%s[0x%x]=", name, offset);
    }
    for (i = 0; i < words - shimword; i++) {
      v = tm->entrydmabuf[i * 4 + 0]
          | (tm->entrydmabuf[i * 4 + 1] << 8)
          | (tm->entrydmabuf[i * 4 + 2] << 16)
          | (tm->entrydmabuf[i * 4 + 3] << 24);
      soc_sbx_g2xx_print(-1, v);
      soc_cm_print(" ");
    }
    soc_cm_print("\n");
    sal_mutex_give(tm->dmabufmutex);
    return SOC_E_NONE;
}

/* Diag shell set memory contents */
int soc_sbx_g2xx_memory_shell_set(int unit, 
             int mid, int argc, char **argv);
int
soc_sbx_g2xx_memory_shell_set(int unit, 
         int mid, int argc, char **argv)
{
    int rv, i, offset, iscnt, words, shimword;
    uint32 v, addr, prot, protsave = 0;
    char *name;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_memory_desc_t *md = &tm->memories[mid];
    int mwidth = md->width;
    int opcode;

    if (argc == 0) {
        soc_cm_print("missing address\n");
        return SOC_E_PARAM;
    }

    rv = soc_sbx_g2xx_read(argv[0], 1 << 23, &addr);
    if (rv) {
        soc_cm_print("illegal address %s\n", argv[0]);
        return 0;
    }
    argc--;
    argv++;

    rv = soc_sbx_g2xx_memory_bank_find(tm,
                  md, (int) addr, &name, &offset, &iscnt);
    if (rv) {
        soc_cm_print("illegal address %s\n", argv[0]);
        return rv;
    }
    if (iscnt) {
        mwidth = 35;
    }

    words = (mwidth + 31) / 32;
    shimword = words < 2 && mid <= SOC_SBX_G2XX_MM1_INT1_ID;
    words += shimword;

    sal_mutex_take(tm->dmabufmutex, sal_mutex_FOREVER);
    for (i = 0; i < words - shimword; i++) {
        if (!argc) {
            soc_cm_print("missing value\n");
            sal_mutex_give(tm->dmabufmutex);
            return SOC_E_PARAM;
        }
          
        rv = soc_sbx_g2xx_read(argv[0],
                    i == words - 1 ? mwidth % 32 : -1, &v);
        if (rv) {
            soc_cm_print("illegal value '%s'\n", argv[i + 1]);
            sal_mutex_give(tm->dmabufmutex);
            return SOC_E_PARAM;
        }
        tm->entrydmabuf[i * 4 + 0] = v;
        tm->entrydmabuf[i * 4 + 1] = v >> 8;
        tm->entrydmabuf[i * 4 + 2] = v >> 16;
        tm->entrydmabuf[i * 4 + 3] = v >> 24;
        argc--;
        argv++;
    }

    if (iscnt) {
        switch (mid) {
        case SOC_SBX_G2XX_MM0_NAR0_ID:
            protsave
                = SAND_HAL_FE2000_READ_STRIDE(fe->regSet, MM, 0,
                                              MM_PROT_SCHEME0);
            prot = SAND_HAL_FE2000_MOD_FIELD(fe->regSet, MM_PROT_SCHEME0,
                                             NP0_PI_SCHEME,
                                             protsave,
                                             SB_FE2000_MM_35BITS_1BITPARITY);
            SAND_HAL_FE2000_WRITE_STRIDE(fe->regSet, MM, 0, MM_PROT_SCHEME0,
                                  prot);
            break;
        case SOC_SBX_G2XX_MM0_NAR1_ID:
            protsave
                = SAND_HAL_FE2000_READ_STRIDE(fe->regSet, MM, 0,
                                              MM_PROT_SCHEME0);
            prot = SAND_HAL_FE2000_MOD_FIELD(fe->regSet, MM_PROT_SCHEME0,
                                             NP1_PI_SCHEME,
                                             protsave,
                                             SB_FE2000_MM_35BITS_1BITPARITY);
            SAND_HAL_FE2000_WRITE_STRIDE(fe->regSet, MM, 0, MM_PROT_SCHEME0,
                                         prot);
            break;
        case SOC_SBX_G2XX_MM1_NAR0_ID:
            protsave
                = SAND_HAL_FE2000_READ_STRIDE(fe->regSet, MM, 1,
                                              MM_PROT_SCHEME0);
            prot = SAND_HAL_FE2000_MOD_FIELD(fe->regSet, MM_PROT_SCHEME0,
                                             NP0_PI_SCHEME,
                                             protsave,
                                             SB_FE2000_MM_35BITS_1BITPARITY);
            SAND_HAL_FE2000_WRITE_STRIDE(fe->regSet, MM, 1,
                                         MM_PROT_SCHEME0,
                                         prot);
            break;
        case SOC_SBX_G2XX_MM1_NAR1_ID:
            protsave
                = SAND_HAL_FE2000_READ_STRIDE(fe->regSet, MM, 1,
                                              MM_PROT_SCHEME0);
            prot = SAND_HAL_FE2000_MOD_FIELD(fe->regSet, MM_PROT_SCHEME0,
                                             NP1_PI_SCHEME,
                                             protsave,
                                             SB_FE2000_MM_35BITS_1BITPARITY);
            SAND_HAL_FE2000_WRITE_STRIDE(fe->regSet, MM, 1, MM_PROT_SCHEME0,
                                         prot);
            break;
        case SOC_SBX_G2XX_MM0_INT0_ID:
        case SOC_SBX_G2XX_MM0_INT1_ID:
        case SOC_SBX_G2XX_MM1_INT0_ID:
        case SOC_SBX_G2XX_MM1_INT1_ID:
            break;
        default:
            soc_cm_print("unexpected counter memory: %d\n", mid);
            sal_mutex_give(tm->dmabufmutex);
            return SOC_E_INTERNAL;
        }
    }

    if (md->dma) {
        opcode = SB_FE2000_DMA_OPCODE_WRITE;
        tm->entrydmaop.opcode = opcode;
        tm->entrydmaop.words = (uint32) ((mwidth + 31) / 32);
        tm->entrydmaop.hostAddress = 
            (uint32 *) (tm->entrydmabuf);
          tm->entrydmaop.hostBusAddress = tm->entrydmabufhba; /*+ bytes;*/
          tm->entrydmaop.feAddress = (uint32)
            SB_FE2000_DMA_MAKE_ADDRESS(mid, addr);
          rv = sbFe2000DmaRequest(fe->pDmaMgr, INT_TO_PTR(unit),
                                 &tm->entrydmaop);
    }else{
        rv = sbFe2000UtilWriteIndir(fe->regSet, 1, md->descending,
                                    md->reg, addr, words, 
                                    (uint32 *) tm->entrydmabuf);
    }

    if (iscnt) {
        switch (mid) {
        case SOC_SBX_G2XX_MM0_NAR0_ID:
        case SOC_SBX_G2XX_MM0_NAR1_ID:
            SAND_HAL_FE2000_WRITE_STRIDE(fe->regSet, MM, 0, MM_PROT_SCHEME0,
                                  protsave);
            break;
        case SOC_SBX_G2XX_MM1_NAR0_ID:
        case SOC_SBX_G2XX_MM1_NAR1_ID:
            SAND_HAL_FE2000_WRITE_STRIDE(fe->regSet, MM, 1, MM_PROT_SCHEME0,
                                  protsave);
            break;
        }
    }

    if (rv) {
        soc_cm_print("memory write to %s[0x%x] failed\n",
                tm->memories[mid].name, addr);
        sal_mutex_give(tm->dmabufmutex);
        return SOC_E_FAIL;
    }

    sal_mutex_give(tm->dmabufmutex);

    return SOC_E_NONE;
}
int soc_sbx_g2xx_memory_map_shell_print(int unit, char *name);
int soc_sbx_g2xx_memory_map_shell_print(int unit, char *name)
{
    int i, j, base, base0, size0, slen;
    int fw = 20;
    char *s;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;
    soc_sbx_g2xx_table_desc_t *td;
    soc_sbx_g2xx_memory_bank_desc_t *mb;

    if (name) {
        for (i = 0; i < SOC_SBX_G2XX_TABLE_MAX_ID; i++) {
            td = &tm->tables[i];
            if (!sal_strcasecmp(td->name, name)) {
                soc_cm_print("\nMemory map for table %s\n", name);
                soc_cm_print("Bank  Memory    Port  Width  Base     Size\n");
                soc_cm_print("-----------------------------------------"
                        "-----\n");
                for (j = 0; j < td->nbanks; j++) {
                    soc_cm_print("%-6d%-11s%-5d%-7d0x%06x 0x%06x\n",
                           j, tm->memories[td->banks[j].memory].name,
                           td->banks[j].memory,
                           td->banks[j].width,
                           td->banks[j].base, td->banks[j].size);
                }
                soc_cm_print("\n");
                return SOC_E_NONE;
            }
        }
        return SOC_E_PARAM;
    } else {
        for (i = 0; i < SOC_SBX_G2XX_MEMORY_MAX_ID; i++) {
            if (tm->memories[i].nbanks) {
                soc_cm_print("Memory map for %s", tm->memories[i].name);
                if (tm->memories[i].dma) {
                    soc_cm_print(" (cpu port %d)", i);
                }
                soc_cm_print("\n%-*s%-*s%s\n",
                        fw, "Element", fw, "Base", "Size");
                soc_cm_print("------------------------------------"
                        "----------------\n");
                base = 0;
                for (j = 0; j < tm->memories[i].nbanks; j++) {
                    mb = &tm->memories[i].banks[j];
                    soc_sbx_g2xx_memory_bank_params_get(&base0, &size0, mb, tm);
                    if (base != base0) {
                        soc_cm_print("%-*s0x%06x%-*s0x%06x\n",
                                fw, "UNUSED", base, fw - 8,
                                "", (base0 - base));
                    }
                    switch (mb->type) {
                    case SOC_SBX_G2XX_TABLE_BANK_TYPE:
                        td = &tm->tables[mb->number];
                        soc_cm_print("%s", td->name);
                        slen = sal_strlen(td->name);
                        if (td->nbanks > 1) {
                            soc_cm_print("%c", '0' + mb->bank);
                            slen++;
                        }
                        soc_cm_print("%*s", fw - slen, "");
                        break;
                    case SOC_SBX_G2XX_COUNTER_BANK_TYPE:
                        s = "counter bank";
                        slen = sal_strlen(s);
                        soc_cm_print("%s %-2d", s, mb->number);
                        soc_cm_print("%*s", fw - slen - 3, "");
                        break;
                    case SOC_SBX_G2XX_POLICER_BANK_TYPE:
                        s = "policer bank";
                        slen = sal_strlen(s);
                        soc_cm_print("%s %-2d", s, mb->number);
                        soc_cm_print("%*s", fw - slen - 3, "");
                    }
                    soc_cm_print("0x%06x%-*s0x%06x\n",
                            base0, fw - 8, "", size0);
                    base = base0 + size0;
                }
                soc_cm_print("%-*s0x%06x\n\n", fw, "END", base);
            }
        }
    }
    return SOC_E_NONE;
}

/*
 * Diag shell print driver implementation
 */
int soc_sbx_g2xx_shell_print(int unit, int argc, char **argv)
{
    int i;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;

    for (i = 0; i < SOC_SBX_G2XX_CONSTANT_MAX_ID; i++) {
        if (!sal_strcasecmp(argv[0], tm->constants[i].name)) {
          return soc_sbx_g2xx_constant_shell_print(unit, i);
        }
    }
    for (i = 0; i < SOC_SBX_G2XX_GLOBAL_MAX_ID; i++) {
        if (!sal_strcasecmp(argv[0], tm->globals[i].name)) {
          return soc_sbx_g2xx_global_shell_print(unit, i);
        }
    }
    for (i = 0; i < SOC_SBX_G2XX_ENTRY_MAX_ID; i++) {
        if (!sal_strcasecmp(argv[0], tm->entries[i].name)
            && tm->entries[i].nindexes) {
            return soc_sbx_g2xx_entries_shell_print(unit,
                            i, argc - 1, &argv[1]);
        }
    }
    for (i = 0; i < SOC_SBX_G2XX_COUNTER_MAX_ID; i++) {
        if (!sal_strcasecmp(argv[0], tm->counters[i].name)) {
            return soc_sbx_g2xx_counters_shell_print(unit,
                            i, argc - 1, &argv[1]);
        }
    }
    for (i = 0; i < SOC_SBX_G2XX_POLICER_MAX_ID; i++) {
        if (!sal_strcasecmp(argv[0], tm->policers[i].name)) {
            return soc_sbx_g2xx_policers_shell_print(unit,
                            i, argc - 1, &argv[1]);
        }
    }
    for (i = 0; i < SOC_SBX_G2XX_MEMORY_MAX_ID; i++) {
        if (!sal_strcasecmp(argv[0], tm->memories[i].name)) {
            return soc_sbx_g2xx_memory_shell_print(unit,
                            i, argc - 1, &argv[1]);
        }
    }
    if (!sal_strcasecmp(argv[0], "memmap")) {
        if (argc > 2) {
            soc_cm_print("extra arguments to %s command\n",
                    "memmap");
        }
        return soc_sbx_g2xx_memory_map_shell_print(unit,
                         argc > 1 ? argv[1] : NULL);
    }
    return SOC_E_PARAM;
}

/*
 * Diag shell set driver implementation
 */
int soc_sbx_g2xx_shell_set(int unit, int argc, char **argv)
{
    int i;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;

    for (i = 0; i < SOC_SBX_G2XX_GLOBAL_MAX_ID; i++) {
        if (!sal_strcasecmp(argv[0], tm->globals[i].name)) {
            return soc_sbx_g2xx_global_shell_set(unit,
                            i, argc - 1, &argv[1]);
        }
    }
    for (i = 0; i < SOC_SBX_G2XX_ENTRY_MAX_ID; i++) {
        if (!sal_strcasecmp(argv[0], tm->entries[i].name)
            && tm->entries[i].nindexes) {
            return soc_sbx_g2xx_entries_shell_set(unit,
                            i, argc - 1, &argv[1]);
        }
    }
    for (i = 0; i < SOC_SBX_G2XX_POLICER_MAX_ID; i++) {
        if (!sal_strcasecmp(argv[0], tm->policers[i].name)) {
            return soc_sbx_g2xx_policers_shell_set(unit,
                            i, argc - 1, &argv[1]);
        }
    }
    for (i = 0; i < SOC_SBX_G2XX_MEMORY_MAX_ID; i++) {
        if (!sal_strcasecmp(argv[0], tm->memories[i].name)) {
            return soc_sbx_g2xx_memory_shell_set(unit,
                            i, argc - 1, &argv[1]);
        }
    }
    return SOC_E_PARAM;
}

/*
 * Diag shell delete driver implementation
 */
int soc_sbx_g2xx_shell_delete(int unit, int argc, char **argv)
{
    int i;
    soc_sbx_g2xx_state_t *fe =
        (soc_sbx_g2xx_state_t *) SOC_SBX_CONTROL(unit)->drv;
    soc_sbx_g2xx_table_manager_t *tm = fe->tableinfo;

    for (i = 0; i < SOC_SBX_G2XX_ENTRY_MAX_ID; i++) {
        if (!sal_strcasecmp(argv[0], tm->entries[i].name)
            && tm->entries[i].nindexes) {
            return soc_sbx_g2xx_entries_shell_delete(unit,
                            i, argc - 1, &argv[1]);
        }
    }
    for (i = 0; i < SOC_SBX_G2XX_POLICER_MAX_ID; i++) {
        if (!sal_strcasecmp(argv[0], tm->policers[i].name)) {
            return soc_sbx_g2xx_policers_shell_delete(unit,
                            i, argc - 1, &argv[1]);
        }
    }
    return SOC_E_PARAM;
}

/* Shell get command usage string */
char soc_sbx_g2xx_get_usage[] =
"g2xxget [<table> idx0=<i0> ...|<constant>|<global>\n"
"          |<counter> [all|<cnum>] [noclear] [noprint]\n"
"          |<memory> <addr>|memmap [table]]\n"
"        memmap          (print memory map) \n"
"        MIN_FREE_EXCEPTION (constant) \n"
"        EXC_COPY_TO_HOST (constant) \n"
"        MAX_FREE_EXCEPTION (constant) \n"
"        HTYPE_ERH       (constant) \n"
"        HTYPE_ETYPE     (constant) \n"
"        HTYPE_ETH       (constant) \n"
"        HTYPE_IETH      (constant) \n"
"        HTYPE_VTAG      (constant) \n"
"        HTYPE_IPV4      (constant) \n"
"        HTYPE_ELEN      (constant) \n"
"        HTYPE_UNKN      (constant) \n"
"        LSMAC_TABLE_SIZE (constant) \n"
"        tpid0           (global) \n"
"        tpid1           (global) \n"
"        tpid2           (global) \n"
"        node            (global) \n"
"        p2e             port=<port> \n"
"        ep2e            port=<port> \n"
"        p2e20           port=<port> \n"
"        ep2e20          port=<port> \n"
"        p2e25           port=<port> \n"
"        ep2e25          port=<port> \n"
"        tpid            tpidi=<tpidi> \n"
"        lsmac           lsi=<lsi> \n"
"        xt              xi=<xi> \n"
"        mm0_nar0        <addr> (memory) \n"
"        mm0_nar1        <addr> (memory) \n"
"        mm0_wide        <addr> (memory) \n"
"        mm0_int0        <addr> (memory) \n"
"        mm0_int1        <addr> (memory) \n"
"        mm1_nar0        <addr> (memory) \n"
"        mm1_nar1        <addr> (memory) \n"
"        mm1_wide        <addr> (memory) \n"
"        mm1_int0        <addr> (memory) \n"
"        mm1_int1        <addr> (memory) \n"
"        rc0_rr          <addr> (memory) \n"
"        rc1_rr          <addr> (memory) \n"
"        rxportdata      <addr> (memory) \n"
"        initialqstate20 <addr> (memory) \n"
"        initialqstate25 <addr> (memory) \n"
;

/* Shell set command usage string */
char soc_sbx_g2xx_set_usage[] =
"g2xxset [<table> idx0=<i0> ...[field0=<f0> ...]\n"
"          |<global> v|<memory> <addr> v]\n"
"        tpid0           <value> (global) \n"
"        tpid1           <value> (global) \n"
"        tpid2           <value> (global) \n"
"        node            <value> (global) \n"
"        p2e             port=<port> [ port=<port> \n"
"                        nativevid=<nativevid> defcfi=<defcfi> \n"
"                        defpri=<defpri> defstrip=<defstrip> \n"
"                        pstrip=<pstrip> mim=<mim> mask=<mask> \n"
"                        customer=<customer> provider=<provider> \n"
"                        oamloop=<oamloop> stpid1=<stpid1> \n"
"                        twintpid=<twintpid> pbb=<pbb> ipv4mc=<ipv4mc> \n"
"                        state=<state> pport=<pport> htype=<htype> ] \n"
"        ep2e            port=<port> [ mim=<mim> pid=<pid> \n"
"                        stpid0=<stpid0> stpid1=<stpid1> \n"
"                        customer=<customer> keeperh=<keeperh> \n"
"                        port=<port> mirroridx=<mirroridx> mask=<mask> \n"
"                        oamloop=<oamloop> pbb=<pbb> state=<state> \n"
"                        htype=<htype> ] \n"
"        p2e20           port=<port> [ port=<port> \n"
"                        nativevid=<nativevid> defcfi=<defcfi> \n"
"                        defpri=<defpri> defstrip=<defstrip> \n"
"                        pstrip=<pstrip> mim=<mim> mask=<mask> \n"
"                        customer=<customer> provider=<provider> \n"
"                        oamloop=<oamloop> stpid1=<stpid1> \n"
"                        twintpid=<twintpid> pbb=<pbb> ipv4mc=<ipv4mc> \n"
"                        state=<state> pport=<pport> htype=<htype> ] \n"
"        ep2e20          port=<port> [ mim=<mim> pid=<pid> \n"
"                        stpid0=<stpid0> stpid1=<stpid1> \n"
"                        customer=<customer> keeperh=<keeperh> \n"
"                        port=<port> mirroridx=<mirroridx> mask=<mask> \n"
"                        oamloop=<oamloop> pbb=<pbb> state=<state> \n"
"                        htype=<htype> ] \n"
"        p2e25           port=<port> [ port=<port> \n"
"                        nativevid=<nativevid> defcfi=<defcfi> \n"
"                        defpri=<defpri> defstrip=<defstrip> \n"
"                        pstrip=<pstrip> mim=<mim> mask=<mask> \n"
"                        customer=<customer> provider=<provider> \n"
"                        oamloop=<oamloop> stpid1=<stpid1> \n"
"                        twintpid=<twintpid> pbb=<pbb> ipv4mc=<ipv4mc> \n"
"                        state=<state> pport=<pport> htype=<htype> ] \n"
"        ep2e25          port=<port> [ mim=<mim> pid=<pid> \n"
"                        stpid0=<stpid0> stpid1=<stpid1> \n"
"                        customer=<customer> keeperh=<keeperh> \n"
"                        port=<port> mirroridx=<mirroridx> mask=<mask> \n"
"                        oamloop=<oamloop> pbb=<pbb> state=<state> \n"
"                        htype=<htype> ] \n"
"        tpid            tpidi=<tpidi> [ tpid=<tpid> ] \n"
"        lsmac           lsi=<lsi> [ port=<port> useport=<useport> \n"
"                        mac=<mac> ] \n"
"        xt              xi=<xi> [ forward=<forward> dp=<dp> qid=<qid> \n"
"                        trunc=<trunc> learn=<learn> \n"
"                        ppspolice=<ppspolice> policer=<policer> ] \n"
"        mm0_nar0        <addr> <value> (memory) \n"
"        mm0_nar1        <addr> <value> (memory) \n"
"        mm0_wide        <addr> <value> (memory) \n"
"        mm0_int0        <addr> <value> (memory) \n"
"        mm0_int1        <addr> <value> (memory) \n"
"        mm1_nar0        <addr> <value> (memory) \n"
"        mm1_nar1        <addr> <value> (memory) \n"
"        mm1_wide        <addr> <value> (memory) \n"
"        mm1_int0        <addr> <value> (memory) \n"
"        mm1_int1        <addr> <value> (memory) \n"
"        rc0_rr          <addr> <value> (memory) \n"
"        rc1_rr          <addr> <value> (memory) \n"
"        rxportdata      <addr> <value> (memory) \n"
"        initialqstate20 <addr> <value> (memory) \n"
"        initialqstate25 <addr> <value> (memory) \n"
;

/* Shell delete command usage string */
char soc_sbx_g2xx_delete_usage[] =
"g2xxdelete <table> idx0=<i0> ...\n"
;
